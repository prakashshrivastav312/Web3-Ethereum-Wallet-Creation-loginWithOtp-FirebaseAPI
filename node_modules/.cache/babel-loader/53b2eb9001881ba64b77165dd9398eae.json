{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.discardSuperfluousZeroBytes = exports.discardSuperfluousBytesInTwosComplement = exports.prependByteToBuffer = exports.flipBufferBitsInPlace = exports.getHexMagnitudeOfBigInt = exports.bigIntToBuffer = exports.bufferToBigInt = exports.cloneBuffer = exports.isMsbZero = exports.isMsbOne = void 0;\n\nconst bignumber_js_1 = __importDefault(require(\"bignumber.js\"));\n/**\n * Returns whether the most significant bit of a given byte (within a buffer) is 1.\n * @param buffer the buffer to test\n * @param byteIndex the index of the byte to test\n */\n\n\nfunction isMsbOne(buffer) {\n  let byteIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n  let byte = buffer[byteIndex];\n  let bit = byte >> 7;\n  let isSet = bit == 1;\n  return isSet;\n}\n\nexports.isMsbOne = isMsbOne;\n/**\n * Returns whether the most significant bit of a given byte (within a buffer) is 0.\n * @param buffer the buffer to test\n * @param byteIndex the index of the byte to test\n */\n\nfunction isMsbZero(buffer) {\n  let byteIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n  return !isMsbOne(buffer, byteIndex);\n}\n\nexports.isMsbZero = isMsbZero;\n\nfunction cloneBuffer(buffer) {\n  let clone = Buffer.alloc(buffer.length);\n  buffer.copy(clone);\n  return clone;\n}\n\nexports.cloneBuffer = cloneBuffer;\n\nfunction bufferToBigInt(buffer) {\n  // Currently, in JavaScript, this is the feasible way to achieve reliable, arbitrary-size Buffer to BigInt conversion.\n  let hex = buffer.toString(\"hex\");\n  return new bignumber_js_1.default(`0x${hex}`, 16);\n}\n\nexports.bufferToBigInt = bufferToBigInt;\n\nfunction bigIntToBuffer(value) {\n  // Currently, in JavaScript, this is the feasible way to achieve reliable, arbitrary-size BigInt to Buffer conversion.\n  let hex = getHexMagnitudeOfBigInt(value);\n  return Buffer.from(hex, \"hex\");\n}\n\nexports.bigIntToBuffer = bigIntToBuffer;\n\nfunction getHexMagnitudeOfBigInt(value) {\n  if (!value) {\n    return \"\";\n  }\n\n  if (value.isNegative()) {\n    value = value.multipliedBy(new bignumber_js_1.default(-1));\n  }\n\n  let hex = value.toString(16);\n  let padding = \"0\";\n\n  if (hex.length % 2 == 1) {\n    hex = padding + hex;\n  }\n\n  return hex;\n}\n\nexports.getHexMagnitudeOfBigInt = getHexMagnitudeOfBigInt;\n\nfunction flipBufferBitsInPlace(buffer) {\n  for (let i = 0; i < buffer.length; i++) {\n    buffer[i] = ~buffer[i];\n  }\n}\n\nexports.flipBufferBitsInPlace = flipBufferBitsInPlace;\n\nfunction prependByteToBuffer(buffer, byte) {\n  return Buffer.concat([Buffer.from([byte]), buffer]);\n}\n\nexports.prependByteToBuffer = prependByteToBuffer;\n/**\n * Discards the leading bytes that are merely a padding of the leading sign bit (but keeps the payload).\n * @param buffer A number, represented as a sequence of bytes (big-endian)\n */\n\nfunction discardSuperfluousBytesInTwosComplement(buffer) {\n  let isNegative = isMsbOne(buffer, 0);\n  let signPadding = isNegative ? 0xFF : 0x00;\n  let index;\n\n  for (index = 0; index < buffer.length - 1; index++) {\n    let isPaddingByte = buffer[index] == signPadding;\n    let hasSignBitOnNextByte = isMsbOne(buffer, index + 1) === isNegative;\n\n    if (isPaddingByte && hasSignBitOnNextByte) {\n      continue;\n    }\n\n    break;\n  }\n\n  return buffer.slice(index);\n}\n\nexports.discardSuperfluousBytesInTwosComplement = discardSuperfluousBytesInTwosComplement;\n/**\n * Discards the leading zero bytes.\n * @param buffer A number, represented as a sequence of bytes (big-endian)\n */\n\nfunction discardSuperfluousZeroBytes(buffer) {\n  let index;\n\n  for (index = 0; index < buffer.length && buffer[index] == 0; index++) {}\n\n  return buffer.slice(index);\n}\n\nexports.discardSuperfluousZeroBytes = discardSuperfluousZeroBytes;","map":{"version":3,"mappings":"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","names":["isMsbOne","buffer","byteIndex","byte","bit","isSet","exports","isMsbZero","cloneBuffer","clone","Buffer","alloc","length","copy","bufferToBigInt","hex","toString","bignumber_js_1","bigIntToBuffer","value","getHexMagnitudeOfBigInt","from","isNegative","multipliedBy","padding","flipBufferBitsInPlace","i","prependByteToBuffer","concat","discardSuperfluousBytesInTwosComplement","signPadding","index","isPaddingByte","hasSignBitOnNextByte","slice","discardSuperfluousZeroBytes"],"sourceRoot":"","sources":["../../../src/smartcontracts/codec/utils.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}