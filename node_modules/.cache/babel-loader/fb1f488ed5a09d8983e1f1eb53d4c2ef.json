{"ast":null,"code":"\"use strict\";\n\nconst assert = require(\"assert\");\n\nconst brorand = require(\"brorand\");\n\nconst hashjs = require(\"hash.js\");\n\nconst elliptic = require(\"elliptic\");\n\nconst addressCodec = require(\"ripple-address-codec\");\n\nconst secp256k1_1 = require(\"./secp256k1\");\n\nconst utils = require(\"./utils\");\n\nconst Ed25519 = elliptic.eddsa('ed25519');\nconst Secp256k1 = elliptic.ec('secp256k1');\nconst {\n  hexToBytes\n} = utils;\nconst {\n  bytesToHex\n} = utils;\n\nfunction generateSeed() {\n  let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  assert.ok(!options.entropy || options.entropy.length >= 16, 'entropy too short');\n  const entropy = options.entropy ? options.entropy.slice(0, 16) : brorand(16);\n  const type = options.algorithm === 'ed25519' ? 'ed25519' : 'secp256k1';\n  return addressCodec.encodeSeed(Buffer.from(entropy), type);\n}\n\nfunction hash(message) {\n  return hashjs.sha512().update(message).digest().slice(0, 32);\n}\n\nconst secp256k1 = {\n  deriveKeypair(entropy, options) {\n    const prefix = '00';\n    const privateKey = prefix + (0, secp256k1_1.derivePrivateKey)(entropy, options).toString(16, 64).toUpperCase();\n    const publicKey = bytesToHex(Secp256k1.keyFromPrivate(privateKey.slice(2)).getPublic().encodeCompressed());\n    return {\n      privateKey,\n      publicKey\n    };\n  },\n\n  sign(message, privateKey) {\n    return bytesToHex(Secp256k1.sign(hash(message), hexToBytes(privateKey), {\n      canonical: true\n    }).toDER());\n  },\n\n  verify(message, signature, publicKey) {\n    return Secp256k1.verify(hash(message), signature, hexToBytes(publicKey));\n  }\n\n};\nconst ed25519 = {\n  deriveKeypair(entropy) {\n    const prefix = 'ED';\n    const rawPrivateKey = hash(entropy);\n    const privateKey = prefix + bytesToHex(rawPrivateKey);\n    const publicKey = prefix + bytesToHex(Ed25519.keyFromSecret(rawPrivateKey).pubBytes());\n    return {\n      privateKey,\n      publicKey\n    };\n  },\n\n  sign(message, privateKey) {\n    // caution: Ed25519.sign interprets all strings as hex, stripping\n    // any non-hex characters without warning\n    assert.ok(Array.isArray(message), 'message must be array of octets');\n    return bytesToHex(Ed25519.sign(message, hexToBytes(privateKey).slice(1)).toBytes());\n  },\n\n  verify(message, signature, publicKey) {\n    return Ed25519.verify(message, hexToBytes(signature), hexToBytes(publicKey).slice(1));\n  }\n\n};\n\nfunction select(algorithm) {\n  const methods = {\n    'ecdsa-secp256k1': secp256k1,\n    ed25519\n  };\n  return methods[algorithm];\n}\n\nfunction deriveKeypair(seed, options) {\n  const decoded = addressCodec.decodeSeed(seed);\n  const algorithm = decoded.type === 'ed25519' ? 'ed25519' : 'ecdsa-secp256k1';\n  const method = select(algorithm);\n  const keypair = method.deriveKeypair(decoded.bytes, options);\n  const messageToVerify = hash('This test message should verify.');\n  const signature = method.sign(messageToVerify, keypair.privateKey);\n  /* istanbul ignore if */\n\n  if (method.verify(messageToVerify, signature, keypair.publicKey) !== true) {\n    throw new Error('derived keypair did not generate verifiable signature');\n  }\n\n  return keypair;\n}\n\nfunction getAlgorithmFromKey(key) {\n  const bytes = hexToBytes(key);\n  return bytes.length === 33 && bytes[0] === 0xed ? 'ed25519' : 'ecdsa-secp256k1';\n}\n\nfunction sign(messageHex, privateKey) {\n  const algorithm = getAlgorithmFromKey(privateKey);\n  return select(algorithm).sign(hexToBytes(messageHex), privateKey);\n}\n\nfunction verify(messageHex, signature, publicKey) {\n  const algorithm = getAlgorithmFromKey(publicKey);\n  return select(algorithm).verify(hexToBytes(messageHex), signature, publicKey);\n}\n\nfunction deriveAddressFromBytes(publicKeyBytes) {\n  return addressCodec.encodeAccountID(utils.computePublicKeyHash(publicKeyBytes));\n}\n\nfunction deriveAddress(publicKey) {\n  return deriveAddressFromBytes(Buffer.from(hexToBytes(publicKey)));\n}\n\nfunction deriveNodeAddress(publicKey) {\n  const generatorBytes = addressCodec.decodeNodePublic(publicKey);\n  const accountPublicBytes = (0, secp256k1_1.accountPublicFromPublicGenerator)(generatorBytes);\n  return deriveAddressFromBytes(accountPublicBytes);\n}\n\nconst {\n  decodeSeed\n} = addressCodec;\nmodule.exports = {\n  generateSeed,\n  deriveKeypair,\n  sign,\n  verify,\n  deriveAddress,\n  deriveNodeAddress,\n  decodeSeed\n};","map":{"version":3,"mappings":"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","names":["Ed25519","elliptic","eddsa","Secp256k1","ec","hexToBytes","utils","bytesToHex","generateSeed","options","assert","ok","entropy","length","slice","brorand","type","algorithm","addressCodec","encodeSeed","Buffer","from","hash","message","hashjs","sha512","update","digest","secp256k1","deriveKeypair","prefix","privateKey","toString","toUpperCase","publicKey","keyFromPrivate","getPublic","encodeCompressed","sign","canonical","toDER","verify","signature","ed25519","rawPrivateKey","keyFromSecret","pubBytes","Array","isArray","toBytes","select","methods","seed","decoded","decodeSeed","method","keypair","bytes","messageToVerify","Error","getAlgorithmFromKey","key","messageHex","deriveAddressFromBytes","publicKeyBytes","encodeAccountID","computePublicKeyHash","deriveAddress","deriveNodeAddress","generatorBytes","decodeNodePublic","accountPublicBytes","module"],"sourceRoot":"","sources":["../src/index.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}