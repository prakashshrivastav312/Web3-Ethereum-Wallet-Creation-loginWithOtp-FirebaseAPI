{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.List = exports.OptionValue = exports.ListType = exports.OptionType = void 0;\n\nconst utils_1 = require(\"../../utils\");\n\nconst types_1 = require(\"./types\");\n\nclass OptionType extends types_1.Type {\n  constructor(typeParameter) {\n    super(\"Option\", [typeParameter]);\n  }\n\n  isAssignableFrom(type) {\n    if (!(type instanceof OptionType)) {\n      return false;\n    }\n\n    let invariantTypeParameters = this.getFirstTypeParameter().equals(type.getFirstTypeParameter());\n    let fakeCovarianceToNull = type.getFirstTypeParameter() instanceof types_1.NullType;\n    return invariantTypeParameters || fakeCovarianceToNull;\n  }\n\n}\n\nexports.OptionType = OptionType;\n\nclass ListType extends types_1.Type {\n  constructor(typeParameter) {\n    super(\"List\", [typeParameter]);\n  }\n\n}\n\nexports.ListType = ListType;\n\nclass OptionValue extends types_1.TypedValue {\n  constructor(type) {\n    let value = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    super(type); // TODO: assert value is of type type.getFirstTypeParameter()\n\n    this.value = value;\n  }\n  /**\n   * Creates an OptionValue, as a missing option argument.\n   */\n\n\n  static newMissing() {\n    let type = new OptionType(new types_1.NullType());\n    return new OptionValue(type);\n  }\n\n  static newMissingType(type) {\n    return new OptionValue(new OptionType(type));\n  }\n  /**\n   * Creates an OptionValue, as a provided option argument.\n   */\n\n\n  static newProvided(typedValue) {\n    let type = new OptionType(typedValue.getType());\n    return new OptionValue(type, typedValue);\n  }\n\n  isSet() {\n    return this.value ? true : false;\n  }\n\n  getTypedValue() {\n    utils_1.guardValueIsSet(\"value\", this.value);\n    return this.value;\n  }\n\n  valueOf() {\n    return this.value ? this.value.valueOf() : null;\n  }\n\n  equals(other) {\n    var _a;\n\n    return ((_a = this.value) === null || _a === void 0 ? void 0 : _a.equals(other.value)) || false;\n  }\n\n}\n\nexports.OptionValue = OptionValue; // TODO: Rename to ListValue, for consistency (though the term is slighly unfortunate).\n// Question for review: or not?\n\nclass List extends types_1.TypedValue {\n  /**\n   *\n   * @param type the type of this TypedValue (an instance of ListType), not the type parameter of the ListType\n   * @param items the items, having the type type.getFirstTypeParameter()\n   */\n  constructor(type, items) {\n    super(type); // TODO: assert items are of type type.getFirstTypeParameter()\n\n    this.items = items;\n  }\n\n  static fromItems(items) {\n    if (items.length == 0) {\n      return new List(new types_1.TypePlaceholder(), []);\n    }\n\n    let typeParameter = items[0].getType();\n    return new List(typeParameter, items);\n  }\n\n  getLength() {\n    return this.items.length;\n  }\n\n  getItems() {\n    return this.items;\n  }\n\n  valueOf() {\n    return this.items.map(item => item.valueOf());\n  }\n\n  equals(other) {\n    if (this.getLength() != other.getLength()) {\n      return false;\n    }\n\n    for (let i = 0; i < this.getLength(); i++) {\n      let selfItem = this.items[i];\n      let otherItem = other.items[i];\n\n      if (!selfItem.equals(otherItem)) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n}\n\nexports.List = List;","map":{"version":3,"mappings":";;;;;;;AAAA;;AACA;;AAEA,MAAaA,UAAb,SAAgCC,YAAhC,CAAoC;EAChCC,YAAYC,aAAZ,EAA+B;IAC3B,MAAM,QAAN,EAAgB,CAACA,aAAD,CAAhB;EACH;;EAEDC,gBAAgB,CAACC,IAAD,EAAW;IACvB,IAAI,EAAEA,IAAI,YAAYL,UAAlB,CAAJ,EAAmC;MAC/B,OAAO,KAAP;IACH;;IAED,IAAIM,uBAAuB,GAAG,KAAKC,qBAAL,GAA6BC,MAA7B,CAAoCH,IAAI,CAACE,qBAAL,EAApC,CAA9B;IACA,IAAIE,oBAAoB,GAAGJ,IAAI,CAACE,qBAAL,cAAwCN,gBAAnE;IACA,OAAOK,uBAAuB,IAAIG,oBAAlC;EACH;;AAb+B;;AAApCC;;AAgBA,MAAaC,QAAb,SAA8BV,YAA9B,CAAkC;EAC9BC,YAAYC,aAAZ,EAA+B;IAC3B,MAAM,MAAN,EAAc,CAACA,aAAD,CAAd;EACH;;AAH6B;;AAAlCO;;AAMA,MAAaE,WAAb,SAAiCX,kBAAjC,CAA2C;EAGvCC,YAAYG,IAAZ,EAA6D;IAAA,IAA/BQ,KAA+B,uEAAJ,IAAI;IACzD,MAAMR,IAAN,EADyD,CAGzD;;IAEA,KAAKQ,KAAL,GAAaA,KAAb;EACH;EAED;;;;;EAGiB,OAAVC,UAAU;IACb,IAAIT,IAAI,GAAG,IAAIL,UAAJ,CAAe,IAAIC,gBAAJ,EAAf,CAAX;IACA,OAAO,IAAIW,WAAJ,CAAgBP,IAAhB,CAAP;EACH;;EAEoB,OAAdU,cAAc,CAACV,IAAD,EAAW;IAC5B,OAAO,IAAIO,WAAJ,CAAgB,IAAIZ,UAAJ,CAAeK,IAAf,CAAhB,CAAP;EACH;EAED;;;;;EAGkB,OAAXW,WAAW,CAACC,UAAD,EAAuB;IACrC,IAAIZ,IAAI,GAAG,IAAIL,UAAJ,CAAeiB,UAAU,CAACC,OAAX,EAAf,CAAX;IACA,OAAO,IAAIN,WAAJ,CAAgBP,IAAhB,EAAsBY,UAAtB,CAAP;EACH;;EAEDE,KAAK;IACD,OAAO,KAAKN,KAAL,GAAa,IAAb,GAAoB,KAA3B;EACH;;EAEDO,aAAa;IACTC,wBAAgB,OAAhB,EAAyB,KAAKR,KAA9B;IACA,OAAO,KAAKA,KAAZ;EACH;;EAEDS,OAAO;IACH,OAAO,KAAKT,KAAL,GAAa,KAAKA,KAAL,CAAWS,OAAX,EAAb,GAAoC,IAA3C;EACH;;EAEDd,MAAM,CAACe,KAAD,EAAmB;;;IACrB,OAAO,YAAKV,KAAL,MAAU,IAAV,IAAUW,aAAV,GAAU,MAAV,GAAUA,GAAEhB,MAAF,CAASe,KAAK,CAACV,KAAf,CAAV,KAAmC,KAA1C;EACH;;AA9CsC;;AAA3CH,kC,CAiDA;AACA;;AACA,MAAae,IAAb,SAA0BxB,kBAA1B,CAAoC;EAGhC;;;;;EAKAC,YAAYG,IAAZ,EAA4BqB,KAA5B,EAA+C;IAC3C,MAAMrB,IAAN,EAD2C,CAG3C;;IAEA,KAAKqB,KAAL,GAAaA,KAAb;EACH;;EAEe,OAATC,SAAS,CAACD,KAAD,EAAoB;IAChC,IAAIA,KAAK,CAACE,MAAN,IAAgB,CAApB,EAAuB;MACnB,OAAO,IAAIH,IAAJ,CAAS,IAAIxB,uBAAJ,EAAT,EAAgC,EAAhC,CAAP;IACH;;IAED,IAAIE,aAAa,GAAGuB,KAAK,CAAC,CAAD,CAAL,CAASR,OAAT,EAApB;IACA,OAAO,IAAIO,IAAJ,CAAStB,aAAT,EAAwBuB,KAAxB,CAAP;EACH;;EAEDG,SAAS;IACL,OAAO,KAAKH,KAAL,CAAWE,MAAlB;EACH;;EAEDE,QAAQ;IACJ,OAAO,KAAKJ,KAAZ;EACH;;EAEDJ,OAAO;IACH,OAAO,KAAKI,KAAL,CAAWK,GAAX,CAAgBC,IAAD,IAAUA,IAAI,CAACV,OAAL,EAAzB,CAAP;EACH;;EAEDd,MAAM,CAACe,KAAD,EAAY;IACd,IAAI,KAAKM,SAAL,MAAoBN,KAAK,CAACM,SAAN,EAAxB,EAA2C;MACvC,OAAO,KAAP;IACH;;IAED,KAAK,IAAII,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG,KAAKJ,SAAL,EAApB,EAAsCI,CAAC,EAAvC,EAA2C;MACvC,IAAIC,QAAQ,GAAG,KAAKR,KAAL,CAAWO,CAAX,CAAf;MACA,IAAIE,SAAS,GAAGZ,KAAK,CAACG,KAAN,CAAYO,CAAZ,CAAhB;;MAEA,IAAI,CAACC,QAAQ,CAAC1B,MAAT,CAAgB2B,SAAhB,CAAL,EAAiC;QAC7B,OAAO,KAAP;MACH;IACJ;;IAED,OAAO,IAAP;EACH;;AApD+B;;AAApCzB","names":["OptionType","types_1","constructor","typeParameter","isAssignableFrom","type","invariantTypeParameters","getFirstTypeParameter","equals","fakeCovarianceToNull","exports","ListType","OptionValue","value","newMissing","newMissingType","newProvided","typedValue","getType","isSet","getTypedValue","utils_1","valueOf","other","_a","List","items","fromItems","length","getLength","getItems","map","item","i","selfItem","otherItem"],"sourceRoot":"","sources":["../../../src/smartcontracts/typesystem/generic.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}