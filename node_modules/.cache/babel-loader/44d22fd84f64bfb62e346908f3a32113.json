{"ast":null,"code":"import { invariant as e } from \"@onflow/util-invariant\";\nimport { encode as n } from \"@onflow/rlp\";\nvar i = 2,\n    t = 3,\n    o = new Set([2, 3]),\n    h = 1,\n    r = 3,\n    a = new Set([1, 3]);\n\nfunction c(i, t, h, r) {\n  return void 0 === r && (r = 1e3), e(\"string\" == typeof i, \"encodeKey(key, curve, hash, weight) -- invalid key (expecting type of string)\"), e(/^[0-9a-z]+$/.test(i), \"encodeKey(key, curve, hash, weight) -- invalid key (incorrect format)\"), e(\"number\" == typeof t, \"encodeKey(key, curve, hash, weight) -- invalid curve (expecting type of number)\"), e(o.has(t), \"encodeKey(key, curve, hash, weight) -- invalid curve (value not included in set of valid curves)\"), e(\"number\" == typeof h, \"encodeKey(key, curve, hash, weight) -- invalid hash (expecting typeof number)\"), e(a.has(h), \"encodeKey(key, curve, hash, weight) -- invalid hash (value not included in set of valid hashings)\"), e(r >= 0 && r <= 1e3, \"encodeKey(key, curve, hash, weight) -- weight needs to be between (inclusive of) 0 and 1000\"), n([Buffer.from(i, \"hex\"), t, h, r]).toString(\"hex\");\n}\n\nexport { i as ECDSA_P256, t as ECDSA_secp256k1, h as SHA2_256, r as SHA3_256, c as encodeKey };","map":{"version":3,"mappings":";;AAIaA,QAAa,CAAbA;AAAAA,IACAC,IAAkB,CADlBD;AAAAA,IAEPE,IAAe,IAAIC,GAAJ,CAAQ,CAFH,CAEG,EADE,CACF,CAAR,CAFRH;AAAAA,IAKAI,IAAW,CALXJ;AAAAA,IAMAK,IAAW,CANXL;AAAAA,IAOPM,IAAiB,IAAIH,GAAJ,CAAQ,CAFP,CAEO,EADP,CACO,CAAR,CAPVH;;AAMW,SAGRO,CAHQ,CAGEC,CAHF,EAGOC,CAHP,EAGcC,CAHd,EAGoBC,CAHpB,EAGoBA;EA8B1C,kBA9B0CA,CA8B1C,KA9B0CA,IAAS,GA8BnD,GA7BAC,EACiB,mBAARJ,CADTI,EAEE,+EAFFA,CA6BA,EAzBAA,EACE,cAAcC,IAAd,CAAmBL,CAAnB,CADFI,EAEE,uEAFFA,CAyBA,EArBAA,EACmB,mBAAVH,CADTG,EAEE,iFAFFA,CAqBA,EAjBAA,EACEV,EAAaY,GAAbZ,CAAiBO,CAAjBP,CADFU,EAEE,kGAFFA,CAiBA,EAbAA,EACkB,mBAATF,CADTE,EAEE,+EAFFA,CAaA,EATAA,EACEN,EAAeQ,GAAfR,CAAmBI,CAAnBJ,CADFM,EAEE,mGAFFA,CASA,EALAA,EACED,KAAU,CAAVA,IAAeA,KAAU,GAD3BC,EAEE,6FAFFA,CAKA,EAAOG,EAAO,CAACC,OAAOC,IAAPD,CAAYR,CAAZQ,EAAiB,KAAjBA,CAAD,EAA0BP,CAA1B,EAAiCC,CAAjC,EAAuCC,CAAvC,CAAPI,EAAuDG,QAAvDH,CAAgE,KAAhEA,CAAP;AAAuE;;AAAA","names":["ECDSA_P256","ECDSA_secp256k1","VALID_CURVES","Set","SHA2_256","SHA3_256","VALID_HASHINGS","encodeKey","key","curve","hash","weight","invariant","test","has","encode","Buffer","from","toString"],"sources":["../src/index.js"],"sourcesContent":["import {invariant} from \"@onflow/util-invariant\"\nimport {encode} from \"@onflow/rlp\"\n\n// Curves\nexport const ECDSA_P256 = 2\nexport const ECDSA_secp256k1 = 3\nconst VALID_CURVES = new Set([ECDSA_P256, ECDSA_secp256k1])\n\n// Hashing\nexport const SHA2_256 = 1\nexport const SHA3_256 = 3\nconst VALID_HASHINGS = new Set([SHA2_256, SHA3_256])\n\nexport function encodeKey(key, curve, hash, weight = 1000) {\n  invariant(\n    typeof key === \"string\",\n    \"encodeKey(key, curve, hash, weight) -- invalid key (expecting type of string)\"\n  )\n  invariant(\n    /^[0-9a-z]+$/.test(key),\n    \"encodeKey(key, curve, hash, weight) -- invalid key (incorrect format)\"\n  )\n  invariant(\n    typeof curve === \"number\",\n    \"encodeKey(key, curve, hash, weight) -- invalid curve (expecting type of number)\"\n  )\n  invariant(\n    VALID_CURVES.has(curve),\n    \"encodeKey(key, curve, hash, weight) -- invalid curve (value not included in set of valid curves)\"\n  )\n  invariant(\n    typeof hash === \"number\",\n    \"encodeKey(key, curve, hash, weight) -- invalid hash (expecting typeof number)\"\n  )\n  invariant(\n    VALID_HASHINGS.has(hash),\n    \"encodeKey(key, curve, hash, weight) -- invalid hash (value not included in set of valid hashings)\"\n  )\n  invariant(\n    weight >= 0 && weight <= 1000,\n    \"encodeKey(key, curve, hash, weight) -- weight needs to be between (inclusive of) 0 and 1000\"\n  )\n\n  return encode([Buffer.from(key, \"hex\"), curve, hash, weight]).toString(\"hex\")\n}\n"]},"metadata":{},"sourceType":"module"}