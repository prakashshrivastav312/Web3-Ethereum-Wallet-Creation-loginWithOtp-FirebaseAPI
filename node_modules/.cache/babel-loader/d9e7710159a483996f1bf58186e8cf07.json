{"ast":null,"code":"/*\n    Copyright 2020 The caver-js Authors\n    This file is part of the caver-js library.\n\n    The caver-js library is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Lesser General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    The caver-js library is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n    GNU Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public License\n    along with the caver-js. If not, see <http://www.gnu.org/licenses/>.\n*/\nconst AccountLib = require('eth-lib/lib/account');\n\nconst Nat = require('eth-lib/lib/nat');\n\nconst elliptic = require('elliptic');\n\nconst secp256k1 = new elliptic.ec('secp256k1');\n\nconst utils = require('../../../caver-utils');\n\nconst SignatureData = require('./signatureData');\n/**\n * Representing a PrivateKey class that includes private key string.\n * @class\n * @hideconstructor\n */\n\n\nclass PrivateKey {\n  /**\n   * creates a privateKey.\n   * @param {string} key - The private key string.\n   */\n  constructor(key) {\n    this.privateKey = key;\n  }\n  /**\n   * @type {string}\n   */\n\n\n  get privateKey() {\n    return this._privateKey;\n  }\n\n  set privateKey(p) {\n    if (!utils.isValidPrivateKey(p)) throw new Error(`Invalid private key: ${p}`);\n    this._privateKey = utils.addHexPrefix(p);\n  }\n  /**\n   * Signs with transactionHash with key and returns signature.\n   *\n   * @example\n   * const signature = privateKey.sign('0xe9a11d9ef95fb437f75d07ce768d43e74f158dd54b106e7d3746ce29d545b550', '0x2810')\n   *\n   * @param {string} transactionHash The hash of transaction.\n   * @param {string|number} chainId The chainId or the network.\n   * @return {SignatureData} A {@link SignatureData}.\n   */\n\n\n  sign(transactionHash, chainId) {\n    let addToV;\n\n    if (chainId === undefined) {\n      throw new Error(`Insufficient parameters: chainId is undefined.`);\n    } else {\n      chainId = utils.toHex(chainId);\n      addToV = Nat.toNumber(chainId) * 2 + 35;\n    }\n\n    const signature = AccountLib.makeSigner(addToV)(transactionHash, this.privateKey);\n    const [v, r, s] = AccountLib.decodeSignature(signature).map(sig => utils.makeEven(utils.trimLeadingZero(sig)));\n    return new SignatureData([v, r, s]);\n  }\n  /**\n   * Signs with hashed data and returns signature data.\n   * ecsign returns a signature which has v as a parity (0 for even, 1 for odd) of the y-value of a secp256k1 signature.\n   *\n   * @example\n   * const signature = privateKey.ecsign('0xe9a11d9ef95fb437f75d07ce768d43e74f158dd54b106e7d3746ce29d545b550')\n   *\n   * @param {string} hash The hash to sign.\n   * @return {SignatureData} A {@link SignatureData}.\n   */\n\n\n  ecsign(hash) {\n    // ecsign returns recovery id `v` as y-parity (0 or 1).\n    // `AccountLib.makeSigner` makes a sign function that adds addToV to `v`, so use 0.\n    const addToV = 0;\n    const signature = AccountLib.makeSigner(addToV)(hash, this.privateKey);\n    let [v, r, s] = AccountLib.decodeSignature(signature).map(sig => utils.makeEven(utils.trimLeadingZero(sig))); // This is for converting '0x' to '0x0'\n\n    v = utils.toHex(utils.hexToNumber(v));\n    return new SignatureData([v, r, s]);\n  }\n  /**\n   * Signs with hashed data and returns `signature`.\n   *\n   * @example\n   * const signature = privateKey.signMessage('0xe9a11d9ef95fb437f75d07ce768d43e74f158dd54b106e7d3746ce29d545b550')\n   *\n   * @param {string} messageHash The hash of data to sign.\n   * @return {SignatureData} A {@link SignatureData}.\n   */\n\n\n  signMessage(messageHash) {\n    const signature = AccountLib.sign(messageHash, this.privateKey);\n    const [v, r, s] = AccountLib.decodeSignature(signature);\n    return new SignatureData([v, r, s]);\n  }\n  /**\n   * Returns public key string.\n   *\n   * @example\n   * const publicKey = privateKey.getPublicKey()\n   *\n   * @param {boolean} [compressed] Whether in compressed format or not.\n   * @return {string} A public key string which is derived from private key string.\n   */\n\n\n  getPublicKey() {\n    let compressed = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    const strippedPrivateKey = utils.stripHexPrefix(this.privateKey);\n    const ecKey = secp256k1.keyFromPrivate(Buffer.from(strippedPrivateKey, 'hex'));\n    if (!compressed) return `0x${ecKey.getPublic(false, 'hex').slice(2)}`;\n    return `0x${ecKey.getPublic(true, 'hex')}`;\n  }\n  /**\n   * Returns derived address from private key string.\n   *\n   * @example\n   * const address = privateKey.getDerivedAddress()\n   *\n   * @return {string} A address which is derived from private key string.\n   */\n\n\n  getDerivedAddress() {\n    return AccountLib.fromPrivate(this.privateKey).address.toLowerCase();\n  }\n\n}\n\nmodule.exports = PrivateKey;","map":{"version":3,"names":["AccountLib","require","Nat","elliptic","secp256k1","ec","utils","SignatureData","PrivateKey","constructor","key","privateKey","_privateKey","p","isValidPrivateKey","Error","addHexPrefix","sign","transactionHash","chainId","addToV","undefined","toHex","toNumber","signature","makeSigner","v","r","s","decodeSignature","map","sig","makeEven","trimLeadingZero","ecsign","hash","hexToNumber","signMessage","messageHash","getPublicKey","compressed","strippedPrivateKey","stripHexPrefix","ecKey","keyFromPrivate","Buffer","from","getPublic","slice","getDerivedAddress","fromPrivate","address","toLowerCase","module","exports"],"sources":["C:/Users/acer/node_modules/caver-js/packages/caver-wallet/src/keyring/privateKey.js"],"sourcesContent":["/*\n    Copyright 2020 The caver-js Authors\n    This file is part of the caver-js library.\n\n    The caver-js library is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Lesser General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    The caver-js library is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n    GNU Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public License\n    along with the caver-js. If not, see <http://www.gnu.org/licenses/>.\n*/\n\nconst AccountLib = require('eth-lib/lib/account')\nconst Nat = require('eth-lib/lib/nat')\n\nconst elliptic = require('elliptic')\n\nconst secp256k1 = new elliptic.ec('secp256k1')\n\nconst utils = require('../../../caver-utils')\nconst SignatureData = require('./signatureData')\n\n/**\n * Representing a PrivateKey class that includes private key string.\n * @class\n * @hideconstructor\n */\nclass PrivateKey {\n    /**\n     * creates a privateKey.\n     * @param {string} key - The private key string.\n     */\n    constructor(key) {\n        this.privateKey = key\n    }\n\n    /**\n     * @type {string}\n     */\n    get privateKey() {\n        return this._privateKey\n    }\n\n    set privateKey(p) {\n        if (!utils.isValidPrivateKey(p)) throw new Error(`Invalid private key: ${p}`)\n        this._privateKey = utils.addHexPrefix(p)\n    }\n\n    /**\n     * Signs with transactionHash with key and returns signature.\n     *\n     * @example\n     * const signature = privateKey.sign('0xe9a11d9ef95fb437f75d07ce768d43e74f158dd54b106e7d3746ce29d545b550', '0x2810')\n     *\n     * @param {string} transactionHash The hash of transaction.\n     * @param {string|number} chainId The chainId or the network.\n     * @return {SignatureData} A {@link SignatureData}.\n     */\n    sign(transactionHash, chainId) {\n        let addToV\n        if (chainId === undefined) {\n            throw new Error(`Insufficient parameters: chainId is undefined.`)\n        } else {\n            chainId = utils.toHex(chainId)\n            addToV = Nat.toNumber(chainId) * 2 + 35\n        }\n        const signature = AccountLib.makeSigner(addToV)(transactionHash, this.privateKey)\n        const [v, r, s] = AccountLib.decodeSignature(signature).map(sig => utils.makeEven(utils.trimLeadingZero(sig)))\n        return new SignatureData([v, r, s])\n    }\n\n    /**\n     * Signs with hashed data and returns signature data.\n     * ecsign returns a signature which has v as a parity (0 for even, 1 for odd) of the y-value of a secp256k1 signature.\n     *\n     * @example\n     * const signature = privateKey.ecsign('0xe9a11d9ef95fb437f75d07ce768d43e74f158dd54b106e7d3746ce29d545b550')\n     *\n     * @param {string} hash The hash to sign.\n     * @return {SignatureData} A {@link SignatureData}.\n     */\n    ecsign(hash) {\n        // ecsign returns recovery id `v` as y-parity (0 or 1).\n        // `AccountLib.makeSigner` makes a sign function that adds addToV to `v`, so use 0.\n        const addToV = 0\n        const signature = AccountLib.makeSigner(addToV)(hash, this.privateKey)\n        let [v, r, s] = AccountLib.decodeSignature(signature).map(sig => utils.makeEven(utils.trimLeadingZero(sig)))\n        // This is for converting '0x' to '0x0'\n        v = utils.toHex(utils.hexToNumber(v))\n\n        return new SignatureData([v, r, s])\n    }\n\n    /**\n     * Signs with hashed data and returns `signature`.\n     *\n     * @example\n     * const signature = privateKey.signMessage('0xe9a11d9ef95fb437f75d07ce768d43e74f158dd54b106e7d3746ce29d545b550')\n     *\n     * @param {string} messageHash The hash of data to sign.\n     * @return {SignatureData} A {@link SignatureData}.\n     */\n    signMessage(messageHash) {\n        const signature = AccountLib.sign(messageHash, this.privateKey)\n        const [v, r, s] = AccountLib.decodeSignature(signature)\n        return new SignatureData([v, r, s])\n    }\n\n    /**\n     * Returns public key string.\n     *\n     * @example\n     * const publicKey = privateKey.getPublicKey()\n     *\n     * @param {boolean} [compressed] Whether in compressed format or not.\n     * @return {string} A public key string which is derived from private key string.\n     */\n    getPublicKey(compressed = false) {\n        const strippedPrivateKey = utils.stripHexPrefix(this.privateKey)\n\n        const ecKey = secp256k1.keyFromPrivate(Buffer.from(strippedPrivateKey, 'hex'))\n\n        if (!compressed) return `0x${ecKey.getPublic(false, 'hex').slice(2)}`\n        return `0x${ecKey.getPublic(true, 'hex')}`\n    }\n\n    /**\n     * Returns derived address from private key string.\n     *\n     * @example\n     * const address = privateKey.getDerivedAddress()\n     *\n     * @return {string} A address which is derived from private key string.\n     */\n    getDerivedAddress() {\n        return AccountLib.fromPrivate(this.privateKey).address.toLowerCase()\n    }\n}\n\nmodule.exports = PrivateKey\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}