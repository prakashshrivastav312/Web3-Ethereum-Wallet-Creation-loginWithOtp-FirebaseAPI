{"ast":null,"code":"\"use strict\";\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.WalletConnectProvider = void 0;\n\nconst client_1 = __importDefault(require(\"@walletconnect/client\"));\n\nconst address_1 = require(\"../address\");\n\nconst signature_1 = require(\"../signature\");\n\nconst constants_1 = require(\"./constants\");\n\nconst logger_1 = require(\"../logger\");\n\nconst errors_1 = require(\"../errors\");\n\nclass WalletConnectProvider {\n  constructor(httpProvider) {\n    let walletConnectBridge = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"\";\n    let onClientConnect = arguments.length > 2 ? arguments[2] : undefined;\n    this.address = \"\";\n    this.signature = \"\";\n    this.provider = httpProvider;\n    this.walletConnectBridge = walletConnectBridge;\n    this.onClientConnect = onClientConnect;\n  }\n  /**\n   * Initiates wallet connect client.\n   */\n\n\n  init() {\n    return __awaiter(this, void 0, void 0, function* () {\n      this.walletConnector = new client_1.default({\n        bridge: this.walletConnectBridge\n      });\n      this.walletConnector.on(\"connect\", this.onConnect.bind(this));\n      this.walletConnector.on(\"session_update\", this.onDisconnect.bind(this));\n      this.walletConnector.on(\"disconnect\", this.onDisconnect.bind(this));\n\n      if (this.walletConnector.connected && this.walletConnector.accounts.length) {\n        const [account] = this.walletConnector.accounts;\n        const [address, signature] = account.split(\".\");\n        yield this.loginAccount(address, signature);\n      }\n\n      return true;\n    });\n  }\n  /**\n   * Returns true if init() was previously called successfully\n   */\n\n\n  isInitialized() {\n    return !!this.walletConnector;\n  }\n  /**\n   * Mocked function, returns isInitialized as an async function\n   */\n\n\n  isConnected() {\n    return new Promise((resolve, _) => resolve(this.isInitialized()));\n  }\n  /**\n   *\n   */\n\n\n  login() {\n    var _a, _b, _c, _d;\n\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!this.walletConnector) {\n        yield this.init();\n      }\n\n      if ((_a = this.walletConnector) === null || _a === void 0 ? void 0 : _a.connected) {\n        yield this.walletConnector.killSession();\n        logger_1.Logger.trace(\"WalletConnect login started but walletConnect not initialized\");\n        return \"\";\n      }\n\n      yield (_b = this.walletConnector) === null || _b === void 0 ? void 0 : _b.createSession({\n        chainId: constants_1.WALLETCONNECT_ELROND_CHAIN_ID\n      });\n\n      if (!((_c = this.walletConnector) === null || _c === void 0 ? void 0 : _c.uri)) {\n        return \"\";\n      }\n\n      return (_d = this.walletConnector) === null || _d === void 0 ? void 0 : _d.uri;\n    });\n  }\n  /**\n   * Mocks a logout request by returning true\n   */\n\n\n  logout() {\n    var _a, _b;\n\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!this.walletConnector) {\n        logger_1.Logger.error(\"logout: Wallet Connect not initialised, call init() first\");\n        throw new Error(\"Wallet Connect not initialised, call init() first\");\n      }\n\n      if ((_a = this.walletConnector) === null || _a === void 0 ? void 0 : _a.connected) {\n        yield (_b = this.walletConnector) === null || _b === void 0 ? void 0 : _b.killSession();\n      }\n\n      return true;\n    });\n  }\n  /**\n   * Fetches the wallet connect address\n   */\n\n\n  getAddress() {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!this.walletConnector) {\n        logger_1.Logger.error(\"getAddress: Wallet Connect not initialised, call init() first\");\n        throw new Error(\"Wallet Connect not initialised, call init() first\");\n      }\n\n      return this.address;\n    });\n  }\n  /**\n   * Fetches the wallet connect signature\n   */\n\n\n  getSignature() {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!this.walletConnector) {\n        logger_1.Logger.error(\"getSignature: Wallet Connect not initialised, call init() first\");\n        throw new Error(\"Wallet Connect not initialised, call init() first\");\n      }\n\n      return this.signature;\n    });\n  }\n  /**\n   * Signs and sends a transaction. Returns the transaction hash\n   * @param transaction\n   */\n\n\n  sendTransaction(transaction) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!this.walletConnector) {\n        logger_1.Logger.error(\"sendTransaction: Wallet Connect not initialised, call init() first\");\n        throw new Error(\"Wallet Connect not initialised, call init() first\");\n      }\n\n      transaction = yield this.signTransaction(transaction);\n      yield transaction.send(this.provider);\n      return transaction;\n    });\n  }\n  /**\n   * Method will be available once the Maiar wallet connect hook is implemented\n   * @param _\n   */\n\n\n  signMessage(_) {\n    return __awaiter(this, void 0, void 0, function* () {\n      throw new errors_1.ErrNotImplemented();\n    });\n  }\n  /**\n   * Signs a transaction and returns it\n   * @param transaction\n   */\n\n\n  signTransaction(transaction) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!this.walletConnector) {\n        logger_1.Logger.error(\"signTransaction: Wallet Connect not initialised, call init() first\");\n        throw new Error(\"Wallet Connect not initialised, call init() first\");\n      }\n\n      const address = yield this.getAddress();\n      const sig = yield this.walletConnector.sendCustomRequest({\n        method: \"erd_sign\",\n        params: this.prepareWalletConnectMessage(transaction, address)\n      });\n\n      if (!sig || !sig.signature) {\n        logger_1.Logger.error(\"signTransaction: Wallet Connect could not sign the transaction\");\n        throw new Error(\"Wallet Connect could not sign the transaction\");\n      }\n\n      transaction.applySignature(new signature_1.Signature(sig.signature), new address_1.Address(address));\n      return transaction;\n    });\n  }\n  /**\n   * Signs an array of transactions and returns it\n   * @param transactions\n   */\n\n\n  signTransactions(transactions) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!this.walletConnector) {\n        logger_1.Logger.error(\"signTransactions: Wallet Connect not initialised, call init() first\");\n        throw new Error(\"Wallet Connect not initialised, call init() first\");\n      }\n\n      const address = yield this.getAddress();\n      const params = transactions.map(transaction => this.prepareWalletConnectMessage(transaction, address));\n      const signatures = yield this.walletConnector.sendCustomRequest({\n        method: \"erd_batch_sign\",\n        params\n      });\n\n      if (!signatures) {\n        logger_1.Logger.error(\"signTransactions: Wallet Connect could not sign the transactions\");\n        throw new Error(\"Wallet Connect could not sign the transactions\");\n      }\n\n      if (Array.isArray(signatures)) {\n        if (transactions.length !== signatures.length) {\n          logger_1.Logger.error(\"signTransactions: Wallet Connect could not sign the transactions. Invalid signatures.\");\n          throw new Error(\"Wallet Connect could not sign the transactions. Invalid signatures.\");\n        }\n\n        transactions.map((transaction, key) => transaction.applySignature(new signature_1.Signature(signatures[key].signature), new address_1.Address(address)));\n        return transactions;\n      }\n\n      transactions[0].applySignature(new signature_1.Signature(signatures.signature), new address_1.Address(address));\n      return transactions;\n    });\n  }\n  /**\n   * Sends a custom method and params and returns the response object\n   */\n\n\n  sendCustomMessage(_ref) {\n    let {\n      method,\n      params\n    } = _ref;\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!this.walletConnector) {\n        logger_1.Logger.error(\"sendCustomMessage: Wallet Connect not initialised, call init() first\");\n        throw new Error(\"Wallet Connect not initialised, call init() first\");\n      }\n\n      const customMessageResponse = yield this.walletConnector.sendCustomRequest({\n        method,\n        params\n      });\n\n      if (!customMessageResponse) {\n        logger_1.Logger.error(\"sendCustomMessage: Wallet Connect could not send the message\");\n        throw new Error(\"Wallet Connect could not send the message\");\n      }\n\n      return customMessageResponse;\n    });\n  }\n\n  onConnect(error, _ref2) {\n    let {\n      params\n    } = _ref2;\n    return __awaiter(this, void 0, void 0, function* () {\n      if (error) {\n        throw error;\n      }\n\n      if (!params || !params[0]) {\n        logger_1.Logger.error(\"Wallet Connect missing payload\");\n        throw new Error(\"missing payload\");\n      }\n\n      const {\n        accounts: [account]\n      } = params[0];\n      const [address, signature] = account.split(\".\");\n      yield this.loginAccount(address, signature);\n    });\n  }\n\n  onDisconnect(error) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (error) {\n        throw error;\n      }\n\n      this.onClientConnect.onClientLogout();\n    });\n  }\n\n  loginAccount(address, signature) {\n    var _a, _b;\n\n    return __awaiter(this, void 0, void 0, function* () {\n      if (this.addressIsValid(address)) {\n        this.address = address;\n\n        if (signature) {\n          this.signature = signature;\n        }\n\n        this.onClientConnect.onClientLogin();\n        return;\n      }\n\n      logger_1.Logger.error(`Wallet Connect invalid address ${address}`);\n\n      if ((_a = this.walletConnector) === null || _a === void 0 ? void 0 : _a.connected) {\n        yield (_b = this.walletConnector) === null || _b === void 0 ? void 0 : _b.killSession();\n      }\n    });\n  }\n\n  prepareWalletConnectMessage(transaction, address) {\n    return {\n      nonce: transaction.getNonce().valueOf(),\n      from: address,\n      to: transaction.getReceiver().toString(),\n      amount: transaction.getValue().toString(),\n      gasPrice: transaction.getGasPrice().valueOf().toString(),\n      gasLimit: transaction.getGasLimit().valueOf().toString(),\n      data: Buffer.from(transaction.getData().toString().trim()).toString(),\n      chainId: transaction.getChainID().valueOf(),\n      version: transaction.getVersion().valueOf()\n    };\n  }\n\n  addressIsValid(destinationAddress) {\n    try {\n      const addr = new address_1.Address(destinationAddress);\n      return !!addr;\n    } catch (_a) {\n      return false;\n    }\n  }\n\n}\n\nexports.WalletConnectProvider = WalletConnectProvider;","map":{"version":3,"mappings":"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","names":["WalletConnectProvider","constructor","httpProvider","walletConnectBridge","onClientConnect","provider","init","walletConnector","client_1","bridge","on","onConnect","bind","onDisconnect","connected","accounts","length","account","address","signature","split","loginAccount","isInitialized","isConnected","Promise","resolve","_","login","_a","killSession","logger_1","trace","_b","createSession","chainId","constants_1","_c","uri","_d","logout","error","Error","getAddress","getSignature","sendTransaction","transaction","signTransaction","send","signMessage","errors_1","sig","sendCustomRequest","method","params","prepareWalletConnectMessage","applySignature","signature_1","address_1","signTransactions","transactions","map","signatures","Array","isArray","key","sendCustomMessage","customMessageResponse","onClientLogout","addressIsValid","onClientLogin","nonce","getNonce","valueOf","from","to","getReceiver","toString","amount","getValue","gasPrice","getGasPrice","gasLimit","getGasLimit","data","Buffer","getData","trim","getChainID","version","getVersion","destinationAddress","addr","exports"],"sourceRoot":"","sources":["../../src/dapp/walletConnectProvider.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}