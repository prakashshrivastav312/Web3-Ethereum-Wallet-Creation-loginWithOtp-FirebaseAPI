{"ast":null,"code":"\"use strict\";\n\nvar __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    if (typeof b !== \"function\" && b !== null) throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.STArray = void 0;\n\nvar serialized_type_1 = require(\"./serialized-type\");\n\nvar st_object_1 = require(\"./st-object\");\n\nvar binary_parser_1 = require(\"../serdes/binary-parser\");\n\nvar buffer_1 = require(\"buffer/\");\n\nvar ARRAY_END_MARKER = buffer_1.Buffer.from([0xf1]);\nvar ARRAY_END_MARKER_NAME = 'ArrayEndMarker';\nvar OBJECT_END_MARKER = buffer_1.Buffer.from([0xe1]);\n/**\n * TypeGuard for Array<JsonObject>\n */\n\nfunction isObjects(args) {\n  return Array.isArray(args) && (args.length === 0 || typeof args[0] === 'object');\n}\n/**\n * Class for serializing and deserializing Arrays of Objects\n */\n\n\nvar STArray =\n/** @class */\nfunction (_super) {\n  __extends(STArray, _super);\n\n  function STArray() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n  /**\n   * Construct an STArray from a BinaryParser\n   *\n   * @param parser BinaryParser to parse an STArray from\n   * @returns An STArray Object\n   */\n\n\n  STArray.fromParser = function (parser) {\n    var bytes = [];\n\n    while (!parser.end()) {\n      var field = parser.readField();\n\n      if (field.name === ARRAY_END_MARKER_NAME) {\n        break;\n      }\n\n      bytes.push(field.header, parser.readFieldValue(field).toBytes(), OBJECT_END_MARKER);\n    }\n\n    bytes.push(ARRAY_END_MARKER);\n    return new STArray(buffer_1.Buffer.concat(bytes));\n  };\n  /**\n   * Construct an STArray from an Array of JSON Objects\n   *\n   * @param value STArray or Array of Objects to parse into an STArray\n   * @returns An STArray object\n   */\n\n\n  STArray.from = function (value) {\n    if (value instanceof STArray) {\n      return value;\n    }\n\n    if (isObjects(value)) {\n      var bytes_1 = [];\n      value.forEach(function (obj) {\n        bytes_1.push(st_object_1.STObject.from(obj).toBytes());\n      });\n      bytes_1.push(ARRAY_END_MARKER);\n      return new STArray(buffer_1.Buffer.concat(bytes_1));\n    }\n\n    throw new Error('Cannot construct STArray from value given');\n  };\n  /**\n   * Return the JSON representation of this.bytes\n   *\n   * @returns An Array of JSON objects\n   */\n\n\n  STArray.prototype.toJSON = function () {\n    var result = [];\n    var arrayParser = new binary_parser_1.BinaryParser(this.toString());\n\n    while (!arrayParser.end()) {\n      var field = arrayParser.readField();\n\n      if (field.name === ARRAY_END_MARKER_NAME) {\n        break;\n      }\n\n      var outer = {};\n      outer[field.name] = st_object_1.STObject.fromParser(arrayParser).toJSON();\n      result.push(outer);\n    }\n\n    return result;\n  };\n\n  return STArray;\n}(serialized_type_1.SerializedType);\n\nexports.STArray = STArray;","map":{"version":3,"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;;AACA;;AACA;;AACA;;AAEA,IAAMA,gBAAgB,GAAGC,gBAAOC,IAAP,CAAY,CAAC,IAAD,CAAZ,CAAzB;AACA,IAAMC,qBAAqB,GAAG,gBAA9B;AAEA,IAAMC,iBAAiB,GAAGH,gBAAOC,IAAP,CAAY,CAAC,IAAD,CAAZ,CAA1B;AAEA;;;;AAGA,SAASG,SAAT,CAAmBC,IAAnB,EAAuB;EACrB,OACEC,KAAK,CAACC,OAAN,CAAcF,IAAd,MAAwBA,IAAI,CAACG,MAAL,KAAgB,CAAhB,IAAqB,OAAOH,IAAI,CAAC,CAAD,CAAX,KAAmB,QAAhE,CADF;AAGD;AAED;;;;;AAGA;AAAA;AAAA;EAAsBI;;EAAtB;;EA0EC;EAzEC;;;;;;;;EAMOC,qBAAP,UAAkBC,MAAlB,EAAsC;IACpC,IAAMC,KAAK,GAAkB,EAA7B;;IAEA,OAAO,CAACD,MAAM,CAACE,GAAP,EAAR,EAAsB;MACpB,IAAMC,KAAK,GAAGH,MAAM,CAACI,SAAP,EAAd;;MACA,IAAID,KAAK,CAACE,IAAN,KAAed,qBAAnB,EAA0C;QACxC;MACD;;MAEDU,KAAK,CAACK,IAAN,CACEH,KAAK,CAACI,MADR,EAEEP,MAAM,CAACQ,cAAP,CAAsBL,KAAtB,EAA6BM,OAA7B,EAFF,EAGEjB,iBAHF;IAKD;;IAEDS,KAAK,CAACK,IAAN,CAAWlB,gBAAX;IACA,OAAO,IAAIW,OAAJ,CAAYV,gBAAOqB,MAAP,CAAcT,KAAd,CAAZ,CAAP;EACD,CAlBM;EAoBP;;;;;;;;EAMOF,eAAP,UAAmDY,KAAnD,EAA2D;IACzD,IAAIA,KAAK,YAAYZ,OAArB,EAA8B;MAC5B,OAAOY,KAAP;IACD;;IAED,IAAIlB,SAAS,CAACkB,KAAD,CAAb,EAAsB;MACpB,IAAMC,OAAK,GAAkB,EAA7B;MACAD,KAAK,CAACE,OAAN,CAAc,UAACC,GAAD,EAAI;QAChBF,OAAK,CAACN,IAAN,CAAWS,qBAASzB,IAAT,CAAcwB,GAAd,EAAmBL,OAAnB,EAAX;MACD,CAFD;MAIAG,OAAK,CAACN,IAAN,CAAWlB,gBAAX;MACA,OAAO,IAAIW,OAAJ,CAAYV,gBAAOqB,MAAP,CAAcE,OAAd,CAAZ,CAAP;IACD;;IAED,MAAM,IAAII,KAAJ,CAAU,2CAAV,CAAN;EACD,CAhBM;EAkBP;;;;;;;EAKAjB;IACE,IAAMkB,MAAM,GAAsB,EAAlC;IAEA,IAAMC,WAAW,GAAG,IAAIC,4BAAJ,CAAiB,KAAKC,QAAL,EAAjB,CAApB;;IAEA,OAAO,CAACF,WAAW,CAAChB,GAAZ,EAAR,EAA2B;MACzB,IAAMC,KAAK,GAAGe,WAAW,CAACd,SAAZ,EAAd;;MACA,IAAID,KAAK,CAACE,IAAN,KAAed,qBAAnB,EAA0C;QACxC;MACD;;MAED,IAAM8B,KAAK,GAAG,EAAd;MACAA,KAAK,CAAClB,KAAK,CAACE,IAAP,CAAL,GAAoBU,qBAASO,UAAT,CAAoBJ,WAApB,EAAiCK,MAAjC,EAApB;MACAN,MAAM,CAACX,IAAP,CAAYe,KAAZ;IACD;;IAED,OAAOJ,MAAP;EACD,CAjBD;;EAkBF;AAAC,CA1ED,CAAsBO,gCAAtB;;AA4ESC","names":["ARRAY_END_MARKER","buffer_1","from","ARRAY_END_MARKER_NAME","OBJECT_END_MARKER","isObjects","args","Array","isArray","length","__extends","STArray","parser","bytes","end","field","readField","name","push","header","readFieldValue","toBytes","concat","value","bytes_1","forEach","obj","st_object_1","Error","result","arrayParser","binary_parser_1","toString","outer","fromParser","toJSON","serialized_type_1","exports"],"sourceRoot":"","sources":["../../src/types/st-array.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}