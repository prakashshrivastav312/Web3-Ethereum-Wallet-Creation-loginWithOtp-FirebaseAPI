{"ast":null,"code":"'use strict';\n\nvar urilib = require('url');\n\nvar attribute = require('./attribute');\n\nvar helpers = require('./helpers');\n\nvar ValidatorResult = helpers.ValidatorResult;\nvar SchemaError = helpers.SchemaError;\nvar SchemaContext = helpers.SchemaContext;\n/**\n * Creates a new Validator object\n * @name Validator\n * @constructor\n */\n\nvar Validator = function Validator() {\n  // Allow a validator instance to override global custom formats or to have their\n  // own custom formats.\n  this.customFormats = Object.create(Validator.prototype.customFormats);\n  this.schemas = {};\n  this.unresolvedRefs = []; // Use Object.create to make this extensible without Validator instances stepping on each other's toes.\n\n  this.types = Object.create(types);\n  this.attributes = Object.create(attribute.validators);\n}; // Allow formats to be registered globally.\n\n\nValidator.prototype.customFormats = {}; // Hint at the presence of a property\n\nValidator.prototype.schemas = null;\nValidator.prototype.types = null;\nValidator.prototype.attributes = null;\nValidator.prototype.unresolvedRefs = null;\n/**\n * Adds a schema with a certain urn to the Validator instance.\n * @param schema\n * @param urn\n * @return {Object}\n */\n\nValidator.prototype.addSchema = function addSchema(schema, uri) {\n  if (!schema) {\n    return null;\n  }\n\n  var ourUri = uri || schema.id;\n  this.addSubSchema(ourUri, schema);\n\n  if (ourUri) {\n    this.schemas[ourUri] = schema;\n  }\n\n  return this.schemas[ourUri];\n};\n\nValidator.prototype.addSubSchema = function addSubSchema(baseuri, schema) {\n  if (!schema || typeof schema != 'object') return; // Mark all referenced schemas so we can tell later which schemas are referred to, but never defined\n\n  if (schema.$ref) {\n    var resolvedUri = urilib.resolve(baseuri, schema.$ref); // Only mark unknown schemas as unresolved\n\n    if (this.schemas[resolvedUri] === undefined) {\n      this.schemas[resolvedUri] = null;\n      this.unresolvedRefs.push(resolvedUri);\n    }\n\n    return;\n  }\n\n  var ourUri = schema.id && urilib.resolve(baseuri, schema.id);\n  var ourBase = ourUri || baseuri;\n\n  if (ourUri) {\n    if (this.schemas[ourUri]) {\n      if (!helpers.deepCompareStrict(this.schemas[ourUri], schema)) {\n        throw new Error('Schema <' + schema + '> already exists with different definition');\n      }\n\n      return this.schemas[ourUri];\n    }\n\n    this.schemas[ourUri] = schema;\n    var documentUri = ourUri.replace(/^([^#]*)#$/, '$1');\n    this.schemas[documentUri] = schema;\n  }\n\n  this.addSubSchemaArray(ourBase, schema.items instanceof Array ? schema.items : [schema.items]);\n  this.addSubSchemaArray(ourBase, schema.extends instanceof Array ? schema.extends : [schema.extends]);\n  this.addSubSchema(ourBase, schema.additionalItems);\n  this.addSubSchemaObject(ourBase, schema.properties);\n  this.addSubSchema(ourBase, schema.additionalProperties);\n  this.addSubSchemaObject(ourBase, schema.definitions);\n  this.addSubSchemaObject(ourBase, schema.patternProperties);\n  this.addSubSchemaObject(ourBase, schema.dependencies);\n  this.addSubSchemaArray(ourBase, schema.disallow);\n  this.addSubSchemaArray(ourBase, schema.allOf);\n  this.addSubSchemaArray(ourBase, schema.anyOf);\n  this.addSubSchemaArray(ourBase, schema.oneOf);\n  this.addSubSchema(ourBase, schema.not);\n  return this.schemas[ourUri];\n};\n\nValidator.prototype.addSubSchemaArray = function addSubSchemaArray(baseuri, schemas) {\n  if (!(schemas instanceof Array)) return;\n\n  for (var i = 0; i < schemas.length; i++) {\n    this.addSubSchema(baseuri, schemas[i]);\n  }\n};\n\nValidator.prototype.addSubSchemaObject = function addSubSchemaArray(baseuri, schemas) {\n  if (!schemas || typeof schemas != 'object') return;\n\n  for (var p in schemas) {\n    this.addSubSchema(baseuri, schemas[p]);\n  }\n};\n/**\n * Sets all the schemas of the Validator instance.\n * @param schemas\n */\n\n\nValidator.prototype.setSchemas = function setSchemas(schemas) {\n  this.schemas = schemas;\n};\n/**\n * Returns the schema of a certain urn\n * @param urn\n */\n\n\nValidator.prototype.getSchema = function getSchema(urn) {\n  return this.schemas[urn];\n};\n/**\n * Validates instance against the provided schema\n * @param instance\n * @param schema\n * @param [options]\n * @param [ctx]\n * @return {Array}\n */\n\n\nValidator.prototype.validate = function validate(instance, schema, options, ctx) {\n  if (!options) {\n    options = {};\n  }\n\n  var propertyName = options.propertyName || 'instance'; // This will work so long as the function at uri.resolve() will resolve a relative URI to a relative URI\n\n  var base = urilib.resolve(options.base || '/', schema.id || '');\n\n  if (!ctx) {\n    ctx = new SchemaContext(schema, options, propertyName, base, Object.create(this.schemas));\n\n    if (!ctx.schemas[base]) {\n      ctx.schemas[base] = schema;\n    }\n  }\n\n  if (schema) {\n    var result = this.validateSchema(instance, schema, options, ctx);\n\n    if (!result) {\n      throw new Error('Result undefined');\n    }\n\n    return result;\n  }\n\n  throw new SchemaError('no schema specified', schema);\n};\n/**\n* @param Object schema\n* @return mixed schema uri or false\n*/\n\n\nfunction shouldResolve(schema) {\n  var ref = typeof schema === 'string' ? schema : schema.$ref;\n  if (typeof ref == 'string') return ref;\n  return false;\n}\n/**\n * Validates an instance against the schema (the actual work horse)\n * @param instance\n * @param schema\n * @param options\n * @param ctx\n * @private\n * @return {ValidatorResult}\n */\n\n\nValidator.prototype.validateSchema = function validateSchema(instance, schema, options, ctx) {\n  var result = new ValidatorResult(instance, schema, options, ctx);\n\n  if (!schema) {\n    throw new Error(\"schema is undefined\");\n  }\n\n  if (schema['extends']) {\n    if (schema['extends'] instanceof Array) {\n      var schemaobj = {\n        schema: schema,\n        ctx: ctx\n      };\n      schema['extends'].forEach(this.schemaTraverser.bind(this, schemaobj));\n      schema = schemaobj.schema;\n      schemaobj.schema = null;\n      schemaobj.ctx = null;\n      schemaobj = null;\n    } else {\n      schema = helpers.deepMerge(schema, this.superResolve(schema['extends'], ctx));\n    }\n  }\n\n  var switchSchema;\n\n  if (switchSchema = shouldResolve(schema)) {\n    var resolved = this.resolve(schema, switchSchema, ctx);\n    var subctx = new SchemaContext(resolved.subschema, options, ctx.propertyPath, resolved.switchSchema, ctx.schemas);\n    return this.validateSchema(instance, resolved.subschema, options, subctx);\n  }\n\n  var skipAttributes = options && options.skipAttributes || []; // Validate each schema attribute against the instance\n\n  for (var key in schema) {\n    if (!attribute.ignoreProperties[key] && skipAttributes.indexOf(key) < 0) {\n      var validatorErr = null;\n      var validator = this.attributes[key];\n\n      if (validator) {\n        validatorErr = validator.call(this, instance, schema, options, ctx);\n      } else if (options.allowUnknownAttributes === false) {\n        // This represents an error with the schema itself, not an invalid instance\n        throw new SchemaError(\"Unsupported attribute: \" + key, schema);\n      }\n\n      if (validatorErr) {\n        result.importErrors(validatorErr);\n      }\n    }\n  }\n\n  if (typeof options.rewrite == 'function') {\n    var value = options.rewrite.call(this, instance, schema, options, ctx);\n    result.instance = value;\n  }\n\n  return result;\n};\n/**\n* @private\n* @param Object schema\n* @param SchemaContext ctx\n* @returns Object schema or resolved schema\n*/\n\n\nValidator.prototype.schemaTraverser = function schemaTraverser(schemaobj, s) {\n  schemaobj.schema = helpers.deepMerge(schemaobj.schema, this.superResolve(s, schemaobj.ctx));\n};\n/**\n* @private\n* @param Object schema\n* @param SchemaContext ctx\n* @returns Object schema or resolved schema\n*/\n\n\nValidator.prototype.superResolve = function superResolve(schema, ctx) {\n  var ref;\n\n  if (ref = shouldResolve(schema)) {\n    return this.resolve(schema, ref, ctx).subschema;\n  }\n\n  return schema;\n};\n/**\n* @private\n* @param Object schema\n* @param Object switchSchema\n* @param SchemaContext ctx\n* @return Object resolved schemas {subschema:String, switchSchema: String}\n* @throws SchemaError\n*/\n\n\nValidator.prototype.resolve = function resolve(schema, switchSchema, ctx) {\n  switchSchema = ctx.resolve(switchSchema); // First see if the schema exists under the provided URI\n\n  if (ctx.schemas[switchSchema]) {\n    return {\n      subschema: ctx.schemas[switchSchema],\n      switchSchema: switchSchema\n    };\n  } // Else try walking the property pointer\n\n\n  var parsed = urilib.parse(switchSchema);\n  var fragment = parsed && parsed.hash;\n  var document = fragment && fragment.length && switchSchema.substr(0, switchSchema.length - fragment.length);\n\n  if (!document || !ctx.schemas[document]) {\n    throw new SchemaError(\"no such schema <\" + switchSchema + \">\", schema);\n  }\n\n  var subschema = helpers.objectGetPath(ctx.schemas[document], fragment.substr(1));\n\n  if (subschema === undefined) {\n    throw new SchemaError(\"no such schema \" + fragment + \" located in <\" + document + \">\", schema);\n  }\n\n  return {\n    subschema: subschema,\n    switchSchema: switchSchema\n  };\n};\n/**\n * Tests whether the instance if of a certain type.\n * @private\n * @param instance\n * @param schema\n * @param options\n * @param ctx\n * @param type\n * @return {boolean}\n */\n\n\nValidator.prototype.testType = function validateType(instance, schema, options, ctx, type) {\n  if (typeof this.types[type] == 'function') {\n    return this.types[type].call(this, instance);\n  }\n\n  if (type && typeof type == 'object') {\n    var res = this.validateSchema(instance, type, options, ctx);\n    return res === undefined || !(res && res.errors.length);\n  } // Undefined or properties not on the list are acceptable, same as not being defined\n\n\n  return true;\n};\n\nvar types = Validator.prototype.types = {};\n\ntypes.string = function testString(instance) {\n  return typeof instance == 'string';\n};\n\ntypes.number = function testNumber(instance) {\n  // isFinite returns false for NaN, Infinity, and -Infinity\n  return typeof instance == 'number' && isFinite(instance);\n};\n\ntypes.integer = function testInteger(instance) {\n  return typeof instance == 'number' && instance % 1 === 0;\n};\n\ntypes.boolean = function testBoolean(instance) {\n  return typeof instance == 'boolean';\n};\n\ntypes.array = function testArray(instance) {\n  return Array.isArray(instance);\n};\n\ntypes['null'] = function testNull(instance) {\n  return instance === null;\n};\n\ntypes.date = function testDate(instance) {\n  return instance instanceof Date;\n};\n\ntypes.any = function testAny(instance) {\n  return true;\n};\n\ntypes.object = function testObject(instance) {\n  // TODO: fix this - see #15\n  return instance && typeof instance === 'object' && !(instance instanceof Array) && !(instance instanceof Date);\n};\n\nmodule.exports = Validator;","map":{"version":3,"names":["urilib","require","attribute","helpers","ValidatorResult","SchemaError","SchemaContext","Validator","customFormats","Object","create","prototype","schemas","unresolvedRefs","types","attributes","validators","addSchema","schema","uri","ourUri","id","addSubSchema","baseuri","$ref","resolvedUri","resolve","undefined","push","ourBase","deepCompareStrict","Error","documentUri","replace","addSubSchemaArray","items","Array","extends","additionalItems","addSubSchemaObject","properties","additionalProperties","definitions","patternProperties","dependencies","disallow","allOf","anyOf","oneOf","not","i","length","p","setSchemas","getSchema","urn","validate","instance","options","ctx","propertyName","base","result","validateSchema","shouldResolve","ref","schemaobj","forEach","schemaTraverser","bind","deepMerge","superResolve","switchSchema","resolved","subctx","subschema","propertyPath","skipAttributes","key","ignoreProperties","indexOf","validatorErr","validator","call","allowUnknownAttributes","importErrors","rewrite","value","s","parsed","parse","fragment","hash","document","substr","objectGetPath","testType","validateType","type","res","errors","string","testString","number","testNumber","isFinite","integer","testInteger","boolean","testBoolean","array","testArray","isArray","testNull","date","testDate","Date","any","testAny","object","testObject","module","exports"],"sources":["C:/Users/acer/node_modules/jsonschema/lib/validator.js"],"sourcesContent":["'use strict';\n\nvar urilib = require('url');\n\nvar attribute = require('./attribute');\nvar helpers = require('./helpers');\nvar ValidatorResult = helpers.ValidatorResult;\nvar SchemaError = helpers.SchemaError;\nvar SchemaContext = helpers.SchemaContext;\n\n/**\n * Creates a new Validator object\n * @name Validator\n * @constructor\n */\nvar Validator = function Validator () {\n  // Allow a validator instance to override global custom formats or to have their\n  // own custom formats.\n  this.customFormats = Object.create(Validator.prototype.customFormats);\n  this.schemas = {};\n  this.unresolvedRefs = [];\n\n  // Use Object.create to make this extensible without Validator instances stepping on each other's toes.\n  this.types = Object.create(types);\n  this.attributes = Object.create(attribute.validators);\n};\n\n// Allow formats to be registered globally.\nValidator.prototype.customFormats = {};\n\n// Hint at the presence of a property\nValidator.prototype.schemas = null;\nValidator.prototype.types = null;\nValidator.prototype.attributes = null;\nValidator.prototype.unresolvedRefs = null;\n\n/**\n * Adds a schema with a certain urn to the Validator instance.\n * @param schema\n * @param urn\n * @return {Object}\n */\nValidator.prototype.addSchema = function addSchema (schema, uri) {\n  if (!schema) {\n    return null;\n  }\n  var ourUri = uri || schema.id;\n  this.addSubSchema(ourUri, schema);\n  if (ourUri) {\n    this.schemas[ourUri] = schema;\n  }\n  return this.schemas[ourUri];\n};\n\nValidator.prototype.addSubSchema = function addSubSchema(baseuri, schema) {\n  if(!schema || typeof schema!='object') return;\n  // Mark all referenced schemas so we can tell later which schemas are referred to, but never defined\n  if(schema.$ref){\n    var resolvedUri = urilib.resolve(baseuri, schema.$ref);\n    // Only mark unknown schemas as unresolved\n    if (this.schemas[resolvedUri] === undefined) {\n      this.schemas[resolvedUri] = null;\n      this.unresolvedRefs.push(resolvedUri);\n    }\n    return;\n  }\n  var ourUri = schema.id && urilib.resolve(baseuri, schema.id);\n  var ourBase = ourUri || baseuri;\n  if (ourUri) {\n    if(this.schemas[ourUri]){\n      if(!helpers.deepCompareStrict(this.schemas[ourUri], schema)){\n        throw new Error('Schema <'+schema+'> already exists with different definition');\n      }\n      return this.schemas[ourUri];\n    }\n    this.schemas[ourUri] = schema;\n    var documentUri = ourUri.replace(/^([^#]*)#$/, '$1');\n    this.schemas[documentUri] = schema;\n  }\n  this.addSubSchemaArray(ourBase, ((schema.items instanceof Array)?schema.items:[schema.items]));\n  this.addSubSchemaArray(ourBase, ((schema.extends instanceof Array)?schema.extends:[schema.extends]));\n  this.addSubSchema(ourBase, schema.additionalItems);\n  this.addSubSchemaObject(ourBase, schema.properties);\n  this.addSubSchema(ourBase, schema.additionalProperties);\n  this.addSubSchemaObject(ourBase, schema.definitions);\n  this.addSubSchemaObject(ourBase, schema.patternProperties);\n  this.addSubSchemaObject(ourBase, schema.dependencies);\n  this.addSubSchemaArray(ourBase, schema.disallow);\n  this.addSubSchemaArray(ourBase, schema.allOf);\n  this.addSubSchemaArray(ourBase, schema.anyOf);\n  this.addSubSchemaArray(ourBase, schema.oneOf);\n  this.addSubSchema(ourBase, schema.not);\n  return this.schemas[ourUri];\n};\n\nValidator.prototype.addSubSchemaArray = function addSubSchemaArray(baseuri, schemas) {\n  if(!(schemas instanceof Array)) return;\n  for(var i=0; i<schemas.length; i++){\n    this.addSubSchema(baseuri, schemas[i]);\n  }\n};\n\nValidator.prototype.addSubSchemaObject = function addSubSchemaArray(baseuri, schemas) {\n  if(!schemas || typeof schemas!='object') return;\n  for(var p in schemas){\n    this.addSubSchema(baseuri, schemas[p]);\n  }\n};\n\n\n\n/**\n * Sets all the schemas of the Validator instance.\n * @param schemas\n */\nValidator.prototype.setSchemas = function setSchemas (schemas) {\n  this.schemas = schemas;\n};\n\n/**\n * Returns the schema of a certain urn\n * @param urn\n */\nValidator.prototype.getSchema = function getSchema (urn) {\n  return this.schemas[urn];\n};\n\n/**\n * Validates instance against the provided schema\n * @param instance\n * @param schema\n * @param [options]\n * @param [ctx]\n * @return {Array}\n */\nValidator.prototype.validate = function validate (instance, schema, options, ctx) {\n  if (!options) {\n    options = {};\n  }\n  var propertyName = options.propertyName || 'instance';\n  // This will work so long as the function at uri.resolve() will resolve a relative URI to a relative URI\n  var base = urilib.resolve(options.base||'/', schema.id||'');\n  if(!ctx){\n    ctx = new SchemaContext(schema, options, propertyName, base, Object.create(this.schemas));\n    if (!ctx.schemas[base]) {\n      ctx.schemas[base] = schema;\n    }\n  }\n  if (schema) {\n    var result = this.validateSchema(instance, schema, options, ctx);\n    if (!result) {\n      throw new Error('Result undefined');\n    }\n    return result;\n  }\n  throw new SchemaError('no schema specified', schema);\n};\n\n/**\n* @param Object schema\n* @return mixed schema uri or false\n*/\nfunction shouldResolve(schema) {\n  var ref = (typeof schema === 'string') ? schema : schema.$ref;\n  if (typeof ref=='string') return ref;\n  return false;\n}\n\n/**\n * Validates an instance against the schema (the actual work horse)\n * @param instance\n * @param schema\n * @param options\n * @param ctx\n * @private\n * @return {ValidatorResult}\n */\nValidator.prototype.validateSchema = function validateSchema (instance, schema, options, ctx) {\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  if (!schema) {\n    throw new Error(\"schema is undefined\");\n  }\n\n  if (schema['extends']) {\n    if (schema['extends'] instanceof Array) {\n      var schemaobj = {schema: schema, ctx: ctx};\n      schema['extends'].forEach(this.schemaTraverser.bind(this, schemaobj));\n      schema = schemaobj.schema;\n      schemaobj.schema = null;\n      schemaobj.ctx = null;\n      schemaobj = null;\n    } else {\n      schema = helpers.deepMerge(schema, this.superResolve(schema['extends'], ctx));\n    }\n  }\n\n  var switchSchema;\n  if (switchSchema = shouldResolve(schema)) {\n    var resolved = this.resolve(schema, switchSchema, ctx);\n    var subctx = new SchemaContext(resolved.subschema, options, ctx.propertyPath, resolved.switchSchema, ctx.schemas);\n    return this.validateSchema(instance, resolved.subschema, options, subctx);\n  }\n\n  var skipAttributes = options && options.skipAttributes || [];\n  // Validate each schema attribute against the instance\n  for (var key in schema) {\n    if (!attribute.ignoreProperties[key] && skipAttributes.indexOf(key) < 0) {\n      var validatorErr = null;\n      var validator = this.attributes[key];\n      if (validator) {\n        validatorErr = validator.call(this, instance, schema, options, ctx);\n      } else if (options.allowUnknownAttributes === false) {\n        // This represents an error with the schema itself, not an invalid instance\n        throw new SchemaError(\"Unsupported attribute: \" + key, schema);\n      }\n      if (validatorErr) {\n        result.importErrors(validatorErr);\n      }\n    }\n  }\n\n  if (typeof options.rewrite == 'function') {\n    var value = options.rewrite.call(this, instance, schema, options, ctx);\n    result.instance = value;\n  }\n  return result;\n};\n\n/**\n* @private\n* @param Object schema\n* @param SchemaContext ctx\n* @returns Object schema or resolved schema\n*/\nValidator.prototype.schemaTraverser = function schemaTraverser (schemaobj, s) {\n  schemaobj.schema = helpers.deepMerge(schemaobj.schema, this.superResolve(s, schemaobj.ctx));\n}\n\n/**\n* @private\n* @param Object schema\n* @param SchemaContext ctx\n* @returns Object schema or resolved schema\n*/\nValidator.prototype.superResolve = function superResolve (schema, ctx) {\n  var ref;\n  if(ref = shouldResolve(schema)) {\n    return this.resolve(schema, ref, ctx).subschema;\n  }\n  return schema;\n}\n\n/**\n* @private\n* @param Object schema\n* @param Object switchSchema\n* @param SchemaContext ctx\n* @return Object resolved schemas {subschema:String, switchSchema: String}\n* @throws SchemaError\n*/\nValidator.prototype.resolve = function resolve (schema, switchSchema, ctx) {\n  switchSchema = ctx.resolve(switchSchema);\n  // First see if the schema exists under the provided URI\n  if (ctx.schemas[switchSchema]) {\n    return {subschema: ctx.schemas[switchSchema], switchSchema: switchSchema};\n  }\n  // Else try walking the property pointer\n  var parsed = urilib.parse(switchSchema);\n  var fragment = parsed && parsed.hash;\n  var document = fragment && fragment.length && switchSchema.substr(0, switchSchema.length - fragment.length);\n  if (!document || !ctx.schemas[document]) {\n    throw new SchemaError(\"no such schema <\" + switchSchema + \">\", schema);\n  }\n  var subschema = helpers.objectGetPath(ctx.schemas[document], fragment.substr(1));\n  if(subschema===undefined){\n    throw new SchemaError(\"no such schema \" + fragment + \" located in <\" + document + \">\", schema);\n  }\n  return {subschema: subschema, switchSchema: switchSchema};\n};\n\n/**\n * Tests whether the instance if of a certain type.\n * @private\n * @param instance\n * @param schema\n * @param options\n * @param ctx\n * @param type\n * @return {boolean}\n */\nValidator.prototype.testType = function validateType (instance, schema, options, ctx, type) {\n  if (typeof this.types[type] == 'function') {\n    return this.types[type].call(this, instance);\n  }\n  if (type && typeof type == 'object') {\n    var res = this.validateSchema(instance, type, options, ctx);\n    return res === undefined || !(res && res.errors.length);\n  }\n  // Undefined or properties not on the list are acceptable, same as not being defined\n  return true;\n};\n\nvar types = Validator.prototype.types = {};\ntypes.string = function testString (instance) {\n  return typeof instance == 'string';\n};\ntypes.number = function testNumber (instance) {\n  // isFinite returns false for NaN, Infinity, and -Infinity\n  return typeof instance == 'number' && isFinite(instance);\n};\ntypes.integer = function testInteger (instance) {\n  return (typeof instance == 'number') && instance % 1 === 0;\n};\ntypes.boolean = function testBoolean (instance) {\n  return typeof instance == 'boolean';\n};\ntypes.array = function testArray (instance) {\n  return Array.isArray(instance);\n};\ntypes['null'] = function testNull (instance) {\n  return instance === null;\n};\ntypes.date = function testDate (instance) {\n  return instance instanceof Date;\n};\ntypes.any = function testAny (instance) {\n  return true;\n};\ntypes.object = function testObject (instance) {\n  // TODO: fix this - see #15\n  return instance && (typeof instance) === 'object' && !(instance instanceof Array) && !(instance instanceof Date);\n};\n\nmodule.exports = Validator;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}