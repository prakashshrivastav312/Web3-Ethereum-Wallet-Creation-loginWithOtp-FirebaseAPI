{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n\nconst convert = require('../converter');\n\nconst tools_1 = require('../converter/tools');\n\nconst varuint = require('../converter/varint');\n\nconst typeFields_1 = require('../typeFields');\n\nfunction psbtFromBuffer(buffer, txGetter) {\n  let offset = 0;\n\n  function varSlice() {\n    const keyLen = varuint.decode(buffer, offset);\n    offset += varuint.encodingLength(keyLen);\n    const key = buffer.slice(offset, offset + keyLen);\n    offset += keyLen;\n    return key;\n  }\n\n  function readUInt32BE() {\n    const num = buffer.readUInt32BE(offset);\n    offset += 4;\n    return num;\n  }\n\n  function readUInt8() {\n    const num = buffer.readUInt8(offset);\n    offset += 1;\n    return num;\n  }\n\n  function getKeyValue() {\n    const key = varSlice();\n    const value = varSlice();\n    return {\n      key,\n      value\n    };\n  }\n\n  function checkEndOfKeyValPairs() {\n    if (offset >= buffer.length) {\n      throw new Error('Format Error: Unexpected End of PSBT');\n    }\n\n    const isEnd = buffer.readUInt8(offset) === 0;\n\n    if (isEnd) {\n      offset++;\n    }\n\n    return isEnd;\n  }\n\n  if (readUInt32BE() !== 0x70736274) {\n    throw new Error('Format Error: Invalid Magic Number');\n  }\n\n  if (readUInt8() !== 0xff) {\n    throw new Error('Format Error: Magic Number must be followed by 0xff separator');\n  }\n\n  const globalMapKeyVals = [];\n  const globalKeyIndex = {};\n\n  while (!checkEndOfKeyValPairs()) {\n    const keyVal = getKeyValue();\n    const hexKey = keyVal.key.toString('hex');\n\n    if (globalKeyIndex[hexKey]) {\n      throw new Error('Format Error: Keys must be unique for global keymap: key ' + hexKey);\n    }\n\n    globalKeyIndex[hexKey] = 1;\n    globalMapKeyVals.push(keyVal);\n  }\n\n  const unsignedTxMaps = globalMapKeyVals.filter(keyVal => keyVal.key[0] === typeFields_1.GlobalTypes.UNSIGNED_TX);\n\n  if (unsignedTxMaps.length !== 1) {\n    throw new Error('Format Error: Only one UNSIGNED_TX allowed');\n  }\n\n  const unsignedTx = txGetter(unsignedTxMaps[0].value); // Get input and output counts to loop the respective fields\n\n  const {\n    inputCount,\n    outputCount\n  } = unsignedTx.getInputOutputCounts();\n  const inputKeyVals = [];\n  const outputKeyVals = []; // Get input fields\n\n  for (const index of tools_1.range(inputCount)) {\n    const inputKeyIndex = {};\n    const input = [];\n\n    while (!checkEndOfKeyValPairs()) {\n      const keyVal = getKeyValue();\n      const hexKey = keyVal.key.toString('hex');\n\n      if (inputKeyIndex[hexKey]) {\n        throw new Error('Format Error: Keys must be unique for each input: ' + 'input index ' + index + ' key ' + hexKey);\n      }\n\n      inputKeyIndex[hexKey] = 1;\n      input.push(keyVal);\n    }\n\n    inputKeyVals.push(input);\n  }\n\n  for (const index of tools_1.range(outputCount)) {\n    const outputKeyIndex = {};\n    const output = [];\n\n    while (!checkEndOfKeyValPairs()) {\n      const keyVal = getKeyValue();\n      const hexKey = keyVal.key.toString('hex');\n\n      if (outputKeyIndex[hexKey]) {\n        throw new Error('Format Error: Keys must be unique for each output: ' + 'output index ' + index + ' key ' + hexKey);\n      }\n\n      outputKeyIndex[hexKey] = 1;\n      output.push(keyVal);\n    }\n\n    outputKeyVals.push(output);\n  }\n\n  return psbtFromKeyVals(unsignedTx, {\n    globalMapKeyVals,\n    inputKeyVals,\n    outputKeyVals\n  });\n}\n\nexports.psbtFromBuffer = psbtFromBuffer;\n\nfunction checkKeyBuffer(type, keyBuf, keyNum) {\n  if (!keyBuf.equals(Buffer.from([keyNum]))) {\n    throw new Error(`Format Error: Invalid ${type} key: ${keyBuf.toString('hex')}`);\n  }\n}\n\nexports.checkKeyBuffer = checkKeyBuffer;\n\nfunction psbtFromKeyVals(unsignedTx, _ref) {\n  let {\n    globalMapKeyVals,\n    inputKeyVals,\n    outputKeyVals\n  } = _ref;\n  // That was easy :-)\n  const globalMap = {\n    unsignedTx\n  };\n  let txCount = 0;\n\n  for (const keyVal of globalMapKeyVals) {\n    // If a globalMap item needs pubkey, uncomment\n    // const pubkey = convert.globals.checkPubkey(keyVal);\n    switch (keyVal.key[0]) {\n      case typeFields_1.GlobalTypes.UNSIGNED_TX:\n        checkKeyBuffer('global', keyVal.key, typeFields_1.GlobalTypes.UNSIGNED_TX);\n\n        if (txCount > 0) {\n          throw new Error('Format Error: GlobalMap has multiple UNSIGNED_TX');\n        }\n\n        txCount++;\n        break;\n\n      case typeFields_1.GlobalTypes.GLOBAL_XPUB:\n        if (globalMap.globalXpub === undefined) {\n          globalMap.globalXpub = [];\n        }\n\n        globalMap.globalXpub.push(convert.globals.globalXpub.decode(keyVal));\n        break;\n\n      default:\n        // This will allow inclusion during serialization.\n        if (!globalMap.unknownKeyVals) globalMap.unknownKeyVals = [];\n        globalMap.unknownKeyVals.push(keyVal);\n    }\n  } // Get input and output counts to loop the respective fields\n\n\n  const inputCount = inputKeyVals.length;\n  const outputCount = outputKeyVals.length;\n  const inputs = [];\n  const outputs = []; // Get input fields\n\n  for (const index of tools_1.range(inputCount)) {\n    const input = {};\n\n    for (const keyVal of inputKeyVals[index]) {\n      convert.inputs.checkPubkey(keyVal);\n\n      switch (keyVal.key[0]) {\n        case typeFields_1.InputTypes.NON_WITNESS_UTXO:\n          checkKeyBuffer('input', keyVal.key, typeFields_1.InputTypes.NON_WITNESS_UTXO);\n\n          if (input.nonWitnessUtxo !== undefined) {\n            throw new Error('Format Error: Input has multiple NON_WITNESS_UTXO');\n          }\n\n          input.nonWitnessUtxo = convert.inputs.nonWitnessUtxo.decode(keyVal);\n          break;\n\n        case typeFields_1.InputTypes.WITNESS_UTXO:\n          checkKeyBuffer('input', keyVal.key, typeFields_1.InputTypes.WITNESS_UTXO);\n\n          if (input.witnessUtxo !== undefined) {\n            throw new Error('Format Error: Input has multiple WITNESS_UTXO');\n          }\n\n          input.witnessUtxo = convert.inputs.witnessUtxo.decode(keyVal);\n          break;\n\n        case typeFields_1.InputTypes.PARTIAL_SIG:\n          if (input.partialSig === undefined) {\n            input.partialSig = [];\n          }\n\n          input.partialSig.push(convert.inputs.partialSig.decode(keyVal));\n          break;\n\n        case typeFields_1.InputTypes.SIGHASH_TYPE:\n          checkKeyBuffer('input', keyVal.key, typeFields_1.InputTypes.SIGHASH_TYPE);\n\n          if (input.sighashType !== undefined) {\n            throw new Error('Format Error: Input has multiple SIGHASH_TYPE');\n          }\n\n          input.sighashType = convert.inputs.sighashType.decode(keyVal);\n          break;\n\n        case typeFields_1.InputTypes.REDEEM_SCRIPT:\n          checkKeyBuffer('input', keyVal.key, typeFields_1.InputTypes.REDEEM_SCRIPT);\n\n          if (input.redeemScript !== undefined) {\n            throw new Error('Format Error: Input has multiple REDEEM_SCRIPT');\n          }\n\n          input.redeemScript = convert.inputs.redeemScript.decode(keyVal);\n          break;\n\n        case typeFields_1.InputTypes.WITNESS_SCRIPT:\n          checkKeyBuffer('input', keyVal.key, typeFields_1.InputTypes.WITNESS_SCRIPT);\n\n          if (input.witnessScript !== undefined) {\n            throw new Error('Format Error: Input has multiple WITNESS_SCRIPT');\n          }\n\n          input.witnessScript = convert.inputs.witnessScript.decode(keyVal);\n          break;\n\n        case typeFields_1.InputTypes.BIP32_DERIVATION:\n          if (input.bip32Derivation === undefined) {\n            input.bip32Derivation = [];\n          }\n\n          input.bip32Derivation.push(convert.inputs.bip32Derivation.decode(keyVal));\n          break;\n\n        case typeFields_1.InputTypes.FINAL_SCRIPTSIG:\n          checkKeyBuffer('input', keyVal.key, typeFields_1.InputTypes.FINAL_SCRIPTSIG);\n          input.finalScriptSig = convert.inputs.finalScriptSig.decode(keyVal);\n          break;\n\n        case typeFields_1.InputTypes.FINAL_SCRIPTWITNESS:\n          checkKeyBuffer('input', keyVal.key, typeFields_1.InputTypes.FINAL_SCRIPTWITNESS);\n          input.finalScriptWitness = convert.inputs.finalScriptWitness.decode(keyVal);\n          break;\n\n        case typeFields_1.InputTypes.POR_COMMITMENT:\n          checkKeyBuffer('input', keyVal.key, typeFields_1.InputTypes.POR_COMMITMENT);\n          input.porCommitment = convert.inputs.porCommitment.decode(keyVal);\n          break;\n\n        case typeFields_1.InputTypes.TAP_KEY_SIG:\n          checkKeyBuffer('input', keyVal.key, typeFields_1.InputTypes.TAP_KEY_SIG);\n          input.tapKeySig = convert.inputs.tapKeySig.decode(keyVal);\n          break;\n\n        case typeFields_1.InputTypes.TAP_SCRIPT_SIG:\n          if (input.tapScriptSig === undefined) {\n            input.tapScriptSig = [];\n          }\n\n          input.tapScriptSig.push(convert.inputs.tapScriptSig.decode(keyVal));\n          break;\n\n        case typeFields_1.InputTypes.TAP_LEAF_SCRIPT:\n          if (input.tapLeafScript === undefined) {\n            input.tapLeafScript = [];\n          }\n\n          input.tapLeafScript.push(convert.inputs.tapLeafScript.decode(keyVal));\n          break;\n\n        case typeFields_1.InputTypes.TAP_BIP32_DERIVATION:\n          if (input.tapBip32Derivation === undefined) {\n            input.tapBip32Derivation = [];\n          }\n\n          input.tapBip32Derivation.push(convert.inputs.tapBip32Derivation.decode(keyVal));\n          break;\n\n        case typeFields_1.InputTypes.TAP_INTERNAL_KEY:\n          checkKeyBuffer('input', keyVal.key, typeFields_1.InputTypes.TAP_INTERNAL_KEY);\n          input.tapInternalKey = convert.inputs.tapInternalKey.decode(keyVal);\n          break;\n\n        case typeFields_1.InputTypes.TAP_MERKLE_ROOT:\n          checkKeyBuffer('input', keyVal.key, typeFields_1.InputTypes.TAP_MERKLE_ROOT);\n          input.tapMerkleRoot = convert.inputs.tapMerkleRoot.decode(keyVal);\n          break;\n\n        default:\n          // This will allow inclusion during serialization.\n          if (!input.unknownKeyVals) input.unknownKeyVals = [];\n          input.unknownKeyVals.push(keyVal);\n      }\n    }\n\n    inputs.push(input);\n  }\n\n  for (const index of tools_1.range(outputCount)) {\n    const output = {};\n\n    for (const keyVal of outputKeyVals[index]) {\n      convert.outputs.checkPubkey(keyVal);\n\n      switch (keyVal.key[0]) {\n        case typeFields_1.OutputTypes.REDEEM_SCRIPT:\n          checkKeyBuffer('output', keyVal.key, typeFields_1.OutputTypes.REDEEM_SCRIPT);\n\n          if (output.redeemScript !== undefined) {\n            throw new Error('Format Error: Output has multiple REDEEM_SCRIPT');\n          }\n\n          output.redeemScript = convert.outputs.redeemScript.decode(keyVal);\n          break;\n\n        case typeFields_1.OutputTypes.WITNESS_SCRIPT:\n          checkKeyBuffer('output', keyVal.key, typeFields_1.OutputTypes.WITNESS_SCRIPT);\n\n          if (output.witnessScript !== undefined) {\n            throw new Error('Format Error: Output has multiple WITNESS_SCRIPT');\n          }\n\n          output.witnessScript = convert.outputs.witnessScript.decode(keyVal);\n          break;\n\n        case typeFields_1.OutputTypes.BIP32_DERIVATION:\n          if (output.bip32Derivation === undefined) {\n            output.bip32Derivation = [];\n          }\n\n          output.bip32Derivation.push(convert.outputs.bip32Derivation.decode(keyVal));\n          break;\n\n        case typeFields_1.OutputTypes.TAP_INTERNAL_KEY:\n          checkKeyBuffer('output', keyVal.key, typeFields_1.OutputTypes.TAP_INTERNAL_KEY);\n          output.tapInternalKey = convert.outputs.tapInternalKey.decode(keyVal);\n          break;\n\n        case typeFields_1.OutputTypes.TAP_TREE:\n          checkKeyBuffer('output', keyVal.key, typeFields_1.OutputTypes.TAP_TREE);\n          output.tapTree = convert.outputs.tapTree.decode(keyVal);\n          break;\n\n        case typeFields_1.OutputTypes.TAP_BIP32_DERIVATION:\n          if (output.tapBip32Derivation === undefined) {\n            output.tapBip32Derivation = [];\n          }\n\n          output.tapBip32Derivation.push(convert.outputs.tapBip32Derivation.decode(keyVal));\n          break;\n\n        default:\n          if (!output.unknownKeyVals) output.unknownKeyVals = [];\n          output.unknownKeyVals.push(keyVal);\n      }\n    }\n\n    outputs.push(output);\n  }\n\n  return {\n    globalMap,\n    inputs,\n    outputs\n  };\n}\n\nexports.psbtFromKeyVals = psbtFromKeyVals;","map":{"version":3,"names":["Object","defineProperty","exports","value","convert","require","tools_1","varuint","typeFields_1","psbtFromBuffer","buffer","txGetter","offset","varSlice","keyLen","decode","encodingLength","key","slice","readUInt32BE","num","readUInt8","getKeyValue","checkEndOfKeyValPairs","length","Error","isEnd","globalMapKeyVals","globalKeyIndex","keyVal","hexKey","toString","push","unsignedTxMaps","filter","GlobalTypes","UNSIGNED_TX","unsignedTx","inputCount","outputCount","getInputOutputCounts","inputKeyVals","outputKeyVals","index","range","inputKeyIndex","input","outputKeyIndex","output","psbtFromKeyVals","checkKeyBuffer","type","keyBuf","keyNum","equals","Buffer","from","globalMap","txCount","GLOBAL_XPUB","globalXpub","undefined","globals","unknownKeyVals","inputs","outputs","checkPubkey","InputTypes","NON_WITNESS_UTXO","nonWitnessUtxo","WITNESS_UTXO","witnessUtxo","PARTIAL_SIG","partialSig","SIGHASH_TYPE","sighashType","REDEEM_SCRIPT","redeemScript","WITNESS_SCRIPT","witnessScript","BIP32_DERIVATION","bip32Derivation","FINAL_SCRIPTSIG","finalScriptSig","FINAL_SCRIPTWITNESS","finalScriptWitness","POR_COMMITMENT","porCommitment","TAP_KEY_SIG","tapKeySig","TAP_SCRIPT_SIG","tapScriptSig","TAP_LEAF_SCRIPT","tapLeafScript","TAP_BIP32_DERIVATION","tapBip32Derivation","TAP_INTERNAL_KEY","tapInternalKey","TAP_MERKLE_ROOT","tapMerkleRoot","OutputTypes","TAP_TREE","tapTree"],"sources":["C:/Users/acer/node_modules/bip174/src/lib/parser/fromBuffer.js"],"sourcesContent":["'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nconst convert = require('../converter');\nconst tools_1 = require('../converter/tools');\nconst varuint = require('../converter/varint');\nconst typeFields_1 = require('../typeFields');\nfunction psbtFromBuffer(buffer, txGetter) {\n  let offset = 0;\n  function varSlice() {\n    const keyLen = varuint.decode(buffer, offset);\n    offset += varuint.encodingLength(keyLen);\n    const key = buffer.slice(offset, offset + keyLen);\n    offset += keyLen;\n    return key;\n  }\n  function readUInt32BE() {\n    const num = buffer.readUInt32BE(offset);\n    offset += 4;\n    return num;\n  }\n  function readUInt8() {\n    const num = buffer.readUInt8(offset);\n    offset += 1;\n    return num;\n  }\n  function getKeyValue() {\n    const key = varSlice();\n    const value = varSlice();\n    return {\n      key,\n      value,\n    };\n  }\n  function checkEndOfKeyValPairs() {\n    if (offset >= buffer.length) {\n      throw new Error('Format Error: Unexpected End of PSBT');\n    }\n    const isEnd = buffer.readUInt8(offset) === 0;\n    if (isEnd) {\n      offset++;\n    }\n    return isEnd;\n  }\n  if (readUInt32BE() !== 0x70736274) {\n    throw new Error('Format Error: Invalid Magic Number');\n  }\n  if (readUInt8() !== 0xff) {\n    throw new Error(\n      'Format Error: Magic Number must be followed by 0xff separator',\n    );\n  }\n  const globalMapKeyVals = [];\n  const globalKeyIndex = {};\n  while (!checkEndOfKeyValPairs()) {\n    const keyVal = getKeyValue();\n    const hexKey = keyVal.key.toString('hex');\n    if (globalKeyIndex[hexKey]) {\n      throw new Error(\n        'Format Error: Keys must be unique for global keymap: key ' + hexKey,\n      );\n    }\n    globalKeyIndex[hexKey] = 1;\n    globalMapKeyVals.push(keyVal);\n  }\n  const unsignedTxMaps = globalMapKeyVals.filter(\n    keyVal => keyVal.key[0] === typeFields_1.GlobalTypes.UNSIGNED_TX,\n  );\n  if (unsignedTxMaps.length !== 1) {\n    throw new Error('Format Error: Only one UNSIGNED_TX allowed');\n  }\n  const unsignedTx = txGetter(unsignedTxMaps[0].value);\n  // Get input and output counts to loop the respective fields\n  const { inputCount, outputCount } = unsignedTx.getInputOutputCounts();\n  const inputKeyVals = [];\n  const outputKeyVals = [];\n  // Get input fields\n  for (const index of tools_1.range(inputCount)) {\n    const inputKeyIndex = {};\n    const input = [];\n    while (!checkEndOfKeyValPairs()) {\n      const keyVal = getKeyValue();\n      const hexKey = keyVal.key.toString('hex');\n      if (inputKeyIndex[hexKey]) {\n        throw new Error(\n          'Format Error: Keys must be unique for each input: ' +\n            'input index ' +\n            index +\n            ' key ' +\n            hexKey,\n        );\n      }\n      inputKeyIndex[hexKey] = 1;\n      input.push(keyVal);\n    }\n    inputKeyVals.push(input);\n  }\n  for (const index of tools_1.range(outputCount)) {\n    const outputKeyIndex = {};\n    const output = [];\n    while (!checkEndOfKeyValPairs()) {\n      const keyVal = getKeyValue();\n      const hexKey = keyVal.key.toString('hex');\n      if (outputKeyIndex[hexKey]) {\n        throw new Error(\n          'Format Error: Keys must be unique for each output: ' +\n            'output index ' +\n            index +\n            ' key ' +\n            hexKey,\n        );\n      }\n      outputKeyIndex[hexKey] = 1;\n      output.push(keyVal);\n    }\n    outputKeyVals.push(output);\n  }\n  return psbtFromKeyVals(unsignedTx, {\n    globalMapKeyVals,\n    inputKeyVals,\n    outputKeyVals,\n  });\n}\nexports.psbtFromBuffer = psbtFromBuffer;\nfunction checkKeyBuffer(type, keyBuf, keyNum) {\n  if (!keyBuf.equals(Buffer.from([keyNum]))) {\n    throw new Error(\n      `Format Error: Invalid ${type} key: ${keyBuf.toString('hex')}`,\n    );\n  }\n}\nexports.checkKeyBuffer = checkKeyBuffer;\nfunction psbtFromKeyVals(\n  unsignedTx,\n  { globalMapKeyVals, inputKeyVals, outputKeyVals },\n) {\n  // That was easy :-)\n  const globalMap = {\n    unsignedTx,\n  };\n  let txCount = 0;\n  for (const keyVal of globalMapKeyVals) {\n    // If a globalMap item needs pubkey, uncomment\n    // const pubkey = convert.globals.checkPubkey(keyVal);\n    switch (keyVal.key[0]) {\n      case typeFields_1.GlobalTypes.UNSIGNED_TX:\n        checkKeyBuffer(\n          'global',\n          keyVal.key,\n          typeFields_1.GlobalTypes.UNSIGNED_TX,\n        );\n        if (txCount > 0) {\n          throw new Error('Format Error: GlobalMap has multiple UNSIGNED_TX');\n        }\n        txCount++;\n        break;\n      case typeFields_1.GlobalTypes.GLOBAL_XPUB:\n        if (globalMap.globalXpub === undefined) {\n          globalMap.globalXpub = [];\n        }\n        globalMap.globalXpub.push(convert.globals.globalXpub.decode(keyVal));\n        break;\n      default:\n        // This will allow inclusion during serialization.\n        if (!globalMap.unknownKeyVals) globalMap.unknownKeyVals = [];\n        globalMap.unknownKeyVals.push(keyVal);\n    }\n  }\n  // Get input and output counts to loop the respective fields\n  const inputCount = inputKeyVals.length;\n  const outputCount = outputKeyVals.length;\n  const inputs = [];\n  const outputs = [];\n  // Get input fields\n  for (const index of tools_1.range(inputCount)) {\n    const input = {};\n    for (const keyVal of inputKeyVals[index]) {\n      convert.inputs.checkPubkey(keyVal);\n      switch (keyVal.key[0]) {\n        case typeFields_1.InputTypes.NON_WITNESS_UTXO:\n          checkKeyBuffer(\n            'input',\n            keyVal.key,\n            typeFields_1.InputTypes.NON_WITNESS_UTXO,\n          );\n          if (input.nonWitnessUtxo !== undefined) {\n            throw new Error(\n              'Format Error: Input has multiple NON_WITNESS_UTXO',\n            );\n          }\n          input.nonWitnessUtxo = convert.inputs.nonWitnessUtxo.decode(keyVal);\n          break;\n        case typeFields_1.InputTypes.WITNESS_UTXO:\n          checkKeyBuffer(\n            'input',\n            keyVal.key,\n            typeFields_1.InputTypes.WITNESS_UTXO,\n          );\n          if (input.witnessUtxo !== undefined) {\n            throw new Error('Format Error: Input has multiple WITNESS_UTXO');\n          }\n          input.witnessUtxo = convert.inputs.witnessUtxo.decode(keyVal);\n          break;\n        case typeFields_1.InputTypes.PARTIAL_SIG:\n          if (input.partialSig === undefined) {\n            input.partialSig = [];\n          }\n          input.partialSig.push(convert.inputs.partialSig.decode(keyVal));\n          break;\n        case typeFields_1.InputTypes.SIGHASH_TYPE:\n          checkKeyBuffer(\n            'input',\n            keyVal.key,\n            typeFields_1.InputTypes.SIGHASH_TYPE,\n          );\n          if (input.sighashType !== undefined) {\n            throw new Error('Format Error: Input has multiple SIGHASH_TYPE');\n          }\n          input.sighashType = convert.inputs.sighashType.decode(keyVal);\n          break;\n        case typeFields_1.InputTypes.REDEEM_SCRIPT:\n          checkKeyBuffer(\n            'input',\n            keyVal.key,\n            typeFields_1.InputTypes.REDEEM_SCRIPT,\n          );\n          if (input.redeemScript !== undefined) {\n            throw new Error('Format Error: Input has multiple REDEEM_SCRIPT');\n          }\n          input.redeemScript = convert.inputs.redeemScript.decode(keyVal);\n          break;\n        case typeFields_1.InputTypes.WITNESS_SCRIPT:\n          checkKeyBuffer(\n            'input',\n            keyVal.key,\n            typeFields_1.InputTypes.WITNESS_SCRIPT,\n          );\n          if (input.witnessScript !== undefined) {\n            throw new Error('Format Error: Input has multiple WITNESS_SCRIPT');\n          }\n          input.witnessScript = convert.inputs.witnessScript.decode(keyVal);\n          break;\n        case typeFields_1.InputTypes.BIP32_DERIVATION:\n          if (input.bip32Derivation === undefined) {\n            input.bip32Derivation = [];\n          }\n          input.bip32Derivation.push(\n            convert.inputs.bip32Derivation.decode(keyVal),\n          );\n          break;\n        case typeFields_1.InputTypes.FINAL_SCRIPTSIG:\n          checkKeyBuffer(\n            'input',\n            keyVal.key,\n            typeFields_1.InputTypes.FINAL_SCRIPTSIG,\n          );\n          input.finalScriptSig = convert.inputs.finalScriptSig.decode(keyVal);\n          break;\n        case typeFields_1.InputTypes.FINAL_SCRIPTWITNESS:\n          checkKeyBuffer(\n            'input',\n            keyVal.key,\n            typeFields_1.InputTypes.FINAL_SCRIPTWITNESS,\n          );\n          input.finalScriptWitness = convert.inputs.finalScriptWitness.decode(\n            keyVal,\n          );\n          break;\n        case typeFields_1.InputTypes.POR_COMMITMENT:\n          checkKeyBuffer(\n            'input',\n            keyVal.key,\n            typeFields_1.InputTypes.POR_COMMITMENT,\n          );\n          input.porCommitment = convert.inputs.porCommitment.decode(keyVal);\n          break;\n        case typeFields_1.InputTypes.TAP_KEY_SIG:\n          checkKeyBuffer(\n            'input',\n            keyVal.key,\n            typeFields_1.InputTypes.TAP_KEY_SIG,\n          );\n          input.tapKeySig = convert.inputs.tapKeySig.decode(keyVal);\n          break;\n        case typeFields_1.InputTypes.TAP_SCRIPT_SIG:\n          if (input.tapScriptSig === undefined) {\n            input.tapScriptSig = [];\n          }\n          input.tapScriptSig.push(convert.inputs.tapScriptSig.decode(keyVal));\n          break;\n        case typeFields_1.InputTypes.TAP_LEAF_SCRIPT:\n          if (input.tapLeafScript === undefined) {\n            input.tapLeafScript = [];\n          }\n          input.tapLeafScript.push(convert.inputs.tapLeafScript.decode(keyVal));\n          break;\n        case typeFields_1.InputTypes.TAP_BIP32_DERIVATION:\n          if (input.tapBip32Derivation === undefined) {\n            input.tapBip32Derivation = [];\n          }\n          input.tapBip32Derivation.push(\n            convert.inputs.tapBip32Derivation.decode(keyVal),\n          );\n          break;\n        case typeFields_1.InputTypes.TAP_INTERNAL_KEY:\n          checkKeyBuffer(\n            'input',\n            keyVal.key,\n            typeFields_1.InputTypes.TAP_INTERNAL_KEY,\n          );\n          input.tapInternalKey = convert.inputs.tapInternalKey.decode(keyVal);\n          break;\n        case typeFields_1.InputTypes.TAP_MERKLE_ROOT:\n          checkKeyBuffer(\n            'input',\n            keyVal.key,\n            typeFields_1.InputTypes.TAP_MERKLE_ROOT,\n          );\n          input.tapMerkleRoot = convert.inputs.tapMerkleRoot.decode(keyVal);\n          break;\n        default:\n          // This will allow inclusion during serialization.\n          if (!input.unknownKeyVals) input.unknownKeyVals = [];\n          input.unknownKeyVals.push(keyVal);\n      }\n    }\n    inputs.push(input);\n  }\n  for (const index of tools_1.range(outputCount)) {\n    const output = {};\n    for (const keyVal of outputKeyVals[index]) {\n      convert.outputs.checkPubkey(keyVal);\n      switch (keyVal.key[0]) {\n        case typeFields_1.OutputTypes.REDEEM_SCRIPT:\n          checkKeyBuffer(\n            'output',\n            keyVal.key,\n            typeFields_1.OutputTypes.REDEEM_SCRIPT,\n          );\n          if (output.redeemScript !== undefined) {\n            throw new Error('Format Error: Output has multiple REDEEM_SCRIPT');\n          }\n          output.redeemScript = convert.outputs.redeemScript.decode(keyVal);\n          break;\n        case typeFields_1.OutputTypes.WITNESS_SCRIPT:\n          checkKeyBuffer(\n            'output',\n            keyVal.key,\n            typeFields_1.OutputTypes.WITNESS_SCRIPT,\n          );\n          if (output.witnessScript !== undefined) {\n            throw new Error('Format Error: Output has multiple WITNESS_SCRIPT');\n          }\n          output.witnessScript = convert.outputs.witnessScript.decode(keyVal);\n          break;\n        case typeFields_1.OutputTypes.BIP32_DERIVATION:\n          if (output.bip32Derivation === undefined) {\n            output.bip32Derivation = [];\n          }\n          output.bip32Derivation.push(\n            convert.outputs.bip32Derivation.decode(keyVal),\n          );\n          break;\n        case typeFields_1.OutputTypes.TAP_INTERNAL_KEY:\n          checkKeyBuffer(\n            'output',\n            keyVal.key,\n            typeFields_1.OutputTypes.TAP_INTERNAL_KEY,\n          );\n          output.tapInternalKey = convert.outputs.tapInternalKey.decode(keyVal);\n          break;\n        case typeFields_1.OutputTypes.TAP_TREE:\n          checkKeyBuffer(\n            'output',\n            keyVal.key,\n            typeFields_1.OutputTypes.TAP_TREE,\n          );\n          output.tapTree = convert.outputs.tapTree.decode(keyVal);\n          break;\n        case typeFields_1.OutputTypes.TAP_BIP32_DERIVATION:\n          if (output.tapBip32Derivation === undefined) {\n            output.tapBip32Derivation = [];\n          }\n          output.tapBip32Derivation.push(\n            convert.outputs.tapBip32Derivation.decode(keyVal),\n          );\n          break;\n        default:\n          if (!output.unknownKeyVals) output.unknownKeyVals = [];\n          output.unknownKeyVals.push(keyVal);\n      }\n    }\n    outputs.push(output);\n  }\n  return { globalMap, inputs, outputs };\n}\nexports.psbtFromKeyVals = psbtFromKeyVals;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}