{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n\nconst scriptNumber = require('./script_number');\n\nconst scriptSignature = require('./script_signature');\n\nconst types = require('./types');\n\nconst bip66 = require('bip66');\n\nconst ecc = require('tiny-secp256k1');\n\nconst pushdata = require('pushdata-bitcoin');\n\nconst typeforce = require('typeforce');\n\nexports.OPS = require('bitcoin-ops');\n\nconst REVERSE_OPS = require('bitcoin-ops/map');\n\nconst OP_INT_BASE = exports.OPS.OP_RESERVED; // OP_1 - 1\n\nfunction isOPInt(value) {\n  return types.Number(value) && (value === exports.OPS.OP_0 || value >= exports.OPS.OP_1 && value <= exports.OPS.OP_16 || value === exports.OPS.OP_1NEGATE);\n}\n\nfunction isPushOnlyChunk(value) {\n  return types.Buffer(value) || isOPInt(value);\n}\n\nfunction isPushOnly(value) {\n  return types.Array(value) && value.every(isPushOnlyChunk);\n}\n\nexports.isPushOnly = isPushOnly;\n\nfunction asMinimalOP(buffer) {\n  if (buffer.length === 0) return exports.OPS.OP_0;\n  if (buffer.length !== 1) return;\n  if (buffer[0] >= 1 && buffer[0] <= 16) return OP_INT_BASE + buffer[0];\n  if (buffer[0] === 0x81) return exports.OPS.OP_1NEGATE;\n}\n\nfunction chunksIsBuffer(buf) {\n  return Buffer.isBuffer(buf);\n}\n\nfunction chunksIsArray(buf) {\n  return types.Array(buf);\n}\n\nfunction singleChunkIsBuffer(buf) {\n  return Buffer.isBuffer(buf);\n}\n\nfunction compile(chunks) {\n  // TODO: remove me\n  if (chunksIsBuffer(chunks)) return chunks;\n  typeforce(types.Array, chunks);\n  const bufferSize = chunks.reduce((accum, chunk) => {\n    // data chunk\n    if (singleChunkIsBuffer(chunk)) {\n      // adhere to BIP62.3, minimal push policy\n      if (chunk.length === 1 && asMinimalOP(chunk) !== undefined) {\n        return accum + 1;\n      }\n\n      return accum + pushdata.encodingLength(chunk.length) + chunk.length;\n    } // opcode\n\n\n    return accum + 1;\n  }, 0.0);\n  const buffer = Buffer.allocUnsafe(bufferSize);\n  let offset = 0;\n  chunks.forEach(chunk => {\n    // data chunk\n    if (singleChunkIsBuffer(chunk)) {\n      // adhere to BIP62.3, minimal push policy\n      const opcode = asMinimalOP(chunk);\n\n      if (opcode !== undefined) {\n        buffer.writeUInt8(opcode, offset);\n        offset += 1;\n        return;\n      }\n\n      offset += pushdata.encode(buffer, chunk.length, offset);\n      chunk.copy(buffer, offset);\n      offset += chunk.length; // opcode\n    } else {\n      buffer.writeUInt8(chunk, offset);\n      offset += 1;\n    }\n  });\n  if (offset !== buffer.length) throw new Error('Could not decode chunks');\n  return buffer;\n}\n\nexports.compile = compile;\n\nfunction decompile(buffer) {\n  // TODO: remove me\n  if (chunksIsArray(buffer)) return buffer;\n  typeforce(types.Buffer, buffer);\n  const chunks = [];\n  let i = 0;\n\n  while (i < buffer.length) {\n    const opcode = buffer[i]; // data chunk\n\n    if (opcode > exports.OPS.OP_0 && opcode <= exports.OPS.OP_PUSHDATA4) {\n      const d = pushdata.decode(buffer, i); // did reading a pushDataInt fail?\n\n      if (d === null) return null;\n      i += d.size; // attempt to read too much data?\n\n      if (i + d.number > buffer.length) return null;\n      const data = buffer.slice(i, i + d.number);\n      i += d.number; // decompile minimally\n\n      const op = asMinimalOP(data);\n\n      if (op !== undefined) {\n        chunks.push(op);\n      } else {\n        chunks.push(data);\n      } // opcode\n\n    } else {\n      chunks.push(opcode);\n      i += 1;\n    }\n  }\n\n  return chunks;\n}\n\nexports.decompile = decompile;\n\nfunction toASM(chunks) {\n  if (chunksIsBuffer(chunks)) {\n    chunks = decompile(chunks);\n  }\n\n  return chunks.map(chunk => {\n    // data?\n    if (singleChunkIsBuffer(chunk)) {\n      const op = asMinimalOP(chunk);\n      if (op === undefined) return chunk.toString('hex');\n      chunk = op;\n    } // opcode!\n\n\n    return REVERSE_OPS[chunk];\n  }).join(' ');\n}\n\nexports.toASM = toASM;\n\nfunction fromASM(asm) {\n  typeforce(types.String, asm);\n  return compile(asm.split(' ').map(chunkStr => {\n    // opcode?\n    if (exports.OPS[chunkStr] !== undefined) return exports.OPS[chunkStr];\n    typeforce(types.Hex, chunkStr); // data!\n\n    return Buffer.from(chunkStr, 'hex');\n  }));\n}\n\nexports.fromASM = fromASM;\n\nfunction toStack(chunks) {\n  chunks = decompile(chunks);\n  typeforce(isPushOnly, chunks);\n  return chunks.map(op => {\n    if (singleChunkIsBuffer(op)) return op;\n    if (op === exports.OPS.OP_0) return Buffer.allocUnsafe(0);\n    return scriptNumber.encode(op - OP_INT_BASE);\n  });\n}\n\nexports.toStack = toStack;\n\nfunction isCanonicalPubKey(buffer) {\n  return ecc.isPoint(buffer);\n}\n\nexports.isCanonicalPubKey = isCanonicalPubKey;\n\nfunction isDefinedHashType(hashType) {\n  const hashTypeMod = hashType & ~0x80; // return hashTypeMod > SIGHASH_ALL && hashTypeMod < SIGHASH_SINGLE\n\n  return hashTypeMod > 0x00 && hashTypeMod < 0x04;\n}\n\nexports.isDefinedHashType = isDefinedHashType;\n\nfunction isCanonicalScriptSignature(buffer) {\n  if (!Buffer.isBuffer(buffer)) return false;\n  if (!isDefinedHashType(buffer[buffer.length - 1])) return false;\n  return bip66.check(buffer.slice(0, -1));\n}\n\nexports.isCanonicalScriptSignature = isCanonicalScriptSignature; // tslint:disable-next-line variable-name\n\nexports.number = scriptNumber;\nexports.signature = scriptSignature;","map":{"version":3,"names":["Object","defineProperty","exports","value","scriptNumber","require","scriptSignature","types","bip66","ecc","pushdata","typeforce","OPS","REVERSE_OPS","OP_INT_BASE","OP_RESERVED","isOPInt","Number","OP_0","OP_1","OP_16","OP_1NEGATE","isPushOnlyChunk","Buffer","isPushOnly","Array","every","asMinimalOP","buffer","length","chunksIsBuffer","buf","isBuffer","chunksIsArray","singleChunkIsBuffer","compile","chunks","bufferSize","reduce","accum","chunk","undefined","encodingLength","allocUnsafe","offset","forEach","opcode","writeUInt8","encode","copy","Error","decompile","i","OP_PUSHDATA4","d","decode","size","number","data","slice","op","push","toASM","map","toString","join","fromASM","asm","String","split","chunkStr","Hex","from","toStack","isCanonicalPubKey","isPoint","isDefinedHashType","hashType","hashTypeMod","isCanonicalScriptSignature","check","signature"],"sources":["C:/Users/acer/node_modules/bitcoinjs-lib/src/script.js"],"sourcesContent":["'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nconst scriptNumber = require('./script_number');\nconst scriptSignature = require('./script_signature');\nconst types = require('./types');\nconst bip66 = require('bip66');\nconst ecc = require('tiny-secp256k1');\nconst pushdata = require('pushdata-bitcoin');\nconst typeforce = require('typeforce');\nexports.OPS = require('bitcoin-ops');\nconst REVERSE_OPS = require('bitcoin-ops/map');\nconst OP_INT_BASE = exports.OPS.OP_RESERVED; // OP_1 - 1\nfunction isOPInt(value) {\n  return (\n    types.Number(value) &&\n    (value === exports.OPS.OP_0 ||\n      (value >= exports.OPS.OP_1 && value <= exports.OPS.OP_16) ||\n      value === exports.OPS.OP_1NEGATE)\n  );\n}\nfunction isPushOnlyChunk(value) {\n  return types.Buffer(value) || isOPInt(value);\n}\nfunction isPushOnly(value) {\n  return types.Array(value) && value.every(isPushOnlyChunk);\n}\nexports.isPushOnly = isPushOnly;\nfunction asMinimalOP(buffer) {\n  if (buffer.length === 0) return exports.OPS.OP_0;\n  if (buffer.length !== 1) return;\n  if (buffer[0] >= 1 && buffer[0] <= 16) return OP_INT_BASE + buffer[0];\n  if (buffer[0] === 0x81) return exports.OPS.OP_1NEGATE;\n}\nfunction chunksIsBuffer(buf) {\n  return Buffer.isBuffer(buf);\n}\nfunction chunksIsArray(buf) {\n  return types.Array(buf);\n}\nfunction singleChunkIsBuffer(buf) {\n  return Buffer.isBuffer(buf);\n}\nfunction compile(chunks) {\n  // TODO: remove me\n  if (chunksIsBuffer(chunks)) return chunks;\n  typeforce(types.Array, chunks);\n  const bufferSize = chunks.reduce((accum, chunk) => {\n    // data chunk\n    if (singleChunkIsBuffer(chunk)) {\n      // adhere to BIP62.3, minimal push policy\n      if (chunk.length === 1 && asMinimalOP(chunk) !== undefined) {\n        return accum + 1;\n      }\n      return accum + pushdata.encodingLength(chunk.length) + chunk.length;\n    }\n    // opcode\n    return accum + 1;\n  }, 0.0);\n  const buffer = Buffer.allocUnsafe(bufferSize);\n  let offset = 0;\n  chunks.forEach(chunk => {\n    // data chunk\n    if (singleChunkIsBuffer(chunk)) {\n      // adhere to BIP62.3, minimal push policy\n      const opcode = asMinimalOP(chunk);\n      if (opcode !== undefined) {\n        buffer.writeUInt8(opcode, offset);\n        offset += 1;\n        return;\n      }\n      offset += pushdata.encode(buffer, chunk.length, offset);\n      chunk.copy(buffer, offset);\n      offset += chunk.length;\n      // opcode\n    } else {\n      buffer.writeUInt8(chunk, offset);\n      offset += 1;\n    }\n  });\n  if (offset !== buffer.length) throw new Error('Could not decode chunks');\n  return buffer;\n}\nexports.compile = compile;\nfunction decompile(buffer) {\n  // TODO: remove me\n  if (chunksIsArray(buffer)) return buffer;\n  typeforce(types.Buffer, buffer);\n  const chunks = [];\n  let i = 0;\n  while (i < buffer.length) {\n    const opcode = buffer[i];\n    // data chunk\n    if (opcode > exports.OPS.OP_0 && opcode <= exports.OPS.OP_PUSHDATA4) {\n      const d = pushdata.decode(buffer, i);\n      // did reading a pushDataInt fail?\n      if (d === null) return null;\n      i += d.size;\n      // attempt to read too much data?\n      if (i + d.number > buffer.length) return null;\n      const data = buffer.slice(i, i + d.number);\n      i += d.number;\n      // decompile minimally\n      const op = asMinimalOP(data);\n      if (op !== undefined) {\n        chunks.push(op);\n      } else {\n        chunks.push(data);\n      }\n      // opcode\n    } else {\n      chunks.push(opcode);\n      i += 1;\n    }\n  }\n  return chunks;\n}\nexports.decompile = decompile;\nfunction toASM(chunks) {\n  if (chunksIsBuffer(chunks)) {\n    chunks = decompile(chunks);\n  }\n  return chunks\n    .map(chunk => {\n      // data?\n      if (singleChunkIsBuffer(chunk)) {\n        const op = asMinimalOP(chunk);\n        if (op === undefined) return chunk.toString('hex');\n        chunk = op;\n      }\n      // opcode!\n      return REVERSE_OPS[chunk];\n    })\n    .join(' ');\n}\nexports.toASM = toASM;\nfunction fromASM(asm) {\n  typeforce(types.String, asm);\n  return compile(\n    asm.split(' ').map(chunkStr => {\n      // opcode?\n      if (exports.OPS[chunkStr] !== undefined) return exports.OPS[chunkStr];\n      typeforce(types.Hex, chunkStr);\n      // data!\n      return Buffer.from(chunkStr, 'hex');\n    }),\n  );\n}\nexports.fromASM = fromASM;\nfunction toStack(chunks) {\n  chunks = decompile(chunks);\n  typeforce(isPushOnly, chunks);\n  return chunks.map(op => {\n    if (singleChunkIsBuffer(op)) return op;\n    if (op === exports.OPS.OP_0) return Buffer.allocUnsafe(0);\n    return scriptNumber.encode(op - OP_INT_BASE);\n  });\n}\nexports.toStack = toStack;\nfunction isCanonicalPubKey(buffer) {\n  return ecc.isPoint(buffer);\n}\nexports.isCanonicalPubKey = isCanonicalPubKey;\nfunction isDefinedHashType(hashType) {\n  const hashTypeMod = hashType & ~0x80;\n  // return hashTypeMod > SIGHASH_ALL && hashTypeMod < SIGHASH_SINGLE\n  return hashTypeMod > 0x00 && hashTypeMod < 0x04;\n}\nexports.isDefinedHashType = isDefinedHashType;\nfunction isCanonicalScriptSignature(buffer) {\n  if (!Buffer.isBuffer(buffer)) return false;\n  if (!isDefinedHashType(buffer[buffer.length - 1])) return false;\n  return bip66.check(buffer.slice(0, -1));\n}\nexports.isCanonicalScriptSignature = isCanonicalScriptSignature;\n// tslint:disable-next-line variable-name\nexports.number = scriptNumber;\nexports.signature = scriptSignature;\n"],"mappings":"AAAA;;AACAA,MAAM,CAACC,cAAP,CAAsBC,OAAtB,EAA+B,YAA/B,EAA6C;EAAEC,KAAK,EAAE;AAAT,CAA7C;;AACA,MAAMC,YAAY,GAAGC,OAAO,CAAC,iBAAD,CAA5B;;AACA,MAAMC,eAAe,GAAGD,OAAO,CAAC,oBAAD,CAA/B;;AACA,MAAME,KAAK,GAAGF,OAAO,CAAC,SAAD,CAArB;;AACA,MAAMG,KAAK,GAAGH,OAAO,CAAC,OAAD,CAArB;;AACA,MAAMI,GAAG,GAAGJ,OAAO,CAAC,gBAAD,CAAnB;;AACA,MAAMK,QAAQ,GAAGL,OAAO,CAAC,kBAAD,CAAxB;;AACA,MAAMM,SAAS,GAAGN,OAAO,CAAC,WAAD,CAAzB;;AACAH,OAAO,CAACU,GAAR,GAAcP,OAAO,CAAC,aAAD,CAArB;;AACA,MAAMQ,WAAW,GAAGR,OAAO,CAAC,iBAAD,CAA3B;;AACA,MAAMS,WAAW,GAAGZ,OAAO,CAACU,GAAR,CAAYG,WAAhC,C,CAA6C;;AAC7C,SAASC,OAAT,CAAiBb,KAAjB,EAAwB;EACtB,OACEI,KAAK,CAACU,MAAN,CAAad,KAAb,MACCA,KAAK,KAAKD,OAAO,CAACU,GAAR,CAAYM,IAAtB,IACEf,KAAK,IAAID,OAAO,CAACU,GAAR,CAAYO,IAArB,IAA6BhB,KAAK,IAAID,OAAO,CAACU,GAAR,CAAYQ,KADpD,IAECjB,KAAK,KAAKD,OAAO,CAACU,GAAR,CAAYS,UAHxB,CADF;AAMD;;AACD,SAASC,eAAT,CAAyBnB,KAAzB,EAAgC;EAC9B,OAAOI,KAAK,CAACgB,MAAN,CAAapB,KAAb,KAAuBa,OAAO,CAACb,KAAD,CAArC;AACD;;AACD,SAASqB,UAAT,CAAoBrB,KAApB,EAA2B;EACzB,OAAOI,KAAK,CAACkB,KAAN,CAAYtB,KAAZ,KAAsBA,KAAK,CAACuB,KAAN,CAAYJ,eAAZ,CAA7B;AACD;;AACDpB,OAAO,CAACsB,UAAR,GAAqBA,UAArB;;AACA,SAASG,WAAT,CAAqBC,MAArB,EAA6B;EAC3B,IAAIA,MAAM,CAACC,MAAP,KAAkB,CAAtB,EAAyB,OAAO3B,OAAO,CAACU,GAAR,CAAYM,IAAnB;EACzB,IAAIU,MAAM,CAACC,MAAP,KAAkB,CAAtB,EAAyB;EACzB,IAAID,MAAM,CAAC,CAAD,CAAN,IAAa,CAAb,IAAkBA,MAAM,CAAC,CAAD,CAAN,IAAa,EAAnC,EAAuC,OAAOd,WAAW,GAAGc,MAAM,CAAC,CAAD,CAA3B;EACvC,IAAIA,MAAM,CAAC,CAAD,CAAN,KAAc,IAAlB,EAAwB,OAAO1B,OAAO,CAACU,GAAR,CAAYS,UAAnB;AACzB;;AACD,SAASS,cAAT,CAAwBC,GAAxB,EAA6B;EAC3B,OAAOR,MAAM,CAACS,QAAP,CAAgBD,GAAhB,CAAP;AACD;;AACD,SAASE,aAAT,CAAuBF,GAAvB,EAA4B;EAC1B,OAAOxB,KAAK,CAACkB,KAAN,CAAYM,GAAZ,CAAP;AACD;;AACD,SAASG,mBAAT,CAA6BH,GAA7B,EAAkC;EAChC,OAAOR,MAAM,CAACS,QAAP,CAAgBD,GAAhB,CAAP;AACD;;AACD,SAASI,OAAT,CAAiBC,MAAjB,EAAyB;EACvB;EACA,IAAIN,cAAc,CAACM,MAAD,CAAlB,EAA4B,OAAOA,MAAP;EAC5BzB,SAAS,CAACJ,KAAK,CAACkB,KAAP,EAAcW,MAAd,CAAT;EACA,MAAMC,UAAU,GAAGD,MAAM,CAACE,MAAP,CAAc,CAACC,KAAD,EAAQC,KAAR,KAAkB;IACjD;IACA,IAAIN,mBAAmB,CAACM,KAAD,CAAvB,EAAgC;MAC9B;MACA,IAAIA,KAAK,CAACX,MAAN,KAAiB,CAAjB,IAAsBF,WAAW,CAACa,KAAD,CAAX,KAAuBC,SAAjD,EAA4D;QAC1D,OAAOF,KAAK,GAAG,CAAf;MACD;;MACD,OAAOA,KAAK,GAAG7B,QAAQ,CAACgC,cAAT,CAAwBF,KAAK,CAACX,MAA9B,CAAR,GAAgDW,KAAK,CAACX,MAA7D;IACD,CARgD,CASjD;;;IACA,OAAOU,KAAK,GAAG,CAAf;EACD,CAXkB,EAWhB,GAXgB,CAAnB;EAYA,MAAMX,MAAM,GAAGL,MAAM,CAACoB,WAAP,CAAmBN,UAAnB,CAAf;EACA,IAAIO,MAAM,GAAG,CAAb;EACAR,MAAM,CAACS,OAAP,CAAeL,KAAK,IAAI;IACtB;IACA,IAAIN,mBAAmB,CAACM,KAAD,CAAvB,EAAgC;MAC9B;MACA,MAAMM,MAAM,GAAGnB,WAAW,CAACa,KAAD,CAA1B;;MACA,IAAIM,MAAM,KAAKL,SAAf,EAA0B;QACxBb,MAAM,CAACmB,UAAP,CAAkBD,MAAlB,EAA0BF,MAA1B;QACAA,MAAM,IAAI,CAAV;QACA;MACD;;MACDA,MAAM,IAAIlC,QAAQ,CAACsC,MAAT,CAAgBpB,MAAhB,EAAwBY,KAAK,CAACX,MAA9B,EAAsCe,MAAtC,CAAV;MACAJ,KAAK,CAACS,IAAN,CAAWrB,MAAX,EAAmBgB,MAAnB;MACAA,MAAM,IAAIJ,KAAK,CAACX,MAAhB,CAV8B,CAW9B;IACD,CAZD,MAYO;MACLD,MAAM,CAACmB,UAAP,CAAkBP,KAAlB,EAAyBI,MAAzB;MACAA,MAAM,IAAI,CAAV;IACD;EACF,CAlBD;EAmBA,IAAIA,MAAM,KAAKhB,MAAM,CAACC,MAAtB,EAA8B,MAAM,IAAIqB,KAAJ,CAAU,yBAAV,CAAN;EAC9B,OAAOtB,MAAP;AACD;;AACD1B,OAAO,CAACiC,OAAR,GAAkBA,OAAlB;;AACA,SAASgB,SAAT,CAAmBvB,MAAnB,EAA2B;EACzB;EACA,IAAIK,aAAa,CAACL,MAAD,CAAjB,EAA2B,OAAOA,MAAP;EAC3BjB,SAAS,CAACJ,KAAK,CAACgB,MAAP,EAAeK,MAAf,CAAT;EACA,MAAMQ,MAAM,GAAG,EAAf;EACA,IAAIgB,CAAC,GAAG,CAAR;;EACA,OAAOA,CAAC,GAAGxB,MAAM,CAACC,MAAlB,EAA0B;IACxB,MAAMiB,MAAM,GAAGlB,MAAM,CAACwB,CAAD,CAArB,CADwB,CAExB;;IACA,IAAIN,MAAM,GAAG5C,OAAO,CAACU,GAAR,CAAYM,IAArB,IAA6B4B,MAAM,IAAI5C,OAAO,CAACU,GAAR,CAAYyC,YAAvD,EAAqE;MACnE,MAAMC,CAAC,GAAG5C,QAAQ,CAAC6C,MAAT,CAAgB3B,MAAhB,EAAwBwB,CAAxB,CAAV,CADmE,CAEnE;;MACA,IAAIE,CAAC,KAAK,IAAV,EAAgB,OAAO,IAAP;MAChBF,CAAC,IAAIE,CAAC,CAACE,IAAP,CAJmE,CAKnE;;MACA,IAAIJ,CAAC,GAAGE,CAAC,CAACG,MAAN,GAAe7B,MAAM,CAACC,MAA1B,EAAkC,OAAO,IAAP;MAClC,MAAM6B,IAAI,GAAG9B,MAAM,CAAC+B,KAAP,CAAaP,CAAb,EAAgBA,CAAC,GAAGE,CAAC,CAACG,MAAtB,CAAb;MACAL,CAAC,IAAIE,CAAC,CAACG,MAAP,CARmE,CASnE;;MACA,MAAMG,EAAE,GAAGjC,WAAW,CAAC+B,IAAD,CAAtB;;MACA,IAAIE,EAAE,KAAKnB,SAAX,EAAsB;QACpBL,MAAM,CAACyB,IAAP,CAAYD,EAAZ;MACD,CAFD,MAEO;QACLxB,MAAM,CAACyB,IAAP,CAAYH,IAAZ;MACD,CAfkE,CAgBnE;;IACD,CAjBD,MAiBO;MACLtB,MAAM,CAACyB,IAAP,CAAYf,MAAZ;MACAM,CAAC,IAAI,CAAL;IACD;EACF;;EACD,OAAOhB,MAAP;AACD;;AACDlC,OAAO,CAACiD,SAAR,GAAoBA,SAApB;;AACA,SAASW,KAAT,CAAe1B,MAAf,EAAuB;EACrB,IAAIN,cAAc,CAACM,MAAD,CAAlB,EAA4B;IAC1BA,MAAM,GAAGe,SAAS,CAACf,MAAD,CAAlB;EACD;;EACD,OAAOA,MAAM,CACV2B,GADI,CACAvB,KAAK,IAAI;IACZ;IACA,IAAIN,mBAAmB,CAACM,KAAD,CAAvB,EAAgC;MAC9B,MAAMoB,EAAE,GAAGjC,WAAW,CAACa,KAAD,CAAtB;MACA,IAAIoB,EAAE,KAAKnB,SAAX,EAAsB,OAAOD,KAAK,CAACwB,QAAN,CAAe,KAAf,CAAP;MACtBxB,KAAK,GAAGoB,EAAR;IACD,CANW,CAOZ;;;IACA,OAAO/C,WAAW,CAAC2B,KAAD,CAAlB;EACD,CAVI,EAWJyB,IAXI,CAWC,GAXD,CAAP;AAYD;;AACD/D,OAAO,CAAC4D,KAAR,GAAgBA,KAAhB;;AACA,SAASI,OAAT,CAAiBC,GAAjB,EAAsB;EACpBxD,SAAS,CAACJ,KAAK,CAAC6D,MAAP,EAAeD,GAAf,CAAT;EACA,OAAOhC,OAAO,CACZgC,GAAG,CAACE,KAAJ,CAAU,GAAV,EAAeN,GAAf,CAAmBO,QAAQ,IAAI;IAC7B;IACA,IAAIpE,OAAO,CAACU,GAAR,CAAY0D,QAAZ,MAA0B7B,SAA9B,EAAyC,OAAOvC,OAAO,CAACU,GAAR,CAAY0D,QAAZ,CAAP;IACzC3D,SAAS,CAACJ,KAAK,CAACgE,GAAP,EAAYD,QAAZ,CAAT,CAH6B,CAI7B;;IACA,OAAO/C,MAAM,CAACiD,IAAP,CAAYF,QAAZ,EAAsB,KAAtB,CAAP;EACD,CAND,CADY,CAAd;AASD;;AACDpE,OAAO,CAACgE,OAAR,GAAkBA,OAAlB;;AACA,SAASO,OAAT,CAAiBrC,MAAjB,EAAyB;EACvBA,MAAM,GAAGe,SAAS,CAACf,MAAD,CAAlB;EACAzB,SAAS,CAACa,UAAD,EAAaY,MAAb,CAAT;EACA,OAAOA,MAAM,CAAC2B,GAAP,CAAWH,EAAE,IAAI;IACtB,IAAI1B,mBAAmB,CAAC0B,EAAD,CAAvB,EAA6B,OAAOA,EAAP;IAC7B,IAAIA,EAAE,KAAK1D,OAAO,CAACU,GAAR,CAAYM,IAAvB,EAA6B,OAAOK,MAAM,CAACoB,WAAP,CAAmB,CAAnB,CAAP;IAC7B,OAAOvC,YAAY,CAAC4C,MAAb,CAAoBY,EAAE,GAAG9C,WAAzB,CAAP;EACD,CAJM,CAAP;AAKD;;AACDZ,OAAO,CAACuE,OAAR,GAAkBA,OAAlB;;AACA,SAASC,iBAAT,CAA2B9C,MAA3B,EAAmC;EACjC,OAAOnB,GAAG,CAACkE,OAAJ,CAAY/C,MAAZ,CAAP;AACD;;AACD1B,OAAO,CAACwE,iBAAR,GAA4BA,iBAA5B;;AACA,SAASE,iBAAT,CAA2BC,QAA3B,EAAqC;EACnC,MAAMC,WAAW,GAAGD,QAAQ,GAAG,CAAC,IAAhC,CADmC,CAEnC;;EACA,OAAOC,WAAW,GAAG,IAAd,IAAsBA,WAAW,GAAG,IAA3C;AACD;;AACD5E,OAAO,CAAC0E,iBAAR,GAA4BA,iBAA5B;;AACA,SAASG,0BAAT,CAAoCnD,MAApC,EAA4C;EAC1C,IAAI,CAACL,MAAM,CAACS,QAAP,CAAgBJ,MAAhB,CAAL,EAA8B,OAAO,KAAP;EAC9B,IAAI,CAACgD,iBAAiB,CAAChD,MAAM,CAACA,MAAM,CAACC,MAAP,GAAgB,CAAjB,CAAP,CAAtB,EAAmD,OAAO,KAAP;EACnD,OAAOrB,KAAK,CAACwE,KAAN,CAAYpD,MAAM,CAAC+B,KAAP,CAAa,CAAb,EAAgB,CAAC,CAAjB,CAAZ,CAAP;AACD;;AACDzD,OAAO,CAAC6E,0BAAR,GAAqCA,0BAArC,C,CACA;;AACA7E,OAAO,CAACuD,MAAR,GAAiBrD,YAAjB;AACAF,OAAO,CAAC+E,SAAR,GAAoB3E,eAApB"},"metadata":{},"sourceType":"script"}