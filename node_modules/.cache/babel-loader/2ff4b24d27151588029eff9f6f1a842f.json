{"ast":null,"code":"const {\n  chacha20poly1305Encrypt,\n  chacha20poly1305Decrypt,\n  blake2b,\n  sha3_256\n} = require(\"./crypto-primitives\");\n\nconst cbor = require('borc');\n\nconst crc32 = require('../utils/crc32');\n\nconst base58 = require('../utils/base58');\n\nconst bech32 = require('../utils/bech32');\n\nconst pbkdf2 = require('../utils/pbkdf2');\n\nconst variableLengthEncode = require('../utils/variableLengthEncode');\n\nconst CborIndefiniteLengthArray = require('../utils/CborIndefiniteLengthArray');\n\nconst {\n  validateBuffer,\n  validateDerivationScheme,\n  validateArray,\n  validateString,\n  validateNetworkId,\n  validateUint32\n} = require(\"../utils/validation\");\n\nconst AddressTypes = {\n  'BASE': 0b0000,\n  'BASE_SCRIPT_KEY': 0b0001,\n  'BASE_KEY_SCRIPT': 0b0010,\n  'BASE_SCRIPT_SCRIPT': 0b0011,\n  'POINTER': 0b0100,\n  'POINTER_SCRIPT': 0b0101,\n  'ENTERPRISE': 0b0110,\n  'ENTERPRISE_SCRIPT': 0b0111,\n  'BOOTSTRAP': 0b1000,\n  'REWARD': 0b1110,\n  'REWARD_SCRIPT': 0b1111\n};\nconst BaseAddressTypes = {\n  'BASE': 0b00,\n  'SCRIPT_KEY': 0b01,\n  'KEY_SCRIPT': 0b10,\n  'SCRIPT_SCRIPT': 0b11\n};\nconst shelleyAddressTypes = [AddressTypes.BASE, AddressTypes.BASE_SCRIPT_KEY, AddressTypes.BASE_KEY_SCRIPT, AddressTypes.BASE_SCRIPT_SCRIPT, AddressTypes.POINTER, AddressTypes.POINTER_SCRIPT, AddressTypes.ENTERPRISE, AddressTypes.ENTERPRISE_SCRIPT, AddressTypes.REWARD, AddressTypes.REWARD_SCRIPT];\nconst PUB_KEY_LEN = 32;\nconst KEY_HASH_LEN = 28;\nconst MAINNET_PROTOCOL_MAGIC = 764824073;\n\nfunction validatePointer(input) {\n  if (!input.hasOwnProperty('blockIndex') || !input.hasOwnProperty('txIndex') || !input.hasOwnProperty('certificateIndex')) {\n    throw new Error('Invalid pointer! Missing one of blockIndex, txIndex, certificateIndex');\n  }\n\n  if (!Number.isInteger(input.blockIndex) || !Number.isInteger(input.txIndex) || !Number.isInteger(input.certificateIndex)) {\n    throw new Error('Invalid pointer! values must be integer');\n  }\n}\n\nfunction packBootstrapAddress(derivationPath, xpub, hdPassphrase, derivationScheme, protocolMagic) {\n  validateBuffer(xpub, 64);\n  validateDerivationScheme(derivationScheme);\n  validateUint32(protocolMagic);\n\n  if (derivationScheme === 1) {\n    validateArray(derivationPath);\n    validateBuffer(hdPassphrase, 32);\n  }\n\n  let addressPayload, addressAttributes;\n\n  if (derivationScheme === 1 && derivationPath.length > 0) {\n    addressPayload = encryptDerivationPath(derivationPath, hdPassphrase);\n    addressAttributes = new Map([[1, cbor.encode(addressPayload)]]);\n  } else {\n    addressPayload = Buffer.from([]);\n    addressAttributes = new Map();\n  }\n\n  if (protocolMagic !== MAINNET_PROTOCOL_MAGIC) {\n    addressAttributes.set(2, cbor.encode(protocolMagic));\n  }\n\n  const getAddressRootHash = input => blake2b(sha3_256(cbor.encode(input)), 28);\n\n  const addressRoot = getAddressRootHash([0, [0, xpub], addressPayload.length > 0 ? new Map([[1, cbor.encode(addressPayload)]]) : new Map()]);\n  const addressType = 0; // Public key address\n\n  const addressData = [addressRoot, addressAttributes, addressType];\n  const addressDataEncoded = cbor.encode(addressData);\n  return cbor.encode([new cbor.Tagged(24, addressDataEncoded), crc32(addressDataEncoded)]);\n}\n\nfunction getAddressHeader(addressType, networkId) {\n  return Buffer.from([addressType << 4 | networkId]);\n}\n\nfunction getPubKeyBlake2b224Hash(pubKey) {\n  validateBuffer(pubKey, PUB_KEY_LEN);\n  return blake2b(pubKey, KEY_HASH_LEN);\n}\n\nfunction packBaseAddress(spendingHash, stakingHash, networkId) {\n  let type = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : BaseAddressTypes.BASE;\n  validateBuffer(spendingHash, KEY_HASH_LEN);\n  validateBuffer(stakingHash, KEY_HASH_LEN);\n  validateNetworkId(networkId);\n  validateUint32(type);\n  return Buffer.concat([getAddressHeader(AddressTypes.BASE | type, networkId), spendingHash, stakingHash]);\n}\n\nfunction packPointerAddress(spendingHash, pointer, networkId, isScript) {\n  validateBuffer(spendingHash, KEY_HASH_LEN);\n  validatePointer(pointer);\n  validateNetworkId(networkId);\n  const {\n    blockIndex,\n    txIndex,\n    certificateIndex\n  } = pointer;\n  return Buffer.concat([getAddressHeader(isScript ? AddressTypes.POINTER_SCRIPT : AddressTypes.POINTER, networkId, isScript), spendingHash, Buffer.concat([variableLengthEncode(blockIndex), variableLengthEncode(txIndex), variableLengthEncode(certificateIndex)])]);\n}\n\nfunction packEnterpriseAddress(spendingHash, networkId, isScript) {\n  validateBuffer(spendingHash, KEY_HASH_LEN);\n  validateNetworkId(networkId);\n  return Buffer.concat([getAddressHeader(isScript ? AddressTypes.ENTERPRISE_SCRIPT : AddressTypes.ENTERPRISE, networkId, isScript), spendingHash]);\n}\n\nfunction packRewardAddress(stakingHash, networkId, isScript) {\n  validateBuffer(stakingHash, KEY_HASH_LEN);\n  validateNetworkId(networkId);\n  return Buffer.concat([getAddressHeader(isScript ? AddressTypes.REWARD_SCRIPT : AddressTypes.REWARD, networkId, isScript), stakingHash]);\n}\n\nfunction getBootstrapAddressAttributes(addressBuffer) {\n  // we decode the address from the base58 string\n  // and then we strip the 24 CBOR data tags (the \"[0].value\" part)\n  const addressAsBuffer = cbor.decode(addressBuffer)[0].value;\n  const addressData = cbor.decode(addressAsBuffer);\n  const addressAttributes = addressData[1]; // cbor decoder decodes empty map as empty object, so we re-cast it to Map(0)\n\n  if (!(addressAttributes instanceof Map)) {\n    return new Map();\n  }\n\n  return addressAttributes;\n}\n\nfunction getBootstrapAddressDerivationPath(addressBuffer, hdPassphrase) {\n  const addressAttributes = getBootstrapAddressAttributes(addressBuffer);\n  const addressPayloadCbor = addressAttributes.get(1);\n\n  if (!addressPayloadCbor) {\n    return null;\n  }\n\n  const addressPayload = cbor.decode(addressPayloadCbor);\n  let derivationPath = null;\n\n  try {\n    derivationPath = decryptDerivationPath(addressPayload, hdPassphrase);\n  } catch (e) {\n    throw new Error('Unable to get derivation path from address');\n  }\n\n  if (derivationPath && derivationPath.length > 2) {\n    throw Error('Invalid derivation path length, should be at most 2');\n  }\n\n  return derivationPath;\n}\n\nfunction getBootstrapAddressProtocolMagic(addressBuffer) {\n  const addressAttributes = getBootstrapAddressAttributes(addressBuffer);\n  const protocolMagicCbor = addressAttributes.get(2);\n\n  if (!protocolMagicCbor) {\n    return MAINNET_PROTOCOL_MAGIC;\n  }\n\n  return cbor.decode(protocolMagicCbor);\n}\n\nfunction isValidBootstrapAddress(address) {\n  validateString(address);\n\n  try {\n    const addressAsArray = cbor.decode(base58.decode(address)); // we strip the 24 CBOR data taga by taking the \"value\" attribute from the \"Tagged\" object\n\n    const addressDataEncoded = addressAsArray[0].value;\n    const crc32Checksum = addressAsArray[1];\n\n    if (crc32Checksum !== crc32(addressDataEncoded)) {\n      return false;\n    }\n  } catch (e) {\n    return false;\n  }\n\n  return true;\n}\n\nfunction isValidShelleyAddress(address) {\n  validateString(address);\n\n  try {\n    const {\n      data: addressBuffer\n    } = bech32.decode(address);\n\n    if (!shelleyAddressTypes.includes(getAddressType(addressBuffer))) {\n      return false;\n    }\n  } catch (e) {\n    return false;\n  }\n\n  return true;\n}\n\nfunction addressToBuffer(addressStr) {\n  validateString(addressStr);\n\n  try {\n    return base58.decode(addressStr);\n  } catch (e) {\n    return bech32.decode(addressStr).data;\n  }\n}\n\nfunction getAddressType(addressBuffer) {\n  validateBuffer(addressBuffer);\n  return addressBuffer[0] >> 4;\n}\n\nfunction hasSpendingScript(addressBuffer) {\n  validateBuffer(addressBuffer);\n  return [AddressTypes.BASE_SCRIPT_KEY, AddressTypes.BASE_SCRIPT_SCRIPT, AddressTypes.POINTER_SCRIPT, AddressTypes.ENTERPRISE_SCRIPT].includes(getAddressType(addressBuffer));\n}\n\nfunction hasStakingScript(addressBuffer) {\n  validateBuffer(addressBuffer);\n  return [AddressTypes.BASE_KEY_SCRIPT, AddressTypes.BASE_SCRIPT_SCRIPT, AddressTypes.REWARD_SCRIPT].includes(getAddressType(addressBuffer));\n}\n\nfunction getShelleyAddressNetworkId(addressBuffer) {\n  validateBuffer(addressBuffer);\n  return addressBuffer[0] & 15;\n}\n\nfunction encryptDerivationPath(derivationPath, hdPassphrase) {\n  const serializedDerivationPath = cbor.encode(new CborIndefiniteLengthArray(derivationPath));\n  return chacha20poly1305Encrypt(serializedDerivationPath, hdPassphrase, Buffer.from('serokellfore'));\n}\n\nfunction decryptDerivationPath(addressPayload, hdPassphrase) {\n  const decipheredDerivationPath = chacha20poly1305Decrypt(addressPayload, hdPassphrase, Buffer.from('serokellfore'));\n\n  try {\n    return cbor.decode(Buffer.from(decipheredDerivationPath));\n  } catch (err) {\n    throw new Error('incorrect address or passphrase');\n  }\n}\n\nasync function xpubToHdPassphrase(xpub) {\n  validateBuffer(xpub, 64);\n  return pbkdf2(xpub, 'address-hashing', 500, 32, 'sha512');\n}\n\nmodule.exports = {\n  addressToBuffer,\n  packBootstrapAddress,\n  packBaseAddress,\n  packPointerAddress,\n  packEnterpriseAddress,\n  packRewardAddress,\n  getAddressType,\n  hasSpendingScript,\n  hasStakingScript,\n  getShelleyAddressNetworkId,\n  getBootstrapAddressAttributes,\n  getBootstrapAddressDerivationPath,\n  getBootstrapAddressProtocolMagic,\n  isValidBootstrapAddress,\n  isValidShelleyAddress,\n  xpubToHdPassphrase,\n  getPubKeyBlake2b224Hash,\n  AddressTypes,\n  BaseAddressTypes\n};","map":{"version":3,"names":["chacha20poly1305Encrypt","chacha20poly1305Decrypt","blake2b","sha3_256","require","cbor","crc32","base58","bech32","pbkdf2","variableLengthEncode","CborIndefiniteLengthArray","validateBuffer","validateDerivationScheme","validateArray","validateString","validateNetworkId","validateUint32","AddressTypes","BaseAddressTypes","shelleyAddressTypes","BASE","BASE_SCRIPT_KEY","BASE_KEY_SCRIPT","BASE_SCRIPT_SCRIPT","POINTER","POINTER_SCRIPT","ENTERPRISE","ENTERPRISE_SCRIPT","REWARD","REWARD_SCRIPT","PUB_KEY_LEN","KEY_HASH_LEN","MAINNET_PROTOCOL_MAGIC","validatePointer","input","hasOwnProperty","Error","Number","isInteger","blockIndex","txIndex","certificateIndex","packBootstrapAddress","derivationPath","xpub","hdPassphrase","derivationScheme","protocolMagic","addressPayload","addressAttributes","length","encryptDerivationPath","Map","encode","Buffer","from","set","getAddressRootHash","addressRoot","addressType","addressData","addressDataEncoded","Tagged","getAddressHeader","networkId","getPubKeyBlake2b224Hash","pubKey","packBaseAddress","spendingHash","stakingHash","type","concat","packPointerAddress","pointer","isScript","packEnterpriseAddress","packRewardAddress","getBootstrapAddressAttributes","addressBuffer","addressAsBuffer","decode","value","getBootstrapAddressDerivationPath","addressPayloadCbor","get","decryptDerivationPath","e","getBootstrapAddressProtocolMagic","protocolMagicCbor","isValidBootstrapAddress","address","addressAsArray","crc32Checksum","isValidShelleyAddress","data","includes","getAddressType","addressToBuffer","addressStr","hasSpendingScript","hasStakingScript","getShelleyAddressNetworkId","serializedDerivationPath","decipheredDerivationPath","err","xpubToHdPassphrase","module","exports"],"sources":["C:/Users/acer/node_modules/cardano-crypto.js/features/address.js"],"sourcesContent":["const {chacha20poly1305Encrypt, chacha20poly1305Decrypt, blake2b, sha3_256} = require(\"./crypto-primitives\")\n\nconst cbor = require('borc')\nconst crc32 = require('../utils/crc32')\nconst base58 = require('../utils/base58')\nconst bech32 = require('../utils/bech32')\nconst pbkdf2 = require('../utils/pbkdf2')\nconst variableLengthEncode = require('../utils/variableLengthEncode')\nconst CborIndefiniteLengthArray = require('../utils/CborIndefiniteLengthArray')\nconst {validateBuffer, validateDerivationScheme, validateArray, validateString, validateNetworkId, validateUint32} = require(\"../utils/validation\")\n\nconst AddressTypes = {\n  'BASE': 0b0000,\n  'BASE_SCRIPT_KEY': 0b0001,\n  'BASE_KEY_SCRIPT': 0b0010,\n  'BASE_SCRIPT_SCRIPT': 0b0011,\n  'POINTER': 0b0100,\n  'POINTER_SCRIPT': 0b0101,\n  'ENTERPRISE': 0b0110,\n  'ENTERPRISE_SCRIPT': 0b0111,\n  'BOOTSTRAP': 0b1000,\n  'REWARD': 0b1110,\n  'REWARD_SCRIPT': 0b1111,\n}\n\nconst BaseAddressTypes = {\n  'BASE': 0b00,\n  'SCRIPT_KEY': 0b01,\n  'KEY_SCRIPT': 0b10,\n  'SCRIPT_SCRIPT': 0b11\n}\n\nconst shelleyAddressTypes = [\n  AddressTypes.BASE,\n  AddressTypes.BASE_SCRIPT_KEY,\n  AddressTypes.BASE_KEY_SCRIPT,\n  AddressTypes.BASE_SCRIPT_SCRIPT,\n  AddressTypes.POINTER,\n  AddressTypes.POINTER_SCRIPT,\n  AddressTypes.ENTERPRISE,\n  AddressTypes.ENTERPRISE_SCRIPT,\n  AddressTypes.REWARD,\n  AddressTypes.REWARD_SCRIPT\n]\n\nconst PUB_KEY_LEN = 32\nconst KEY_HASH_LEN = 28\nconst MAINNET_PROTOCOL_MAGIC = 764824073\n\nfunction validatePointer(input) {\n  if (!input.hasOwnProperty('blockIndex')\n    || !input.hasOwnProperty('txIndex')\n    || !input.hasOwnProperty('certificateIndex')) {\n    throw new Error('Invalid pointer! Missing one of blockIndex, txIndex, certificateIndex')\n  }\n  if (!Number.isInteger(input.blockIndex)\n    || !Number.isInteger(input.txIndex)\n    || !Number.isInteger(input.certificateIndex)) {\n    throw new Error('Invalid pointer! values must be integer')\n  }\n}\n\nfunction packBootstrapAddress(derivationPath, xpub, hdPassphrase, derivationScheme, protocolMagic) {\n  validateBuffer(xpub, 64)\n  validateDerivationScheme(derivationScheme)\n  validateUint32(protocolMagic)\n\n  if (derivationScheme === 1) {\n    validateArray(derivationPath)\n    validateBuffer(hdPassphrase, 32)\n  }\n\n  let addressPayload, addressAttributes\n  if (derivationScheme === 1 && derivationPath.length > 0) {\n    addressPayload = encryptDerivationPath(derivationPath, hdPassphrase)\n    addressAttributes = new Map([[1, cbor.encode(addressPayload)]])\n  } else {\n    addressPayload = Buffer.from([])\n    addressAttributes = new Map()\n  }\n\n  if (protocolMagic !== MAINNET_PROTOCOL_MAGIC) {\n    addressAttributes.set(2, cbor.encode(protocolMagic))\n  }\n\n  const getAddressRootHash = (input) => blake2b(sha3_256(cbor.encode(input)), 28)\n\n  const addressRoot = getAddressRootHash([\n    0,\n    [0, xpub],\n    addressPayload.length > 0 ? new Map([[1, cbor.encode(addressPayload)]]) : new Map(),\n  ])\n  const addressType = 0 // Public key address\n  const addressData = [addressRoot, addressAttributes, addressType]\n  const addressDataEncoded = cbor.encode(addressData)\n\n  return cbor.encode([new cbor.Tagged(24, addressDataEncoded), crc32(addressDataEncoded)])\n}\n\nfunction getAddressHeader(addressType, networkId) {\n  return Buffer.from([(addressType << 4) | networkId])\n}\n\nfunction getPubKeyBlake2b224Hash(pubKey) {\n  validateBuffer(pubKey, PUB_KEY_LEN)\n\n  return blake2b(pubKey, KEY_HASH_LEN)\n}\n\nfunction packBaseAddress(spendingHash, stakingHash, networkId, type = BaseAddressTypes.BASE) {\n  validateBuffer(spendingHash, KEY_HASH_LEN)\n  validateBuffer(stakingHash, KEY_HASH_LEN)\n  validateNetworkId(networkId)\n  validateUint32(type)\n\n  return Buffer.concat([\n    getAddressHeader(AddressTypes.BASE | type, networkId),\n    spendingHash,\n    stakingHash,\n  ])\n}\n\nfunction packPointerAddress(spendingHash, pointer, networkId, isScript) {\n  validateBuffer(spendingHash, KEY_HASH_LEN)\n  validatePointer(pointer)\n  validateNetworkId(networkId)\n\n  const {blockIndex, txIndex, certificateIndex} = pointer\n\n  return Buffer.concat([\n    getAddressHeader(isScript? AddressTypes.POINTER_SCRIPT : AddressTypes.POINTER, networkId, isScript),\n    spendingHash,\n    Buffer.concat([\n      variableLengthEncode(blockIndex),\n      variableLengthEncode(txIndex),\n      variableLengthEncode(certificateIndex)\n    ])\n  ])\n}\n\nfunction packEnterpriseAddress(spendingHash, networkId, isScript) {\n  validateBuffer(spendingHash, KEY_HASH_LEN)\n  validateNetworkId(networkId)\n\n  return Buffer.concat([\n    getAddressHeader(isScript ? AddressTypes.ENTERPRISE_SCRIPT : AddressTypes.ENTERPRISE, networkId, isScript),\n    spendingHash\n  ])\n}\n\nfunction packRewardAddress(stakingHash, networkId, isScript) {\n  validateBuffer(stakingHash, KEY_HASH_LEN)\n  validateNetworkId(networkId)\n\n  return Buffer.concat([\n    getAddressHeader(isScript ? AddressTypes.REWARD_SCRIPT : AddressTypes.REWARD, networkId, isScript),\n    stakingHash\n  ])\n}\n\nfunction getBootstrapAddressAttributes(addressBuffer) {\n  // we decode the address from the base58 string\n  // and then we strip the 24 CBOR data tags (the \"[0].value\" part)\n  const addressAsBuffer = cbor.decode(addressBuffer)[0].value\n  const addressData = cbor.decode(addressAsBuffer)\n  const addressAttributes = addressData[1]\n\n  // cbor decoder decodes empty map as empty object, so we re-cast it to Map(0)\n  if (!(addressAttributes instanceof Map)) {\n    return new Map()\n  }\n\n  return addressAttributes\n}\n\nfunction getBootstrapAddressDerivationPath(addressBuffer, hdPassphrase) {\n  const addressAttributes = getBootstrapAddressAttributes(addressBuffer)\n  const addressPayloadCbor = addressAttributes.get(1)\n\n  if (!addressPayloadCbor) {\n    return null\n  }\n  const addressPayload = cbor.decode(addressPayloadCbor)\n\n\n  let derivationPath = null\n  try {\n    derivationPath = decryptDerivationPath(addressPayload, hdPassphrase)\n  } catch (e) {\n    throw new Error('Unable to get derivation path from address')\n  }\n\n  if (derivationPath && derivationPath.length > 2) {\n    throw Error('Invalid derivation path length, should be at most 2')\n  }\n\n  return derivationPath\n}\n\nfunction getBootstrapAddressProtocolMagic(addressBuffer) {\n  const addressAttributes = getBootstrapAddressAttributes(addressBuffer)\n\n  const protocolMagicCbor = addressAttributes.get(2)\n  if (!protocolMagicCbor) {\n    return MAINNET_PROTOCOL_MAGIC\n  }\n\n  return cbor.decode(protocolMagicCbor)\n}\n\nfunction isValidBootstrapAddress(address) {\n  validateString(address)\n\n  try {\n    const addressAsArray = cbor.decode(base58.decode(address))\n    // we strip the 24 CBOR data taga by taking the \"value\" attribute from the \"Tagged\" object\n    const addressDataEncoded = addressAsArray[0].value\n    const crc32Checksum = addressAsArray[1]\n\n    if (crc32Checksum !== crc32(addressDataEncoded)) {\n      return false\n    }\n\n  } catch (e) {\n    return false\n  }\n  return true\n}\n\nfunction isValidShelleyAddress(address) {\n  validateString(address)\n\n  try {\n    const {data: addressBuffer} = bech32.decode(address)\n    \n    if (!shelleyAddressTypes.includes(getAddressType(addressBuffer))) {\n      return false\n    }\n  } catch (e) {\n    return false\n  }\n  return true\n}\n\nfunction addressToBuffer(addressStr) {\n  validateString(addressStr)\n\n  try {\n    return base58.decode(addressStr)\n  } catch (e) {\n    return bech32.decode(addressStr).data\n  }\n}\n\nfunction getAddressType(addressBuffer) {\n  validateBuffer(addressBuffer)\n\n  return addressBuffer[0] >> 4\n}\n\nfunction hasSpendingScript(addressBuffer) {\n  validateBuffer(addressBuffer)\n  \n  return [\n    AddressTypes.BASE_SCRIPT_KEY,\n    AddressTypes.BASE_SCRIPT_SCRIPT,\n    AddressTypes.POINTER_SCRIPT,\n    AddressTypes.ENTERPRISE_SCRIPT\n  ].includes(getAddressType(addressBuffer))\n}\n\nfunction hasStakingScript(addressBuffer) {\n  validateBuffer(addressBuffer)\n  \n  return [\n    AddressTypes.BASE_KEY_SCRIPT,\n    AddressTypes.BASE_SCRIPT_SCRIPT,\n    AddressTypes.REWARD_SCRIPT\n  ].includes(getAddressType(addressBuffer))\n}\n\nfunction getShelleyAddressNetworkId(addressBuffer) {\n  validateBuffer(addressBuffer)\n\n  return addressBuffer[0] & 15\n}\n\nfunction encryptDerivationPath(derivationPath, hdPassphrase) {\n  const serializedDerivationPath = cbor.encode(new CborIndefiniteLengthArray(derivationPath))\n\n  return chacha20poly1305Encrypt(\n    serializedDerivationPath,\n    hdPassphrase,\n    Buffer.from('serokellfore')\n  )\n}\n\nfunction decryptDerivationPath(addressPayload, hdPassphrase) {\n  const decipheredDerivationPath = chacha20poly1305Decrypt(\n    addressPayload,\n    hdPassphrase,\n    Buffer.from('serokellfore')\n  )\n\n  try {\n    return cbor.decode(Buffer.from(decipheredDerivationPath))\n  } catch (err) {\n    throw new Error('incorrect address or passphrase')\n  }\n}\n\nasync function xpubToHdPassphrase(xpub) {\n  validateBuffer(xpub, 64)\n\n  return pbkdf2(xpub, 'address-hashing', 500, 32, 'sha512')\n}\n\nmodule.exports = {\n  addressToBuffer,\n  packBootstrapAddress,\n  packBaseAddress,\n  packPointerAddress,\n  packEnterpriseAddress,\n  packRewardAddress,\n  getAddressType,\n  hasSpendingScript,\n  hasStakingScript,\n  getShelleyAddressNetworkId,\n  getBootstrapAddressAttributes,\n  getBootstrapAddressDerivationPath,\n  getBootstrapAddressProtocolMagic,\n  isValidBootstrapAddress,\n  isValidShelleyAddress,\n  xpubToHdPassphrase,\n  getPubKeyBlake2b224Hash,\n  AddressTypes,\n  BaseAddressTypes\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}