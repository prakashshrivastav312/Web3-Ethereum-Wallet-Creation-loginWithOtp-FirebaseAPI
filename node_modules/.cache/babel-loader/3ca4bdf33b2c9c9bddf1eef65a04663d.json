{"ast":null,"code":"/*\n    Copyright 2021 The caver-js Authors\n    This file is part of the caver-js library.\n\n    The caver-js library is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Lesser General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    The caver-js library is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n    GNU Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public License\n    along with the caver-js. If not, see <http://www.gnu.org/licenses/>.\n*/\nconst _ = require('lodash');\n\nconst BigNumber = require('bignumber.js');\n\nconst Contract = require('../../caver-contract');\n\nconst {\n  kip37JsonInterface,\n  kip37ByteCode,\n  determineSendParams,\n  formatParamForUint256,\n  validateDeployParameterForKIP37,\n  interfaceIds\n} = require('./kctHelper');\n\nconst {\n  isAddress,\n  toBuffer,\n  isHexStrict,\n  toHex,\n  stripHexPrefix,\n  leftPad\n} = require('../../caver-utils');\n\nconst KIP13 = require('./kip13');\n/**\n * The KIP37 class that helps you easily handle a smart contract that implements KIP-37 as a JavaScript object on the Klaytn blockchain platform (Klaytn).\n * @hideconstructor\n * @class\n */\n\n\nclass KIP37 extends Contract {\n  /**\n   * Creates a new KIP37 instance with its bound methods and events.\n   *\n   * @example\n   * const kip37 = caver.kct.kip37.create('0x{address in hex}')\n   *\n   * @param {string} tokenAddress - The KIP-37 token contract address.\n   * @param {Array} [abi] - The Contract Application Binary Interface (ABI) of the KIP-37.\n   * @return {KIP37}\n   */\n  static create(tokenAddress, abi) {\n    return new KIP37(tokenAddress, abi);\n  }\n  /**\n   * An object that defines the parameters required to deploy the KIP-37 contract.\n   *\n   * @typedef {object} KIP37.KIP37DeployParams\n   * @property {string} uri - The URI for all token types, by relying on the {@link http://kips.klaytn.com/KIPs/kip-37#metadata|token type ID substitution mechanism}.\n   */\n\n  /**\n   * Deploys a KIP-37 token contract to Klaytn network.\n   *\n   * By default, it returns a KIP37 instance when the deployment is finished.\n   * If you define a custom function in the `contractDeployFormatter` field in {@link Contract.SendOptions|SendOptions}, you can control return type.\n   *\n   * @example\n   * const tokenInfo = { uri: 'uri string' }\n   *\n   * // Below example will use `caver.wallet`.\n   * const deployed = await caver.kct.kip37.deploy(tokenInfo, '0x{deployer address}')\n   *\n   * // Use sendOptions instead of deployer address.\n   * const sendOptions = { from: '0x{deployer address}', feeDelegation: true, feePayer: '0x{fee payer address}' }\n   * const deployed = await caver.kct.kip37.deploy(tokenInfo, sendOptions)\n   *\n   * // If you want to use your own wallet that implements the 'IWallet' interface, pass it into the last parameter.\n   * const deployed = await caver.kct.kip37.deploy(tokenInfo, '0x{deployer address}', wallet)\n   *\n   * @param {KIP37.KIP37DeployParams} tokenInfo The object that defines the uri to deploy.\n   * @param {Contract.SendOptions|string} sendOptions An object holding parameters that are required for sending a transaction.\n   * @param {IWallet} [wallet] The wallet instance to sign and send a transaction.\n   * @return {Promise<*>}\n   */\n\n\n  static deploy(tokenInfo, sendOptions, wallet) {\n    validateDeployParameterForKIP37(tokenInfo);\n    const {\n      uri\n    } = tokenInfo;\n    const kip37 = new KIP37();\n    if (wallet !== undefined) kip37.setWallet(wallet); // If sendOptions is string type, sendOptions means deployer's address\n\n    if (_.isString(sendOptions)) sendOptions = {\n      from: sendOptions,\n      gas: 7000000,\n      value: 0\n    };\n    sendOptions.gas = sendOptions.gas !== undefined ? sendOptions.gas : 7000000;\n    return kip37.deploy({\n      data: kip37ByteCode,\n      arguments: [uri]\n    }).send(sendOptions);\n  }\n  /**\n   * An object that defines the parameters required to deploy the KIP-37 contract.\n   *\n   * @typedef {object} KIP37.KIP37DetectedObject\n   * @property {boolean} IKIP37 - Whether to implement `IKIP37` interface.\n   * @property {boolean} IKIP37Metadata - Whether to implement `IKIP37Metadata` interface.\n   * @property {boolean} IKIP37Mintable - Whether to implement `IKIP37Mintable` interface.\n   * @property {boolean} IKIP37Burnable - Whether to implement `IKIP37Burnable` interface.\n   * @property {boolean} IKIP37Pausable - Whether to implement `IKIP37Pausable` interface.\n   */\n\n  /**\n   * Returns the information of the interface implemented by the token contract.\n   *\n   * @example\n   * const detected = await caver.kct.kip37.detectInterface('0x{address in hex}')\n   *\n   * @param {string} contractAddress The address of the KIP-37 token contract to detect.\n   * @return {Promise<KIP37.KIP37DetectedObject>}\n   */\n\n\n  static detectInterface(contractAddress) {\n    const kip37 = new KIP37(contractAddress);\n    return kip37.detectInterface();\n  }\n\n  constructor(tokenAddress) {\n    let abi = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : kip37JsonInterface;\n\n    if (tokenAddress) {\n      if (_.isString(tokenAddress)) {\n        if (!isAddress(tokenAddress)) throw new Error(`Invalid token address ${tokenAddress}`);\n      } else {\n        abi = tokenAddress;\n        tokenAddress = undefined;\n      }\n    }\n\n    super(abi, tokenAddress);\n    this.setWallet(KIP37.wallet);\n  }\n  /**\n   * Clones the current KIP37 instance.\n   *\n   * @example\n   * const cloned = kip37.clone()\n   * const cloned = kip37.clone('0x{new kip7 address}')\n   *\n   * @param {string} [tokenAddress] The address of the token contract.\n   * @return {KIP37}\n   */\n\n\n  clone() {\n    let tokenAddress = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.options.address;\n    const cloned = new this.constructor(tokenAddress, this.options.jsonInterface);\n    cloned.setWallet(this._wallet);\n    return cloned;\n  }\n  /**\n   * Returns the information of the interface implemented by the token contract.\n   *\n   * @example\n   * const detected = await kip37.detectInterface()\n   *\n   * @return {Promise<KIP37.KIP37DetectedObject>}\n   */\n\n\n  async detectInterface() {\n    const detected = {\n      IKIP37: false,\n      IKIP37Metadata: false,\n      IKIP37Mintable: false,\n      IKIP37Burnable: false,\n      IKIP37Pausable: false\n    };\n    const notSupportedMsg = `This contract does not support KIP-13.`;\n    const contractAddress = this._address;\n\n    try {\n      const isSupported = await KIP13.isImplementedKIP13Interface(contractAddress);\n      if (isSupported !== true) throw new Error(notSupportedMsg); // Since there is an extension that has the same interface id even though it is a different KCT,\n      // it must be checked first whether the contract is a KIP-37 contract.\n\n      detected.IKIP37 = await this.supportsInterface(interfaceIds.kip37.IKIP37);\n      if (detected.IKIP37 === false) return detected;\n      await Promise.all(Object.keys(interfaceIds.kip37).map(async interfaceName => {\n        if (interfaceIds.kip37[interfaceName] !== interfaceIds.kip37.IKIP37) detected[interfaceName] = await this.supportsInterface(interfaceIds.kip37[interfaceName]);\n      }));\n      return detected;\n    } catch (e) {\n      throw new Error(notSupportedMsg);\n    }\n  }\n  /**\n   * Returns `true` if this contract implements the interface defined by `interfaceId`.\n   *\n   * @example\n   * const supported = await kip37.supportsInterface('0x6433ca1f')\n   *\n   * @param {string} interfaceId The interface id to check.\n   * @return {Promise<boolean>}\n   */\n\n\n  async supportsInterface(interfaceId) {\n    const isSupported = await this.methods.supportsInterface(interfaceId).call();\n    return isSupported;\n  }\n  /**\n   * Returns distinct Uniform Resource Identifier (URI) of the given token.\n   * If the string {id} exists in any URI, this function will replace this with the actual token ID in hexadecimal form.\n   * Please refer to {@link http://kips.klaytn.com/KIPs/kip-37#metadata|KIP-34 Metadata}.\n   *\n   * @example\n   * const uri = await kip37.uri('0x0')\n   *\n   * @param {BigNumber|string|number} id The token id to get uri.\n   * @return {Promise<string>}\n   */\n\n\n  async uri(id) {\n    let uri = await this.methods.uri(formatParamForUint256(id)).call(); // Replace {id} to token id in hexadecimal form.\n\n    if (uri.includes('{id}')) {\n      let tokenIdInHex = stripHexPrefix(toHex(id));\n      tokenIdInHex = leftPad(tokenIdInHex, 64, '0');\n      uri = uri.replace('{id}', tokenIdInHex);\n    }\n\n    return uri;\n  }\n  /**\n   * Returns the total token supply of the specific token.\n   *\n   * @example\n   * const totalSupply = await kip37.totalSupply(0)\n   *\n   * @param {BigNumber|string|number} id The token id to see the total supply.\n   * @return {Promise<BigNumber>}\n   */\n\n\n  async totalSupply(id) {\n    const totalSupply = await this.methods.totalSupply(formatParamForUint256(id)).call();\n    return new BigNumber(totalSupply);\n  }\n  /**\n   * Returns the amount of tokens of token type `id` owned by `account`.\n   *\n   * @example\n   * const balance = await kip37.balanceOf('0x{address in hex}', 0)\n   *\n   * @param {string} account The address of the account for which you want to see balance.\n   * @param {BigNumber|string|number} id The token id to see balance.\n   * @return {Promise<BigNumber>}\n   */\n\n\n  async balanceOf(account, id) {\n    const balance = await this.methods.balanceOf(account, formatParamForUint256(id)).call();\n    return new BigNumber(balance);\n  }\n  /**\n   * Returns the balance of multiple account/token pairs.\n   * `balanceOfBatch` is a batch operation of {@link balanceOf}, and the length of arrays with `accounts` and `ids` must be the same.\n   *\n   * @param {Array.<string>} accounts The address of the accounts for which you want to see balance.\n   * @param {Array.<BigNumber|string|number>} ids An array of ids of token you want to see balance.\n   * @return {Promise<Array.<BigNumber>>}\n   */\n\n\n  async balanceOfBatch(accounts, ids) {\n    if (ids.length !== accounts.length) throw new Error(`ids and accounts must have the same length.`);\n    const formattedTokenIds = [];\n\n    for (let i = 0; i < ids.length; i++) {\n      formattedTokenIds.push(formatParamForUint256(ids[i]));\n    }\n\n    const balances = await this.methods.balanceOfBatch(accounts, formattedTokenIds).call();\n    const ret = [];\n\n    for (const bal of balances) {\n      ret.push(new BigNumber(bal));\n    }\n\n    return ret;\n  }\n  /**\n   * Queries the approval status of an operator for a given owner. Returns true if an operator is approved by a given owner.\n   *\n   * @example\n   * const isApprovedForAll = await kip37.isApprovedForAll('0x{address in hex}', '0x{address in hex}')\n   *\n   * @param {string} owner The address of the owner.\n   * @param {string} operator The address of the operator.\n   * @return {Promise<boolean>}\n   */\n\n\n  async isApprovedForAll(owner, operator) {\n    const isApprovedForAll = await this.methods.isApprovedForAll(owner, operator).call();\n    return isApprovedForAll;\n  }\n  /**\n   * Returns whether or not the token contract's transaction (or specific token) is paused.\n   *\n   * If `id` parameter is not defined, return whether the token contract's transaction is paused.\n   * If `id` parameter is defined, return whether the specific token is paused.\n   *\n   * @example\n   * // without token id parameter\n   * const isPaused = await kip37.paused()\n   * // with token id parameter\n   * const isPaused = await kip37.paused(0)\n   *\n   * @param {BigNumber|string|number} [id] The token id to check wether paused or not. If this parameter is omitted, the `paused` function return whether the contract is in paused state.\n   * @return {Promise<boolean>}\n   */\n\n\n  async paused(id) {\n    const callObject = id !== undefined ? this.methods.paused(formatParamForUint256(id)) : this.methods.paused();\n    const isPaused = await callObject.call();\n    return isPaused;\n  }\n  /**\n   * Returns `true` if the given account is a pauser who can suspend transferring tokens.\n   *\n   * @example\n   * const isPauser = await kip37.isPauser('0x{address in hex}')\n   *\n   * @param {string} account The address of the account to be checked for having the right to suspend transferring tokens.\n   * @return {Promise<boolean>}\n   */\n\n\n  async isPauser(account) {\n    const isPauser = await this.methods.isPauser(account).call();\n    return isPauser;\n  }\n  /**\n   * Returns `true` if the given account is a minter who can issue new KIP37 tokens.\n   *\n   * @example\n   * const isMinter = await kip37.isMinter('0x{address in hex}')\n   *\n   * @param {string} account The address of the account to be checked for having the minting right.\n   * @return {Promise<boolean>}\n   */\n\n\n  async isMinter(account) {\n    const isMinter = await this.methods.isMinter(account).call();\n    return isMinter;\n  }\n  /**\n   * create creates token and assigns them to account, increasing the total supply.\n   *\n   * @example\n   * // Send via a sendParam object with the from field given\n   * const receipt = await kip37.create(2, '1000000000000000000', { from: '0x{address in hex}' })\n   *\n   * @param {BigNumber|string|number} id The token id to create.\n   * @param {BigNumber|string|number} initialSupply The amount of tokens being minted.\n   * @param {string} [uri] The token URI of the created token.\n   * @param {Contract.SendOptios} [sendParam] (optional) An object holding parameters that are required for sending a transaction.\n   * @return {Promise<object>} A receipt containing the execution result of the transaction for executing the KIP-37 token contract.\n   *                  In this receipt, instead of the logs property, there is an events property parsed by KIP-37 abi.\n   */\n\n\n  async create(id, initialSupply, uri) {\n    let sendParam = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n\n    if (uri && _.isObject(uri)) {\n      if (uri.gas !== undefined || uri.from !== undefined) {\n        if (Object.keys(sendParam).length > 0) throw new Error(`Invalid parameters`);\n        sendParam = uri;\n        uri = '';\n      }\n    }\n\n    const executableObj = this.methods.create(formatParamForUint256(id), formatParamForUint256(initialSupply), uri);\n    sendParam = await determineSendParams(executableObj, sendParam, this.options);\n    return executableObj.send(sendParam);\n  }\n  /**\n   * Approves the given operator, or disallow the given operator, to transfer all tokens of the owner.\n   * An operator is allowed to transfer all tokens of the sender on their behalf.\n   *\n   * @example\n   * const receipt = await kip37.setApprovalForAll('0x{address in hex}', true, { from: '0x{address in hex}' })\n   *\n   * @param {string} operator The address of an account to be approved/prohibited to transfer the owner's all tokens.\n   * @param {boolean} approved This operator will be approved if `true`. The operator will be disallowed if `false`.\n   * @param {Contract.SendOptios} [sendParam] (optional) An object holding parameters that are required for sending a transaction.\n   * @return {Promise<object>} A receipt containing the execution result of the transaction for executing the KIP-37 token contract.\n   *                  In this receipt, instead of the logs property, there is an events property parsed by KIP-37 abi.\n   */\n\n\n  async setApprovalForAll(operator, approved) {\n    let sendParam = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    const executableObj = this.methods.setApprovalForAll(operator, approved);\n    sendParam = await determineSendParams(executableObj, sendParam, this.options);\n    return executableObj.send(sendParam);\n  }\n  /**\n   * Safely transfers the given `amount` tokens of specific token type `id` from `from` to the `recipient`.\n   *\n   * The address who was approved to send the owner's token (the operator) or the token owner itself is expected to execute this token transferring transaction.\n   * Thus, the approved one or the token owner should be the sender of this transaction whose address must be given at `sendParam.from` or `kip37.options.from`.\n   * Without `sendParam.from` nor `kip37.options.from` being provided, an error would occur.\n   *\n   * If the `recipient` was a contract address, it should implement `IKIP37Receiver.onKIP37Received`. Otherwise, the transfer is reverted.\n   *\n   * @example\n   * const receipt = await kip37.safeTransferFrom('0x{address in hex}', '0x{address in hex}', 2, 10000, { from: '0x{address in hex}' })\n   *\n   * @param {string} from The address of the account that owns the token to be sent with allowance mechanism.\n   * @param {string} to The address of the account to receive the token.\n   * @param {BigNumber|string|number} id The token id to transfer.\n   * @param {BigNumber|string|number} amount The amount of token you want to transfer.\n   * @param {Buffer|string|number} [data] (optional) The data to send along with the call.\n   * @param {Contract.SendOptios} [sendParam] (optional) An object holding parameters that are required for sending a transaction.\n   * @return {Promise<object>} A receipt containing the execution result of the transaction for executing the KIP-37 token contract.\n   *                  In this receipt, instead of the logs property, there is an events property parsed by KIP-37 abi.\n   */\n\n\n  async safeTransferFrom(from, to, id, amount, data) {\n    let sendParam = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : {};\n\n    if (data && _.isObject(data)) {\n      if (data.gas !== undefined || data.from !== undefined) {\n        if (Object.keys(sendParam).length > 0) throw new Error(`Invalid parameters`);\n        sendParam = data;\n        data = Buffer.from('');\n      }\n    }\n\n    if (data && !_.isBuffer(data)) {\n      if (_.isString(data) && !isHexStrict(data)) data = toHex(data);\n      data = toBuffer(data);\n    }\n\n    const executableObj = this.methods.safeTransferFrom(from, to, formatParamForUint256(id), formatParamForUint256(amount), data);\n    sendParam = await determineSendParams(executableObj, sendParam, this.options);\n    return executableObj.send(sendParam);\n  }\n  /**\n   * Safely batch transfers of multiple token ids and values from `from` to the `recipient`.\n   *\n   * The address who was approved to send the owner's token (the operator) or the token owner itself is expected to execute this token transferring transaction.\n   * Thus, the approved one or the token owner should be the sender of this transaction whose address must be given at `sendParam.from` or `kip37.options.from`.\n   * Without `sendParam.from` nor `kip37.options.from` being provided, an error would occur.\n   *\n   * If the `recipient` was a contract address, it should implement `IKIP37Receiver.onKIP37Received`. Otherwise, the transfer is reverted.\n   *\n   * @example\n   * const receipt = await kip37.safeBatchTransferFrom('0x{address in hex}', '0x{address in hex}', [1, 2], [10, 1000], { from: '0x{address in hex}' })\n   *\n   * @param {string} from The address of the account that owns the token to be sent with allowance mechanism.\n   * @param {string} recipient The address of the account to receive the token.\n   * @param {Array.<BigNumber|string|number>} ids An array of the token ids to transfer.\n   * @param {Array.<BigNumber|string|number>} amounts An array of the token amounts you want to transfer.\n   * @param {Buffer|string|number} [data] (optional) The data to send along with the call.\n   * @param {Contract.SendOptios} [sendParam] (optional) An object holding parameters that are required for sending a transaction.\n   * @return {Promise<object>} A receipt containing the execution result of the transaction for executing the KIP-37 token contract.\n   *                  In this receipt, instead of the logs property, there is an events property parsed by KIP-37 abi.\n   */\n\n\n  async safeBatchTransferFrom(from, recipient, ids, amounts, data) {\n    let sendParam = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : {};\n\n    if (data && _.isObject(data)) {\n      if (data.gas !== undefined || data.from !== undefined) {\n        if (Object.keys(sendParam).length > 0) throw new Error(`Invalid parameters`);\n        sendParam = data;\n        data = Buffer.from('');\n      }\n    }\n\n    if (data && !_.isBuffer(data)) {\n      if (_.isString(data) && !isHexStrict(data)) data = toHex(data);\n      data = toBuffer(data);\n    }\n\n    if (ids.length !== amounts.length) throw new Error(`ids and amounts must have the same length.`);\n    const formattedTokenIds = [];\n    const formattedTokenAmounts = [];\n\n    for (let i = 0; i < ids.length; i++) {\n      formattedTokenIds.push(formatParamForUint256(ids[i]));\n      formattedTokenAmounts.push(formatParamForUint256(amounts[i]));\n    }\n\n    const executableObj = this.methods.safeBatchTransferFrom(from, recipient, formattedTokenIds, formattedTokenAmounts, data);\n    sendParam = await determineSendParams(executableObj, sendParam, this.options);\n    return executableObj.send(sendParam);\n  }\n  /**\n   * Mints the token of the specific token type `id` and assigns the tokens according to the variables `to` and `value`.\n   * The mint function allows you to mint specific token to multiple accounts at once by passing arrays `to` to and `value` as parameters.\n   *\n   * If `sendParam.from` or `kip37.options.from` were given, it should be a minter with MinterRole.\n   *\n   * @example\n   * const receipt = await kip37.mint('0x{address in hex}', 2, 1000, { from: '0x{address in hex}' })\n   *\n   * @param {string|Array.<string>} toList An address of the account or an array of addresses to which the minted token will be issued.\n   * @param {BigNumber|string|number} id The token id to mint.\n   * @param {BigNumber|string|number|Array.<BigNumber|string|number>} values The amount of token to be minted. If an array containing multiple addresses is delivered to `to` parameter, the value must be delivered in the form of an array.\n   * @param {Contract.SendOptios} [sendParam] (optional) An object holding parameters that are required for sending a transaction.\n   * @return {Promise<object>} A receipt containing the execution result of the transaction for executing the KIP-37 token contract.\n   *                  In this receipt, instead of the logs property, there is an events property parsed by KIP-37 abi.\n   */\n\n\n  async mint(toList, id, values) {\n    let sendParam = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n    if (_.isArray(toList) !== _.isArray(values)) throw new Error(`If you want to minting a specific token to multiple accounts, both toList and values both must be arrays.`);\n    let executableObj;\n\n    if (_.isArray(toList)) {\n      if (toList.length !== values.length) throw new Error(`toList and values must have the same length.`);\n      const formattedTokenValues = [];\n\n      for (const val of values) {\n        formattedTokenValues.push(formatParamForUint256(val));\n      }\n\n      executableObj = this.methods.mint(formatParamForUint256(id), toList, formattedTokenValues);\n    } else {\n      executableObj = this.methods.mint(formatParamForUint256(id), toList, formatParamForUint256(values));\n    }\n\n    sendParam = await determineSendParams(executableObj, sendParam, this.options);\n    return executableObj.send(sendParam);\n  }\n  /**\n   * Mints the multiple KIP-37 tokens of the specific token types `ids` in a batch and assigns the tokens according to the variables `to` and `values`.\n   *\n   * If `sendParam.from` or `kip37.options.from` were given, it should be a minter with MinterRole.\n   *\n   * @example\n   * const receipt = await kip37.mintBatch('0x{address in hex}', [1, 2], [100, 200], { from: '0x{address in hex}' })\n   *\n   * @param {string} to An address of the account to which the minted tokens will be issued.\n   * @param {Array.<BigNumber|string|number>} ids An array of the token ids to mint.\n   * @param {Array.<BigNumber|string|number>} values An array of the token amounts to mint.\n   * @param {Contract.SendOptios} [sendParam] (optional) An object holding parameters that are required for sending a transaction.\n   * @return {Promise<object>} A receipt containing the execution result of the transaction for executing the KIP-37 token contract.\n   *                  In this receipt, instead of the logs property, there is an events property parsed by KIP-37 abi.\n   */\n\n\n  async mintBatch(to, ids, values) {\n    let sendParam = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n    if (ids.length !== values.length) throw new Error(`ids and values must have the same length.`);\n    const formattedTokenIds = [];\n    const formattedTokenValues = [];\n\n    for (let i = 0; i < ids.length; i++) {\n      formattedTokenIds.push(formatParamForUint256(ids[i]));\n      formattedTokenValues.push(formatParamForUint256(values[i]));\n    }\n\n    const executableObj = this.methods.mintBatch(to, formattedTokenIds, formattedTokenValues);\n    sendParam = await determineSendParams(executableObj, sendParam, this.options);\n    return executableObj.send(sendParam);\n  }\n  /**\n   * Adds an account as a minter, who are permitted to mint tokens.\n   *\n   * If `sendParam.from` or `kip37.options.from` were given, it should be a minter with MinterRole.\n   *\n   * @example\n   * const receipt = await kip37.addMinter('0x{address in hex}', { from: '0x{address in hex}' })\n   *\n   * @param {string} account The address of the account to be added as a minter.\n   * @param {Contract.SendOptios} [sendParam] (optional) An object holding parameters that are required for sending a transaction.\n   * @return {Promise<object>} A receipt containing the execution result of the transaction for executing the KIP-37 token contract.\n   *                  In this receipt, instead of the logs property, there is an events property parsed by KIP-37 abi.\n   */\n\n\n  async addMinter(account) {\n    let sendParam = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const executableObj = this.methods.addMinter(account);\n    sendParam = await determineSendParams(executableObj, sendParam, this.options);\n    return executableObj.send(sendParam);\n  }\n  /**\n   * Renounces the right to mint tokens. Only a minter address can renounce the minting right.\n   *\n   * If `sendParam.from` or `kip37.options.from` were given, it should be a minter with MinterRole.\n   *\n   * @example\n   * const receipt = await kip37.renounceMinter({ from: '0x{address in hex}' })\n   *\n   * @param {Contract.SendOptios} [sendParam] (optional) An object holding parameters that are required for sending a transaction.\n   * @return {Promise<object>} A receipt containing the execution result of the transaction for executing the KIP-37 token contract.\n   *                  In this receipt, instead of the logs property, there is an events property parsed by KIP-37 abi.\n   */\n\n\n  async renounceMinter() {\n    let sendParam = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const executableObj = this.methods.renounceMinter();\n    sendParam = await determineSendParams(executableObj, sendParam, this.options);\n    return executableObj.send(sendParam);\n  }\n  /**\n   * Burns specific KIP-37 tokens.\n   *\n   * The address who was approved to operate the owner's token (the operator) or the token owner itself is expected to execute this token transferring transaction.\n   * Thus, the approved one or the token owner should be the sender of this transaction whose address must be given at `sendParam.from` or `kip37.options.from`.\n   * Without `sendParam.from` nor `kip37.options.from` being provided, an error would occur.\n   *\n   * @example\n   * const receipt = await kip37.burn('0x{address in hex}', 2, 10, { from: '0x{address in hex}' })\n   *\n   * @param {string} account The address of the account that owns the token to be destroyed.\n   * @param {BigNumber|string|number} id The id of token to be destroyed.\n   * @param {BigNumber|string|number} value The amount of token to be destroyed.\n   * @param {Contract.SendOptios} [sendParam] (optional) An object holding parameters that are required for sending a transaction.\n   * @return {Promise<object>} A receipt containing the execution result of the transaction for executing the KIP-7 token contract.\n   *                  In this receipt, instead of the logs property, there is an events property parsed by KIP-7 abi.\n   */\n\n\n  async burn(account, id, value) {\n    let sendParam = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n    const executableObj = this.methods.burn(account, formatParamForUint256(id), formatParamForUint256(value));\n    sendParam = await determineSendParams(executableObj, sendParam, this.options);\n    return executableObj.send(sendParam);\n  }\n  /**\n   * Burns the multiple KIP-37 tokens.\n   *\n   * The address who was approved to operate the owner's token (the operator) or the token owner itself is expected to execute this token transferring transaction.\n   * Thus, the approved one or the token owner should be the sender of this transaction whose address must be given at `sendParam.from` or `kip37.options.from`.\n   * Without `sendParam.from` nor `kip37.options.from` being provided, an error would occur.\n   *\n   * @example\n   * const receipt = await kip37.burnBatch('0x{address in hex}', [1, 2], [100, 200], { from: '0x{address in hex}' })\n   *\n   * @param {string} account The address of the account that owns the token to be destroyed.\n   * @param {Array.<BigNumber|string|number>} ids An array of the token ids to burn.\n   * @param {Array.<BigNumber|string|number>} values An array of the token amounts to burn.\n   * @param {Contract.SendOptios} [sendParam] (optional) An object holding parameters that are required for sending a transaction.\n   * @return {Promise<object>} A receipt containing the execution result of the transaction for executing the KIP-37 token contract.\n   *                  In this receipt, instead of the logs property, there is an events property parsed by KIP-37 abi.\n   */\n\n\n  async burnBatch(account, ids, values) {\n    let sendParam = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n    if (ids.length !== values.length) throw new Error(`ids and values must have the same length.`);\n    const formattedTokenIds = [];\n    const formattedTokenValues = [];\n\n    for (let i = 0; i < ids.length; i++) {\n      formattedTokenIds.push(formatParamForUint256(ids[i]));\n      formattedTokenValues.push(formatParamForUint256(values[i]));\n    }\n\n    const executableObj = this.methods.burnBatch(account, formattedTokenIds, formattedTokenValues);\n    sendParam = await determineSendParams(executableObj, sendParam, this.options);\n    return executableObj.send(sendParam);\n  }\n  /**\n   * Suspends functions related to token operation.\n   * If `id` parameter is defined, pause the specific token. Otherwise pause the token contract.\n   *\n   * If `sendParam.from` or `kip37.options.from` were given, it should be a pauser with PauserRole.\n   *\n   * @example\n   * const receipt = await kip37.pause({ from: '0x{address in hex}' })\n   *\n   * @param {BigNumber|string|number} [id] The token id to pause. If this parameter is omitted, the `pause` function pause the token contract.\n   * @param {Contract.SendOptios} [sendParam] (optional) An object holding parameters that are required for sending a transaction.\n   * @return {Promise<object>} A receipt containing the execution result of the transaction for executing the KIP-37 token contract.\n   *                  In this receipt, instead of the logs property, there is an events property parsed by KIP-37 abi.\n   */\n\n\n  async pause(id) {\n    let sendParam = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    if (Object.keys(sendParam).length === 0 && _.isObject(id)) {\n      sendParam = id;\n      id = undefined;\n    }\n\n    const executableObj = id !== undefined ? this.methods.pause(formatParamForUint256(id)) : this.methods.pause();\n    sendParam = await determineSendParams(executableObj, sendParam, this.options);\n    return executableObj.send(sendParam);\n  }\n  /**\n   * Resumes the paused contract or specific token.\n   * If `id` parameter is defined, unpause the specific token. Otherwise unpause the token contract.\n   *\n   * If `sendParam.from` or `kip37.options.from` were given, it should be a pauser with PauserRole.\n   *\n   * @example\n   * const receipt = await kip37.unpause({ from: '0x{address in hex}' })\n   *\n   * @param {BigNumber|string|number} [id] The token id to unpause. If this parameter is omitted, the `unpause` function unpause the token contract.\n   * @param {Contract.SendOptios} [sendParam] (optional) An object holding parameters that are required for sending a transaction.\n   * @return {Promise<object>} A receipt containing the execution result of the transaction for executing the KIP-37 token contract.\n   *                  In this receipt, instead of the logs property, there is an events property parsed by KIP-37 abi.\n   */\n\n\n  async unpause(id) {\n    let sendParam = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    if (Object.keys(sendParam).length === 0 && _.isObject(id)) {\n      sendParam = id;\n      id = undefined;\n    }\n\n    const executableObj = id !== undefined ? this.methods.unpause(formatParamForUint256(id)) : this.methods.unpause();\n    sendParam = await determineSendParams(executableObj, sendParam, this.options);\n    return executableObj.send(sendParam);\n  }\n  /**\n   * Adds an account as a pauser that has the right to suspend the contract.\n   *\n   * If `sendParam.from` or `kip37.options.from` were given, it should be a pauser with PauserRole.\n   *\n   * @example\n   * const receipt = await kip37.addPauser('0x{address in hex}', { from: '0x{address in hex}' })\n   *\n   * @param {string} account The address of the account to be a new pauser.\n   * @param {Contract.SendOptios} [sendParam] (optional) An object holding parameters that are required for sending a transaction.\n   * @return {Promise<object>} A receipt containing the execution result of the transaction for executing the KIP-37 token contract.\n   *                  In this receipt, instead of the logs property, there is an events property parsed by KIP-37 abi.\n   */\n\n\n  async addPauser(account) {\n    let sendParam = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const executableObj = this.methods.addPauser(account);\n    sendParam = await determineSendParams(executableObj, sendParam, this.options);\n    return executableObj.send(sendParam);\n  }\n  /**\n   * Renounces the right to pause the contract. Only a pauser address can renounce the pausing right.\n   *\n   * If `sendParam.from` or `kip37.options.from` were given, it should be a pauser with PauserRole.\n   *\n   * @example\n   * const receipt = await kip37.renouncePauser({ from: '0x{address in hex}' })\n   *\n   * @param {Contract.SendOptios} [sendParam] (optional) An object holding parameters that are required for sending a transaction.\n   * @return {Promise<object>} A receipt containing the execution result of the transaction for executing the KIP-37 token contract.\n   *                  In this receipt, instead of the logs property, there is an events property parsed by KIP-37 abi.\n   */\n\n\n  async renouncePauser() {\n    let sendParam = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const executableObj = this.methods.renouncePauser();\n    sendParam = await determineSendParams(executableObj, sendParam, this.options);\n    return executableObj.send(sendParam);\n  }\n\n}\n/**\n * The byte code of the KIP-37 token contract.\n *\n * @example\n * caver.kct.kip37.byteCode\n *\n * @static\n * @type {string}\n */\n\n\nKIP37.byteCode = kip37ByteCode;\n/**\n * The abi of the KIP-37 token contract.\n *\n * @example\n * caver.kct.kip37.abi\n *\n * @static\n * @type {Array.<object>}\n */\n\nKIP37.abi = kip37JsonInterface;\nmodule.exports = KIP37;","map":{"version":3,"names":["_","require","BigNumber","Contract","kip37JsonInterface","kip37ByteCode","determineSendParams","formatParamForUint256","validateDeployParameterForKIP37","interfaceIds","isAddress","toBuffer","isHexStrict","toHex","stripHexPrefix","leftPad","KIP13","KIP37","create","tokenAddress","abi","deploy","tokenInfo","sendOptions","wallet","uri","kip37","undefined","setWallet","isString","from","gas","value","data","arguments","send","detectInterface","contractAddress","constructor","Error","clone","options","address","cloned","jsonInterface","_wallet","detected","IKIP37","IKIP37Metadata","IKIP37Mintable","IKIP37Burnable","IKIP37Pausable","notSupportedMsg","_address","isSupported","isImplementedKIP13Interface","supportsInterface","Promise","all","Object","keys","map","interfaceName","e","interfaceId","methods","call","id","includes","tokenIdInHex","replace","totalSupply","balanceOf","account","balance","balanceOfBatch","accounts","ids","length","formattedTokenIds","i","push","balances","ret","bal","isApprovedForAll","owner","operator","paused","callObject","isPaused","isPauser","isMinter","initialSupply","sendParam","isObject","executableObj","setApprovalForAll","approved","safeTransferFrom","to","amount","Buffer","isBuffer","safeBatchTransferFrom","recipient","amounts","formattedTokenAmounts","mint","toList","values","isArray","formattedTokenValues","val","mintBatch","addMinter","renounceMinter","burn","burnBatch","pause","unpause","addPauser","renouncePauser","byteCode","module","exports"],"sources":["C:/Users/acer/node_modules/caver-js/packages/caver-kct/src/kip37.js"],"sourcesContent":["/*\n    Copyright 2021 The caver-js Authors\n    This file is part of the caver-js library.\n\n    The caver-js library is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Lesser General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    The caver-js library is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n    GNU Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public License\n    along with the caver-js. If not, see <http://www.gnu.org/licenses/>.\n*/\n\nconst _ = require('lodash')\nconst BigNumber = require('bignumber.js')\n\nconst Contract = require('../../caver-contract')\nconst {\n    kip37JsonInterface,\n    kip37ByteCode,\n    determineSendParams,\n    formatParamForUint256,\n    validateDeployParameterForKIP37,\n    interfaceIds,\n} = require('./kctHelper')\nconst { isAddress, toBuffer, isHexStrict, toHex, stripHexPrefix, leftPad } = require('../../caver-utils')\nconst KIP13 = require('./kip13')\n\n/**\n * The KIP37 class that helps you easily handle a smart contract that implements KIP-37 as a JavaScript object on the Klaytn blockchain platform (Klaytn).\n * @hideconstructor\n * @class\n */\nclass KIP37 extends Contract {\n    /**\n     * Creates a new KIP37 instance with its bound methods and events.\n     *\n     * @example\n     * const kip37 = caver.kct.kip37.create('0x{address in hex}')\n     *\n     * @param {string} tokenAddress - The KIP-37 token contract address.\n     * @param {Array} [abi] - The Contract Application Binary Interface (ABI) of the KIP-37.\n     * @return {KIP37}\n     */\n    static create(tokenAddress, abi) {\n        return new KIP37(tokenAddress, abi)\n    }\n\n    /**\n     * An object that defines the parameters required to deploy the KIP-37 contract.\n     *\n     * @typedef {object} KIP37.KIP37DeployParams\n     * @property {string} uri - The URI for all token types, by relying on the {@link http://kips.klaytn.com/KIPs/kip-37#metadata|token type ID substitution mechanism}.\n     */\n    /**\n     * Deploys a KIP-37 token contract to Klaytn network.\n     *\n     * By default, it returns a KIP37 instance when the deployment is finished.\n     * If you define a custom function in the `contractDeployFormatter` field in {@link Contract.SendOptions|SendOptions}, you can control return type.\n     *\n     * @example\n     * const tokenInfo = { uri: 'uri string' }\n     *\n     * // Below example will use `caver.wallet`.\n     * const deployed = await caver.kct.kip37.deploy(tokenInfo, '0x{deployer address}')\n     *\n     * // Use sendOptions instead of deployer address.\n     * const sendOptions = { from: '0x{deployer address}', feeDelegation: true, feePayer: '0x{fee payer address}' }\n     * const deployed = await caver.kct.kip37.deploy(tokenInfo, sendOptions)\n     *\n     * // If you want to use your own wallet that implements the 'IWallet' interface, pass it into the last parameter.\n     * const deployed = await caver.kct.kip37.deploy(tokenInfo, '0x{deployer address}', wallet)\n     *\n     * @param {KIP37.KIP37DeployParams} tokenInfo The object that defines the uri to deploy.\n     * @param {Contract.SendOptions|string} sendOptions An object holding parameters that are required for sending a transaction.\n     * @param {IWallet} [wallet] The wallet instance to sign and send a transaction.\n     * @return {Promise<*>}\n     */\n    static deploy(tokenInfo, sendOptions, wallet) {\n        validateDeployParameterForKIP37(tokenInfo)\n\n        const { uri } = tokenInfo\n        const kip37 = new KIP37()\n        if (wallet !== undefined) kip37.setWallet(wallet)\n\n        // If sendOptions is string type, sendOptions means deployer's address\n        if (_.isString(sendOptions)) sendOptions = { from: sendOptions, gas: 7000000, value: 0 }\n        sendOptions.gas = sendOptions.gas !== undefined ? sendOptions.gas : 7000000\n\n        return kip37\n            .deploy({\n                data: kip37ByteCode,\n                arguments: [uri],\n            })\n            .send(sendOptions)\n    }\n\n    /**\n     * An object that defines the parameters required to deploy the KIP-37 contract.\n     *\n     * @typedef {object} KIP37.KIP37DetectedObject\n     * @property {boolean} IKIP37 - Whether to implement `IKIP37` interface.\n     * @property {boolean} IKIP37Metadata - Whether to implement `IKIP37Metadata` interface.\n     * @property {boolean} IKIP37Mintable - Whether to implement `IKIP37Mintable` interface.\n     * @property {boolean} IKIP37Burnable - Whether to implement `IKIP37Burnable` interface.\n     * @property {boolean} IKIP37Pausable - Whether to implement `IKIP37Pausable` interface.\n     */\n    /**\n     * Returns the information of the interface implemented by the token contract.\n     *\n     * @example\n     * const detected = await caver.kct.kip37.detectInterface('0x{address in hex}')\n     *\n     * @param {string} contractAddress The address of the KIP-37 token contract to detect.\n     * @return {Promise<KIP37.KIP37DetectedObject>}\n     */\n    static detectInterface(contractAddress) {\n        const kip37 = new KIP37(contractAddress)\n        return kip37.detectInterface()\n    }\n\n    constructor(tokenAddress, abi = kip37JsonInterface) {\n        if (tokenAddress) {\n            if (_.isString(tokenAddress)) {\n                if (!isAddress(tokenAddress)) throw new Error(`Invalid token address ${tokenAddress}`)\n            } else {\n                abi = tokenAddress\n                tokenAddress = undefined\n            }\n        }\n        super(abi, tokenAddress)\n        this.setWallet(KIP37.wallet)\n    }\n\n    /**\n     * Clones the current KIP37 instance.\n     *\n     * @example\n     * const cloned = kip37.clone()\n     * const cloned = kip37.clone('0x{new kip7 address}')\n     *\n     * @param {string} [tokenAddress] The address of the token contract.\n     * @return {KIP37}\n     */\n    clone(tokenAddress = this.options.address) {\n        const cloned = new this.constructor(tokenAddress, this.options.jsonInterface)\n        cloned.setWallet(this._wallet)\n        return cloned\n    }\n\n    /**\n     * Returns the information of the interface implemented by the token contract.\n     *\n     * @example\n     * const detected = await kip37.detectInterface()\n     *\n     * @return {Promise<KIP37.KIP37DetectedObject>}\n     */\n    async detectInterface() {\n        const detected = {\n            IKIP37: false,\n            IKIP37Metadata: false,\n            IKIP37Mintable: false,\n            IKIP37Burnable: false,\n            IKIP37Pausable: false,\n        }\n\n        const notSupportedMsg = `This contract does not support KIP-13.`\n        const contractAddress = this._address\n\n        try {\n            const isSupported = await KIP13.isImplementedKIP13Interface(contractAddress)\n            if (isSupported !== true) throw new Error(notSupportedMsg)\n\n            // Since there is an extension that has the same interface id even though it is a different KCT,\n            // it must be checked first whether the contract is a KIP-37 contract.\n            detected.IKIP37 = await this.supportsInterface(interfaceIds.kip37.IKIP37)\n            if (detected.IKIP37 === false) return detected\n\n            await Promise.all(\n                Object.keys(interfaceIds.kip37).map(async interfaceName => {\n                    if (interfaceIds.kip37[interfaceName] !== interfaceIds.kip37.IKIP37)\n                        detected[interfaceName] = await this.supportsInterface(interfaceIds.kip37[interfaceName])\n                })\n            )\n            return detected\n        } catch (e) {\n            throw new Error(notSupportedMsg)\n        }\n    }\n\n    /**\n     * Returns `true` if this contract implements the interface defined by `interfaceId`.\n     *\n     * @example\n     * const supported = await kip37.supportsInterface('0x6433ca1f')\n     *\n     * @param {string} interfaceId The interface id to check.\n     * @return {Promise<boolean>}\n     */\n    async supportsInterface(interfaceId) {\n        const isSupported = await this.methods.supportsInterface(interfaceId).call()\n        return isSupported\n    }\n\n    /**\n     * Returns distinct Uniform Resource Identifier (URI) of the given token.\n     * If the string {id} exists in any URI, this function will replace this with the actual token ID in hexadecimal form.\n     * Please refer to {@link http://kips.klaytn.com/KIPs/kip-37#metadata|KIP-34 Metadata}.\n     *\n     * @example\n     * const uri = await kip37.uri('0x0')\n     *\n     * @param {BigNumber|string|number} id The token id to get uri.\n     * @return {Promise<string>}\n     */\n    async uri(id) {\n        let uri = await this.methods.uri(formatParamForUint256(id)).call()\n\n        // Replace {id} to token id in hexadecimal form.\n        if (uri.includes('{id}')) {\n            let tokenIdInHex = stripHexPrefix(toHex(id))\n            tokenIdInHex = leftPad(tokenIdInHex, 64, '0')\n            uri = uri.replace('{id}', tokenIdInHex)\n        }\n        return uri\n    }\n\n    /**\n     * Returns the total token supply of the specific token.\n     *\n     * @example\n     * const totalSupply = await kip37.totalSupply(0)\n     *\n     * @param {BigNumber|string|number} id The token id to see the total supply.\n     * @return {Promise<BigNumber>}\n     */\n    async totalSupply(id) {\n        const totalSupply = await this.methods.totalSupply(formatParamForUint256(id)).call()\n        return new BigNumber(totalSupply)\n    }\n\n    /**\n     * Returns the amount of tokens of token type `id` owned by `account`.\n     *\n     * @example\n     * const balance = await kip37.balanceOf('0x{address in hex}', 0)\n     *\n     * @param {string} account The address of the account for which you want to see balance.\n     * @param {BigNumber|string|number} id The token id to see balance.\n     * @return {Promise<BigNumber>}\n     */\n    async balanceOf(account, id) {\n        const balance = await this.methods.balanceOf(account, formatParamForUint256(id)).call()\n        return new BigNumber(balance)\n    }\n\n    /**\n     * Returns the balance of multiple account/token pairs.\n     * `balanceOfBatch` is a batch operation of {@link balanceOf}, and the length of arrays with `accounts` and `ids` must be the same.\n     *\n     * @param {Array.<string>} accounts The address of the accounts for which you want to see balance.\n     * @param {Array.<BigNumber|string|number>} ids An array of ids of token you want to see balance.\n     * @return {Promise<Array.<BigNumber>>}\n     */\n    async balanceOfBatch(accounts, ids) {\n        if (ids.length !== accounts.length) throw new Error(`ids and accounts must have the same length.`)\n\n        const formattedTokenIds = []\n        for (let i = 0; i < ids.length; i++) {\n            formattedTokenIds.push(formatParamForUint256(ids[i]))\n        }\n\n        const balances = await this.methods.balanceOfBatch(accounts, formattedTokenIds).call()\n\n        const ret = []\n        for (const bal of balances) {\n            ret.push(new BigNumber(bal))\n        }\n\n        return ret\n    }\n\n    /**\n     * Queries the approval status of an operator for a given owner. Returns true if an operator is approved by a given owner.\n     *\n     * @example\n     * const isApprovedForAll = await kip37.isApprovedForAll('0x{address in hex}', '0x{address in hex}')\n     *\n     * @param {string} owner The address of the owner.\n     * @param {string} operator The address of the operator.\n     * @return {Promise<boolean>}\n     */\n    async isApprovedForAll(owner, operator) {\n        const isApprovedForAll = await this.methods.isApprovedForAll(owner, operator).call()\n        return isApprovedForAll\n    }\n\n    /**\n     * Returns whether or not the token contract's transaction (or specific token) is paused.\n     *\n     * If `id` parameter is not defined, return whether the token contract's transaction is paused.\n     * If `id` parameter is defined, return whether the specific token is paused.\n     *\n     * @example\n     * // without token id parameter\n     * const isPaused = await kip37.paused()\n     * // with token id parameter\n     * const isPaused = await kip37.paused(0)\n     *\n     * @param {BigNumber|string|number} [id] The token id to check wether paused or not. If this parameter is omitted, the `paused` function return whether the contract is in paused state.\n     * @return {Promise<boolean>}\n     */\n    async paused(id) {\n        const callObject = id !== undefined ? this.methods.paused(formatParamForUint256(id)) : this.methods.paused()\n        const isPaused = await callObject.call()\n        return isPaused\n    }\n\n    /**\n     * Returns `true` if the given account is a pauser who can suspend transferring tokens.\n     *\n     * @example\n     * const isPauser = await kip37.isPauser('0x{address in hex}')\n     *\n     * @param {string} account The address of the account to be checked for having the right to suspend transferring tokens.\n     * @return {Promise<boolean>}\n     */\n    async isPauser(account) {\n        const isPauser = await this.methods.isPauser(account).call()\n        return isPauser\n    }\n\n    /**\n     * Returns `true` if the given account is a minter who can issue new KIP37 tokens.\n     *\n     * @example\n     * const isMinter = await kip37.isMinter('0x{address in hex}')\n     *\n     * @param {string} account The address of the account to be checked for having the minting right.\n     * @return {Promise<boolean>}\n     */\n    async isMinter(account) {\n        const isMinter = await this.methods.isMinter(account).call()\n        return isMinter\n    }\n\n    /**\n     * create creates token and assigns them to account, increasing the total supply.\n     *\n     * @example\n     * // Send via a sendParam object with the from field given\n     * const receipt = await kip37.create(2, '1000000000000000000', { from: '0x{address in hex}' })\n     *\n     * @param {BigNumber|string|number} id The token id to create.\n     * @param {BigNumber|string|number} initialSupply The amount of tokens being minted.\n     * @param {string} [uri] The token URI of the created token.\n     * @param {Contract.SendOptios} [sendParam] (optional) An object holding parameters that are required for sending a transaction.\n     * @return {Promise<object>} A receipt containing the execution result of the transaction for executing the KIP-37 token contract.\n     *                  In this receipt, instead of the logs property, there is an events property parsed by KIP-37 abi.\n     */\n    async create(id, initialSupply, uri, sendParam = {}) {\n        if (uri && _.isObject(uri)) {\n            if (uri.gas !== undefined || uri.from !== undefined) {\n                if (Object.keys(sendParam).length > 0) throw new Error(`Invalid parameters`)\n                sendParam = uri\n                uri = ''\n            }\n        }\n\n        const executableObj = this.methods.create(formatParamForUint256(id), formatParamForUint256(initialSupply), uri)\n        sendParam = await determineSendParams(executableObj, sendParam, this.options)\n\n        return executableObj.send(sendParam)\n    }\n\n    /**\n     * Approves the given operator, or disallow the given operator, to transfer all tokens of the owner.\n     * An operator is allowed to transfer all tokens of the sender on their behalf.\n     *\n     * @example\n     * const receipt = await kip37.setApprovalForAll('0x{address in hex}', true, { from: '0x{address in hex}' })\n     *\n     * @param {string} operator The address of an account to be approved/prohibited to transfer the owner's all tokens.\n     * @param {boolean} approved This operator will be approved if `true`. The operator will be disallowed if `false`.\n     * @param {Contract.SendOptios} [sendParam] (optional) An object holding parameters that are required for sending a transaction.\n     * @return {Promise<object>} A receipt containing the execution result of the transaction for executing the KIP-37 token contract.\n     *                  In this receipt, instead of the logs property, there is an events property parsed by KIP-37 abi.\n     */\n    async setApprovalForAll(operator, approved, sendParam = {}) {\n        const executableObj = this.methods.setApprovalForAll(operator, approved)\n        sendParam = await determineSendParams(executableObj, sendParam, this.options)\n\n        return executableObj.send(sendParam)\n    }\n\n    /**\n     * Safely transfers the given `amount` tokens of specific token type `id` from `from` to the `recipient`.\n     *\n     * The address who was approved to send the owner's token (the operator) or the token owner itself is expected to execute this token transferring transaction.\n     * Thus, the approved one or the token owner should be the sender of this transaction whose address must be given at `sendParam.from` or `kip37.options.from`.\n     * Without `sendParam.from` nor `kip37.options.from` being provided, an error would occur.\n     *\n     * If the `recipient` was a contract address, it should implement `IKIP37Receiver.onKIP37Received`. Otherwise, the transfer is reverted.\n     *\n     * @example\n     * const receipt = await kip37.safeTransferFrom('0x{address in hex}', '0x{address in hex}', 2, 10000, { from: '0x{address in hex}' })\n     *\n     * @param {string} from The address of the account that owns the token to be sent with allowance mechanism.\n     * @param {string} to The address of the account to receive the token.\n     * @param {BigNumber|string|number} id The token id to transfer.\n     * @param {BigNumber|string|number} amount The amount of token you want to transfer.\n     * @param {Buffer|string|number} [data] (optional) The data to send along with the call.\n     * @param {Contract.SendOptios} [sendParam] (optional) An object holding parameters that are required for sending a transaction.\n     * @return {Promise<object>} A receipt containing the execution result of the transaction for executing the KIP-37 token contract.\n     *                  In this receipt, instead of the logs property, there is an events property parsed by KIP-37 abi.\n     */\n    async safeTransferFrom(from, to, id, amount, data, sendParam = {}) {\n        if (data && _.isObject(data)) {\n            if (data.gas !== undefined || data.from !== undefined) {\n                if (Object.keys(sendParam).length > 0) throw new Error(`Invalid parameters`)\n                sendParam = data\n                data = Buffer.from('')\n            }\n        }\n\n        if (data && !_.isBuffer(data)) {\n            if (_.isString(data) && !isHexStrict(data)) data = toHex(data)\n            data = toBuffer(data)\n        }\n\n        const executableObj = this.methods.safeTransferFrom(from, to, formatParamForUint256(id), formatParamForUint256(amount), data)\n        sendParam = await determineSendParams(executableObj, sendParam, this.options)\n\n        return executableObj.send(sendParam)\n    }\n\n    /**\n     * Safely batch transfers of multiple token ids and values from `from` to the `recipient`.\n     *\n     * The address who was approved to send the owner's token (the operator) or the token owner itself is expected to execute this token transferring transaction.\n     * Thus, the approved one or the token owner should be the sender of this transaction whose address must be given at `sendParam.from` or `kip37.options.from`.\n     * Without `sendParam.from` nor `kip37.options.from` being provided, an error would occur.\n     *\n     * If the `recipient` was a contract address, it should implement `IKIP37Receiver.onKIP37Received`. Otherwise, the transfer is reverted.\n     *\n     * @example\n     * const receipt = await kip37.safeBatchTransferFrom('0x{address in hex}', '0x{address in hex}', [1, 2], [10, 1000], { from: '0x{address in hex}' })\n     *\n     * @param {string} from The address of the account that owns the token to be sent with allowance mechanism.\n     * @param {string} recipient The address of the account to receive the token.\n     * @param {Array.<BigNumber|string|number>} ids An array of the token ids to transfer.\n     * @param {Array.<BigNumber|string|number>} amounts An array of the token amounts you want to transfer.\n     * @param {Buffer|string|number} [data] (optional) The data to send along with the call.\n     * @param {Contract.SendOptios} [sendParam] (optional) An object holding parameters that are required for sending a transaction.\n     * @return {Promise<object>} A receipt containing the execution result of the transaction for executing the KIP-37 token contract.\n     *                  In this receipt, instead of the logs property, there is an events property parsed by KIP-37 abi.\n     */\n    async safeBatchTransferFrom(from, recipient, ids, amounts, data, sendParam = {}) {\n        if (data && _.isObject(data)) {\n            if (data.gas !== undefined || data.from !== undefined) {\n                if (Object.keys(sendParam).length > 0) throw new Error(`Invalid parameters`)\n                sendParam = data\n                data = Buffer.from('')\n            }\n        }\n\n        if (data && !_.isBuffer(data)) {\n            if (_.isString(data) && !isHexStrict(data)) data = toHex(data)\n            data = toBuffer(data)\n        }\n\n        if (ids.length !== amounts.length) throw new Error(`ids and amounts must have the same length.`)\n\n        const formattedTokenIds = []\n        const formattedTokenAmounts = []\n        for (let i = 0; i < ids.length; i++) {\n            formattedTokenIds.push(formatParamForUint256(ids[i]))\n            formattedTokenAmounts.push(formatParamForUint256(amounts[i]))\n        }\n\n        const executableObj = this.methods.safeBatchTransferFrom(from, recipient, formattedTokenIds, formattedTokenAmounts, data)\n\n        sendParam = await determineSendParams(executableObj, sendParam, this.options)\n\n        return executableObj.send(sendParam)\n    }\n\n    /**\n     * Mints the token of the specific token type `id` and assigns the tokens according to the variables `to` and `value`.\n     * The mint function allows you to mint specific token to multiple accounts at once by passing arrays `to` to and `value` as parameters.\n     *\n     * If `sendParam.from` or `kip37.options.from` were given, it should be a minter with MinterRole.\n     *\n     * @example\n     * const receipt = await kip37.mint('0x{address in hex}', 2, 1000, { from: '0x{address in hex}' })\n     *\n     * @param {string|Array.<string>} toList An address of the account or an array of addresses to which the minted token will be issued.\n     * @param {BigNumber|string|number} id The token id to mint.\n     * @param {BigNumber|string|number|Array.<BigNumber|string|number>} values The amount of token to be minted. If an array containing multiple addresses is delivered to `to` parameter, the value must be delivered in the form of an array.\n     * @param {Contract.SendOptios} [sendParam] (optional) An object holding parameters that are required for sending a transaction.\n     * @return {Promise<object>} A receipt containing the execution result of the transaction for executing the KIP-37 token contract.\n     *                  In this receipt, instead of the logs property, there is an events property parsed by KIP-37 abi.\n     */\n    async mint(toList, id, values, sendParam = {}) {\n        if (_.isArray(toList) !== _.isArray(values))\n            throw new Error(`If you want to minting a specific token to multiple accounts, both toList and values both must be arrays.`)\n\n        let executableObj\n        if (_.isArray(toList)) {\n            if (toList.length !== values.length) throw new Error(`toList and values must have the same length.`)\n\n            const formattedTokenValues = []\n            for (const val of values) {\n                formattedTokenValues.push(formatParamForUint256(val))\n            }\n\n            executableObj = this.methods.mint(formatParamForUint256(id), toList, formattedTokenValues)\n        } else {\n            executableObj = this.methods.mint(formatParamForUint256(id), toList, formatParamForUint256(values))\n        }\n\n        sendParam = await determineSendParams(executableObj, sendParam, this.options)\n\n        return executableObj.send(sendParam)\n    }\n\n    /**\n     * Mints the multiple KIP-37 tokens of the specific token types `ids` in a batch and assigns the tokens according to the variables `to` and `values`.\n     *\n     * If `sendParam.from` or `kip37.options.from` were given, it should be a minter with MinterRole.\n     *\n     * @example\n     * const receipt = await kip37.mintBatch('0x{address in hex}', [1, 2], [100, 200], { from: '0x{address in hex}' })\n     *\n     * @param {string} to An address of the account to which the minted tokens will be issued.\n     * @param {Array.<BigNumber|string|number>} ids An array of the token ids to mint.\n     * @param {Array.<BigNumber|string|number>} values An array of the token amounts to mint.\n     * @param {Contract.SendOptios} [sendParam] (optional) An object holding parameters that are required for sending a transaction.\n     * @return {Promise<object>} A receipt containing the execution result of the transaction for executing the KIP-37 token contract.\n     *                  In this receipt, instead of the logs property, there is an events property parsed by KIP-37 abi.\n     */\n    async mintBatch(to, ids, values, sendParam = {}) {\n        if (ids.length !== values.length) throw new Error(`ids and values must have the same length.`)\n\n        const formattedTokenIds = []\n        const formattedTokenValues = []\n        for (let i = 0; i < ids.length; i++) {\n            formattedTokenIds.push(formatParamForUint256(ids[i]))\n            formattedTokenValues.push(formatParamForUint256(values[i]))\n        }\n\n        const executableObj = this.methods.mintBatch(to, formattedTokenIds, formattedTokenValues)\n        sendParam = await determineSendParams(executableObj, sendParam, this.options)\n\n        return executableObj.send(sendParam)\n    }\n\n    /**\n     * Adds an account as a minter, who are permitted to mint tokens.\n     *\n     * If `sendParam.from` or `kip37.options.from` were given, it should be a minter with MinterRole.\n     *\n     * @example\n     * const receipt = await kip37.addMinter('0x{address in hex}', { from: '0x{address in hex}' })\n     *\n     * @param {string} account The address of the account to be added as a minter.\n     * @param {Contract.SendOptios} [sendParam] (optional) An object holding parameters that are required for sending a transaction.\n     * @return {Promise<object>} A receipt containing the execution result of the transaction for executing the KIP-37 token contract.\n     *                  In this receipt, instead of the logs property, there is an events property parsed by KIP-37 abi.\n     */\n    async addMinter(account, sendParam = {}) {\n        const executableObj = this.methods.addMinter(account)\n        sendParam = await determineSendParams(executableObj, sendParam, this.options)\n\n        return executableObj.send(sendParam)\n    }\n\n    /**\n     * Renounces the right to mint tokens. Only a minter address can renounce the minting right.\n     *\n     * If `sendParam.from` or `kip37.options.from` were given, it should be a minter with MinterRole.\n     *\n     * @example\n     * const receipt = await kip37.renounceMinter({ from: '0x{address in hex}' })\n     *\n     * @param {Contract.SendOptios} [sendParam] (optional) An object holding parameters that are required for sending a transaction.\n     * @return {Promise<object>} A receipt containing the execution result of the transaction for executing the KIP-37 token contract.\n     *                  In this receipt, instead of the logs property, there is an events property parsed by KIP-37 abi.\n     */\n    async renounceMinter(sendParam = {}) {\n        const executableObj = this.methods.renounceMinter()\n        sendParam = await determineSendParams(executableObj, sendParam, this.options)\n\n        return executableObj.send(sendParam)\n    }\n\n    /**\n     * Burns specific KIP-37 tokens.\n     *\n     * The address who was approved to operate the owner's token (the operator) or the token owner itself is expected to execute this token transferring transaction.\n     * Thus, the approved one or the token owner should be the sender of this transaction whose address must be given at `sendParam.from` or `kip37.options.from`.\n     * Without `sendParam.from` nor `kip37.options.from` being provided, an error would occur.\n     *\n     * @example\n     * const receipt = await kip37.burn('0x{address in hex}', 2, 10, { from: '0x{address in hex}' })\n     *\n     * @param {string} account The address of the account that owns the token to be destroyed.\n     * @param {BigNumber|string|number} id The id of token to be destroyed.\n     * @param {BigNumber|string|number} value The amount of token to be destroyed.\n     * @param {Contract.SendOptios} [sendParam] (optional) An object holding parameters that are required for sending a transaction.\n     * @return {Promise<object>} A receipt containing the execution result of the transaction for executing the KIP-7 token contract.\n     *                  In this receipt, instead of the logs property, there is an events property parsed by KIP-7 abi.\n     */\n    async burn(account, id, value, sendParam = {}) {\n        const executableObj = this.methods.burn(account, formatParamForUint256(id), formatParamForUint256(value))\n        sendParam = await determineSendParams(executableObj, sendParam, this.options)\n\n        return executableObj.send(sendParam)\n    }\n\n    /**\n     * Burns the multiple KIP-37 tokens.\n     *\n     * The address who was approved to operate the owner's token (the operator) or the token owner itself is expected to execute this token transferring transaction.\n     * Thus, the approved one or the token owner should be the sender of this transaction whose address must be given at `sendParam.from` or `kip37.options.from`.\n     * Without `sendParam.from` nor `kip37.options.from` being provided, an error would occur.\n     *\n     * @example\n     * const receipt = await kip37.burnBatch('0x{address in hex}', [1, 2], [100, 200], { from: '0x{address in hex}' })\n     *\n     * @param {string} account The address of the account that owns the token to be destroyed.\n     * @param {Array.<BigNumber|string|number>} ids An array of the token ids to burn.\n     * @param {Array.<BigNumber|string|number>} values An array of the token amounts to burn.\n     * @param {Contract.SendOptios} [sendParam] (optional) An object holding parameters that are required for sending a transaction.\n     * @return {Promise<object>} A receipt containing the execution result of the transaction for executing the KIP-37 token contract.\n     *                  In this receipt, instead of the logs property, there is an events property parsed by KIP-37 abi.\n     */\n    async burnBatch(account, ids, values, sendParam = {}) {\n        if (ids.length !== values.length) throw new Error(`ids and values must have the same length.`)\n\n        const formattedTokenIds = []\n        const formattedTokenValues = []\n        for (let i = 0; i < ids.length; i++) {\n            formattedTokenIds.push(formatParamForUint256(ids[i]))\n            formattedTokenValues.push(formatParamForUint256(values[i]))\n        }\n\n        const executableObj = this.methods.burnBatch(account, formattedTokenIds, formattedTokenValues)\n        sendParam = await determineSendParams(executableObj, sendParam, this.options)\n\n        return executableObj.send(sendParam)\n    }\n\n    /**\n     * Suspends functions related to token operation.\n     * If `id` parameter is defined, pause the specific token. Otherwise pause the token contract.\n     *\n     * If `sendParam.from` or `kip37.options.from` were given, it should be a pauser with PauserRole.\n     *\n     * @example\n     * const receipt = await kip37.pause({ from: '0x{address in hex}' })\n     *\n     * @param {BigNumber|string|number} [id] The token id to pause. If this parameter is omitted, the `pause` function pause the token contract.\n     * @param {Contract.SendOptios} [sendParam] (optional) An object holding parameters that are required for sending a transaction.\n     * @return {Promise<object>} A receipt containing the execution result of the transaction for executing the KIP-37 token contract.\n     *                  In this receipt, instead of the logs property, there is an events property parsed by KIP-37 abi.\n     */\n    async pause(id, sendParam = {}) {\n        if (Object.keys(sendParam).length === 0 && _.isObject(id)) {\n            sendParam = id\n            id = undefined\n        }\n\n        const executableObj = id !== undefined ? this.methods.pause(formatParamForUint256(id)) : this.methods.pause()\n        sendParam = await determineSendParams(executableObj, sendParam, this.options)\n\n        return executableObj.send(sendParam)\n    }\n\n    /**\n     * Resumes the paused contract or specific token.\n     * If `id` parameter is defined, unpause the specific token. Otherwise unpause the token contract.\n     *\n     * If `sendParam.from` or `kip37.options.from` were given, it should be a pauser with PauserRole.\n     *\n     * @example\n     * const receipt = await kip37.unpause({ from: '0x{address in hex}' })\n     *\n     * @param {BigNumber|string|number} [id] The token id to unpause. If this parameter is omitted, the `unpause` function unpause the token contract.\n     * @param {Contract.SendOptios} [sendParam] (optional) An object holding parameters that are required for sending a transaction.\n     * @return {Promise<object>} A receipt containing the execution result of the transaction for executing the KIP-37 token contract.\n     *                  In this receipt, instead of the logs property, there is an events property parsed by KIP-37 abi.\n     */\n    async unpause(id, sendParam = {}) {\n        if (Object.keys(sendParam).length === 0 && _.isObject(id)) {\n            sendParam = id\n            id = undefined\n        }\n\n        const executableObj = id !== undefined ? this.methods.unpause(formatParamForUint256(id)) : this.methods.unpause()\n        sendParam = await determineSendParams(executableObj, sendParam, this.options)\n\n        return executableObj.send(sendParam)\n    }\n\n    /**\n     * Adds an account as a pauser that has the right to suspend the contract.\n     *\n     * If `sendParam.from` or `kip37.options.from` were given, it should be a pauser with PauserRole.\n     *\n     * @example\n     * const receipt = await kip37.addPauser('0x{address in hex}', { from: '0x{address in hex}' })\n     *\n     * @param {string} account The address of the account to be a new pauser.\n     * @param {Contract.SendOptios} [sendParam] (optional) An object holding parameters that are required for sending a transaction.\n     * @return {Promise<object>} A receipt containing the execution result of the transaction for executing the KIP-37 token contract.\n     *                  In this receipt, instead of the logs property, there is an events property parsed by KIP-37 abi.\n     */\n    async addPauser(account, sendParam = {}) {\n        const executableObj = this.methods.addPauser(account)\n        sendParam = await determineSendParams(executableObj, sendParam, this.options)\n\n        return executableObj.send(sendParam)\n    }\n\n    /**\n     * Renounces the right to pause the contract. Only a pauser address can renounce the pausing right.\n     *\n     * If `sendParam.from` or `kip37.options.from` were given, it should be a pauser with PauserRole.\n     *\n     * @example\n     * const receipt = await kip37.renouncePauser({ from: '0x{address in hex}' })\n     *\n     * @param {Contract.SendOptios} [sendParam] (optional) An object holding parameters that are required for sending a transaction.\n     * @return {Promise<object>} A receipt containing the execution result of the transaction for executing the KIP-37 token contract.\n     *                  In this receipt, instead of the logs property, there is an events property parsed by KIP-37 abi.\n     */\n    async renouncePauser(sendParam = {}) {\n        const executableObj = this.methods.renouncePauser()\n        sendParam = await determineSendParams(executableObj, sendParam, this.options)\n\n        return executableObj.send(sendParam)\n    }\n}\n\n/**\n * The byte code of the KIP-37 token contract.\n *\n * @example\n * caver.kct.kip37.byteCode\n *\n * @static\n * @type {string}\n */\nKIP37.byteCode = kip37ByteCode\n\n/**\n * The abi of the KIP-37 token contract.\n *\n * @example\n * caver.kct.kip37.abi\n *\n * @static\n * @type {Array.<object>}\n */\nKIP37.abi = kip37JsonInterface\n\nmodule.exports = KIP37\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}