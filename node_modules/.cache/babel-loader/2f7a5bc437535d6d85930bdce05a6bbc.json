{"ast":null,"code":"/* eslint-disable class-methods-use-this */\n\n/*\n    Copyright 2020 The caver-js Authors\n    This file is part of the caver-js library.\n\n    The caver-js library is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Lesser General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    The caver-js library is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n    GNU Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public License\n    along with the caver-js. If not, see <http://www.gnu.org/licenses/>.\n*/\nconst lodash = require('lodash');\n\nconst fs = require('fs');\n\nconst ipfsClient = require('ipfs-http-client');\n\nconst multihash = require('multihashes');\n/**\n * Representing a class for uploading and loading files to IPFS.\n * @hideconstructor\n * @class\n */\n\n\nclass IPFS {\n  /**\n   * Create an IPFS instance.\n   * @param {string} [host] The IPFS Node url to connect with.\n   * @param {number} [port] The port number to use.\n   * @param {boolean} [ssl] With or without SSL. If true, the https protocol is used. Otherwise, the http protocol is used.\n   */\n  constructor(host, port, ssl) {\n    if (host !== undefined && port !== undefined && ssl !== undefined) {\n      this.setIPFSNode(host, port, ssl);\n    }\n  }\n  /**\n   * Initializes a connection with an IPFS Node.\n   * When an IPFS Node information is set through this function, you can upload files to IPFS or load files from IPFS.\n   *\n   * @example\n   * caver.ipfs.setIPFSNode('localhost', 5001, false)\n   *\n   * @param {string} host The IPFS Node url to connect with.\n   * @param {number} port The port number to use.\n   * @param {boolean} ssl With or without SSL. If true, the https protocol is used. Otherwise, the http protocol is used.\n   * @return {void}\n   */\n\n\n  setIPFSNode(host, port, ssl) {\n    const protocol = ssl ? 'https' : 'http';\n    this.ipfs = ipfsClient({\n      host,\n      port,\n      protocol\n    });\n  }\n  /**\n   * Adds a file to IPFS. The {@link https://docs.ipfs.io/concepts/content-addressing/#content-addressing-and-cids|CID(Content Identifier)} of the uploaded file is returned.\n   * If the path of a file is passed, the contents of the file are loaded from the path and uploaded to IPFS. If a buffer is passed, it is uploaded to IPFS directly.\n   *\n   * If the `data` parameter is a `Buffer` or `ArrayBuffer`, upload to IPFS directly without using `fs`.\n   * If the `data` parameter is a string, use `fs` to read the file.\n   * Since `fs` is a module that can only be used on the server side, if it is client-side code,\n   * it must read the file in advance and pass the file contents in the format of `ArrayBuffer`.\n   *\n   * If you get a \"Error: Can't resolve 'fs'\" error when building your client code, add the following to your \"webpack.config.json\" file.\n   * ```\n   * module.exports = {\n   *     ...\n   *     node: {\n   *         fs: 'empty',\n   *     },\n   *     ...\n   * }\n   * ```\n   *\n   * If you use Next.js web framework(https://nextjs.org/), add the following to your \"next.config.json\" file.\n   * ```\n   * module.exports = {\n   *     ...\n   *     webpack: (config, { isServer }) => {\n   *         // Fixes npm packages that depend on `fs` module\n   *         if (!isServer) {\n   *             config.node = {\n   *                 fs: 'empty'\n   *             }\n   *         }\n   *         return config\n   *     },\n   *     ...\n   * }\n   * ```\n   *\n   * @example\n   * const cid = await caver.ipfs.add('./test.txt')\n   * const cid = await caver.ipfs.add(Buffer.from('test data'))\n   *\n   * @param {string|Buffer|ArrayBuffer} data The file path string or file contents.\n   * @return {Promise<string>}\n   */\n\n\n  async add(data) {\n    if (!this.ipfs) throw new Error(`Please set IPFS Node through 'caver.ipfs.setIPFSNode'.`); // Read file\n\n    if (lodash.isString(data)) {\n      if (typeof window !== 'undefined') throw new Error(`Cannot use fs module: Please pass the file contents as a parameter of type Buffer or ArrayBuffer.`);\n      data = fs.readFileSync(data);\n    }\n\n    if (!lodash.isBuffer(data) && !lodash.isArrayBuffer(data)) throw new Error(`Invalid data: ${data}`);\n    const ret = await this.ipfs.add(Buffer.from(data));\n    return ret.path;\n  }\n  /**\n   * Returns a file addressed by a valid IPFS path.\n   *\n   * @example\n   * const fileContents = await caver.ipfs.get('Qmd9thymMS6mejhEDZfwXPowSDunzgma9ex4ezpCSRZGwC')\n   *\n   * @param {string} hash An {@link https://docs.ipfs.io/concepts/content-addressing/#content-addressing-and-cids|CID(Content Identifier)} of the file to download.\n   * @return {Promise<Buffer>}\n   */\n\n\n  async get(hash) {\n    if (!this.ipfs) throw new Error(`Please set IPFS Node through 'caver.ipfs.setIPFSNode'.`);\n    const ret = await this.ipfs.cat(hash);\n    return (await ret.next(0)).value;\n  }\n  /**\n   * Converts a {@link https://docs.ipfs.io/concepts/content-addressing/#content-addressing-and-cids|CID(Content Identifier)} to a {@link https://multiformats.io/multihash/|Multihash}.\n   *\n   * @example\n   * // This will return '0x1220dc1dbe0bcf1e5f6cce80bd3d7e7d873801c5a1732add889c0f25391d53470dc3'\n   * const multihash = caver.ipfs.toHex('Qmd9thymMS6mejhEDZfwXPowSDunzgma9ex4ezpCSRZGwC')\n   *\n   * @param {string} hash A {@link https://docs.ipfs.io/concepts/content-addressing/#content-addressing-and-cids|CID(Content Identifier)} to convert.\n   * @return {string}\n   */\n\n\n  toHex(hash) {\n    const buf = multihash.fromB58String(hash);\n    return `0x${multihash.toHexString(buf)}`;\n  }\n  /**\n   * Converts to {@link https://docs.ipfs.io/concepts/content-addressing/#content-addressing-and-cids|CID(Content Identifier)} from a {@link https://multiformats.io/multihash/|Multihash}.\n   *\n   * @example\n   * // This will return 'Qmd9thymMS6mejhEDZfwXPowSDunzgma9ex4ezpCSRZGwC'\n   * const multihash = caver.ipfs.fromHex('0x1220dc1dbe0bcf1e5f6cce80bd3d7e7d873801c5a1732add889c0f25391d53470dc3')\n   *\n   * @param {string} hash A {@link https://multiformats.io/multihash/|Multihash} to convert.\n   * @return {string}\n   */\n\n\n  fromHex(contentHash) {\n    const hex = contentHash.substring(2);\n    const buf = multihash.fromHexString(hex);\n    return multihash.toB58String(buf);\n  }\n\n}\n\nmodule.exports = IPFS;","map":{"version":3,"names":["lodash","require","fs","ipfsClient","multihash","IPFS","constructor","host","port","ssl","undefined","setIPFSNode","protocol","ipfs","add","data","Error","isString","window","readFileSync","isBuffer","isArrayBuffer","ret","Buffer","from","path","get","hash","cat","next","value","toHex","buf","fromB58String","toHexString","fromHex","contentHash","hex","substring","fromHexString","toB58String","module","exports"],"sources":["C:/Users/acer/node_modules/caver-js/packages/caver-ipfs/src/index.js"],"sourcesContent":["/* eslint-disable class-methods-use-this */\n/*\n    Copyright 2020 The caver-js Authors\n    This file is part of the caver-js library.\n\n    The caver-js library is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Lesser General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    The caver-js library is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n    GNU Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public License\n    along with the caver-js. If not, see <http://www.gnu.org/licenses/>.\n*/\n\nconst lodash = require('lodash')\nconst fs = require('fs')\nconst ipfsClient = require('ipfs-http-client')\nconst multihash = require('multihashes')\n\n/**\n * Representing a class for uploading and loading files to IPFS.\n * @hideconstructor\n * @class\n */\nclass IPFS {\n    /**\n     * Create an IPFS instance.\n     * @param {string} [host] The IPFS Node url to connect with.\n     * @param {number} [port] The port number to use.\n     * @param {boolean} [ssl] With or without SSL. If true, the https protocol is used. Otherwise, the http protocol is used.\n     */\n    constructor(host, port, ssl) {\n        if (host !== undefined && port !== undefined && ssl !== undefined) {\n            this.setIPFSNode(host, port, ssl)\n        }\n    }\n\n    /**\n     * Initializes a connection with an IPFS Node.\n     * When an IPFS Node information is set through this function, you can upload files to IPFS or load files from IPFS.\n     *\n     * @example\n     * caver.ipfs.setIPFSNode('localhost', 5001, false)\n     *\n     * @param {string} host The IPFS Node url to connect with.\n     * @param {number} port The port number to use.\n     * @param {boolean} ssl With or without SSL. If true, the https protocol is used. Otherwise, the http protocol is used.\n     * @return {void}\n     */\n    setIPFSNode(host, port, ssl) {\n        const protocol = ssl ? 'https' : 'http'\n        this.ipfs = ipfsClient({ host, port, protocol })\n    }\n\n    /**\n     * Adds a file to IPFS. The {@link https://docs.ipfs.io/concepts/content-addressing/#content-addressing-and-cids|CID(Content Identifier)} of the uploaded file is returned.\n     * If the path of a file is passed, the contents of the file are loaded from the path and uploaded to IPFS. If a buffer is passed, it is uploaded to IPFS directly.\n     *\n     * If the `data` parameter is a `Buffer` or `ArrayBuffer`, upload to IPFS directly without using `fs`.\n     * If the `data` parameter is a string, use `fs` to read the file.\n     * Since `fs` is a module that can only be used on the server side, if it is client-side code,\n     * it must read the file in advance and pass the file contents in the format of `ArrayBuffer`.\n     *\n     * If you get a \"Error: Can't resolve 'fs'\" error when building your client code, add the following to your \"webpack.config.json\" file.\n     * ```\n     * module.exports = {\n     *     ...\n     *     node: {\n     *         fs: 'empty',\n     *     },\n     *     ...\n     * }\n     * ```\n     *\n     * If you use Next.js web framework(https://nextjs.org/), add the following to your \"next.config.json\" file.\n     * ```\n     * module.exports = {\n     *     ...\n     *     webpack: (config, { isServer }) => {\n     *         // Fixes npm packages that depend on `fs` module\n     *         if (!isServer) {\n     *             config.node = {\n     *                 fs: 'empty'\n     *             }\n     *         }\n     *         return config\n     *     },\n     *     ...\n     * }\n     * ```\n     *\n     * @example\n     * const cid = await caver.ipfs.add('./test.txt')\n     * const cid = await caver.ipfs.add(Buffer.from('test data'))\n     *\n     * @param {string|Buffer|ArrayBuffer} data The file path string or file contents.\n     * @return {Promise<string>}\n     */\n    async add(data) {\n        if (!this.ipfs) throw new Error(`Please set IPFS Node through 'caver.ipfs.setIPFSNode'.`)\n\n        // Read file\n        if (lodash.isString(data)) {\n            if (typeof window !== 'undefined')\n                throw new Error(`Cannot use fs module: Please pass the file contents as a parameter of type Buffer or ArrayBuffer.`)\n            data = fs.readFileSync(data)\n        }\n        if (!lodash.isBuffer(data) && !lodash.isArrayBuffer(data)) throw new Error(`Invalid data: ${data}`)\n\n        const ret = await this.ipfs.add(Buffer.from(data))\n        return ret.path\n    }\n\n    /**\n     * Returns a file addressed by a valid IPFS path.\n     *\n     * @example\n     * const fileContents = await caver.ipfs.get('Qmd9thymMS6mejhEDZfwXPowSDunzgma9ex4ezpCSRZGwC')\n     *\n     * @param {string} hash An {@link https://docs.ipfs.io/concepts/content-addressing/#content-addressing-and-cids|CID(Content Identifier)} of the file to download.\n     * @return {Promise<Buffer>}\n     */\n    async get(hash) {\n        if (!this.ipfs) throw new Error(`Please set IPFS Node through 'caver.ipfs.setIPFSNode'.`)\n\n        const ret = await this.ipfs.cat(hash)\n\n        return (await ret.next(0)).value\n    }\n\n    /**\n     * Converts a {@link https://docs.ipfs.io/concepts/content-addressing/#content-addressing-and-cids|CID(Content Identifier)} to a {@link https://multiformats.io/multihash/|Multihash}.\n     *\n     * @example\n     * // This will return '0x1220dc1dbe0bcf1e5f6cce80bd3d7e7d873801c5a1732add889c0f25391d53470dc3'\n     * const multihash = caver.ipfs.toHex('Qmd9thymMS6mejhEDZfwXPowSDunzgma9ex4ezpCSRZGwC')\n     *\n     * @param {string} hash A {@link https://docs.ipfs.io/concepts/content-addressing/#content-addressing-and-cids|CID(Content Identifier)} to convert.\n     * @return {string}\n     */\n    toHex(hash) {\n        const buf = multihash.fromB58String(hash)\n        return `0x${multihash.toHexString(buf)}`\n    }\n\n    /**\n     * Converts to {@link https://docs.ipfs.io/concepts/content-addressing/#content-addressing-and-cids|CID(Content Identifier)} from a {@link https://multiformats.io/multihash/|Multihash}.\n     *\n     * @example\n     * // This will return 'Qmd9thymMS6mejhEDZfwXPowSDunzgma9ex4ezpCSRZGwC'\n     * const multihash = caver.ipfs.fromHex('0x1220dc1dbe0bcf1e5f6cce80bd3d7e7d873801c5a1732add889c0f25391d53470dc3')\n     *\n     * @param {string} hash A {@link https://multiformats.io/multihash/|Multihash} to convert.\n     * @return {string}\n     */\n    fromHex(contentHash) {\n        const hex = contentHash.substring(2)\n        const buf = multihash.fromHexString(hex)\n        return multihash.toB58String(buf)\n    }\n}\n\nmodule.exports = IPFS\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}