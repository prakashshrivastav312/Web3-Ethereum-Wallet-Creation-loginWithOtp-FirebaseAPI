{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.SHAMap = exports.Leaf = exports.InnerNode = exports.Node = exports.NodeType = void 0;\n\nconst hash_prefix_1 = __importDefault(require(\"./hash-prefix\"));\n\nconst sha512Half_1 = __importDefault(require(\"./sha512Half\"));\n\nconst HEX_ZERO = '0000000000000000000000000000000000000000000000000000000000000000';\nvar NodeType;\n\n(function (NodeType) {\n  NodeType[NodeType[\"INNER\"] = 1] = \"INNER\";\n  NodeType[NodeType[\"TRANSACTION_NO_METADATA\"] = 2] = \"TRANSACTION_NO_METADATA\";\n  NodeType[NodeType[\"TRANSACTION_METADATA\"] = 3] = \"TRANSACTION_METADATA\";\n  NodeType[NodeType[\"ACCOUNT_STATE\"] = 4] = \"ACCOUNT_STATE\";\n})(NodeType = exports.NodeType || (exports.NodeType = {}));\n\nclass Node {\n  constructor() {}\n\n  addItem(_tag, _node) {\n    throw new Error('Called unimplemented virtual method SHAMapTreeNode#addItem.');\n  }\n\n  get hash() {\n    throw new Error('Called unimplemented virtual method SHAMapTreeNode#hash.');\n  }\n\n}\n\nexports.Node = Node;\n\nclass InnerNode extends Node {\n  constructor() {\n    let depth = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    super();\n    this.leaves = {};\n    this.type = NodeType.INNER;\n    this.depth = depth;\n    this.empty = true;\n  }\n\n  addItem(tag, node) {\n    const existingNode = this.getNode(parseInt(tag[this.depth], 16));\n\n    if (existingNode) {\n      if (existingNode instanceof InnerNode) {\n        existingNode.addItem(tag, node);\n      } else if (existingNode instanceof Leaf) {\n        if (existingNode.tag === tag) {\n          throw new Error('Tried to add a node to a SHAMap that was already in there.');\n        } else {\n          const newInnerNode = new InnerNode(this.depth + 1);\n          newInnerNode.addItem(existingNode.tag, existingNode);\n          newInnerNode.addItem(tag, node);\n          this.setNode(parseInt(tag[this.depth], 16), newInnerNode);\n        }\n      }\n    } else {\n      this.setNode(parseInt(tag[this.depth], 16), node);\n    }\n  }\n\n  setNode(slot, node) {\n    if (slot < 0 || slot > 15) {\n      throw new Error('Invalid slot: slot must be between 0-15.');\n    }\n\n    this.leaves[slot] = node;\n    this.empty = false;\n  }\n\n  getNode(slot) {\n    if (slot < 0 || slot > 15) {\n      throw new Error('Invalid slot: slot must be between 0-15.');\n    }\n\n    return this.leaves[slot];\n  }\n\n  get hash() {\n    if (this.empty) return HEX_ZERO;\n    let hex = '';\n\n    for (let i = 0; i < 16; i++) {\n      hex += this.leaves[i] ? this.leaves[i].hash : HEX_ZERO;\n    }\n\n    const prefix = hash_prefix_1.default.INNER_NODE.toString(16);\n    return sha512Half_1.default(prefix + hex);\n  }\n\n}\n\nexports.InnerNode = InnerNode;\n\nclass Leaf extends Node {\n  constructor(tag, data, type) {\n    super();\n    this.tag = tag;\n    this.type = type;\n    this.data = data;\n  }\n\n  get hash() {\n    switch (this.type) {\n      case NodeType.ACCOUNT_STATE:\n        {\n          const leafPrefix = hash_prefix_1.default.LEAF_NODE.toString(16);\n          return sha512Half_1.default(leafPrefix + this.data + this.tag);\n        }\n\n      case NodeType.TRANSACTION_NO_METADATA:\n        {\n          const txIDPrefix = hash_prefix_1.default.TRANSACTION_ID.toString(16);\n          return sha512Half_1.default(txIDPrefix + this.data);\n        }\n\n      case NodeType.TRANSACTION_METADATA:\n        {\n          const txNodePrefix = hash_prefix_1.default.TRANSACTION_NODE.toString(16);\n          return sha512Half_1.default(txNodePrefix + this.data + this.tag);\n        }\n\n      default:\n        throw new Error('Tried to hash a SHAMap node of unknown type.');\n    }\n  }\n\n}\n\nexports.Leaf = Leaf;\n\nclass SHAMap {\n  constructor() {\n    this.root = new InnerNode(0);\n  }\n\n  addItem(tag, data, type) {\n    this.root.addItem(tag, new Leaf(tag, data, type));\n  }\n\n  get hash() {\n    return this.root.hash;\n  }\n\n}\n\nexports.SHAMap = SHAMap;","map":{"version":3,"mappings":";;;;;;;;;;;;;AAAA;;AACA;;AACA,MAAMA,QAAQ,GACZ,kEADF;AAGA,IAAYC,QAAZ;;AAAA,WAAYA,QAAZ,EAAoB;EAClBA;EACAA;EACAA;EACAA;AACD,CALD,EAAYA,QAAQ,GAARC,wCAAQ,EAAR,CAAZ;;AAOA,MAAsBC,IAAtB,CAA0B;EAMxBC,eAAuB;;EAEhBC,OAAO,CAACC,IAAD,EAAeC,KAAf,EAA0B;IACtC,MAAM,IAAIC,KAAJ,CACJ,6DADI,CAAN;EAGD;;EACc,IAAJC,IAAI;IACb,MAAM,IAAID,KAAJ,CAAU,0DAAV,CAAN;EACD;;AAfuB;;AAA1BN;;AAkBA,MAAaQ,SAAb,SAA+BP,IAA/B,CAAmC;EAWjCC,cAAoC;IAAA,IAAjBO,KAAiB,uEAAD,CAAC;IAClC;IACA,KAAKC,MAAL,GAAc,EAAd;IACA,KAAKC,IAAL,GAAYZ,QAAQ,CAACa,KAArB;IACA,KAAKH,KAAL,GAAaA,KAAb;IACA,KAAKI,KAAL,GAAa,IAAb;EACD;;EAQMV,OAAO,CAACW,GAAD,EAAcC,IAAd,EAAwB;IACpC,MAAMC,YAAY,GAAG,KAAKC,OAAL,CAAaC,QAAQ,CAACJ,GAAG,CAAC,KAAKL,KAAN,CAAJ,EAAkB,EAAlB,CAArB,CAArB;;IACA,IAAIO,YAAJ,EAAkB;MAEhB,IAAIA,YAAY,YAAYR,SAA5B,EAAuC;QAErCQ,YAAY,CAACb,OAAb,CAAqBW,GAArB,EAA0BC,IAA1B;MACD,CAHD,MAGO,IAAIC,YAAY,YAAYG,IAA5B,EAAkC;QACvC,IAAIH,YAAY,CAACF,GAAb,KAAqBA,GAAzB,EAA8B;UAE5B,MAAM,IAAIR,KAAJ,CACJ,4DADI,CAAN;QAGD,CALD,MAKO;UAEL,MAAMc,YAAY,GAAG,IAAIZ,SAAJ,CAAc,KAAKC,KAAL,GAAa,CAA3B,CAArB;UAGAW,YAAY,CAACjB,OAAb,CAAqBa,YAAY,CAACF,GAAlC,EAAuCE,YAAvC;UACAI,YAAY,CAACjB,OAAb,CAAqBW,GAArB,EAA0BC,IAA1B;UAGA,KAAKM,OAAL,CAAaH,QAAQ,CAACJ,GAAG,CAAC,KAAKL,KAAN,CAAJ,EAAkB,EAAlB,CAArB,EAA4CW,YAA5C;QACD;MACF;IACF,CAvBD,MAuBO;MAEL,KAAKC,OAAL,CAAaH,QAAQ,CAACJ,GAAG,CAAC,KAAKL,KAAN,CAAJ,EAAkB,EAAlB,CAArB,EAA4CM,IAA5C;IACD;EACF;;EAQMM,OAAO,CAACC,IAAD,EAAeP,IAAf,EAAyB;IACrC,IAAIO,IAAI,GAAG,CAAP,IAAYA,IAAI,GAAG,EAAvB,EAA2B;MACzB,MAAM,IAAIhB,KAAJ,CAAU,0CAAV,CAAN;IACD;;IACD,KAAKI,MAAL,CAAYY,IAAZ,IAAoBP,IAApB;IACA,KAAKF,KAAL,GAAa,KAAb;EACD;;EAOMI,OAAO,CAACK,IAAD,EAAa;IACzB,IAAIA,IAAI,GAAG,CAAP,IAAYA,IAAI,GAAG,EAAvB,EAA2B;MACzB,MAAM,IAAIhB,KAAJ,CAAU,0CAAV,CAAN;IACD;;IACD,OAAO,KAAKI,MAAL,CAAYY,IAAZ,CAAP;EACD;;EAEc,IAAJf,IAAI;IACb,IAAI,KAAKM,KAAT,EAAgB,OAAOf,QAAP;IAChB,IAAIyB,GAAG,GAAG,EAAV;;IACA,KAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG,EAApB,EAAwBA,CAAC,EAAzB,EAA6B;MAC3BD,GAAG,IAAI,KAAKb,MAAL,CAAYc,CAAZ,IAAiB,KAAKd,MAAL,CAAYc,CAAZ,EAAejB,IAAhC,GAAuCT,QAA9C;IACD;;IACD,MAAM2B,MAAM,GAAGC,sBAAWC,UAAX,CAAsBC,QAAtB,CAA+B,EAA/B,CAAf;IACA,OAAOC,qBAAWJ,MAAM,GAAGF,GAApB,CAAP;EACD;;AA1FgC;;AAAnCvB;;AA6FA,MAAamB,IAAb,SAA0BlB,IAA1B,CAA8B;EAY5BC,YAAmBY,GAAnB,EAAgCgB,IAAhC,EAA8CnB,IAA9C,EAA4D;IAC1D;IACA,KAAKG,GAAL,GAAWA,GAAX;IACA,KAAKH,IAAL,GAAYA,IAAZ;IACA,KAAKmB,IAAL,GAAYA,IAAZ;EACD;;EAEc,IAAJvB,IAAI;IACb,QAAQ,KAAKI,IAAb;MACE,KAAKZ,QAAQ,CAACgC,aAAd;QAA6B;UAC3B,MAAMC,UAAU,GAAGN,sBAAWO,SAAX,CAAqBL,QAArB,CAA8B,EAA9B,CAAnB;UACA,OAAOC,qBAAWG,UAAU,GAAG,KAAKF,IAAlB,GAAyB,KAAKhB,GAAzC,CAAP;QACD;;MACD,KAAKf,QAAQ,CAACmC,uBAAd;QAAuC;UACrC,MAAMC,UAAU,GAAGT,sBAAWU,cAAX,CAA0BR,QAA1B,CAAmC,EAAnC,CAAnB;UACA,OAAOC,qBAAWM,UAAU,GAAG,KAAKL,IAA7B,CAAP;QACD;;MACD,KAAK/B,QAAQ,CAACsC,oBAAd;QAAoC;UAClC,MAAMC,YAAY,GAAGZ,sBAAWa,gBAAX,CAA4BX,QAA5B,CAAqC,EAArC,CAArB;UACA,OAAOC,qBAAWS,YAAY,GAAG,KAAKR,IAApB,GAA2B,KAAKhB,GAA3C,CAAP;QACD;;MACD;QACE,MAAM,IAAIR,KAAJ,CAAU,8CAAV,CAAN;IAdJ;EAgBD;;AApC2B;;AAA9BN;;AAuCA,MAAawC,MAAb,CAAmB;EAOjBtC;IACE,KAAKuC,IAAL,GAAY,IAAIjC,SAAJ,CAAc,CAAd,CAAZ;EACD;;EAEML,OAAO,CAACW,GAAD,EAAcgB,IAAd,EAA4BnB,IAA5B,EAA0C;IACtD,KAAK8B,IAAL,CAAUtC,OAAV,CAAkBW,GAAlB,EAAuB,IAAIK,IAAJ,CAASL,GAAT,EAAcgB,IAAd,EAAoBnB,IAApB,CAAvB;EACD;;EAEc,IAAJJ,IAAI;IACb,OAAO,KAAKkC,IAAL,CAAUlC,IAAjB;EACD;;AAjBgB;;AAAnBP","names":["HEX_ZERO","NodeType","exports","Node","constructor","addItem","_tag","_node","Error","hash","InnerNode","depth","leaves","type","INNER","empty","tag","node","existingNode","getNode","parseInt","Leaf","newInnerNode","setNode","slot","hex","i","prefix","hash_prefix_1","INNER_NODE","toString","sha512Half_1","data","ACCOUNT_STATE","leafPrefix","LEAF_NODE","TRANSACTION_NO_METADATA","txIDPrefix","TRANSACTION_ID","TRANSACTION_METADATA","txNodePrefix","TRANSACTION_NODE","SHAMap","root"],"sourceRoot":"","sources":["../../../../src/common/hashes/shamap.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}