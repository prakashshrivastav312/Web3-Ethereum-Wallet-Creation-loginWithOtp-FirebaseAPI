{"ast":null,"code":"'use strict';\n\nvar _ = require('lodash');\n\nvar $ = require('../../util/preconditions');\n\nconst errors = require('../../errors');\n\nvar BufferWriter = require('../../encoding/bufferwriter');\n\nvar buffer = require('buffer');\n\nvar BufferUtil = require('../../util/buffer');\n\nvar JSUtil = require('../../util/js');\n\nvar Script = require('../../script');\n\nvar Sighash = require('../sighash');\n\nvar Output = require('../output');\n\nvar MAXINT = 0xffffffff; // Math.pow(2, 32) - 1;\n\nvar DEFAULT_SEQNUMBER = MAXINT;\nvar DEFAULT_LOCKTIME_SEQNUMBER = MAXINT - 1;\nvar DEFAULT_RBF_SEQNUMBER = MAXINT - 2;\nconst SEQUENCE_LOCKTIME_DISABLE_FLAG = Math.pow(2, 31); // (1 << 31);\n\nconst SEQUENCE_LOCKTIME_TYPE_FLAG = Math.pow(2, 22); // (1 << 22);\n\nconst SEQUENCE_LOCKTIME_MASK = 0xffff;\nconst SEQUENCE_LOCKTIME_GRANULARITY = 512; // 512 seconds\n\nconst SEQUENCE_BLOCKDIFF_LIMIT = Math.pow(2, 16) - 1; // 16 bits \n\nfunction Input(params) {\n  if (!(this instanceof Input)) {\n    return new Input(params);\n  }\n\n  if (params) {\n    return this._fromObject(params);\n  }\n}\n\nInput.MAXINT = MAXINT;\nInput.DEFAULT_SEQNUMBER = DEFAULT_SEQNUMBER;\nInput.DEFAULT_LOCKTIME_SEQNUMBER = DEFAULT_LOCKTIME_SEQNUMBER;\nInput.DEFAULT_RBF_SEQNUMBER = DEFAULT_RBF_SEQNUMBER;\nInput.SEQUENCE_LOCKTIME_TYPE_FLAG = SEQUENCE_LOCKTIME_TYPE_FLAG;\nObject.defineProperty(Input.prototype, 'script', {\n  configurable: false,\n  enumerable: true,\n  get: function () {\n    if (this.isNull()) {\n      return null;\n    }\n\n    if (!this._script) {\n      this._script = new Script(this._scriptBuffer);\n      this._script._isInput = true;\n    }\n\n    return this._script;\n  }\n});\n\nInput.fromObject = function (obj) {\n  $.checkArgument(_.isObject(obj));\n  var input = new Input();\n  return input._fromObject(obj);\n};\n\nInput.prototype._fromObject = function (params) {\n  var prevTxId;\n\n  if (_.isString(params.prevTxId) && JSUtil.isHexa(params.prevTxId)) {\n    prevTxId = Buffer.from(params.prevTxId, 'hex');\n  } else {\n    prevTxId = params.prevTxId;\n  }\n\n  this.witnesses = [];\n  this.output = params.output ? params.output instanceof Output ? params.output : new Output(params.output) : undefined;\n  this.prevTxId = prevTxId || params.txidbuf;\n  this.outputIndex = _.isUndefined(params.outputIndex) ? params.txoutnum : params.outputIndex;\n  this.sequenceNumber = _.isUndefined(params.sequenceNumber) ? _.isUndefined(params.seqnum) ? DEFAULT_SEQNUMBER : params.seqnum : params.sequenceNumber;\n\n  if (_.isUndefined(params.script) && _.isUndefined(params.scriptBuffer)) {\n    throw new errors.Transaction.Input.MissingScript();\n  }\n\n  this.setScript(params.scriptBuffer || params.script);\n  return this;\n};\n\nInput.prototype.toObject = Input.prototype.toJSON = function toObject() {\n  var obj = {\n    prevTxId: this.prevTxId.toString('hex'),\n    outputIndex: this.outputIndex,\n    sequenceNumber: this.sequenceNumber,\n    script: this._scriptBuffer.toString('hex')\n  }; // add human readable form if input contains valid script\n\n  if (this.script) {\n    obj.scriptString = this.script.toString();\n  }\n\n  if (this.output) {\n    obj.output = this.output.toObject();\n  }\n\n  return obj;\n};\n\nInput.fromBufferReader = function (br) {\n  var input = new Input();\n  input.prevTxId = br.readReverse(32);\n  input.outputIndex = br.readUInt32LE();\n  input._scriptBuffer = br.readVarLengthBuffer();\n  input.sequenceNumber = br.readUInt32LE(); // TODO: return different classes according to which input it is\n  // e.g: CoinbaseInput, PublicKeyHashInput, MultiSigScriptHashInput, etc.\n\n  return input;\n};\n\nInput.prototype.toBufferWriter = function (writer) {\n  if (!writer) {\n    writer = new BufferWriter();\n  }\n\n  writer.writeReverse(this.prevTxId);\n  writer.writeUInt32LE(this.outputIndex);\n  var script = this._scriptBuffer;\n  writer.writeVarintNum(script.length);\n  writer.write(script);\n  writer.writeUInt32LE(this.sequenceNumber);\n  return writer;\n};\n\nInput.prototype.setScript = function (script) {\n  this._script = null;\n\n  if (script instanceof Script) {\n    this._script = script;\n    this._script._isInput = true;\n    this._scriptBuffer = script.toBuffer();\n  } else if (JSUtil.isHexa(script)) {\n    // hex string script\n    this._scriptBuffer = Buffer.from(script, 'hex');\n  } else if (_.isString(script)) {\n    // human readable string script\n    this._script = new Script(script);\n    this._script._isInput = true;\n    this._scriptBuffer = this._script.toBuffer();\n  } else if (BufferUtil.isBuffer(script)) {\n    // buffer script\n    this._scriptBuffer = Buffer.from(script);\n  } else {\n    throw new TypeError('Invalid argument type: script');\n  }\n\n  return this;\n};\n/**\n * Retrieve signatures for the provided PrivateKey.\n *\n * @param {Transaction} transaction - the transaction to be signed\n * @param {PrivateKey} privateKey - the private key to use when signing\n * @param {number} inputIndex - the index of this input in the provided transaction\n * @param {number} sigType - defaults to Signature.SIGHASH_ALL\n * @param {Buffer} addressHash - if provided, don't calculate the hash of the\n *     public key associated with the private key provided\n * @abstract\n */\n\n\nInput.prototype.getSignatures = function () {\n  throw new errors.AbstractMethodInvoked('Trying to sign unsupported output type (only P2PKH and P2SH multisig inputs are supported)' + ' for input: ' + JSON.stringify(this));\n};\n\nInput.prototype.getSatoshisBuffer = function () {\n  $.checkState(this.output instanceof Output);\n  $.checkState(this.output._satoshisBN);\n  return new BufferWriter().writeUInt64LEBN(this.output._satoshisBN).toBuffer();\n};\n\nInput.prototype.isFullySigned = function () {\n  throw new errors.AbstractMethodInvoked('Input#isFullySigned');\n};\n\nInput.prototype.isFinal = function () {\n  return this.sequenceNumber !== Input.MAXINT;\n};\n\nInput.prototype.addSignature = function () {\n  throw new errors.AbstractMethodInvoked('Input#addSignature');\n};\n\nInput.prototype.clearSignatures = function () {\n  throw new errors.AbstractMethodInvoked('Input#clearSignatures');\n};\n\nInput.prototype.hasWitnesses = function () {\n  if (this.witnesses && this.witnesses.length > 0) {\n    return true;\n  }\n\n  return false;\n};\n\nInput.prototype.getWitnesses = function () {\n  return this.witnesses;\n};\n\nInput.prototype.setWitnesses = function (witnesses) {\n  this.witnesses = witnesses;\n};\n\nInput.prototype.isValidSignature = function (transaction, signature, signingMethod) {\n  // FIXME: Refactor signature so this is not necessary\n  signingMethod = signingMethod || 'ecdsa';\n  signature.signature.nhashtype = signature.sigtype;\n  return Sighash.verify(transaction, signature.signature, signature.publicKey, signature.inputIndex, this.output.script, signingMethod);\n};\n/**\n * @returns true if this is a coinbase input (represents no input)\n */\n\n\nInput.prototype.isNull = function () {\n  return this.prevTxId.toString('hex') === '0000000000000000000000000000000000000000000000000000000000000000' && this.outputIndex === 0xffffffff;\n};\n\nInput.prototype._estimateSize = function () {\n  return this.toBufferWriter().toBuffer().length;\n};\n/**\n * Sets sequence number so that transaction is not valid until the desired seconds\n *  since the transaction is mined\n *\n * @param {Number} time in seconds\n * @return {Transaction} this\n */\n\n\nInput.prototype.lockForSeconds = function (seconds) {\n  $.checkArgument(_.isNumber(seconds));\n\n  if (seconds < 0 || seconds >= SEQUENCE_LOCKTIME_GRANULARITY * SEQUENCE_LOCKTIME_MASK) {\n    throw new errors.Transaction.Input.LockTimeRange();\n  }\n\n  seconds = parseInt(Math.floor(seconds / SEQUENCE_LOCKTIME_GRANULARITY)); // SEQUENCE_LOCKTIME_DISABLE_FLAG = 1 \n\n  this.sequenceNumber = seconds | SEQUENCE_LOCKTIME_TYPE_FLAG;\n  return this;\n};\n/**\n * Sets sequence number so that transaction is not valid until the desired block height differnece since the tx is mined\n *\n * @param {Number} height\n * @return {Transaction} this\n */\n\n\nInput.prototype.lockUntilBlockHeight = function (heightDiff) {\n  $.checkArgument(_.isNumber(heightDiff));\n\n  if (heightDiff < 0 || heightDiff >= SEQUENCE_BLOCKDIFF_LIMIT) {\n    throw new errors.Transaction.Input.BlockHeightOutOfRange();\n  } // SEQUENCE_LOCKTIME_TYPE_FLAG = 0\n  // SEQUENCE_LOCKTIME_DISABLE_FLAG = 0\n\n\n  this.sequenceNumber = heightDiff;\n  return this;\n};\n/**\n *  Returns a semantic version of the input's sequence nLockTime.\n *  @return {Number|Date}\n *  If sequence lock is disabled  it returns null,\n *  if is set to block height lock, returns a block height (number)\n *  else it returns a Date object.\n */\n\n\nInput.prototype.getLockTime = function () {\n  if (this.sequenceNumber & SEQUENCE_LOCKTIME_DISABLE_FLAG) {\n    return null;\n  }\n\n  if (this.sequenceNumber & SEQUENCE_LOCKTIME_TYPE_FLAG) {\n    var seconds = SEQUENCE_LOCKTIME_GRANULARITY * (this.sequenceNumber & SEQUENCE_LOCKTIME_MASK);\n    return seconds;\n  } else {\n    var blockHeight = this.sequenceNumber & SEQUENCE_LOCKTIME_MASK;\n    return blockHeight;\n  }\n};\n\nmodule.exports = Input;","map":{"version":3,"names":["_","require","$","errors","BufferWriter","buffer","BufferUtil","JSUtil","Script","Sighash","Output","MAXINT","DEFAULT_SEQNUMBER","DEFAULT_LOCKTIME_SEQNUMBER","DEFAULT_RBF_SEQNUMBER","SEQUENCE_LOCKTIME_DISABLE_FLAG","Math","pow","SEQUENCE_LOCKTIME_TYPE_FLAG","SEQUENCE_LOCKTIME_MASK","SEQUENCE_LOCKTIME_GRANULARITY","SEQUENCE_BLOCKDIFF_LIMIT","Input","params","_fromObject","Object","defineProperty","prototype","configurable","enumerable","get","isNull","_script","_scriptBuffer","_isInput","fromObject","obj","checkArgument","isObject","input","prevTxId","isString","isHexa","Buffer","from","witnesses","output","undefined","txidbuf","outputIndex","isUndefined","txoutnum","sequenceNumber","seqnum","script","scriptBuffer","Transaction","MissingScript","setScript","toObject","toJSON","toString","scriptString","fromBufferReader","br","readReverse","readUInt32LE","readVarLengthBuffer","toBufferWriter","writer","writeReverse","writeUInt32LE","writeVarintNum","length","write","toBuffer","isBuffer","TypeError","getSignatures","AbstractMethodInvoked","JSON","stringify","getSatoshisBuffer","checkState","_satoshisBN","writeUInt64LEBN","isFullySigned","isFinal","addSignature","clearSignatures","hasWitnesses","getWitnesses","setWitnesses","isValidSignature","transaction","signature","signingMethod","nhashtype","sigtype","verify","publicKey","inputIndex","_estimateSize","lockForSeconds","seconds","isNumber","LockTimeRange","parseInt","floor","lockUntilBlockHeight","heightDiff","BlockHeightOutOfRange","getLockTime","blockHeight","module","exports"],"sources":["C:/Users/acer/node_modules/bitcore-lib/lib/transaction/input/input.js"],"sourcesContent":["'use strict';\n\nvar _ = require('lodash');\nvar $ = require('../../util/preconditions');\nconst errors = require('../../errors');\nvar BufferWriter = require('../../encoding/bufferwriter');\nvar buffer = require('buffer');\nvar BufferUtil = require('../../util/buffer');\nvar JSUtil = require('../../util/js');\nvar Script = require('../../script');\nvar Sighash = require('../sighash');\nvar Output = require('../output');\n\nvar MAXINT = 0xffffffff; // Math.pow(2, 32) - 1;\nvar DEFAULT_SEQNUMBER = MAXINT;\nvar DEFAULT_LOCKTIME_SEQNUMBER = MAXINT - 1;\nvar DEFAULT_RBF_SEQNUMBER = MAXINT - 2;\nconst SEQUENCE_LOCKTIME_DISABLE_FLAG =  Math.pow(2,31); // (1 << 31);\nconst SEQUENCE_LOCKTIME_TYPE_FLAG = Math.pow(2,22); // (1 << 22);\nconst SEQUENCE_LOCKTIME_MASK = 0xffff;\nconst SEQUENCE_LOCKTIME_GRANULARITY = 512; // 512 seconds\nconst SEQUENCE_BLOCKDIFF_LIMIT = Math.pow(2,16)-1; // 16 bits \n\n\nfunction Input(params) {\n  if (!(this instanceof Input)) {\n    return new Input(params);\n  }\n  if (params) {\n    return this._fromObject(params);\n  }\n}\n\nInput.MAXINT = MAXINT;\nInput.DEFAULT_SEQNUMBER = DEFAULT_SEQNUMBER;\nInput.DEFAULT_LOCKTIME_SEQNUMBER = DEFAULT_LOCKTIME_SEQNUMBER;\nInput.DEFAULT_RBF_SEQNUMBER = DEFAULT_RBF_SEQNUMBER;\nInput.SEQUENCE_LOCKTIME_TYPE_FLAG = SEQUENCE_LOCKTIME_TYPE_FLAG;\n\nObject.defineProperty(Input.prototype, 'script', {\n  configurable: false,\n  enumerable: true,\n  get: function() {\n    if (this.isNull()) {\n      return null;\n    }\n    if (!this._script) {\n      this._script = new Script(this._scriptBuffer);\n      this._script._isInput = true;\n    }\n    return this._script;\n  }\n});\n\nInput.fromObject = function(obj) {\n  $.checkArgument(_.isObject(obj));\n  var input = new Input();\n  return input._fromObject(obj);\n};\n\nInput.prototype._fromObject = function(params) {\n  var prevTxId;\n  if (_.isString(params.prevTxId) && JSUtil.isHexa(params.prevTxId)) {\n    prevTxId = Buffer.from(params.prevTxId, 'hex');\n  } else {\n    prevTxId = params.prevTxId;\n  }\n  this.witnesses = [];\n  this.output = params.output ?\n    (params.output instanceof Output ? params.output : new Output(params.output)) : undefined;\n  this.prevTxId = prevTxId || params.txidbuf;\n  this.outputIndex = _.isUndefined(params.outputIndex) ? params.txoutnum : params.outputIndex;\n  this.sequenceNumber = _.isUndefined(params.sequenceNumber) ?\n    (_.isUndefined(params.seqnum) ? DEFAULT_SEQNUMBER : params.seqnum) : params.sequenceNumber;\n  if (_.isUndefined(params.script) && _.isUndefined(params.scriptBuffer)) {\n    throw new errors.Transaction.Input.MissingScript();\n  }\n  this.setScript(params.scriptBuffer || params.script);\n  return this;\n};\n\nInput.prototype.toObject = Input.prototype.toJSON = function toObject() {\n  var obj = {\n    prevTxId: this.prevTxId.toString('hex'),\n    outputIndex: this.outputIndex,\n    sequenceNumber: this.sequenceNumber,\n    script: this._scriptBuffer.toString('hex'),\n  };\n  // add human readable form if input contains valid script\n  if (this.script) {\n    obj.scriptString = this.script.toString();\n  }\n  if (this.output) {\n    obj.output = this.output.toObject();\n  }\n  return obj;\n};\n\nInput.fromBufferReader = function(br) {\n  var input = new Input();\n  input.prevTxId = br.readReverse(32);\n  input.outputIndex = br.readUInt32LE();\n  input._scriptBuffer = br.readVarLengthBuffer();\n  input.sequenceNumber = br.readUInt32LE();\n  // TODO: return different classes according to which input it is\n  // e.g: CoinbaseInput, PublicKeyHashInput, MultiSigScriptHashInput, etc.\n  return input;\n};\n\nInput.prototype.toBufferWriter = function(writer) {\n  if (!writer) {\n    writer = new BufferWriter();\n  }\n  writer.writeReverse(this.prevTxId);\n  writer.writeUInt32LE(this.outputIndex);\n  var script = this._scriptBuffer;\n  writer.writeVarintNum(script.length);\n  writer.write(script);\n  writer.writeUInt32LE(this.sequenceNumber);\n  return writer;\n};\n\nInput.prototype.setScript = function(script) {\n  this._script = null;\n  if (script instanceof Script) {\n    this._script = script;\n    this._script._isInput = true;\n    this._scriptBuffer = script.toBuffer();\n  } else if (JSUtil.isHexa(script)) {\n    // hex string script\n    this._scriptBuffer = Buffer.from(script, 'hex');\n  } else if (_.isString(script)) {\n    // human readable string script\n    this._script = new Script(script);\n    this._script._isInput = true;\n    this._scriptBuffer = this._script.toBuffer();\n  } else if (BufferUtil.isBuffer(script)) {\n    // buffer script\n    this._scriptBuffer = Buffer.from(script);\n  } else {\n    throw new TypeError('Invalid argument type: script');\n  }\n  return this;\n};\n\n/**\n * Retrieve signatures for the provided PrivateKey.\n *\n * @param {Transaction} transaction - the transaction to be signed\n * @param {PrivateKey} privateKey - the private key to use when signing\n * @param {number} inputIndex - the index of this input in the provided transaction\n * @param {number} sigType - defaults to Signature.SIGHASH_ALL\n * @param {Buffer} addressHash - if provided, don't calculate the hash of the\n *     public key associated with the private key provided\n * @abstract\n */\nInput.prototype.getSignatures = function() {\n  throw new errors.AbstractMethodInvoked(\n    'Trying to sign unsupported output type (only P2PKH and P2SH multisig inputs are supported)' +\n    ' for input: ' + JSON.stringify(this)\n  );\n};\n\nInput.prototype.getSatoshisBuffer = function() {\n  $.checkState(this.output instanceof Output);\n  $.checkState(this.output._satoshisBN);\n  return new BufferWriter().writeUInt64LEBN(this.output._satoshisBN).toBuffer();\n};\n\n\nInput.prototype.isFullySigned = function() {\n  throw new errors.AbstractMethodInvoked('Input#isFullySigned');\n};\n\nInput.prototype.isFinal = function() {\n  return this.sequenceNumber !== Input.MAXINT;\n};\n\nInput.prototype.addSignature = function() {\n  throw new errors.AbstractMethodInvoked('Input#addSignature');\n};\n\nInput.prototype.clearSignatures = function() {\n  throw new errors.AbstractMethodInvoked('Input#clearSignatures');\n};\n\nInput.prototype.hasWitnesses = function() {\n  if (this.witnesses && this.witnesses.length > 0) {\n    return true;\n  }\n  return false;\n};\n\nInput.prototype.getWitnesses = function() {\n  return this.witnesses;\n};\n\nInput.prototype.setWitnesses = function(witnesses) {\n  this.witnesses = witnesses;\n};\n\nInput.prototype.isValidSignature = function(transaction, signature, signingMethod) {\n  // FIXME: Refactor signature so this is not necessary\n  signingMethod = signingMethod || 'ecdsa';\n  signature.signature.nhashtype = signature.sigtype;\n  return Sighash.verify(\n    transaction,\n    signature.signature,\n    signature.publicKey,\n    signature.inputIndex,\n    this.output.script,\n    signingMethod\n  );\n};\n\n/**\n * @returns true if this is a coinbase input (represents no input)\n */\nInput.prototype.isNull = function() {\n  return this.prevTxId.toString('hex') === '0000000000000000000000000000000000000000000000000000000000000000' &&\n    this.outputIndex === 0xffffffff;\n};\n\nInput.prototype._estimateSize = function() {\n  return this.toBufferWriter().toBuffer().length;\n};\n\n\n/**\n * Sets sequence number so that transaction is not valid until the desired seconds\n *  since the transaction is mined\n *\n * @param {Number} time in seconds\n * @return {Transaction} this\n */\nInput.prototype.lockForSeconds = function(seconds) {\n  $.checkArgument(_.isNumber(seconds));\n  if (seconds < 0 ||  seconds >= SEQUENCE_LOCKTIME_GRANULARITY * SEQUENCE_LOCKTIME_MASK) {\n    throw new errors.Transaction.Input.LockTimeRange();\n  }\n  seconds = parseInt(Math.floor(seconds / SEQUENCE_LOCKTIME_GRANULARITY));\n\n  // SEQUENCE_LOCKTIME_DISABLE_FLAG = 1 \n  this.sequenceNumber = seconds | SEQUENCE_LOCKTIME_TYPE_FLAG ;\n  return this;\n};\n\n/**\n * Sets sequence number so that transaction is not valid until the desired block height differnece since the tx is mined\n *\n * @param {Number} height\n * @return {Transaction} this\n */\nInput.prototype.lockUntilBlockHeight = function(heightDiff) {\n  $.checkArgument(_.isNumber(heightDiff));\n  if (heightDiff < 0 || heightDiff >= SEQUENCE_BLOCKDIFF_LIMIT) {\n    throw new errors.Transaction.Input.BlockHeightOutOfRange();\n  }\n  // SEQUENCE_LOCKTIME_TYPE_FLAG = 0\n  // SEQUENCE_LOCKTIME_DISABLE_FLAG = 0\n  this.sequenceNumber = heightDiff ;\n  return this;\n};\n\n\n/**\n *  Returns a semantic version of the input's sequence nLockTime.\n *  @return {Number|Date}\n *  If sequence lock is disabled  it returns null,\n *  if is set to block height lock, returns a block height (number)\n *  else it returns a Date object.\n */\nInput.prototype.getLockTime = function() {\n  if (this.sequenceNumber & SEQUENCE_LOCKTIME_DISABLE_FLAG) {\n    return null;\n  }\n\n  if (this.sequenceNumber & SEQUENCE_LOCKTIME_TYPE_FLAG) {\n    var seconds = SEQUENCE_LOCKTIME_GRANULARITY * (this.sequenceNumber & SEQUENCE_LOCKTIME_MASK);\n    return seconds;\n  } else {\n    var blockHeight = this.sequenceNumber & SEQUENCE_LOCKTIME_MASK;\n    return blockHeight;\n  }\n};\n\n\n\n\nmodule.exports = Input;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}