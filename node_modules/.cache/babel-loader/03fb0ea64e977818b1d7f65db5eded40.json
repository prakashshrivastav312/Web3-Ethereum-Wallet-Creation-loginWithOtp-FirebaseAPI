{"ast":null,"code":"var Buffer = require('safe-buffer').Buffer;\n\nvar baddress = require('./address');\n\nvar bcrypto = require('./crypto');\n\nvar bscript = require('./script');\n\nvar btemplates = require('./templates');\n\nvar networks = require('./networks');\n\nvar ops = require('@tatumio/bitcoincash-ops');\n\nvar typeforce = require('typeforce');\n\nvar types = require('./types');\n\nvar scriptTypes = btemplates.types;\nvar SIGNABLE = [btemplates.types.P2PKH, btemplates.types.P2PK, btemplates.types.MULTISIG];\nvar P2SH = SIGNABLE.concat([btemplates.types.P2WPKH, btemplates.types.P2WSH]);\n\nvar ECPair = require('./ecpair');\n\nvar ECSignature = require('./ecsignature');\n\nvar Transaction = require('./transaction');\n\nfunction supportedType(type) {\n  return SIGNABLE.indexOf(type) !== -1;\n}\n\nfunction supportedP2SHType(type) {\n  return P2SH.indexOf(type) !== -1;\n}\n\nfunction extractChunks(type, chunks, script) {\n  var pubKeys = [];\n  var signatures = [];\n\n  switch (type) {\n    case scriptTypes.P2PKH:\n      // if (redeemScript) throw new Error('Nonstandard... P2SH(P2PKH)')\n      pubKeys = chunks.slice(1);\n      signatures = chunks.slice(0, 1);\n      break;\n\n    case scriptTypes.P2PK:\n      pubKeys[0] = script ? btemplates.pubKey.output.decode(script) : undefined;\n      signatures = chunks.slice(0, 1);\n      break;\n\n    case scriptTypes.MULTISIG:\n      if (script) {\n        var multisig = btemplates.multisig.output.decode(script);\n        pubKeys = multisig.pubKeys;\n      }\n\n      signatures = chunks.slice(1).map(function (chunk) {\n        return chunk.length === 0 ? undefined : chunk;\n      });\n      break;\n  }\n\n  return {\n    pubKeys: pubKeys,\n    signatures: signatures\n  };\n}\n\nfunction expandInput(scriptSig, witnessStack) {\n  if (scriptSig.length === 0 && witnessStack.length === 0) return {};\n  var prevOutScript;\n  var prevOutType;\n  var scriptType;\n  var script;\n  var redeemScript;\n  var witnessScript;\n  var witnessScriptType;\n  var redeemScriptType;\n  var witness = false;\n  var p2wsh = false;\n  var p2sh = false;\n  var witnessProgram;\n  var chunks;\n  var scriptSigChunks = bscript.decompile(scriptSig);\n  var sigType = btemplates.classifyInput(scriptSigChunks, true);\n\n  if (sigType === scriptTypes.P2SH) {\n    p2sh = true;\n    redeemScript = scriptSigChunks[scriptSigChunks.length - 1];\n    redeemScriptType = btemplates.classifyOutput(redeemScript);\n    prevOutScript = btemplates.scriptHash.output.encode(bcrypto.hash160(redeemScript));\n    prevOutType = scriptTypes.P2SH;\n    script = redeemScript;\n  }\n\n  var classifyWitness = btemplates.classifyWitness(witnessStack, true);\n\n  if (classifyWitness === scriptTypes.P2WSH) {\n    witnessScript = witnessStack[witnessStack.length - 1];\n    witnessScriptType = btemplates.classifyOutput(witnessScript);\n    p2wsh = true;\n    witness = true;\n\n    if (scriptSig.length === 0) {\n      prevOutScript = btemplates.witnessScriptHash.output.encode(bcrypto.sha256(witnessScript));\n      prevOutType = scriptTypes.P2WSH;\n\n      if (redeemScript !== undefined) {\n        throw new Error('Redeem script given when unnecessary');\n      } // bare witness\n\n    } else {\n      if (!redeemScript) {\n        throw new Error('No redeemScript provided for P2WSH, but scriptSig non-empty');\n      }\n\n      witnessProgram = btemplates.witnessScriptHash.output.encode(bcrypto.sha256(witnessScript));\n\n      if (!redeemScript.equals(witnessProgram)) {\n        throw new Error('Redeem script didn\\'t match witnessScript');\n      }\n    }\n\n    if (!supportedType(btemplates.classifyOutput(witnessScript))) {\n      throw new Error('unsupported witness script');\n    }\n\n    script = witnessScript;\n    scriptType = witnessScriptType;\n    chunks = witnessStack.slice(0, -1);\n  } else if (classifyWitness === scriptTypes.P2WPKH) {\n    witness = true;\n    var key = witnessStack[witnessStack.length - 1];\n    var keyHash = bcrypto.hash160(key);\n\n    if (scriptSig.length === 0) {\n      prevOutScript = btemplates.witnessPubKeyHash.output.encode(keyHash);\n      prevOutType = scriptTypes.P2WPKH;\n\n      if (typeof redeemScript !== 'undefined') {\n        throw new Error('Redeem script given when unnecessary');\n      }\n    } else {\n      if (!redeemScript) {\n        throw new Error('No redeemScript provided for P2WPKH, but scriptSig wasn\\'t empty');\n      }\n\n      witnessProgram = btemplates.witnessPubKeyHash.output.encode(keyHash);\n\n      if (!redeemScript.equals(witnessProgram)) {\n        throw new Error('Redeem script did not have the right witness program');\n      }\n    }\n\n    scriptType = scriptTypes.P2PKH;\n    chunks = witnessStack;\n  } else if (redeemScript) {\n    if (!supportedP2SHType(redeemScriptType)) {\n      throw new Error('Bad redeemscript!');\n    }\n\n    script = redeemScript;\n    scriptType = redeemScriptType;\n    chunks = scriptSigChunks.slice(0, -1);\n  } else {\n    prevOutType = scriptType = btemplates.classifyInput(scriptSig);\n    chunks = scriptSigChunks;\n  }\n\n  var expanded = extractChunks(scriptType, chunks, script);\n  var result = {\n    pubKeys: expanded.pubKeys,\n    signatures: expanded.signatures,\n    prevOutScript: prevOutScript,\n    prevOutType: prevOutType,\n    signType: scriptType,\n    signScript: script,\n    witness: Boolean(witness)\n  };\n\n  if (p2sh) {\n    result.redeemScript = redeemScript;\n    result.redeemScriptType = redeemScriptType;\n  }\n\n  if (p2wsh) {\n    result.witnessScript = witnessScript;\n    result.witnessScriptType = witnessScriptType;\n  }\n\n  return result;\n} // could be done in expandInput, but requires the original Transaction for hashForSignature\n\n\nfunction fixMultisigOrder(input, transaction, vin, value, bitcoinCash) {\n  if (input.redeemScriptType !== scriptTypes.MULTISIG || !input.redeemScript) return;\n  if (input.pubKeys.length === input.signatures.length) return;\n  var unmatched = input.signatures.concat();\n  input.signatures = input.pubKeys.map(function (pubKey) {\n    var keyPair = ECPair.fromPublicKeyBuffer(pubKey);\n    var match; // check for a signature\n\n    unmatched.some(function (signature, i) {\n      // skip if undefined || OP_0\n      if (!signature) return false; // TODO: avoid O(n) hashForSignature\n\n      var parsed = ECSignature.parseScriptSignature(signature);\n      var hash;\n\n      if (bitcoinCash) {\n        hash = transaction.hashForCashSignature(vin, input.signScript, value, parsed.hashType);\n      } else {\n        if (input.witness) {\n          hash = transaction.hashForWitnessV0(vin, input.signScript, value, parsed.hashType);\n        } else {\n          hash = transaction.hashForSignature(vin, input.signScript, parsed.hashType);\n        }\n      } // skip if signature does not match pubKey\n\n\n      if (!keyPair.verify(hash, parsed.signature)) return false; // remove matched signature from unmatched\n\n      unmatched[i] = undefined;\n      match = signature;\n      return true;\n    });\n    return match;\n  });\n}\n\nfunction expandOutput(script, scriptType, ourPubKey) {\n  typeforce(types.Buffer, script);\n  var scriptChunks = bscript.decompile(script);\n\n  if (!scriptType) {\n    scriptType = btemplates.classifyOutput(script);\n  }\n\n  var pubKeys = [];\n\n  switch (scriptType) {\n    // does our hash160(pubKey) match the output scripts?\n    case scriptTypes.P2PKH:\n      if (!ourPubKey) break;\n      var pkh1 = scriptChunks[2];\n      var pkh2 = bcrypto.hash160(ourPubKey);\n      if (pkh1.equals(pkh2)) pubKeys = [ourPubKey];\n      break;\n    // does our hash160(pubKey) match the output scripts?\n\n    case scriptTypes.P2WPKH:\n      if (!ourPubKey) break;\n      var wpkh1 = scriptChunks[1];\n      var wpkh2 = bcrypto.hash160(ourPubKey);\n      if (wpkh1.equals(wpkh2)) pubKeys = [ourPubKey];\n      break;\n\n    case scriptTypes.P2PK:\n      pubKeys = scriptChunks.slice(0, 1);\n      break;\n\n    case scriptTypes.MULTISIG:\n      pubKeys = scriptChunks.slice(1, -2);\n      break;\n\n    default:\n      return {\n        scriptType: scriptType\n      };\n  }\n\n  return {\n    pubKeys: pubKeys,\n    scriptType: scriptType,\n    signatures: pubKeys.map(function () {\n      return undefined;\n    })\n  };\n}\n\nfunction checkP2SHInput(input, redeemScriptHash) {\n  if (input.prevOutType) {\n    if (input.prevOutType !== scriptTypes.P2SH) throw new Error('PrevOutScript must be P2SH');\n    var prevOutScriptScriptHash = bscript.decompile(input.prevOutScript)[1];\n    if (!prevOutScriptScriptHash.equals(redeemScriptHash)) throw new Error('Inconsistent hash160(RedeemScript)');\n  }\n}\n\nfunction checkP2WSHInput(input, witnessScriptHash) {\n  if (input.prevOutType) {\n    if (input.prevOutType !== scriptTypes.P2WSH) throw new Error('PrevOutScript must be P2WSH');\n    var scriptHash = bscript.decompile(input.prevOutScript)[1];\n    if (!scriptHash.equals(witnessScriptHash)) throw new Error('Inconsistent sha25(WitnessScript)');\n  }\n}\n\nfunction prepareInput(input, kpPubKey, redeemScript, witnessValue, witnessScript) {\n  var expanded;\n  var prevOutType;\n  var prevOutScript;\n  var p2sh = false;\n  var p2shType;\n  var redeemScriptHash;\n  var witness = false;\n  var p2wsh = false;\n  var witnessType;\n  var witnessScriptHash;\n  var signType;\n  var signScript;\n\n  if (redeemScript && witnessScript) {\n    redeemScriptHash = bcrypto.hash160(redeemScript);\n    witnessScriptHash = bcrypto.sha256(witnessScript);\n    checkP2SHInput(input, redeemScriptHash);\n    if (!redeemScript.equals(btemplates.witnessScriptHash.output.encode(witnessScriptHash))) throw new Error('Witness script inconsistent with redeem script');\n    expanded = expandOutput(witnessScript, undefined, kpPubKey);\n    if (!expanded.pubKeys) throw new Error('WitnessScript not supported \"' + bscript.toASM(redeemScript) + '\"');\n    prevOutType = btemplates.types.P2SH;\n    prevOutScript = btemplates.scriptHash.output.encode(redeemScriptHash);\n    p2sh = witness = p2wsh = true;\n    p2shType = btemplates.types.P2WSH;\n    signType = witnessType = expanded.scriptType;\n    signScript = witnessScript;\n  } else if (redeemScript) {\n    redeemScriptHash = bcrypto.hash160(redeemScript);\n    checkP2SHInput(input, redeemScriptHash);\n    expanded = expandOutput(redeemScript, undefined, kpPubKey);\n    if (!expanded.pubKeys) throw new Error('RedeemScript not supported \"' + bscript.toASM(redeemScript) + '\"');\n    prevOutType = btemplates.types.P2SH;\n    prevOutScript = btemplates.scriptHash.output.encode(redeemScriptHash);\n    p2sh = true;\n    signType = p2shType = expanded.scriptType;\n    signScript = redeemScript;\n    witness = signType === btemplates.types.P2WPKH;\n  } else if (witnessScript) {\n    witnessScriptHash = bcrypto.sha256(witnessScript);\n    checkP2WSHInput(input, witnessScriptHash);\n    expanded = expandOutput(witnessScript, undefined, kpPubKey);\n    if (!expanded.pubKeys) throw new Error('WitnessScript not supported \"' + bscript.toASM(redeemScript) + '\"');\n    prevOutType = btemplates.types.P2WSH;\n    prevOutScript = btemplates.witnessScriptHash.output.encode(witnessScriptHash);\n    witness = p2wsh = true;\n    signType = witnessType = expanded.scriptType;\n    signScript = witnessScript;\n  } else if (input.prevOutType) {\n    // embedded scripts are not possible without a redeemScript\n    if (input.prevOutType === scriptTypes.P2SH || input.prevOutType === scriptTypes.P2WSH) {\n      throw new Error('PrevOutScript is ' + input.prevOutType + ', requires redeemScript');\n    }\n\n    prevOutType = input.prevOutType;\n    prevOutScript = input.prevOutScript;\n    expanded = expandOutput(input.prevOutScript, input.prevOutType, kpPubKey);\n    if (!expanded.pubKeys) return;\n    witness = input.prevOutType === scriptTypes.P2WPKH;\n    signType = prevOutType;\n    signScript = prevOutScript;\n  } else {\n    prevOutScript = btemplates.pubKeyHash.output.encode(bcrypto.hash160(kpPubKey));\n    expanded = expandOutput(prevOutScript, scriptTypes.P2PKH, kpPubKey);\n    prevOutType = scriptTypes.P2PKH;\n    witness = false;\n    signType = prevOutType;\n    signScript = prevOutScript;\n  }\n\n  if (signType === scriptTypes.P2WPKH) {\n    signScript = btemplates.pubKeyHash.output.encode(btemplates.witnessPubKeyHash.output.decode(signScript));\n  }\n\n  if (p2sh) {\n    input.redeemScript = redeemScript;\n    input.redeemScriptType = p2shType;\n  }\n\n  if (p2wsh) {\n    input.witnessScript = witnessScript;\n    input.witnessScriptType = witnessType;\n  }\n\n  input.pubKeys = expanded.pubKeys;\n  input.signatures = expanded.signatures;\n  input.signScript = signScript;\n  input.signType = signType;\n  input.prevOutScript = prevOutScript;\n  input.prevOutType = prevOutType;\n  input.witness = witness;\n}\n\nfunction buildStack(type, signatures, pubKeys, allowIncomplete) {\n  if (type === scriptTypes.P2PKH) {\n    if (signatures.length === 1 && Buffer.isBuffer(signatures[0]) && pubKeys.length === 1) return btemplates.pubKeyHash.input.encodeStack(signatures[0], pubKeys[0]);\n  } else if (type === scriptTypes.P2PK) {\n    if (signatures.length === 1 && Buffer.isBuffer(signatures[0])) return btemplates.pubKey.input.encodeStack(signatures[0]);\n  } else if (type === scriptTypes.MULTISIG) {\n    if (signatures.length > 0) {\n      signatures = signatures.map(function (signature) {\n        return signature || ops.OP_0;\n      });\n\n      if (!allowIncomplete) {\n        // remove blank signatures\n        signatures = signatures.filter(function (x) {\n          return x !== ops.OP_0;\n        });\n      }\n\n      return btemplates.multisig.input.encodeStack(signatures);\n    }\n  } else {\n    throw new Error('Not yet supported');\n  }\n\n  if (!allowIncomplete) throw new Error('Not enough signatures provided');\n  return [];\n}\n\nfunction buildInput(input, allowIncomplete) {\n  var scriptType = input.prevOutType;\n  var sig = [];\n  var witness = [];\n\n  if (supportedType(scriptType)) {\n    sig = buildStack(scriptType, input.signatures, input.pubKeys, allowIncomplete);\n  }\n\n  var p2sh = false;\n\n  if (scriptType === btemplates.types.P2SH) {\n    // We can remove this error later when we have a guarantee prepareInput\n    // rejects unsignable scripts - it MUST be signable at this point.\n    if (!allowIncomplete && !supportedP2SHType(input.redeemScriptType)) {\n      throw new Error('Impossible to sign this type');\n    }\n\n    if (supportedType(input.redeemScriptType)) {\n      sig = buildStack(input.redeemScriptType, input.signatures, input.pubKeys, allowIncomplete);\n    } // If it wasn't SIGNABLE, it's witness, defer to that\n\n\n    if (input.redeemScriptType) {\n      p2sh = true;\n      scriptType = input.redeemScriptType;\n    }\n  }\n\n  switch (scriptType) {\n    // P2WPKH is a special case of P2PKH\n    case btemplates.types.P2WPKH:\n      witness = buildStack(btemplates.types.P2PKH, input.signatures, input.pubKeys, allowIncomplete);\n      break;\n\n    case btemplates.types.P2WSH:\n      // We can remove this check later\n      if (!allowIncomplete && !supportedType(input.witnessScriptType)) {\n        throw new Error('Impossible to sign this type');\n      }\n\n      if (supportedType(input.witnessScriptType)) {\n        witness = buildStack(input.witnessScriptType, input.signatures, input.pubKeys, allowIncomplete);\n        witness.push(input.witnessScript);\n        scriptType = input.witnessScriptType;\n      }\n\n      break;\n  } // append redeemScript if necessary\n\n\n  if (p2sh) {\n    sig.push(input.redeemScript);\n  }\n\n  return {\n    type: scriptType,\n    script: bscript.compile(sig),\n    witness: witness\n  };\n}\n\nfunction TransactionBuilder(network, maximumFeeRate) {\n  this.prevTxMap = {};\n  this.network = network || networks.bitcoin; // WARNING: This is __NOT__ to be relied on, its just another potential safety mechanism (safety in-depth)\n\n  this.maximumFeeRate = maximumFeeRate || 2500;\n  this.inputs = [];\n  this.bitcoinCash = true;\n  this.tx = new Transaction();\n}\n\nTransactionBuilder.prototype.setLockTime = function (locktime) {\n  typeforce(types.UInt32, locktime); // if any signatures exist, throw\n\n  if (this.inputs.some(function (input) {\n    if (!input.signatures) return false;\n    return input.signatures.some(function (s) {\n      return s;\n    });\n  })) {\n    throw new Error('No, this would invalidate signatures');\n  }\n\n  this.tx.locktime = locktime;\n};\n\nTransactionBuilder.fromTransaction = function (transaction, network, bitcoinCashTx) {\n  var txb = new TransactionBuilder(network); // Copy transaction fields\n\n  txb.setLockTime(transaction.locktime); // Copy outputs (done first to avoid signature invalidation)\n\n  transaction.outs.forEach(function (txOut) {\n    txb.addOutput(txOut.script, txOut.value);\n  }); // Copy inputs\n\n  transaction.ins.forEach(function (txIn) {\n    txb.__addInputUnsafe(txIn.hash, txIn.index, {\n      sequence: txIn.sequence,\n      script: txIn.script,\n      witness: txIn.witness,\n      value: txIn.value\n    });\n  }); // fix some things not possible through the public API\n\n  txb.inputs.forEach(function (input, i) {\n    fixMultisigOrder(input, transaction, i, input.value, bitcoinCashTx);\n  });\n  return txb;\n};\n\nTransactionBuilder.prototype.addInput = function (txHash, vout, sequence, prevOutScript) {\n  if (!this.__canModifyInputs()) {\n    throw new Error('No, this would invalidate signatures');\n  }\n\n  var value; // is it a hex string?\n\n  if (typeof txHash === 'string') {\n    // transaction hashs's are displayed in reverse order, un-reverse it\n    txHash = Buffer.from(txHash, 'hex').reverse(); // is it a Transaction object?\n  } else if (txHash instanceof Transaction) {\n    var txOut = txHash.outs[vout];\n    prevOutScript = txOut.script;\n    value = txOut.value;\n    txHash = txHash.getHash();\n  }\n\n  return this.__addInputUnsafe(txHash, vout, {\n    sequence: sequence,\n    prevOutScript: prevOutScript,\n    value: value\n  });\n};\n\nTransactionBuilder.prototype.__addInputUnsafe = function (txHash, vout, options) {\n  if (Transaction.isCoinbaseHash(txHash)) {\n    throw new Error('coinbase inputs not supported');\n  }\n\n  var prevTxOut = txHash.toString('hex') + ':' + vout;\n  if (this.prevTxMap[prevTxOut] !== undefined) throw new Error('Duplicate TxOut: ' + prevTxOut);\n  var input = {}; // derive what we can from the scriptSig\n\n  if (options.script !== undefined) {\n    input = expandInput(options.script, options.witness || []);\n  } // if an input value was given, retain it\n\n\n  if (options.value !== undefined) {\n    input.value = options.value;\n  } // derive what we can from the previous transactions output script\n\n\n  if (!input.prevOutScript && options.prevOutScript) {\n    var prevOutType;\n\n    if (!input.pubKeys && !input.signatures) {\n      var expanded = expandOutput(options.prevOutScript);\n\n      if (expanded.pubKeys) {\n        input.pubKeys = expanded.pubKeys;\n        input.signatures = expanded.signatures;\n      }\n\n      prevOutType = expanded.scriptType;\n    }\n\n    input.prevOutScript = options.prevOutScript;\n    input.prevOutType = prevOutType || btemplates.classifyOutput(options.prevOutScript);\n  }\n\n  var vin = this.tx.addInput(txHash, vout, options.sequence, options.scriptSig);\n  this.inputs[vin] = input;\n  this.prevTxMap[prevTxOut] = vin;\n  return vin;\n};\n\nTransactionBuilder.prototype.addOutput = function (scriptPubKey, value) {\n  if (!this.__canModifyOutputs()) {\n    throw new Error('No, this would invalidate signatures');\n  } // Attempt to get a script if it's a base58 address string\n\n\n  if (typeof scriptPubKey === 'string') {\n    scriptPubKey = baddress.toOutputScript(scriptPubKey, this.network);\n  }\n\n  return this.tx.addOutput(scriptPubKey, value);\n};\n\nTransactionBuilder.prototype.build = function () {\n  return this.__build(false);\n};\n\nTransactionBuilder.prototype.buildIncomplete = function () {\n  return this.__build(true);\n};\n\nTransactionBuilder.prototype.__build = function (allowIncomplete) {\n  if (!allowIncomplete) {\n    if (!this.tx.ins.length) throw new Error('Transaction has no inputs');\n    if (!this.tx.outs.length) throw new Error('Transaction has no outputs');\n  }\n\n  var tx = this.tx.clone(); // Create script signatures from inputs\n\n  this.inputs.forEach(function (input, i) {\n    var scriptType = input.witnessScriptType || input.redeemScriptType || input.prevOutType;\n    if (!scriptType && !allowIncomplete) throw new Error('Transaction is not complete');\n    var result = buildInput(input, allowIncomplete); // skip if no result\n\n    if (!allowIncomplete) {\n      if (!supportedType(result.type) && result.type !== btemplates.types.P2WPKH) {\n        throw new Error(result.type + ' not supported');\n      }\n    }\n\n    tx.setInputScript(i, result.script);\n    tx.setWitness(i, result.witness);\n  });\n\n  if (!allowIncomplete) {\n    // do not rely on this, its merely a last resort\n    if (this.__overMaximumFees(tx.virtualSize())) {\n      throw new Error('Transaction has absurd fees');\n    }\n  }\n\n  return tx;\n};\n\nfunction canSign(input) {\n  return input.prevOutScript !== undefined && input.signScript !== undefined && input.pubKeys !== undefined && input.signatures !== undefined && input.signatures.length === input.pubKeys.length && input.pubKeys.length > 0 && (input.witness === false || input.witness === true && input.value !== undefined);\n}\n\nTransactionBuilder.prototype.sign = function (vin, keyPair, redeemScript, hashType, witnessValue, witnessScript, signatureAlgorithm) {\n  hashType = hashType | Transaction.SIGHASH_BITCOINCASHBIP143;\n  if (!this.inputs[vin]) throw new Error('No input at index: ' + vin);\n  hashType = hashType || Transaction.SIGHASH_ALL;\n  var input = this.inputs[vin]; // if redeemScript was previously provided, enforce consistency\n\n  if (input.redeemScript !== undefined && redeemScript && !input.redeemScript.equals(redeemScript)) {\n    throw new Error('Inconsistent redeemScript');\n  }\n\n  var kpPubKey = keyPair.publicKey || keyPair.getPublicKeyBuffer();\n\n  if (!canSign(input)) {\n    if (witnessValue !== undefined) {\n      if (input.value !== undefined && input.value !== witnessValue) throw new Error('Input didn\\'t match witnessValue');\n      typeforce(types.Satoshi, witnessValue);\n      input.value = witnessValue;\n    }\n\n    if (!canSign(input)) prepareInput(input, kpPubKey, redeemScript, witnessValue, witnessScript);\n    if (!canSign(input)) throw Error(input.prevOutType + ' not supported');\n  } // ready to sign\n  // var signatureHash = this.tx.hashForCashSignature(vin, input.signScript, witnessValue, hashType)\n\n\n  var signatureHash = this.tx.hashForCashSignature(vin, input.signScript, witnessValue, hashType); // if (this.bitcoinCash) {\n  //   signatureHash = this.tx.hashForCashSignature(vin, input.signScript, witnessValue, hashType)\n  // } else {\n  //   if (input.witness) {\n  //     signatureHash = this.tx.hashForWitnessV0(vin, input.signScript, witnessValue, hashType)\n  //   } else {\n  //     signatureHash = this.tx.hashForSignature(vin, input.signScript, hashType)\n  //   }\n  // }\n  // enforce in order signing of public keys\n\n  var signed = input.pubKeys.some(function (pubKey, i) {\n    if (!kpPubKey.equals(pubKey)) return false;\n    if (input.signatures[i]) throw new Error('Signature already exists');\n    if (kpPubKey.length !== 33 && input.signType === scriptTypes.P2WPKH) throw new Error('BIP143 rejects uncompressed public keys in P2WPKH or P2WSH');\n    var signature = keyPair.sign(signatureHash, signatureAlgorithm);\n    if (Buffer.isBuffer(signature)) signature = ECSignature.fromRSBuffer(signature);\n    input.signatures[i] = signature.toScriptSignature(hashType, signatureAlgorithm);\n    return true;\n  });\n  if (!signed) throw new Error('Key pair cannot sign for this input');\n};\n\nfunction signatureHashType(buffer) {\n  return buffer.readUInt8(buffer.length - 1);\n}\n\nTransactionBuilder.prototype.__canModifyInputs = function () {\n  return this.inputs.every(function (input) {\n    // any signatures?\n    if (input.signatures === undefined) return true;\n    return input.signatures.every(function (signature) {\n      if (!signature) return true;\n      var hashType = signatureHashType(signature); // if SIGHASH_ANYONECANPAY is set, signatures would not\n      // be invalidated by more inputs\n\n      return hashType & Transaction.SIGHASH_ANYONECANPAY;\n    });\n  });\n};\n\nTransactionBuilder.prototype.__canModifyOutputs = function () {\n  var nInputs = this.tx.ins.length;\n  var nOutputs = this.tx.outs.length;\n  return this.inputs.every(function (input) {\n    if (input.signatures === undefined) return true;\n    return input.signatures.every(function (signature) {\n      if (!signature) return true;\n      var hashType = signatureHashType(signature);\n      var hashTypeMod = hashType & 0x1f;\n      if (hashTypeMod === Transaction.SIGHASH_NONE) return true;\n\n      if (hashTypeMod === Transaction.SIGHASH_SINGLE) {\n        // if SIGHASH_SINGLE is set, and nInputs > nOutputs\n        // some signatures would be invalidated by the addition\n        // of more outputs\n        return nInputs <= nOutputs;\n      }\n    });\n  });\n};\n\nTransactionBuilder.prototype.__overMaximumFees = function (bytes) {\n  // not all inputs will have .value defined\n  var incoming = this.inputs.reduce(function (a, x) {\n    return a + (x.value >>> 0);\n  }, 0); // but all outputs do, and if we have any input value\n  // we can immediately determine if the outputs are too small\n\n  var outgoing = this.tx.outs.reduce(function (a, x) {\n    return a + x.value;\n  }, 0);\n  var fee = incoming - outgoing;\n  var feeRate = fee / bytes;\n  return feeRate > this.maximumFeeRate;\n};\n\nmodule.exports = TransactionBuilder;","map":{"version":3,"names":["Buffer","require","baddress","bcrypto","bscript","btemplates","networks","ops","typeforce","types","scriptTypes","SIGNABLE","P2PKH","P2PK","MULTISIG","P2SH","concat","P2WPKH","P2WSH","ECPair","ECSignature","Transaction","supportedType","type","indexOf","supportedP2SHType","extractChunks","chunks","script","pubKeys","signatures","slice","pubKey","output","decode","undefined","multisig","map","chunk","length","expandInput","scriptSig","witnessStack","prevOutScript","prevOutType","scriptType","redeemScript","witnessScript","witnessScriptType","redeemScriptType","witness","p2wsh","p2sh","witnessProgram","scriptSigChunks","decompile","sigType","classifyInput","classifyOutput","scriptHash","encode","hash160","classifyWitness","witnessScriptHash","sha256","Error","equals","key","keyHash","witnessPubKeyHash","expanded","result","signType","signScript","Boolean","fixMultisigOrder","input","transaction","vin","value","bitcoinCash","unmatched","keyPair","fromPublicKeyBuffer","match","some","signature","i","parsed","parseScriptSignature","hash","hashForCashSignature","hashType","hashForWitnessV0","hashForSignature","verify","expandOutput","ourPubKey","scriptChunks","pkh1","pkh2","wpkh1","wpkh2","checkP2SHInput","redeemScriptHash","prevOutScriptScriptHash","checkP2WSHInput","prepareInput","kpPubKey","witnessValue","p2shType","witnessType","toASM","pubKeyHash","buildStack","allowIncomplete","isBuffer","encodeStack","OP_0","filter","x","buildInput","sig","push","compile","TransactionBuilder","network","maximumFeeRate","prevTxMap","bitcoin","inputs","tx","prototype","setLockTime","locktime","UInt32","s","fromTransaction","bitcoinCashTx","txb","outs","forEach","txOut","addOutput","ins","txIn","__addInputUnsafe","index","sequence","addInput","txHash","vout","__canModifyInputs","from","reverse","getHash","options","isCoinbaseHash","prevTxOut","toString","scriptPubKey","__canModifyOutputs","toOutputScript","build","__build","buildIncomplete","clone","setInputScript","setWitness","__overMaximumFees","virtualSize","canSign","sign","signatureAlgorithm","SIGHASH_BITCOINCASHBIP143","SIGHASH_ALL","publicKey","getPublicKeyBuffer","Satoshi","signatureHash","signed","fromRSBuffer","toScriptSignature","signatureHashType","buffer","readUInt8","every","SIGHASH_ANYONECANPAY","nInputs","nOutputs","hashTypeMod","SIGHASH_NONE","SIGHASH_SINGLE","bytes","incoming","reduce","a","outgoing","fee","feeRate","module","exports"],"sources":["C:/Users/acer/node_modules/@tatumio/bitcoincashjs2-lib/src/transaction_builder.js"],"sourcesContent":["var Buffer = require('safe-buffer').Buffer\nvar baddress = require('./address')\nvar bcrypto = require('./crypto')\nvar bscript = require('./script')\nvar btemplates = require('./templates')\nvar networks = require('./networks')\nvar ops = require('@tatumio/bitcoincash-ops')\nvar typeforce = require('typeforce')\nvar types = require('./types')\nvar scriptTypes = btemplates.types\nvar SIGNABLE = [btemplates.types.P2PKH, btemplates.types.P2PK, btemplates.types.MULTISIG]\nvar P2SH = SIGNABLE.concat([btemplates.types.P2WPKH, btemplates.types.P2WSH])\n\nvar ECPair = require('./ecpair')\nvar ECSignature = require('./ecsignature')\nvar Transaction = require('./transaction')\n\nfunction supportedType (type) {\n  return SIGNABLE.indexOf(type) !== -1\n}\n\nfunction supportedP2SHType (type) {\n  return P2SH.indexOf(type) !== -1\n}\n\nfunction extractChunks (type, chunks, script) {\n  var pubKeys = []\n  var signatures = []\n  switch (type) {\n    case scriptTypes.P2PKH:\n      // if (redeemScript) throw new Error('Nonstandard... P2SH(P2PKH)')\n      pubKeys = chunks.slice(1)\n      signatures = chunks.slice(0, 1)\n      break\n\n    case scriptTypes.P2PK:\n      pubKeys[0] = script ? btemplates.pubKey.output.decode(script) : undefined\n      signatures = chunks.slice(0, 1)\n      break\n\n    case scriptTypes.MULTISIG:\n      if (script) {\n        var multisig = btemplates.multisig.output.decode(script)\n        pubKeys = multisig.pubKeys\n      }\n\n      signatures = chunks.slice(1).map(function (chunk) {\n        return chunk.length === 0 ? undefined : chunk\n      })\n      break\n  }\n\n  return {\n    pubKeys: pubKeys,\n    signatures: signatures\n  }\n}\nfunction expandInput (scriptSig, witnessStack) {\n  if (scriptSig.length === 0 && witnessStack.length === 0) return {}\n\n  var prevOutScript\n  var prevOutType\n  var scriptType\n  var script\n  var redeemScript\n  var witnessScript\n  var witnessScriptType\n  var redeemScriptType\n  var witness = false\n  var p2wsh = false\n  var p2sh = false\n  var witnessProgram\n  var chunks\n\n  var scriptSigChunks = bscript.decompile(scriptSig)\n  var sigType = btemplates.classifyInput(scriptSigChunks, true)\n  if (sigType === scriptTypes.P2SH) {\n    p2sh = true\n    redeemScript = scriptSigChunks[scriptSigChunks.length - 1]\n    redeemScriptType = btemplates.classifyOutput(redeemScript)\n    prevOutScript = btemplates.scriptHash.output.encode(bcrypto.hash160(redeemScript))\n    prevOutType = scriptTypes.P2SH\n    script = redeemScript\n  }\n\n  var classifyWitness = btemplates.classifyWitness(witnessStack, true)\n  if (classifyWitness === scriptTypes.P2WSH) {\n    witnessScript = witnessStack[witnessStack.length - 1]\n    witnessScriptType = btemplates.classifyOutput(witnessScript)\n    p2wsh = true\n    witness = true\n    if (scriptSig.length === 0) {\n      prevOutScript = btemplates.witnessScriptHash.output.encode(bcrypto.sha256(witnessScript))\n      prevOutType = scriptTypes.P2WSH\n      if (redeemScript !== undefined) {\n        throw new Error('Redeem script given when unnecessary')\n      }\n      // bare witness\n    } else {\n      if (!redeemScript) {\n        throw new Error('No redeemScript provided for P2WSH, but scriptSig non-empty')\n      }\n      witnessProgram = btemplates.witnessScriptHash.output.encode(bcrypto.sha256(witnessScript))\n      if (!redeemScript.equals(witnessProgram)) {\n        throw new Error('Redeem script didn\\'t match witnessScript')\n      }\n    }\n\n    if (!supportedType(btemplates.classifyOutput(witnessScript))) {\n      throw new Error('unsupported witness script')\n    }\n\n    script = witnessScript\n    scriptType = witnessScriptType\n    chunks = witnessStack.slice(0, -1)\n  } else if (classifyWitness === scriptTypes.P2WPKH) {\n    witness = true\n    var key = witnessStack[witnessStack.length - 1]\n    var keyHash = bcrypto.hash160(key)\n    if (scriptSig.length === 0) {\n      prevOutScript = btemplates.witnessPubKeyHash.output.encode(keyHash)\n      prevOutType = scriptTypes.P2WPKH\n      if (typeof redeemScript !== 'undefined') {\n        throw new Error('Redeem script given when unnecessary')\n      }\n    } else {\n      if (!redeemScript) {\n        throw new Error('No redeemScript provided for P2WPKH, but scriptSig wasn\\'t empty')\n      }\n      witnessProgram = btemplates.witnessPubKeyHash.output.encode(keyHash)\n      if (!redeemScript.equals(witnessProgram)) {\n        throw new Error('Redeem script did not have the right witness program')\n      }\n    }\n\n    scriptType = scriptTypes.P2PKH\n    chunks = witnessStack\n  } else if (redeemScript) {\n    if (!supportedP2SHType(redeemScriptType)) {\n      throw new Error('Bad redeemscript!')\n    }\n\n    script = redeemScript\n    scriptType = redeemScriptType\n    chunks = scriptSigChunks.slice(0, -1)\n  } else {\n    prevOutType = scriptType = btemplates.classifyInput(scriptSig)\n    chunks = scriptSigChunks\n  }\n\n  var expanded = extractChunks(scriptType, chunks, script)\n\n  var result = {\n    pubKeys: expanded.pubKeys,\n    signatures: expanded.signatures,\n    prevOutScript: prevOutScript,\n    prevOutType: prevOutType,\n    signType: scriptType,\n    signScript: script,\n    witness: Boolean(witness)\n  }\n\n  if (p2sh) {\n    result.redeemScript = redeemScript\n    result.redeemScriptType = redeemScriptType\n  }\n\n  if (p2wsh) {\n    result.witnessScript = witnessScript\n    result.witnessScriptType = witnessScriptType\n  }\n\n  return result\n}\n\n// could be done in expandInput, but requires the original Transaction for hashForSignature\nfunction fixMultisigOrder (input, transaction, vin, value, bitcoinCash) {\n  if (input.redeemScriptType !== scriptTypes.MULTISIG || !input.redeemScript) return\n  if (input.pubKeys.length === input.signatures.length) return\n\n  var unmatched = input.signatures.concat()\n\n  input.signatures = input.pubKeys.map(function (pubKey) {\n    var keyPair = ECPair.fromPublicKeyBuffer(pubKey)\n    var match\n\n    // check for a signature\n    unmatched.some(function (signature, i) {\n      // skip if undefined || OP_0\n      if (!signature) return false\n\n      // TODO: avoid O(n) hashForSignature\n      var parsed = ECSignature.parseScriptSignature(signature)\n      var hash\n      if (bitcoinCash) {\n        hash = transaction.hashForCashSignature(vin, input.signScript, value, parsed.hashType)\n      } else {\n        if (input.witness) {\n          hash = transaction.hashForWitnessV0(vin, input.signScript, value, parsed.hashType)\n        } else {\n          hash = transaction.hashForSignature(vin, input.signScript, parsed.hashType)\n        }\n      }\n\n      // skip if signature does not match pubKey\n      if (!keyPair.verify(hash, parsed.signature)) return false\n\n      // remove matched signature from unmatched\n      unmatched[i] = undefined\n      match = signature\n\n      return true\n    })\n\n    return match\n  })\n}\n\nfunction expandOutput (script, scriptType, ourPubKey) {\n  typeforce(types.Buffer, script)\n\n  var scriptChunks = bscript.decompile(script)\n  if (!scriptType) {\n    scriptType = btemplates.classifyOutput(script)\n  }\n\n  var pubKeys = []\n\n  switch (scriptType) {\n    // does our hash160(pubKey) match the output scripts?\n    case scriptTypes.P2PKH:\n      if (!ourPubKey) break\n\n      var pkh1 = scriptChunks[2]\n      var pkh2 = bcrypto.hash160(ourPubKey)\n      if (pkh1.equals(pkh2)) pubKeys = [ourPubKey]\n      break\n\n    // does our hash160(pubKey) match the output scripts?\n    case scriptTypes.P2WPKH:\n      if (!ourPubKey) break\n\n      var wpkh1 = scriptChunks[1]\n      var wpkh2 = bcrypto.hash160(ourPubKey)\n      if (wpkh1.equals(wpkh2)) pubKeys = [ourPubKey]\n      break\n\n    case scriptTypes.P2PK:\n      pubKeys = scriptChunks.slice(0, 1)\n      break\n\n    case scriptTypes.MULTISIG:\n      pubKeys = scriptChunks.slice(1, -2)\n      break\n\n    default: return { scriptType: scriptType }\n  }\n\n  return {\n    pubKeys: pubKeys,\n    scriptType: scriptType,\n    signatures: pubKeys.map(function () { return undefined })\n  }\n}\n\nfunction checkP2SHInput (input, redeemScriptHash) {\n  if (input.prevOutType) {\n    if (input.prevOutType !== scriptTypes.P2SH) throw new Error('PrevOutScript must be P2SH')\n\n    var prevOutScriptScriptHash = bscript.decompile(input.prevOutScript)[1]\n    if (!prevOutScriptScriptHash.equals(redeemScriptHash)) throw new Error('Inconsistent hash160(RedeemScript)')\n  }\n}\n\nfunction checkP2WSHInput (input, witnessScriptHash) {\n  if (input.prevOutType) {\n    if (input.prevOutType !== scriptTypes.P2WSH) throw new Error('PrevOutScript must be P2WSH')\n\n    var scriptHash = bscript.decompile(input.prevOutScript)[1]\n    if (!scriptHash.equals(witnessScriptHash)) throw new Error('Inconsistent sha25(WitnessScript)')\n  }\n}\n\nfunction prepareInput (input, kpPubKey, redeemScript, witnessValue, witnessScript) {\n  var expanded\n  var prevOutType\n  var prevOutScript\n\n  var p2sh = false\n  var p2shType\n  var redeemScriptHash\n\n  var witness = false\n  var p2wsh = false\n  var witnessType\n  var witnessScriptHash\n\n  var signType\n  var signScript\n\n  if (redeemScript && witnessScript) {\n    redeemScriptHash = bcrypto.hash160(redeemScript)\n    witnessScriptHash = bcrypto.sha256(witnessScript)\n    checkP2SHInput(input, redeemScriptHash)\n\n    if (!redeemScript.equals(btemplates.witnessScriptHash.output.encode(witnessScriptHash))) throw new Error('Witness script inconsistent with redeem script')\n\n    expanded = expandOutput(witnessScript, undefined, kpPubKey)\n    if (!expanded.pubKeys) throw new Error('WitnessScript not supported \"' + bscript.toASM(redeemScript) + '\"')\n\n    prevOutType = btemplates.types.P2SH\n    prevOutScript = btemplates.scriptHash.output.encode(redeemScriptHash)\n    p2sh = witness = p2wsh = true\n    p2shType = btemplates.types.P2WSH\n    signType = witnessType = expanded.scriptType\n    signScript = witnessScript\n  } else if (redeemScript) {\n    redeemScriptHash = bcrypto.hash160(redeemScript)\n    checkP2SHInput(input, redeemScriptHash)\n\n    expanded = expandOutput(redeemScript, undefined, kpPubKey)\n    if (!expanded.pubKeys) throw new Error('RedeemScript not supported \"' + bscript.toASM(redeemScript) + '\"')\n\n    prevOutType = btemplates.types.P2SH\n    prevOutScript = btemplates.scriptHash.output.encode(redeemScriptHash)\n    p2sh = true\n    signType = p2shType = expanded.scriptType\n    signScript = redeemScript\n    witness = signType === btemplates.types.P2WPKH\n  } else if (witnessScript) {\n    witnessScriptHash = bcrypto.sha256(witnessScript)\n    checkP2WSHInput(input, witnessScriptHash)\n\n    expanded = expandOutput(witnessScript, undefined, kpPubKey)\n    if (!expanded.pubKeys) throw new Error('WitnessScript not supported \"' + bscript.toASM(redeemScript) + '\"')\n\n    prevOutType = btemplates.types.P2WSH\n    prevOutScript = btemplates.witnessScriptHash.output.encode(witnessScriptHash)\n    witness = p2wsh = true\n    signType = witnessType = expanded.scriptType\n    signScript = witnessScript\n  } else if (input.prevOutType) {\n    // embedded scripts are not possible without a redeemScript\n    if (input.prevOutType === scriptTypes.P2SH ||\n      input.prevOutType === scriptTypes.P2WSH) {\n      throw new Error('PrevOutScript is ' + input.prevOutType + ', requires redeemScript')\n    }\n\n    prevOutType = input.prevOutType\n    prevOutScript = input.prevOutScript\n    expanded = expandOutput(input.prevOutScript, input.prevOutType, kpPubKey)\n    if (!expanded.pubKeys) return\n\n    witness = (input.prevOutType === scriptTypes.P2WPKH)\n    signType = prevOutType\n    signScript = prevOutScript\n  } else {\n    prevOutScript = btemplates.pubKeyHash.output.encode(bcrypto.hash160(kpPubKey))\n    expanded = expandOutput(prevOutScript, scriptTypes.P2PKH, kpPubKey)\n\n    prevOutType = scriptTypes.P2PKH\n    witness = false\n    signType = prevOutType\n    signScript = prevOutScript\n  }\n\n  if (signType === scriptTypes.P2WPKH) {\n    signScript = btemplates.pubKeyHash.output.encode(btemplates.witnessPubKeyHash.output.decode(signScript))\n  }\n\n  if (p2sh) {\n    input.redeemScript = redeemScript\n    input.redeemScriptType = p2shType\n  }\n\n  if (p2wsh) {\n    input.witnessScript = witnessScript\n    input.witnessScriptType = witnessType\n  }\n\n  input.pubKeys = expanded.pubKeys\n  input.signatures = expanded.signatures\n  input.signScript = signScript\n  input.signType = signType\n  input.prevOutScript = prevOutScript\n  input.prevOutType = prevOutType\n  input.witness = witness\n}\n\nfunction buildStack (type, signatures, pubKeys, allowIncomplete) {\n  if (type === scriptTypes.P2PKH) {\n    if (signatures.length === 1 && Buffer.isBuffer(signatures[0]) && pubKeys.length === 1) return btemplates.pubKeyHash.input.encodeStack(signatures[0], pubKeys[0])\n  } else if (type === scriptTypes.P2PK) {\n    if (signatures.length === 1 && Buffer.isBuffer(signatures[0])) return btemplates.pubKey.input.encodeStack(signatures[0])\n  } else if (type === scriptTypes.MULTISIG) {\n    if (signatures.length > 0) {\n      signatures = signatures.map(function (signature) {\n        return signature || ops.OP_0\n      })\n      if (!allowIncomplete) {\n        // remove blank signatures\n        signatures = signatures.filter(function (x) { return x !== ops.OP_0 })\n      }\n\n      return btemplates.multisig.input.encodeStack(signatures)\n    }\n  } else {\n    throw new Error('Not yet supported')\n  }\n\n  if (!allowIncomplete) throw new Error('Not enough signatures provided')\n  return []\n}\n\nfunction buildInput (input, allowIncomplete) {\n  var scriptType = input.prevOutType\n  var sig = []\n  var witness = []\n\n  if (supportedType(scriptType)) {\n    sig = buildStack(scriptType, input.signatures, input.pubKeys, allowIncomplete)\n  }\n\n  var p2sh = false\n  if (scriptType === btemplates.types.P2SH) {\n    // We can remove this error later when we have a guarantee prepareInput\n    // rejects unsignable scripts - it MUST be signable at this point.\n    if (!allowIncomplete && !supportedP2SHType(input.redeemScriptType)) {\n      throw new Error('Impossible to sign this type')\n    }\n\n    if (supportedType(input.redeemScriptType)) {\n      sig = buildStack(input.redeemScriptType, input.signatures, input.pubKeys, allowIncomplete)\n    }\n\n    // If it wasn't SIGNABLE, it's witness, defer to that\n    if (input.redeemScriptType) {\n      p2sh = true\n      scriptType = input.redeemScriptType\n    }\n  }\n\n  switch (scriptType) {\n    // P2WPKH is a special case of P2PKH\n    case btemplates.types.P2WPKH:\n      witness = buildStack(btemplates.types.P2PKH, input.signatures, input.pubKeys, allowIncomplete)\n      break\n\n    case btemplates.types.P2WSH:\n      // We can remove this check later\n      if (!allowIncomplete && !supportedType(input.witnessScriptType)) {\n        throw new Error('Impossible to sign this type')\n      }\n\n      if (supportedType(input.witnessScriptType)) {\n        witness = buildStack(input.witnessScriptType, input.signatures, input.pubKeys, allowIncomplete)\n        witness.push(input.witnessScript)\n        scriptType = input.witnessScriptType\n      }\n\n      break\n  }\n\n  // append redeemScript if necessary\n  if (p2sh) {\n    sig.push(input.redeemScript)\n  }\n\n  return {\n    type: scriptType,\n    script: bscript.compile(sig),\n    witness: witness\n  }\n}\n\nfunction TransactionBuilder (network, maximumFeeRate) {\n  this.prevTxMap = {}\n  this.network = network || networks.bitcoin\n\n  // WARNING: This is __NOT__ to be relied on, its just another potential safety mechanism (safety in-depth)\n  this.maximumFeeRate = maximumFeeRate || 2500\n\n  this.inputs = []\n  this.bitcoinCash = true\n  this.tx = new Transaction()\n}\n\nTransactionBuilder.prototype.setLockTime = function (locktime) {\n  typeforce(types.UInt32, locktime)\n\n  // if any signatures exist, throw\n  if (this.inputs.some(function (input) {\n    if (!input.signatures) return false\n\n    return input.signatures.some(function (s) { return s })\n  })) {\n    throw new Error('No, this would invalidate signatures')\n  }\n\n  this.tx.locktime = locktime\n}\n\nTransactionBuilder.fromTransaction = function (transaction, network, bitcoinCashTx) {\n  var txb = new TransactionBuilder(network)\n\n  // Copy transaction fields\n  txb.setLockTime(transaction.locktime)\n\n  // Copy outputs (done first to avoid signature invalidation)\n  transaction.outs.forEach(function (txOut) {\n    txb.addOutput(txOut.script, txOut.value)\n  })\n\n  // Copy inputs\n  transaction.ins.forEach(function (txIn) {\n    txb.__addInputUnsafe(txIn.hash, txIn.index, {\n      sequence: txIn.sequence,\n      script: txIn.script,\n      witness: txIn.witness,\n      value: txIn.value\n    })\n  })\n\n  // fix some things not possible through the public API\n  txb.inputs.forEach(function (input, i) {\n    fixMultisigOrder(input, transaction, i, input.value, bitcoinCashTx)\n  })\n\n  return txb\n}\n\nTransactionBuilder.prototype.addInput = function (txHash, vout, sequence, prevOutScript) {\n  if (!this.__canModifyInputs()) {\n    throw new Error('No, this would invalidate signatures')\n  }\n\n  var value\n\n  // is it a hex string?\n  if (typeof txHash === 'string') {\n    // transaction hashs's are displayed in reverse order, un-reverse it\n    txHash = Buffer.from(txHash, 'hex').reverse()\n\n  // is it a Transaction object?\n  } else if (txHash instanceof Transaction) {\n    var txOut = txHash.outs[vout]\n    prevOutScript = txOut.script\n    value = txOut.value\n\n    txHash = txHash.getHash()\n  }\n\n  return this.__addInputUnsafe(txHash, vout, {\n    sequence: sequence,\n    prevOutScript: prevOutScript,\n    value: value\n  })\n}\n\nTransactionBuilder.prototype.__addInputUnsafe = function (txHash, vout, options) {\n  if (Transaction.isCoinbaseHash(txHash)) {\n    throw new Error('coinbase inputs not supported')\n  }\n\n  var prevTxOut = txHash.toString('hex') + ':' + vout\n  if (this.prevTxMap[prevTxOut] !== undefined) throw new Error('Duplicate TxOut: ' + prevTxOut)\n\n  var input = {}\n\n  // derive what we can from the scriptSig\n  if (options.script !== undefined) {\n    input = expandInput(options.script, options.witness || [])\n  }\n\n  // if an input value was given, retain it\n  if (options.value !== undefined) {\n    input.value = options.value\n  }\n\n  // derive what we can from the previous transactions output script\n  if (!input.prevOutScript && options.prevOutScript) {\n    var prevOutType\n\n    if (!input.pubKeys && !input.signatures) {\n      var expanded = expandOutput(options.prevOutScript)\n\n      if (expanded.pubKeys) {\n        input.pubKeys = expanded.pubKeys\n        input.signatures = expanded.signatures\n      }\n\n      prevOutType = expanded.scriptType\n    }\n\n    input.prevOutScript = options.prevOutScript\n    input.prevOutType = prevOutType || btemplates.classifyOutput(options.prevOutScript)\n  }\n\n  var vin = this.tx.addInput(txHash, vout, options.sequence, options.scriptSig)\n  this.inputs[vin] = input\n  this.prevTxMap[prevTxOut] = vin\n  return vin\n}\n\nTransactionBuilder.prototype.addOutput = function (scriptPubKey, value) {\n  if (!this.__canModifyOutputs()) {\n    throw new Error('No, this would invalidate signatures')\n  }\n\n  // Attempt to get a script if it's a base58 address string\n  if (typeof scriptPubKey === 'string') {\n    scriptPubKey = baddress.toOutputScript(scriptPubKey, this.network)\n  }\n\n  return this.tx.addOutput(scriptPubKey, value)\n}\n\nTransactionBuilder.prototype.build = function () {\n  return this.__build(false)\n}\nTransactionBuilder.prototype.buildIncomplete = function () {\n  return this.__build(true)\n}\n\nTransactionBuilder.prototype.__build = function (allowIncomplete) {\n  if (!allowIncomplete) {\n    if (!this.tx.ins.length) throw new Error('Transaction has no inputs')\n    if (!this.tx.outs.length) throw new Error('Transaction has no outputs')\n  }\n\n  var tx = this.tx.clone()\n  // Create script signatures from inputs\n  this.inputs.forEach(function (input, i) {\n    var scriptType = input.witnessScriptType || input.redeemScriptType || input.prevOutType\n    if (!scriptType && !allowIncomplete) throw new Error('Transaction is not complete')\n    var result = buildInput(input, allowIncomplete)\n\n    // skip if no result\n    if (!allowIncomplete) {\n      if (!supportedType(result.type) && result.type !== btemplates.types.P2WPKH) {\n        throw new Error(result.type + ' not supported')\n      }\n    }\n\n    tx.setInputScript(i, result.script)\n    tx.setWitness(i, result.witness)\n  })\n\n  if (!allowIncomplete) {\n    // do not rely on this, its merely a last resort\n    if (this.__overMaximumFees(tx.virtualSize())) {\n      throw new Error('Transaction has absurd fees')\n    }\n  }\n\n  return tx\n}\n\nfunction canSign (input) {\n  return input.prevOutScript !== undefined &&\n    input.signScript !== undefined &&\n    input.pubKeys !== undefined &&\n    input.signatures !== undefined &&\n    input.signatures.length === input.pubKeys.length &&\n    input.pubKeys.length > 0 &&\n    (\n      input.witness === false ||\n      (input.witness === true && input.value !== undefined)\n    )\n}\n\nTransactionBuilder.prototype.sign = function (vin, keyPair, redeemScript, hashType, witnessValue, witnessScript, signatureAlgorithm) {\n  hashType = hashType | Transaction.SIGHASH_BITCOINCASHBIP143;\n\n  if (!this.inputs[vin]) throw new Error('No input at index: ' + vin)\n  hashType = hashType || Transaction.SIGHASH_ALL\n\n  var input = this.inputs[vin]\n\n  // if redeemScript was previously provided, enforce consistency\n  if (input.redeemScript !== undefined &&\n      redeemScript &&\n      !input.redeemScript.equals(redeemScript)) {\n    throw new Error('Inconsistent redeemScript')\n  }\n\n  var kpPubKey = keyPair.publicKey || keyPair.getPublicKeyBuffer()\n  if (!canSign(input)) {\n    if (witnessValue !== undefined) {\n      if (input.value !== undefined && input.value !== witnessValue) throw new Error('Input didn\\'t match witnessValue')\n      typeforce(types.Satoshi, witnessValue)\n      input.value = witnessValue\n    }\n\n    if (!canSign(input)) prepareInput(input, kpPubKey, redeemScript, witnessValue, witnessScript)\n    if (!canSign(input)) throw Error(input.prevOutType + ' not supported')\n  }\n\n  // ready to sign\n  // var signatureHash = this.tx.hashForCashSignature(vin, input.signScript, witnessValue, hashType)\n  var signatureHash = this.tx.hashForCashSignature(vin, input.signScript, witnessValue, hashType);\n  // if (this.bitcoinCash) {\n  //   signatureHash = this.tx.hashForCashSignature(vin, input.signScript, witnessValue, hashType)\n  // } else {\n  //   if (input.witness) {\n  //     signatureHash = this.tx.hashForWitnessV0(vin, input.signScript, witnessValue, hashType)\n  //   } else {\n  //     signatureHash = this.tx.hashForSignature(vin, input.signScript, hashType)\n  //   }\n  // }\n\n  // enforce in order signing of public keys\n  var signed = input.pubKeys.some(function (pubKey, i) {\n    if (!kpPubKey.equals(pubKey)) return false\n    if (input.signatures[i]) throw new Error('Signature already exists')\n    if (kpPubKey.length !== 33 &&\n      input.signType === scriptTypes.P2WPKH) throw new Error('BIP143 rejects uncompressed public keys in P2WPKH or P2WSH')\n\n    var signature = keyPair.sign(signatureHash, signatureAlgorithm)\n    if (Buffer.isBuffer(signature)) signature = ECSignature.fromRSBuffer(signature)\n\n    input.signatures[i] = signature.toScriptSignature(hashType, signatureAlgorithm)\n    return true\n  })\n\n  if (!signed) throw new Error('Key pair cannot sign for this input')\n}\n\nfunction signatureHashType (buffer) {\n  return buffer.readUInt8(buffer.length - 1)\n}\n\nTransactionBuilder.prototype.__canModifyInputs = function () {\n  return this.inputs.every(function (input) {\n    // any signatures?\n    if (input.signatures === undefined) return true\n\n    return input.signatures.every(function (signature) {\n      if (!signature) return true\n      var hashType = signatureHashType(signature)\n\n      // if SIGHASH_ANYONECANPAY is set, signatures would not\n      // be invalidated by more inputs\n      return hashType & Transaction.SIGHASH_ANYONECANPAY\n    })\n  })\n}\n\nTransactionBuilder.prototype.__canModifyOutputs = function () {\n  var nInputs = this.tx.ins.length\n  var nOutputs = this.tx.outs.length\n\n  return this.inputs.every(function (input) {\n    if (input.signatures === undefined) return true\n\n    return input.signatures.every(function (signature) {\n      if (!signature) return true\n      var hashType = signatureHashType(signature)\n\n      var hashTypeMod = hashType & 0x1f\n      if (hashTypeMod === Transaction.SIGHASH_NONE) return true\n      if (hashTypeMod === Transaction.SIGHASH_SINGLE) {\n        // if SIGHASH_SINGLE is set, and nInputs > nOutputs\n        // some signatures would be invalidated by the addition\n        // of more outputs\n        return nInputs <= nOutputs\n      }\n    })\n  })\n}\n\nTransactionBuilder.prototype.__overMaximumFees = function (bytes) {\n  // not all inputs will have .value defined\n  var incoming = this.inputs.reduce(function (a, x) { return a + (x.value >>> 0) }, 0)\n\n  // but all outputs do, and if we have any input value\n  // we can immediately determine if the outputs are too small\n  var outgoing = this.tx.outs.reduce(function (a, x) { return a + x.value }, 0)\n  var fee = incoming - outgoing\n  var feeRate = fee / bytes\n\n  return feeRate > this.maximumFeeRate\n}\n\nmodule.exports = TransactionBuilder\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}