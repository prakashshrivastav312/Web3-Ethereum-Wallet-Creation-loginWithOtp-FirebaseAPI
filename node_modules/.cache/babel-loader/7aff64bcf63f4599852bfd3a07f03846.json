{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n\nconst NETWORKS = require('./networks');\n\nconst types = require('./types');\n\nconst ecc = require('tiny-secp256k1');\n\nconst randomBytes = require('randombytes');\n\nconst typeforce = require('typeforce');\n\nconst wif = require('wif');\n\nconst isOptions = typeforce.maybe(typeforce.compile({\n  compressed: types.maybe(types.Boolean),\n  network: types.maybe(types.Network)\n}));\n\nclass ECPair {\n  constructor(__D, __Q, options) {\n    this.__D = __D;\n    this.__Q = __Q;\n    this.lowR = false;\n    if (options === undefined) options = {};\n    this.compressed = options.compressed === undefined ? true : options.compressed;\n    this.network = options.network || NETWORKS.bitcoin;\n    if (__Q !== undefined) this.__Q = ecc.pointCompress(__Q, this.compressed);\n  }\n\n  get privateKey() {\n    return this.__D;\n  }\n\n  get publicKey() {\n    if (!this.__Q) this.__Q = ecc.pointFromScalar(this.__D, this.compressed);\n    return this.__Q;\n  }\n\n  toWIF() {\n    if (!this.__D) throw new Error('Missing private key');\n    return wif.encode(this.network.wif, this.__D, this.compressed);\n  }\n\n  sign(hash, lowR) {\n    if (!this.__D) throw new Error('Missing private key');\n    if (lowR === undefined) lowR = this.lowR;\n\n    if (lowR === false) {\n      return ecc.sign(hash, this.__D);\n    } else {\n      let sig = ecc.sign(hash, this.__D);\n      const extraData = Buffer.alloc(32, 0);\n      let counter = 0; // if first try is lowR, skip the loop\n      // for second try and on, add extra entropy counting up\n\n      while (sig[0] > 0x7f) {\n        counter++;\n        extraData.writeUIntLE(counter, 0, 6);\n        sig = ecc.signWithEntropy(hash, this.__D, extraData);\n      }\n\n      return sig;\n    }\n  }\n\n  verify(hash, signature) {\n    return ecc.verify(hash, this.publicKey, signature);\n  }\n\n}\n\nfunction fromPrivateKey(buffer, options) {\n  typeforce(types.Buffer256bit, buffer);\n  if (!ecc.isPrivate(buffer)) throw new TypeError('Private key not in range [1, n)');\n  typeforce(isOptions, options);\n  return new ECPair(buffer, undefined, options);\n}\n\nexports.fromPrivateKey = fromPrivateKey;\n\nfunction fromPublicKey(buffer, options) {\n  typeforce(ecc.isPoint, buffer);\n  typeforce(isOptions, options);\n  return new ECPair(undefined, buffer, options);\n}\n\nexports.fromPublicKey = fromPublicKey;\n\nfunction fromWIF(wifString, network) {\n  const decoded = wif.decode(wifString);\n  const version = decoded.version; // list of networks?\n\n  if (types.Array(network)) {\n    network = network.filter(x => {\n      return version === x.wif;\n    }).pop();\n    if (!network) throw new Error('Unknown network version'); // otherwise, assume a network object (or default to bitcoin)\n  } else {\n    network = network || NETWORKS.bitcoin;\n    if (version !== network.wif) throw new Error('Invalid network version');\n  }\n\n  return fromPrivateKey(decoded.privateKey, {\n    compressed: decoded.compressed,\n    network: network\n  });\n}\n\nexports.fromWIF = fromWIF;\n\nfunction makeRandom(options) {\n  typeforce(isOptions, options);\n  if (options === undefined) options = {};\n  const rng = options.rng || randomBytes;\n  let d;\n\n  do {\n    d = rng(32);\n    typeforce(types.Buffer256bit, d);\n  } while (!ecc.isPrivate(d));\n\n  return fromPrivateKey(d, options);\n}\n\nexports.makeRandom = makeRandom;","map":{"version":3,"names":["Object","defineProperty","exports","value","NETWORKS","require","types","ecc","randomBytes","typeforce","wif","isOptions","maybe","compile","compressed","Boolean","network","Network","ECPair","constructor","__D","__Q","options","lowR","undefined","bitcoin","pointCompress","privateKey","publicKey","pointFromScalar","toWIF","Error","encode","sign","hash","sig","extraData","Buffer","alloc","counter","writeUIntLE","signWithEntropy","verify","signature","fromPrivateKey","buffer","Buffer256bit","isPrivate","TypeError","fromPublicKey","isPoint","fromWIF","wifString","decoded","decode","version","Array","filter","x","pop","makeRandom","rng","d"],"sources":["C:/Users/acer/node_modules/bitcoinjs-lib/src/ecpair.js"],"sourcesContent":["'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nconst NETWORKS = require('./networks');\nconst types = require('./types');\nconst ecc = require('tiny-secp256k1');\nconst randomBytes = require('randombytes');\nconst typeforce = require('typeforce');\nconst wif = require('wif');\nconst isOptions = typeforce.maybe(\n  typeforce.compile({\n    compressed: types.maybe(types.Boolean),\n    network: types.maybe(types.Network),\n  }),\n);\nclass ECPair {\n  constructor(__D, __Q, options) {\n    this.__D = __D;\n    this.__Q = __Q;\n    this.lowR = false;\n    if (options === undefined) options = {};\n    this.compressed =\n      options.compressed === undefined ? true : options.compressed;\n    this.network = options.network || NETWORKS.bitcoin;\n    if (__Q !== undefined) this.__Q = ecc.pointCompress(__Q, this.compressed);\n  }\n  get privateKey() {\n    return this.__D;\n  }\n  get publicKey() {\n    if (!this.__Q) this.__Q = ecc.pointFromScalar(this.__D, this.compressed);\n    return this.__Q;\n  }\n  toWIF() {\n    if (!this.__D) throw new Error('Missing private key');\n    return wif.encode(this.network.wif, this.__D, this.compressed);\n  }\n  sign(hash, lowR) {\n    if (!this.__D) throw new Error('Missing private key');\n    if (lowR === undefined) lowR = this.lowR;\n    if (lowR === false) {\n      return ecc.sign(hash, this.__D);\n    } else {\n      let sig = ecc.sign(hash, this.__D);\n      const extraData = Buffer.alloc(32, 0);\n      let counter = 0;\n      // if first try is lowR, skip the loop\n      // for second try and on, add extra entropy counting up\n      while (sig[0] > 0x7f) {\n        counter++;\n        extraData.writeUIntLE(counter, 0, 6);\n        sig = ecc.signWithEntropy(hash, this.__D, extraData);\n      }\n      return sig;\n    }\n  }\n  verify(hash, signature) {\n    return ecc.verify(hash, this.publicKey, signature);\n  }\n}\nfunction fromPrivateKey(buffer, options) {\n  typeforce(types.Buffer256bit, buffer);\n  if (!ecc.isPrivate(buffer))\n    throw new TypeError('Private key not in range [1, n)');\n  typeforce(isOptions, options);\n  return new ECPair(buffer, undefined, options);\n}\nexports.fromPrivateKey = fromPrivateKey;\nfunction fromPublicKey(buffer, options) {\n  typeforce(ecc.isPoint, buffer);\n  typeforce(isOptions, options);\n  return new ECPair(undefined, buffer, options);\n}\nexports.fromPublicKey = fromPublicKey;\nfunction fromWIF(wifString, network) {\n  const decoded = wif.decode(wifString);\n  const version = decoded.version;\n  // list of networks?\n  if (types.Array(network)) {\n    network = network\n      .filter(x => {\n        return version === x.wif;\n      })\n      .pop();\n    if (!network) throw new Error('Unknown network version');\n    // otherwise, assume a network object (or default to bitcoin)\n  } else {\n    network = network || NETWORKS.bitcoin;\n    if (version !== network.wif) throw new Error('Invalid network version');\n  }\n  return fromPrivateKey(decoded.privateKey, {\n    compressed: decoded.compressed,\n    network: network,\n  });\n}\nexports.fromWIF = fromWIF;\nfunction makeRandom(options) {\n  typeforce(isOptions, options);\n  if (options === undefined) options = {};\n  const rng = options.rng || randomBytes;\n  let d;\n  do {\n    d = rng(32);\n    typeforce(types.Buffer256bit, d);\n  } while (!ecc.isPrivate(d));\n  return fromPrivateKey(d, options);\n}\nexports.makeRandom = makeRandom;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}