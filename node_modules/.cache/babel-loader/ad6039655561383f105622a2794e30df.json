{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  Object.defineProperty(o, k2, {\n    enumerable: true,\n    get: function () {\n      return m[k];\n    }\n  });\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.TypeMapper = void 0;\n\nconst errors = __importStar(require(\"../../errors\"));\n\nconst address_1 = require(\"./address\");\n\nconst boolean_1 = require(\"./boolean\");\n\nconst bytes_1 = require(\"./bytes\");\n\nconst composite_1 = require(\"./composite\");\n\nconst enum_1 = require(\"./enum\");\n\nconst generic_1 = require(\"./generic\");\n\nconst h256_1 = require(\"./h256\");\n\nconst numerical_1 = require(\"./numerical\");\n\nconst struct_1 = require(\"./struct\");\n\nconst tokenIdentifier_1 = require(\"./tokenIdentifier\");\n\nconst variadic_1 = require(\"./variadic\");\n\nconst algebraic_1 = require(\"./algebraic\");\n\nconst _1 = require(\".\");\n\nclass TypeMapper {\n  constructor() {\n    let customTypes = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n    this.openTypesConstructors = new Map([[\"Option\", generic_1.OptionType], [\"List\", generic_1.ListType], // For the following open generics, we use a slightly different typing than the one defined by elrond-wasm-rs (temporary workaround).\n    [\"VarArgs\", variadic_1.VariadicType], [\"MultiResultVec\", variadic_1.VariadicType], [\"variadic\", variadic_1.VariadicType], [\"OptionalArg\", algebraic_1.OptionalType], [\"optional\", algebraic_1.OptionalType], [\"OptionalResult\", algebraic_1.OptionalType], [\"multi\", composite_1.CompositeType], [\"MultiArg\", composite_1.CompositeType], [\"MultiResult\", composite_1.CompositeType], [\"multi\", composite_1.CompositeType], // Perhaps we can adjust the ABI generator to only output \"tuple\", instead of \"tupleN\"?\n    [\"tuple\", _1.TupleType], [\"tuple2\", _1.TupleType], [\"tuple3\", _1.TupleType], [\"tuple4\", _1.TupleType], [\"tuple5\", _1.TupleType], [\"tuple6\", _1.TupleType], [\"tuple7\", _1.TupleType], [\"tuple8\", _1.TupleType]]); // For closed types, we hold actual type instances instead of type constructors (no type parameters needed).\n\n    this.closedTypesMap = new Map([[\"u8\", new numerical_1.U8Type()], [\"u16\", new numerical_1.U16Type()], [\"u32\", new numerical_1.U32Type()], [\"u64\", new numerical_1.U64Type()], [\"U64\", new numerical_1.U64Type()], [\"BigUint\", new numerical_1.BigUIntType()], [\"i8\", new numerical_1.I8Type()], [\"i16\", new numerical_1.I16Type()], [\"i32\", new numerical_1.I32Type()], [\"i64\", new numerical_1.I64Type()], [\"Bigint\", new numerical_1.BigIntType()], [\"BigInt\", new numerical_1.BigIntType()], [\"bool\", new boolean_1.BooleanType()], [\"bytes\", new bytes_1.BytesType()], [\"Address\", new address_1.AddressType()], [\"H256\", new h256_1.H256Type()], [\"utf-8 string\", new _1.StringType()], [\"TokenIdentifier\", new tokenIdentifier_1.TokenIdentifierType()]]);\n\n    for (const customType of customTypes) {\n      this.closedTypesMap.set(customType.getName(), customType);\n    }\n  }\n\n  mapType(type) {\n    let isGeneric = type.isGenericType();\n\n    if (type instanceof enum_1.EnumType) {\n      return type;\n    }\n\n    if (type instanceof struct_1.StructType) {\n      // This will call mapType() recursively, for all the struct's fields.\n      return this.mapStructType(type);\n    }\n\n    if (isGeneric) {\n      // This will call mapType() recursively, for all the type parameters.\n      return this.mapGenericType(type);\n    }\n\n    let knownClosedType = this.closedTypesMap.get(type.getName());\n\n    if (!knownClosedType) {\n      throw new errors.ErrTypingSystem(`Cannot map the type \"${type.getName()}\" to a known type`);\n    }\n\n    return knownClosedType;\n  }\n\n  feedCustomType(type) {\n    this.closedTypesMap.delete(type.getName());\n    this.closedTypesMap.set(type.getName(), type);\n  }\n\n  mapStructType(type) {\n    let mappedFields = type.fields.map(item => new struct_1.StructFieldDefinition(item.name, item.description, this.mapType(item.type)));\n    let mappedStruct = new struct_1.StructType(type.getName(), mappedFields);\n    return mappedStruct;\n  }\n\n  mapGenericType(type) {\n    let typeParameters = type.getTypeParameters();\n    let mappedTypeParameters = typeParameters.map(item => this.mapType(item));\n    let constructor = this.openTypesConstructors.get(type.getName());\n\n    if (!constructor) {\n      throw new errors.ErrTypingSystem(`Cannot map the generic type \"${type.getName()}\" to a known type`);\n    }\n\n    return new constructor(...mappedTypeParameters);\n  }\n\n}\n\nexports.TypeMapper = TypeMapper;","map":{"version":3,"mappings":"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","names":["TypeMapper","constructor","customTypes","openTypesConstructors","Map","generic_1","variadic_1","algebraic_1","composite_1","_1","closedTypesMap","numerical_1","boolean_1","bytes_1","address_1","h256_1","tokenIdentifier_1","customType","set","getName","mapType","type","isGeneric","isGenericType","enum_1","struct_1","mapStructType","mapGenericType","knownClosedType","get","errors","ErrTypingSystem","feedCustomType","delete","mappedFields","fields","map","item","name","description","mappedStruct","typeParameters","getTypeParameters","mappedTypeParameters","exports"],"sourceRoot":"","sources":["../../../src/smartcontracts/typesystem/typeMapper.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}