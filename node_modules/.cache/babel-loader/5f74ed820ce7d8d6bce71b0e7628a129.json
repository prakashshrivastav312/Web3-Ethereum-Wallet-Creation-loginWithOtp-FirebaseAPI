{"ast":null,"code":"\"use strict\";\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getFaucetUrl = exports.FaucetNetwork = void 0;\n\nconst https = require(\"https\");\n\nconst common_1 = require(\"../common\");\n\nconst schema_validator_1 = require(\"../common/schema-validator\");\n\nconst errors_1 = require(\"../common/errors\");\n\nvar FaucetNetwork;\n\n(function (FaucetNetwork) {\n  FaucetNetwork[\"Testnet\"] = \"faucet.altnet.rippletest.net\";\n  FaucetNetwork[\"Devnet\"] = \"faucet.devnet.rippletest.net\";\n})(FaucetNetwork = exports.FaucetNetwork || (exports.FaucetNetwork = {}));\n\nconst INTERVAL_SECONDS = 1;\nconst MAX_ATTEMPTS = 20;\n\nfunction generateFaucetWallet(address) {\n  return __awaiter(this, void 0, void 0, function* () {\n    if (!this.isConnected()) throw new errors_1.RippledError(\"RippleAPI not connected, cannot call faucet\");\n    let body;\n    let startingBalance = 0;\n    let faucetUrl = getFaucetUrl(this);\n\n    if (address && schema_validator_1.isValidAddress(address)) {\n      body = new TextEncoder().encode(JSON.stringify({\n        destination: address\n      }));\n      const addressToFundBalance = yield getAddressXrpBalance(this, address);\n\n      if (addressToFundBalance && !isNaN(+addressToFundBalance)) {\n        startingBalance = +addressToFundBalance;\n      } else {\n        startingBalance = 0;\n      }\n    }\n\n    const options = {\n      hostname: faucetUrl,\n      port: 443,\n      path: '/accounts',\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json',\n        'Content-Length': body ? body.length : 0\n      }\n    };\n    return new Promise((resolve, reject) => {\n      const request = https.request(options, response => {\n        const chunks = [];\n        response.on('data', d => {\n          chunks.push(d);\n        });\n        response.on('end', () => __awaiter(this, void 0, void 0, function* () {\n          const body = Buffer.concat(chunks).toString();\n\n          if (response.headers['content-type'].startsWith('application/json')) {\n            const wallet = JSON.parse(body);\n            const classicAddress = wallet.account.classicAddress;\n\n            if (classicAddress) {\n              try {\n                const isFunded = yield hasAddressBalanceIncreased(this, classicAddress, startingBalance);\n\n                if (isFunded) {\n                  resolve(wallet);\n                } else {\n                  reject(new common_1.errors.XRPLFaucetError(`Unable to fund address with faucet after waiting ${INTERVAL_SECONDS * MAX_ATTEMPTS} seconds`));\n                }\n              } catch (err) {\n                reject(new common_1.errors.XRPLFaucetError(err));\n              }\n            } else {\n              reject(new common_1.errors.XRPLFaucetError(`The faucet account classic address is undefined`));\n            }\n          } else {\n            reject({\n              statusCode: response.statusCode,\n              contentType: response.headers['content-type'],\n              body\n            });\n          }\n        }));\n      });\n      request.write(body ? body : '');\n      request.on('error', error => {\n        reject(error);\n      });\n      request.end();\n    });\n  });\n}\n\nfunction getAddressXrpBalance(api, address) {\n  return __awaiter(this, void 0, void 0, function* () {\n    try {\n      const balances = yield api.getBalances(address);\n      const xrpBalance = balances.filter(balance => balance.currency.toUpperCase() === 'XRP');\n      return xrpBalance[0].value;\n    } catch (err) {\n      return `Unable to retrieve ${address} balance. Error: ${err}`;\n    }\n  });\n}\n\nfunction hasAddressBalanceIncreased(api, address, originalBalance) {\n  return __awaiter(this, void 0, void 0, function* () {\n    return new Promise((resolve, reject) => {\n      let attempts = MAX_ATTEMPTS;\n      const interval = setInterval(() => __awaiter(this, void 0, void 0, function* () {\n        if (attempts < 0) {\n          clearInterval(interval);\n          resolve(false);\n        } else {\n          attempts--;\n        }\n\n        try {\n          const newBalance = +(yield getAddressXrpBalance(api, address));\n\n          if (newBalance > originalBalance) {\n            clearInterval(interval);\n            resolve(true);\n          }\n        } catch (err) {\n          clearInterval(interval);\n          reject(new common_1.errors.XRPLFaucetError(`Unable to check if the address ${address} balance has increased. Error: ${err}`));\n        }\n      }), INTERVAL_SECONDS * 1000);\n    });\n  });\n}\n\nfunction getFaucetUrl(api) {\n  const connectionUrl = api.connection.getUrl();\n\n  if (connectionUrl.includes('altnet') || connectionUrl.includes('testnet')) {\n    return FaucetNetwork.Testnet;\n  }\n\n  if (connectionUrl.includes('devnet')) {\n    return FaucetNetwork.Devnet;\n  }\n\n  return undefined;\n}\n\nexports.getFaucetUrl = getFaucetUrl;\nexports.default = generateFaucetWallet;","map":{"version":3,"mappings":"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","names":["FaucetNetwork","exports","INTERVAL_SECONDS","MAX_ATTEMPTS","generateFaucetWallet","address","isConnected","errors_1","body","startingBalance","faucetUrl","getFaucetUrl","schema_validator_1","TextEncoder","encode","JSON","stringify","destination","addressToFundBalance","getAddressXrpBalance","isNaN","options","hostname","port","path","method","headers","length","Promise","resolve","reject","request","https","response","chunks","on","d","push","__awaiter","Buffer","concat","toString","startsWith","wallet","parse","classicAddress","account","isFunded","hasAddressBalanceIncreased","common_1","XRPLFaucetError","err","statusCode","contentType","write","error","end","api","balances","getBalances","xrpBalance","filter","balance","currency","toUpperCase","value","originalBalance","attempts","interval","setInterval","clearInterval","newBalance","connectionUrl","connection","getUrl","includes","Testnet","Devnet","undefined"],"sourceRoot":"","sources":["../../../src/wallet/wallet-generation.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}