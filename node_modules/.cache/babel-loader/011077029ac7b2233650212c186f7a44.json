{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  Object.defineProperty(o, k2, {\n    enumerable: true,\n    get: function () {\n      return m[k];\n    }\n  });\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.UserPublicKey = exports.UserSecretKey = exports.USER_PUBKEY_LENGTH = exports.USER_SEED_LENGTH = void 0;\n\nconst tweetnacl = __importStar(require(\"tweetnacl\"));\n\nconst address_1 = require(\"../address\");\n\nconst utils_1 = require(\"../utils\");\n\nconst pem_1 = require(\"./pem\");\n\nconst logger_1 = require(\"../logger\");\n\nexports.USER_SEED_LENGTH = 32;\nexports.USER_PUBKEY_LENGTH = 32;\n\nclass UserSecretKey {\n  constructor(buffer) {\n    utils_1.guardLength(buffer, exports.USER_SEED_LENGTH);\n    this.buffer = buffer;\n  }\n\n  static fromString(value) {\n    utils_1.guardLength(value, exports.USER_SEED_LENGTH * 2);\n    let buffer = Buffer.from(value, \"hex\");\n    return new UserSecretKey(buffer);\n  }\n\n  static fromPem(text) {\n    let index = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    return pem_1.parseUserKey(text, index);\n  }\n\n  generatePublicKey() {\n    let keyPair = tweetnacl.sign.keyPair.fromSeed(new Uint8Array(this.buffer));\n    let buffer = Buffer.from(keyPair.publicKey);\n    return new UserPublicKey(buffer);\n  }\n\n  sign(message) {\n    let pair = tweetnacl.sign.keyPair.fromSeed(new Uint8Array(this.buffer));\n    let signingKey = pair.secretKey;\n    let signature = tweetnacl.sign(new Uint8Array(message), signingKey); // \"tweetnacl.sign()\" returns the concatenated [signature, message], therfore we remove the appended message:\n\n    signature = signature.slice(0, signature.length - message.length);\n    return Buffer.from(signature);\n  }\n\n  hex() {\n    return this.buffer.toString(\"hex\");\n  }\n\n  valueOf() {\n    return this.buffer;\n  }\n\n}\n\nexports.UserSecretKey = UserSecretKey;\n\nclass UserPublicKey {\n  constructor(buffer) {\n    utils_1.guardLength(buffer, exports.USER_PUBKEY_LENGTH);\n    this.buffer = buffer;\n  }\n\n  verify(message, signature) {\n    try {\n      const unopenedMessage = Buffer.concat([signature, message]);\n      const unsignedMessage = tweetnacl.sign.open(unopenedMessage, this.buffer);\n      return unsignedMessage != null;\n    } catch (err) {\n      logger_1.Logger.error(err);\n      return false;\n    }\n  }\n\n  hex() {\n    return this.buffer.toString(\"hex\");\n  }\n\n  toAddress() {\n    return new address_1.Address(this.buffer);\n  }\n\n  valueOf() {\n    return this.buffer;\n  }\n\n}\n\nexports.UserPublicKey = UserPublicKey;","map":{"version":3,"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;;AACA;;AACA;;AACA;;AAEA;;AAEaA,2BAAmB,EAAnB;AACAA,6BAAqB,EAArB;;AAEb,MAAaC,aAAb,CAA0B;EAGtBC,YAAYC,MAAZ,EAA0B;IACtBC,oBAAYD,MAAZ,EAAoBH,wBAApB;IAEA,KAAKG,MAAL,GAAcA,MAAd;EACH;;EAEgB,OAAVE,UAAU,CAACC,KAAD,EAAc;IAC3BF,oBAAYE,KAAZ,EAAmBN,2BAAmB,CAAtC;IAEA,IAAIG,MAAM,GAAGI,MAAM,CAACC,IAAP,CAAYF,KAAZ,EAAmB,KAAnB,CAAb;IACA,OAAO,IAAIL,aAAJ,CAAkBE,MAAlB,CAAP;EACH;;EAEa,OAAPM,OAAO,CAACC,IAAD,EAAgC;IAAA,IAAjBC,KAAiB,uEAAD,CAAC;IAC1C,OAAOC,mBAAaF,IAAb,EAAmBC,KAAnB,CAAP;EACH;;EAEDE,iBAAiB;IACb,IAAIC,OAAO,GAAGC,SAAS,CAACC,IAAV,CAAeF,OAAf,CAAuBG,QAAvB,CAAgC,IAAIC,UAAJ,CAAe,KAAKf,MAApB,CAAhC,CAAd;IACA,IAAIA,MAAM,GAAGI,MAAM,CAACC,IAAP,CAAYM,OAAO,CAACK,SAApB,CAAb;IACA,OAAO,IAAIC,aAAJ,CAAkBjB,MAAlB,CAAP;EACH;;EAEDa,IAAI,CAACK,OAAD,EAAgB;IAChB,IAAIC,IAAI,GAAGP,SAAS,CAACC,IAAV,CAAeF,OAAf,CAAuBG,QAAvB,CAAgC,IAAIC,UAAJ,CAAe,KAAKf,MAApB,CAAhC,CAAX;IACA,IAAIoB,UAAU,GAAGD,IAAI,CAACE,SAAtB;IACA,IAAIC,SAAS,GAAGV,SAAS,CAACC,IAAV,CAAe,IAAIE,UAAJ,CAAeG,OAAf,CAAf,EAAwCE,UAAxC,CAAhB,CAHgB,CAIhB;;IACAE,SAAS,GAAGA,SAAS,CAACC,KAAV,CAAgB,CAAhB,EAAmBD,SAAS,CAACE,MAAV,GAAmBN,OAAO,CAACM,MAA9C,CAAZ;IAEA,OAAOpB,MAAM,CAACC,IAAP,CAAYiB,SAAZ,CAAP;EACH;;EAEDG,GAAG;IACC,OAAO,KAAKzB,MAAL,CAAY0B,QAAZ,CAAqB,KAArB,CAAP;EACH;;EAEDC,OAAO;IACH,OAAO,KAAK3B,MAAZ;EACH;;AA1CqB;;AAA1BH;;AA6CA,MAAaoB,aAAb,CAA0B;EAGtBlB,YAAYC,MAAZ,EAA0B;IACtBC,oBAAYD,MAAZ,EAAoBH,0BAApB;IAEA,KAAKG,MAAL,GAAcA,MAAd;EACH;;EAED4B,MAAM,CAACV,OAAD,EAAkBI,SAAlB,EAAmC;IACrC,IAAI;MACA,MAAMO,eAAe,GAAGzB,MAAM,CAAC0B,MAAP,CAAc,CAACR,SAAD,EAAYJ,OAAZ,CAAd,CAAxB;MACA,MAAMa,eAAe,GAAGnB,SAAS,CAACC,IAAV,CAAemB,IAAf,CAAoBH,eAApB,EAAqC,KAAK7B,MAA1C,CAAxB;MACA,OAAO+B,eAAe,IAAI,IAA1B;IACH,CAJD,CAIE,OAAOE,GAAP,EAAY;MACVC,gBAAOC,KAAP,CAAaF,GAAb;MACA,OAAO,KAAP;IACH;EACJ;;EAEDR,GAAG;IACC,OAAO,KAAKzB,MAAL,CAAY0B,QAAZ,CAAqB,KAArB,CAAP;EACH;;EAEDU,SAAS;IACL,OAAO,IAAIC,iBAAJ,CAAY,KAAKrC,MAAjB,CAAP;EACH;;EAED2B,OAAO;IACH,OAAO,KAAK3B,MAAZ;EACH;;AA9BqB;;AAA1BH","names":["exports","UserSecretKey","constructor","buffer","utils_1","fromString","value","Buffer","from","fromPem","text","index","pem_1","generatePublicKey","keyPair","tweetnacl","sign","fromSeed","Uint8Array","publicKey","UserPublicKey","message","pair","signingKey","secretKey","signature","slice","length","hex","toString","valueOf","verify","unopenedMessage","concat","unsignedMessage","open","err","logger_1","error","toAddress","address_1"],"sourceRoot":"","sources":["../../src/walletcore/userKeys.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}