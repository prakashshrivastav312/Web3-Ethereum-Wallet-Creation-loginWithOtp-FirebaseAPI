{"ast":null,"code":"\"use strict\";\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.HWProvider = void 0;\n\nconst hw_transport_u2f_1 = __importDefault(require(\"@ledgerhq/hw-transport-u2f\"));\n\nconst hw_transport_webusb_1 = __importDefault(require(\"@ledgerhq/hw-transport-webusb\")); // @ts-ignore\n\n\nconst hw_app_elrond_1 = __importDefault(require(\"@elrondnetwork/hw-app-elrond\"));\n\nconst platform_1 = __importDefault(require(\"platform\"));\n\nconst address_1 = require(\"../address\");\n\nconst signature_1 = require(\"../signature\");\n\nconst versioning_1 = require(\"../versioning\");\n\nconst constants_1 = require(\"./constants\");\n\nconst networkParams_1 = require(\"../networkParams\");\n\nclass HWProvider {\n  constructor(httpProvider) {\n    this.addressIndex = 0;\n    this.provider = httpProvider;\n  }\n  /**\n   * Creates transport and initialises ledger app.\n   */\n\n\n  init() {\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        let webUSBSupported = yield hw_transport_webusb_1.default.isSupported();\n        webUSBSupported = webUSBSupported && !!platform_1.default.os && platform_1.default.os.family !== \"Windows\" && platform_1.default.name !== \"Opera\";\n        const transport = webUSBSupported ? yield hw_transport_webusb_1.default.create() : yield hw_transport_u2f_1.default.create();\n        this.hwApp = new hw_app_elrond_1.default(transport);\n        return true;\n      } catch (error) {\n        return false;\n      }\n    });\n  }\n  /**\n   * Returns true if init() was previously called successfully\n   */\n\n\n  isInitialized() {\n    return !!this.hwApp;\n  }\n  /**\n   * Mocked function, returns isInitialized as an async function\n   */\n\n\n  isConnected() {\n    return new Promise((resolve, _) => resolve(this.isInitialized()));\n  }\n  /**\n   * Performs a login request by setting the selected index in Ledger and returning that address\n   */\n\n\n  login(options) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!this.hwApp) {\n        throw new Error(\"HWApp not initialised, call init() first\");\n      }\n\n      if (options && options.addressIndex) {\n        this.addressIndex = options.addressIndex;\n      }\n\n      yield this.hwApp.setAddress(0, this.addressIndex);\n      const {\n        address\n      } = yield this.hwApp.getAddress(0, this.addressIndex, true);\n      return address;\n    });\n  }\n\n  getAccounts() {\n    let page = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    let pageSize = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 10;\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!this.hwApp) {\n        throw new Error(\"HWApp not initialised, call init() first\");\n      }\n\n      const addresses = [];\n      const startIndex = page * pageSize;\n\n      for (let index = startIndex; index < startIndex + pageSize; index++) {\n        const {\n          address\n        } = yield this.hwApp.getAddress(0, index);\n        addresses.push(address);\n      }\n\n      return addresses;\n    });\n  }\n  /**\n   * Mocks a logout request by returning true\n   */\n\n\n  logout() {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!this.hwApp) {\n        throw new Error(\"HWApp not initialised, call init() first\");\n      }\n\n      return true;\n    });\n  }\n  /**\n   * Fetches current selected ledger address\n   */\n\n\n  getAddress() {\n    return __awaiter(this, void 0, void 0, function* () {\n      return this.getCurrentAddress();\n    });\n  }\n  /**\n   * Signs and sends a transaction. Returns the transaction hash\n   * @param transaction\n   */\n\n\n  sendTransaction(transaction) {\n    return __awaiter(this, void 0, void 0, function* () {\n      transaction = yield this.signTransaction(transaction);\n      yield transaction.send(this.provider);\n      return transaction;\n    });\n  }\n\n  signTransaction(transaction) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!this.hwApp) {\n        throw new Error(\"HWApp not initialised, call init() first\");\n      }\n\n      const address = yield this.getCurrentAddress();\n      let signUsingHash = yield this.shouldSignUsingHash();\n\n      if (signUsingHash) {\n        transaction.options = networkParams_1.TransactionOptions.withTxHashSignOptions();\n        transaction.version = networkParams_1.TransactionVersion.withTxHashSignVersion();\n      }\n\n      const sig = yield this.hwApp.signTransaction(transaction.serializeForSigning(new address_1.Address(address)), signUsingHash);\n      transaction.applySignature(new signature_1.Signature(sig), new address_1.Address(address));\n      return transaction;\n    });\n  }\n\n  signTransactions(transactions) {\n    return __awaiter(this, void 0, void 0, function* () {\n      let retTx = [];\n\n      for (let tx of transactions) {\n        retTx.push(yield this.signTransaction(tx));\n      }\n\n      return retTx;\n    });\n  }\n\n  signMessage(message) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!this.hwApp) {\n        throw new Error(\"HWApp not initialised, call init() first\");\n      }\n\n      const signature = yield this.hwApp.signMessage(message.serializeForSigningRaw());\n      message.applySignature(new signature_1.Signature(signature));\n      return message;\n    });\n  }\n\n  shouldSignUsingHash() {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!this.hwApp) {\n        throw new Error(\"HWApp not initialised, call init() first\");\n      }\n\n      const config = yield this.hwApp.getAppConfiguration();\n      let diff = versioning_1.compareVersions(config.version, constants_1.LEDGER_TX_HASH_SIGN_MIN_VERSION);\n      return diff >= 0;\n    });\n  }\n\n  getCurrentAddress() {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!this.hwApp) {\n        throw new Error(\"HWApp not initialised, call init() first\");\n      }\n\n      const {\n        address\n      } = yield this.hwApp.getAddress(0, this.addressIndex);\n      return address;\n    });\n  }\n\n}\n\nexports.HWProvider = HWProvider;","map":{"version":3,"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;;AACA,wF,CACA;;;AACA;;AAEA;;AAKA;;AACA;;AACA;;AACA;;AACA;;AAGA,MAAaA,UAAb,CAAuB;EAKnBC,YAAYC,YAAZ,EAAmC;IAFnC,oBAAuB,CAAvB;IAGI,KAAKC,QAAL,GAAgBD,YAAhB;EACH;EAED;;;;;EAGME,IAAI;;MACN,IAAI;QACA,IAAIC,eAAe,GAAG,MAAMC,8BAAgBC,WAAhB,EAA5B;QACAF,eAAe,GACXA,eAAe,IAAI,CAAC,CAACG,mBAASC,EAA9B,IAAoCD,mBAASC,EAAT,CAAYC,MAAZ,KAAuB,SAA3D,IAAwEF,mBAASG,IAAT,KAAkB,OAD9F;QAGA,MAAMC,SAAS,GAAGP,eAAe,GAAG,MAAMC,8BAAgBO,MAAhB,EAAT,GAAoC,MAAMC,2BAAaD,MAAb,EAA3E;QACA,KAAKE,KAAL,GAAa,IAAIC,uBAAJ,CAAcJ,SAAd,CAAb;QAEA,OAAO,IAAP;MACH,CATD,CASE,OAAOK,KAAP,EAAc;QACZ,OAAO,KAAP;MACH;IACJ;EAAA;EAED;;;;;EAGAC,aAAa;IACT,OAAO,CAAC,CAAC,KAAKH,KAAd;EACH;EAED;;;;;EAGAI,WAAW;IACP,OAAO,IAAIC,OAAJ,CAAY,CAACC,OAAD,EAAUC,CAAV,KAAgBD,OAAO,CAAC,KAAKH,aAAL,EAAD,CAAnC,CAAP;EACH;EAED;;;;;EAGMK,KAAK,CAACC,OAAD,EAAoC;;MAC3C,IAAI,CAAC,KAAKT,KAAV,EAAiB;QACb,MAAM,IAAIU,KAAJ,CAAU,0CAAV,CAAN;MACH;;MAED,IAAGD,OAAO,IAAIA,OAAO,CAACE,YAAtB,EAAoC;QAChC,KAAKA,YAAL,GAAoBF,OAAO,CAACE,YAA5B;MACH;;MAED,MAAM,KAAKX,KAAL,CAAWY,UAAX,CAAsB,CAAtB,EAAyB,KAAKD,YAA9B,CAAN;MACA,MAAM;QAACE;MAAD,IAAY,MAAM,KAAKb,KAAL,CAAWc,UAAX,CAAsB,CAAtB,EAAyB,KAAKH,YAA9B,EAA4C,IAA5C,CAAxB;MAEA,OAAOE,OAAP;IACH;EAAA;;EAEKE,WAAW,GAAwC;IAAA,IAAvCC,IAAuC,uEAAxB,CAAwB;IAAA,IAArBC,QAAqB,uEAAF,EAAE;;MACrD,IAAI,CAAC,KAAKjB,KAAV,EAAiB;QACb,MAAM,IAAIU,KAAJ,CAAU,0CAAV,CAAN;MACH;;MACD,MAAMQ,SAAS,GAAG,EAAlB;MAEA,MAAMC,UAAU,GAAGH,IAAI,GAAGC,QAA1B;;MACA,KAAK,IAAIG,KAAK,GAAGD,UAAjB,EAA6BC,KAAK,GAAGD,UAAU,GAAGF,QAAlD,EAA4DG,KAAK,EAAjE,EAAqE;QACjE,MAAM;UAAEP;QAAF,IAAc,MAAM,KAAKb,KAAL,CAAWc,UAAX,CAAsB,CAAtB,EAAyBM,KAAzB,CAA1B;QACAF,SAAS,CAACG,IAAV,CAAeR,OAAf;MACH;;MACD,OAAOK,SAAP;IACH;EAAA;EAED;;;;;EAGMI,MAAM;;MACR,IAAI,CAAC,KAAKtB,KAAV,EAAiB;QACb,MAAM,IAAIU,KAAJ,CAAU,0CAAV,CAAN;MACH;;MAED,OAAO,IAAP;IACH;EAAA;EAED;;;;;EAGMI,UAAU;;MACZ,OAAO,KAAKS,iBAAL,EAAP;IACH;EAAA;EAED;;;;;;EAIMC,eAAe,CAACC,WAAD,EAAyB;;MAC1CA,WAAW,GAAG,MAAM,KAAKC,eAAL,CAAqBD,WAArB,CAApB;MACA,MAAMA,WAAW,CAACE,IAAZ,CAAiB,KAAKvC,QAAtB,CAAN;MAEA,OAAOqC,WAAP;IACH;EAAA;;EAEKC,eAAe,CAACD,WAAD,EAAyB;;MAC1C,IAAI,CAAC,KAAKzB,KAAV,EAAiB;QACb,MAAM,IAAIU,KAAJ,CAAU,0CAAV,CAAN;MACH;;MAED,MAAMG,OAAO,GAAG,MAAM,KAAKU,iBAAL,EAAtB;MACA,IAAIK,aAAa,GAAG,MAAM,KAAKC,mBAAL,EAA1B;;MACA,IAAGD,aAAH,EAAkB;QACdH,WAAW,CAAChB,OAAZ,GAAsBqB,mCAAmBC,qBAAnB,EAAtB;QACAN,WAAW,CAACO,OAAZ,GAAsBF,mCAAmBG,qBAAnB,EAAtB;MACH;;MACD,MAAMC,GAAG,GAAG,MAAM,KAAKlC,KAAL,CAAW0B,eAAX,CAChBD,WAAW,CAACU,mBAAZ,CAAgC,IAAIC,iBAAJ,CAAYvB,OAAZ,CAAhC,CADgB,EAEhBe,aAFgB,CAAlB;MAIAH,WAAW,CAACY,cAAZ,CAA2B,IAAIC,qBAAJ,CAAcJ,GAAd,CAA3B,EAA+C,IAAIE,iBAAJ,CAAYvB,OAAZ,CAA/C;MAEA,OAAOY,WAAP;IACH;EAAA;;EAEKc,gBAAgB,CAACC,YAAD,EAA4B;;MAC9C,IAAIC,KAAK,GAAkB,EAA3B;;MACA,KAAK,IAAIC,EAAT,IAAeF,YAAf,EAA6B;QACzBC,KAAK,CAACpB,IAAN,CAAW,MAAM,KAAKK,eAAL,CAAqBgB,EAArB,CAAjB;MACH;;MAED,OAAOD,KAAP;IACH;EAAA;;EAEKE,WAAW,CAACC,OAAD,EAAyB;;MACtC,IAAI,CAAC,KAAK5C,KAAV,EAAiB;QACb,MAAM,IAAIU,KAAJ,CAAU,0CAAV,CAAN;MACH;;MAED,MAAMmC,SAAS,GAAG,MAAM,KAAK7C,KAAL,CAAW2C,WAAX,CAAuBC,OAAO,CAACE,sBAAR,EAAvB,CAAxB;MACAF,OAAO,CAACP,cAAR,CAAuB,IAAIC,qBAAJ,CAAcO,SAAd,CAAvB;MAEA,OAAOD,OAAP;IACH;EAAA;;EAEaf,mBAAmB;;MAC7B,IAAI,CAAC,KAAK7B,KAAV,EAAiB;QACb,MAAM,IAAIU,KAAJ,CAAU,0CAAV,CAAN;MACH;;MAED,MAAMqC,MAAM,GAAG,MAAM,KAAK/C,KAAL,CAAWgD,mBAAX,EAArB;MAEA,IAAIC,IAAI,GAAGC,6BAAgBH,MAAM,CAACf,OAAvB,EAAgCmB,2CAAhC,CAAX;MACA,OAAOF,IAAI,IAAI,CAAf;IACH;EAAA;;EAEa1B,iBAAiB;;MAC3B,IAAI,CAAC,KAAKvB,KAAV,EAAiB;QACb,MAAM,IAAIU,KAAJ,CAAU,0CAAV,CAAN;MACH;;MACD,MAAM;QAAEG;MAAF,IAAc,MAAM,KAAKb,KAAL,CAAWc,UAAX,CAAsB,CAAtB,EAAyB,KAAKH,YAA9B,CAA1B;MAEA,OAAOE,OAAP;IACH;EAAA;;AAhKkB;;AAAvBuC","names":["HWProvider","constructor","httpProvider","provider","init","webUSBSupported","hw_transport_webusb_1","isSupported","platform_1","os","family","name","transport","create","hw_transport_u2f_1","hwApp","hw_app_elrond_1","error","isInitialized","isConnected","Promise","resolve","_","login","options","Error","addressIndex","setAddress","address","getAddress","getAccounts","page","pageSize","addresses","startIndex","index","push","logout","getCurrentAddress","sendTransaction","transaction","signTransaction","send","signUsingHash","shouldSignUsingHash","networkParams_1","withTxHashSignOptions","version","withTxHashSignVersion","sig","serializeForSigning","address_1","applySignature","signature_1","signTransactions","transactions","retTx","tx","signMessage","message","signature","serializeForSigningRaw","config","getAppConfiguration","diff","versioning_1","constants_1","exports"],"sourceRoot":"","sources":["../../src/dapp/hwProvider.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}