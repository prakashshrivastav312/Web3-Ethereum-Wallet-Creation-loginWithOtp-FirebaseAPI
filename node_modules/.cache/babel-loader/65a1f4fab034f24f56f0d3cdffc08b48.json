{"ast":null,"code":"const bip39 = require('bip39');\n\nconst {\n  validateBuffer,\n  validateDerivationIndex,\n  validateDerivationScheme,\n  validateMnemonic\n} = require(\"../utils/validation\");\n\nconst crypto = require(\"./crypto-primitives\");\n\nconst pbkdf2 = require('../utils/pbkdf2');\n\nconst Module = require('../lib.js');\n\nasync function mnemonicToRootKeypair(mnemonic, derivationScheme) {\n  validateDerivationScheme(derivationScheme);\n\n  if (derivationScheme === 1) {\n    return mnemonicToRootKeypairV1(mnemonic);\n  } else if (derivationScheme === 2) {\n    return mnemonicToRootKeypairV2(mnemonic, '');\n  } else {\n    throw Error(`Derivation scheme ${derivationScheme} not implemented`);\n  }\n}\n\nfunction mnemonicToRootKeypairV1(mnemonic) {\n  const seed = mnemonicToSeedV1(mnemonic);\n  return seedToKeypairV1(seed);\n}\n\nfunction mnemonicToSeedV1(mnemonic) {\n  validateMnemonic(mnemonic);\n  const entropy = Buffer.from(bip39.mnemonicToEntropy(mnemonic), 'hex');\n  return cborEncodeBuffer(crypto.blake2b(cborEncodeBuffer(entropy), 32));\n}\n\nfunction seedToKeypairV1(seed) {\n  let result;\n\n  for (let i = 1; result === undefined && i <= 1000; i++) {\n    try {\n      const digest = crypto.hmac_sha512(seed, [Buffer.from(`Root Seed Chain ${i}`, 'ascii')]);\n      const tempSeed = digest.slice(0, 32);\n      const chainCode = digest.slice(32, 64);\n      result = trySeedChainCodeToKeypairV1(tempSeed, chainCode);\n    } catch (e) {\n      if (e.name === 'InvalidKeypair') {\n        continue;\n      }\n\n      throw e;\n    }\n  }\n\n  if (result === undefined) {\n    const e = new Error('Secret key generation from mnemonic is looping forever');\n    e.name = 'RuntimeException';\n    throw e;\n  }\n\n  return result;\n}\n\nfunction trySeedChainCodeToKeypairV1(seed, chainCode) {\n  validateBuffer(seed, 32);\n  validateBuffer(chainCode, 32);\n\n  const seedArrPtr = Module._malloc(32);\n\n  const seedArr = new Uint8Array(Module.HEAPU8.buffer, seedArrPtr, 32);\n\n  const chainCodeArrPtr = Module._malloc(32);\n\n  const chainCodeArr = new Uint8Array(Module.HEAPU8.buffer, chainCodeArrPtr, 32);\n\n  const keypairArrPtr = Module._malloc(128);\n\n  const keypairArr = new Uint8Array(Module.HEAPU8.buffer, keypairArrPtr, 128);\n  seedArr.set(seed);\n  chainCodeArr.set(chainCode);\n\n  const returnCode = Module._emscripten_wallet_secret_from_seed(seedArrPtr, chainCodeArrPtr, keypairArrPtr);\n\n  Module._free(seedArrPtr);\n\n  Module._free(chainCodeArrPtr);\n\n  Module._free(keypairArrPtr);\n\n  if (returnCode === 1) {\n    const e = new Error('Invalid keypair');\n    e.name = 'InvalidKeypair';\n    throw e;\n  }\n\n  return Buffer.from(keypairArr);\n}\n\nasync function mnemonicToRootKeypairV2(mnemonic, password) {\n  const seed = mnemonicToSeedV2(mnemonic);\n  const rootSecret = await seedToKeypairV2(seed, password);\n  return seedToKeypairV2(seed, password);\n}\n\nfunction mnemonicToSeedV2(mnemonic) {\n  validateMnemonic(mnemonic);\n  return Buffer.from(bip39.mnemonicToEntropy(mnemonic), 'hex');\n}\n\nasync function seedToKeypairV2(seed, password) {\n  const xprv = await pbkdf2(password, seed, 4096, 96, 'sha512');\n  xprv[0] &= 248;\n  xprv[31] &= 31;\n  xprv[31] |= 64;\n  const publicKey = toPublic(xprv.slice(0, 64));\n  return Buffer.concat([xprv.slice(0, 64), publicKey, xprv.slice(64)]);\n}\n\nfunction toPublic(privateKey) {\n  validateBuffer(privateKey, 64);\n\n  const privateKeyArrPtr = Module._malloc(64);\n\n  const privateKeyArr = new Uint8Array(Module.HEAPU8.buffer, privateKeyArrPtr, 64);\n\n  const publicKeyArrPtr = Module._malloc(32);\n\n  const publicKeyArr = new Uint8Array(Module.HEAPU8.buffer, publicKeyArrPtr, 32);\n  privateKeyArr.set(privateKey);\n\n  Module._emscripten_to_public(privateKeyArrPtr, publicKeyArrPtr);\n\n  Module._free(privateKeyArrPtr);\n\n  Module._free(publicKeyArrPtr);\n\n  return Buffer.from(publicKeyArr);\n}\n\nfunction derivePrivate(parentKey, index, derivationScheme) {\n  validateBuffer(parentKey, 128);\n  validateDerivationIndex(index);\n  validateDerivationScheme(derivationScheme);\n\n  const parentKeyArrPtr = Module._malloc(128);\n\n  const parentKeyArr = new Uint8Array(Module.HEAPU8.buffer, parentKeyArrPtr, 128);\n\n  const childKeyArrPtr = Module._malloc(128);\n\n  const childKeyArr = new Uint8Array(Module.HEAPU8.buffer, childKeyArrPtr, 128);\n  parentKeyArr.set(parentKey);\n\n  Module._emscripten_derive_private(parentKeyArrPtr, index, childKeyArrPtr, derivationScheme);\n\n  Module._free(parentKeyArrPtr);\n\n  Module._free(childKeyArrPtr);\n\n  return Buffer.from(childKeyArr);\n}\n\nfunction derivePublic(parentExtPubKey, index, derivationScheme) {\n  validateBuffer(parentExtPubKey, 64);\n  validateDerivationIndex(index);\n  validateDerivationScheme(derivationScheme);\n  const parentPubKey = parentExtPubKey.slice(0, 32);\n  const parentChainCode = parentExtPubKey.slice(32, 64);\n\n  const parentPubKeyArrPtr = Module._malloc(32);\n\n  const parentPubKeyArr = new Uint8Array(Module.HEAPU8.buffer, parentPubKeyArrPtr, 32);\n\n  const parentChainCodeArrPtr = Module._malloc(32);\n\n  const parentChainCodeArr = new Uint8Array(Module.HEAPU8.buffer, parentChainCodeArrPtr, 32);\n\n  const childPubKeyArrPtr = Module._malloc(32);\n\n  const childPubKeyArr = new Uint8Array(Module.HEAPU8.buffer, childPubKeyArrPtr, 32);\n\n  const childChainCodeArrPtr = Module._malloc(32);\n\n  const childChainCodeArr = new Uint8Array(Module.HEAPU8.buffer, childChainCodeArrPtr, 32);\n  parentPubKeyArr.set(parentPubKey);\n  parentChainCodeArr.set(parentChainCode);\n\n  const resultCode = Module._emscripten_derive_public(parentPubKeyArrPtr, parentChainCodeArrPtr, index, childPubKeyArrPtr, childChainCodeArrPtr, derivationScheme);\n\n  Module._free(parentPubKeyArrPtr);\n\n  Module._free(parentChainCodeArrPtr);\n\n  Module._free(parentPubKeyArrPtr);\n\n  Module._free(parentChainCodeArrPtr);\n\n  if (resultCode !== 0) {\n    throw Error(`derivePublic has exited with code ${resultCode}`);\n  }\n\n  return Buffer.concat([Buffer.from(childPubKeyArr), Buffer.from(childChainCodeArr)]);\n}\n\nfunction cborEncodeBuffer(input) {\n  validateBuffer(input);\n  const len = input.length;\n  let cborPrefix = [];\n\n  if (len < 24) {\n    cborPrefix = [0x40 + len];\n  } else if (len < 256) {\n    cborPrefix = [0x58, len];\n  } else {\n    throw Error('CBOR encode for more than 256 bytes not yet implemented');\n  }\n\n  return Buffer.concat([Buffer.from(cborPrefix), input]);\n}\n\nmodule.exports = {\n  mnemonicToRootKeypair,\n  derivePublic,\n  derivePrivate,\n  toPublic,\n  _mnemonicToSeedV1: mnemonicToSeedV1,\n  _seedToKeypairV1: seedToKeypairV1,\n  _seedToKeypairV2: seedToKeypairV2,\n  _mnemonicToSeedV2: mnemonicToSeedV2\n};","map":{"version":3,"names":["bip39","require","validateBuffer","validateDerivationIndex","validateDerivationScheme","validateMnemonic","crypto","pbkdf2","Module","mnemonicToRootKeypair","mnemonic","derivationScheme","mnemonicToRootKeypairV1","mnemonicToRootKeypairV2","Error","seed","mnemonicToSeedV1","seedToKeypairV1","entropy","Buffer","from","mnemonicToEntropy","cborEncodeBuffer","blake2b","result","i","undefined","digest","hmac_sha512","tempSeed","slice","chainCode","trySeedChainCodeToKeypairV1","e","name","seedArrPtr","_malloc","seedArr","Uint8Array","HEAPU8","buffer","chainCodeArrPtr","chainCodeArr","keypairArrPtr","keypairArr","set","returnCode","_emscripten_wallet_secret_from_seed","_free","password","mnemonicToSeedV2","rootSecret","seedToKeypairV2","xprv","publicKey","toPublic","concat","privateKey","privateKeyArrPtr","privateKeyArr","publicKeyArrPtr","publicKeyArr","_emscripten_to_public","derivePrivate","parentKey","index","parentKeyArrPtr","parentKeyArr","childKeyArrPtr","childKeyArr","_emscripten_derive_private","derivePublic","parentExtPubKey","parentPubKey","parentChainCode","parentPubKeyArrPtr","parentPubKeyArr","parentChainCodeArrPtr","parentChainCodeArr","childPubKeyArrPtr","childPubKeyArr","childChainCodeArrPtr","childChainCodeArr","resultCode","_emscripten_derive_public","input","len","length","cborPrefix","module","exports","_mnemonicToSeedV1","_seedToKeypairV1","_seedToKeypairV2","_mnemonicToSeedV2"],"sources":["C:/Users/acer/node_modules/cardano-crypto.js/features/key-derivation.js"],"sourcesContent":["const bip39 = require('bip39')\n\nconst {validateBuffer, validateDerivationIndex, validateDerivationScheme, validateMnemonic} = require(\"../utils/validation\")\nconst crypto = require(\"./crypto-primitives\")\nconst pbkdf2 = require('../utils/pbkdf2')\nconst Module = require('../lib.js')\n\nasync function mnemonicToRootKeypair(mnemonic, derivationScheme) {\n  validateDerivationScheme(derivationScheme)\n\n  if (derivationScheme === 1) {\n    return mnemonicToRootKeypairV1(mnemonic)\n  } else if (derivationScheme === 2) {\n    return mnemonicToRootKeypairV2(mnemonic, '')\n  } else {\n    throw Error(`Derivation scheme ${derivationScheme} not implemented`)\n  }\n}\n\nfunction mnemonicToRootKeypairV1(mnemonic) {\n  const seed = mnemonicToSeedV1(mnemonic)\n  return seedToKeypairV1(seed)\n}\n\nfunction mnemonicToSeedV1(mnemonic) {\n  validateMnemonic(mnemonic)\n  const entropy = Buffer.from(bip39.mnemonicToEntropy(mnemonic), 'hex')\n\n  return cborEncodeBuffer(crypto.blake2b(cborEncodeBuffer(entropy), 32))\n}\n\nfunction seedToKeypairV1(seed) {\n  let result\n  for (let i = 1; result === undefined && i <= 1000; i++) {\n    try {\n      const digest = crypto.hmac_sha512(seed, [Buffer.from(`Root Seed Chain ${i}`, 'ascii')])\n      const tempSeed = digest.slice(0, 32)\n      const chainCode = digest.slice(32, 64)\n\n      result = trySeedChainCodeToKeypairV1(tempSeed, chainCode)\n\n    } catch (e) {\n      if (e.name === 'InvalidKeypair') {\n        continue\n      }\n\n      throw e\n    }\n  }\n\n  if (result === undefined) {\n    const e = new Error('Secret key generation from mnemonic is looping forever')\n    e.name = 'RuntimeException'\n    throw e\n  }\n\n  return result\n}\n\nfunction trySeedChainCodeToKeypairV1(seed, chainCode) {\n  validateBuffer(seed, 32)\n  validateBuffer(chainCode, 32)\n\n  const seedArrPtr = Module._malloc(32)\n  const seedArr = new Uint8Array(Module.HEAPU8.buffer, seedArrPtr, 32)\n  const chainCodeArrPtr = Module._malloc(32)\n  const chainCodeArr = new Uint8Array(Module.HEAPU8.buffer, chainCodeArrPtr, 32)\n  const keypairArrPtr = Module._malloc(128)\n  const keypairArr = new Uint8Array(Module.HEAPU8.buffer, keypairArrPtr, 128)\n\n  seedArr.set(seed)\n  chainCodeArr.set(chainCode)\n\n  const returnCode = Module._emscripten_wallet_secret_from_seed(seedArrPtr, chainCodeArrPtr, keypairArrPtr)\n\n  Module._free(seedArrPtr)\n  Module._free(chainCodeArrPtr)\n  Module._free(keypairArrPtr)\n\n  if (returnCode === 1) {\n    const e = new Error('Invalid keypair')\n    e.name = 'InvalidKeypair'\n\n    throw e\n  }\n\n  return Buffer.from(keypairArr)\n}\n\nasync function mnemonicToRootKeypairV2(mnemonic, password) {\n  const seed = mnemonicToSeedV2(mnemonic)\n  const rootSecret = await seedToKeypairV2(seed, password)\n\n  return seedToKeypairV2(seed, password)\n}\n\nfunction mnemonicToSeedV2(mnemonic) {\n  validateMnemonic(mnemonic)\n  return Buffer.from(bip39.mnemonicToEntropy(mnemonic), 'hex')\n}\n\nasync function seedToKeypairV2(seed, password) {\n  const xprv = await pbkdf2(password, seed, 4096, 96, 'sha512')\n\n  xprv[0] &= 248\n  xprv[31] &= 31\n  xprv[31] |= 64\n\n  const publicKey = toPublic(xprv.slice(0, 64))\n\n  return Buffer.concat([xprv.slice(0, 64), publicKey, xprv.slice(64,)])\n}\n\nfunction toPublic(privateKey) {\n  validateBuffer(privateKey, 64)\n\n  const privateKeyArrPtr = Module._malloc(64)\n  const privateKeyArr = new Uint8Array(Module.HEAPU8.buffer, privateKeyArrPtr, 64)\n  const publicKeyArrPtr = Module._malloc(32)\n  const publicKeyArr = new Uint8Array(Module.HEAPU8.buffer, publicKeyArrPtr, 32)\n\n  privateKeyArr.set(privateKey)\n\n  Module._emscripten_to_public(privateKeyArrPtr, publicKeyArrPtr)\n\n  Module._free(privateKeyArrPtr)\n  Module._free(publicKeyArrPtr)\n\n  return Buffer.from(publicKeyArr)\n}\n\nfunction derivePrivate(parentKey, index, derivationScheme) {\n  validateBuffer(parentKey, 128)\n  validateDerivationIndex(index)\n  validateDerivationScheme(derivationScheme)\n\n  const parentKeyArrPtr = Module._malloc(128)\n  const parentKeyArr = new Uint8Array(Module.HEAPU8.buffer, parentKeyArrPtr, 128)\n  const childKeyArrPtr = Module._malloc(128)\n  const childKeyArr = new Uint8Array(Module.HEAPU8.buffer, childKeyArrPtr, 128)\n\n  parentKeyArr.set(parentKey)\n\n  Module._emscripten_derive_private(parentKeyArrPtr, index, childKeyArrPtr, derivationScheme)\n  Module._free(parentKeyArrPtr)\n  Module._free(childKeyArrPtr)\n\n  return Buffer.from(childKeyArr)\n}\n\nfunction derivePublic(parentExtPubKey, index, derivationScheme) {\n  validateBuffer(parentExtPubKey, 64)\n  validateDerivationIndex(index)\n  validateDerivationScheme(derivationScheme)\n\n  const parentPubKey = parentExtPubKey.slice(0, 32)\n  const parentChainCode = parentExtPubKey.slice(32, 64)\n\n  const parentPubKeyArrPtr = Module._malloc(32)\n  const parentPubKeyArr = new Uint8Array(Module.HEAPU8.buffer, parentPubKeyArrPtr, 32)\n  const parentChainCodeArrPtr = Module._malloc(32)\n  const parentChainCodeArr = new Uint8Array(Module.HEAPU8.buffer, parentChainCodeArrPtr, 32)\n\n  const childPubKeyArrPtr = Module._malloc(32)\n  const childPubKeyArr = new Uint8Array(Module.HEAPU8.buffer, childPubKeyArrPtr, 32)\n  const childChainCodeArrPtr = Module._malloc(32)\n  const childChainCodeArr = new Uint8Array(Module.HEAPU8.buffer, childChainCodeArrPtr, 32)\n\n  parentPubKeyArr.set(parentPubKey)\n  parentChainCodeArr.set(parentChainCode)\n\n  const resultCode = Module._emscripten_derive_public(parentPubKeyArrPtr, parentChainCodeArrPtr, index, childPubKeyArrPtr, childChainCodeArrPtr, derivationScheme)\n\n  Module._free(parentPubKeyArrPtr)\n  Module._free(parentChainCodeArrPtr)\n  Module._free(parentPubKeyArrPtr)\n  Module._free(parentChainCodeArrPtr)\n\n  if (resultCode !== 0) {\n    throw Error(`derivePublic has exited with code ${resultCode}`)\n  }\n\n  return Buffer.concat([Buffer.from(childPubKeyArr), Buffer.from(childChainCodeArr)])\n}\n\nfunction cborEncodeBuffer(input) {\n  validateBuffer(input)\n\n  const len = input.length\n  let cborPrefix = []\n\n  if (len < 24) {\n    cborPrefix = [0x40 + len]\n  } else if (len < 256) {\n    cborPrefix = [0x58, len]\n  } else {\n    throw Error('CBOR encode for more than 256 bytes not yet implemented')\n  }\n\n  return Buffer.concat([Buffer.from(cborPrefix), input])\n}\n\nmodule.exports = {\n  mnemonicToRootKeypair,\n  derivePublic,\n  derivePrivate,\n  toPublic,\n  _mnemonicToSeedV1: mnemonicToSeedV1,\n  _seedToKeypairV1: seedToKeypairV1,\n  _seedToKeypairV2: seedToKeypairV2,\n  _mnemonicToSeedV2: mnemonicToSeedV2,\n}"],"mappings":"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"},"metadata":{},"sourceType":"script"}