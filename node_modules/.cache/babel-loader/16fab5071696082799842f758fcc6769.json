{"ast":null,"code":"'use strict';\n\nvar _ = require('lodash');\n\nvar Script = require('./script');\n\nvar Opcode = require('../opcode');\n\nvar BN = require('../crypto/bn');\n\nvar Hash = require('../crypto/hash');\n\nvar Signature = require('../crypto/signature');\n\nvar PublicKey = require('../publickey');\n/**\n * Bitcoin transactions contain scripts. Each input has a script called the\n * scriptSig, and each output has a script called the scriptPubkey. To validate\n * an input, the input's script is concatenated with the referenced output script,\n * and the result is executed. If at the end of execution the stack contains a\n * \"true\" value, then the transaction is valid.\n *\n * The primary way to use this class is via the verify function.\n * e.g., Interpreter().verify( ... );\n */\n\n\nvar Interpreter = function Interpreter(obj) {\n  if (!(this instanceof Interpreter)) {\n    return new Interpreter(obj);\n  }\n\n  if (obj) {\n    this.initialize();\n    this.set(obj);\n  } else {\n    this.initialize();\n  }\n};\n\nInterpreter.prototype.verifyWitnessProgram = function (version, program, witness, satoshis, flags) {\n  var scriptPubKey = new Script();\n  var stack = [];\n\n  if (version === 0) {\n    if (program.length === 32) {\n      if (witness.length === 0) {\n        this.errstr = 'SCRIPT_ERR_WITNESS_PROGRAM_WITNESS_EMPTY';\n        return false;\n      }\n\n      var scriptPubKeyBuffer = witness[witness.length - 1];\n      scriptPubKey = new Script(scriptPubKeyBuffer);\n      var hash = Hash.sha256(scriptPubKeyBuffer);\n\n      if (hash.toString('hex') !== program.toString('hex')) {\n        this.errstr = 'SCRIPT_ERR_WITNESS_PROGRAM_MISMATCH';\n        return false;\n      }\n\n      stack = witness.slice(0, -1);\n    } else if (program.length === 20) {\n      if (witness.length !== 2) {\n        this.errstr = 'SCRIPT_ERR_WITNESS_PROGRAM_MISMATCH';\n        return false;\n      }\n\n      scriptPubKey.add(Opcode.OP_DUP);\n      scriptPubKey.add(Opcode.OP_HASH160);\n      scriptPubKey.add(program);\n      scriptPubKey.add(Opcode.OP_EQUALVERIFY);\n      scriptPubKey.add(Opcode.OP_CHECKSIG);\n      stack = witness;\n    } else {\n      this.errstr = 'SCRIPT_ERR_WITNESS_PROGRAM_WRONG_LENGTH';\n      return false;\n    }\n  } else if (flags & Interpreter.SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_WITNESS_PROGRAM) {\n    this.errstr = 'SCRIPT_ERR_DISCOURAGE_UPGRADABLE_WITNESS_PROGRAM';\n    return false;\n  } else {\n    return true;\n  }\n\n  this.initialize();\n  this.set({\n    script: scriptPubKey,\n    stack: stack,\n    sigversion: Interpreter.SIGVERSION_WITNESS_V0,\n    satoshis: satoshis,\n    flags: flags\n  }); // Disallow stack item size > MAX_SCRIPT_ELEMENT_SIZE in witness stack\n\n  for (let s of stack) {\n    if (s.length > Interpreter.MAX_SCRIPT_ELEMENT_SIZE) {\n      this.errstr = 'SCRIPT_ERR_PUSH_SIZE';\n      return false;\n    }\n  }\n\n  if (!this.evaluate()) {\n    return false;\n  }\n\n  if (this.stack.length !== 1) {\n    this.errstr = 'SCRIPT_ERR_EVAL_FALSE';\n    return false;\n  }\n\n  var buf = this.stack[this.stack.length - 1];\n\n  if (!Interpreter.castToBool(buf)) {\n    this.errstr = 'SCRIPT_ERR_EVAL_FALSE_IN_STACK';\n    return false;\n  }\n\n  return true;\n};\n/**\n * Verifies a Script by executing it and returns true if it is valid.\n * This function needs to be provided with the scriptSig and the scriptPubkey\n * separately.\n * @param {Script} scriptSig - the script's first part (corresponding to the tx input)\n * @param {Script} scriptPubkey - the script's last part (corresponding to the tx output)\n * @param {Transaction=} tx - the Transaction containing the scriptSig in one input (used\n *    to check signature validity for some opcodes like OP_CHECKSIG)\n * @param {number} nin - index of the transaction input containing the scriptSig verified.\n * @param {number} flags - evaluation flags. See Interpreter.SCRIPT_* constants\n * @param {number} witness - array of witness data\n * @param {number} satoshis - number of satoshis created by this output\n *\n * Translated from bitcoind's VerifyScript\n */\n\n\nInterpreter.prototype.verify = function (scriptSig, scriptPubkey, tx, nin, flags, witness, satoshis) {\n  var Transaction = require('../transaction');\n\n  if (_.isUndefined(tx)) {\n    tx = new Transaction();\n  }\n\n  if (_.isUndefined(nin)) {\n    nin = 0;\n  }\n\n  if (_.isUndefined(flags)) {\n    flags = 0;\n  }\n\n  if (_.isUndefined(witness)) {\n    witness = null;\n  }\n\n  if (_.isUndefined(satoshis)) {\n    satoshis = 0;\n  }\n\n  this.set({\n    script: scriptSig,\n    tx: tx,\n    nin: nin,\n    sigversion: Interpreter.SIGVERSION_BASE,\n    satoshis: 0,\n    flags: flags\n  });\n  var stackCopy;\n\n  if ((flags & Interpreter.SCRIPT_VERIFY_SIGPUSHONLY) !== 0 && !scriptSig.isPushOnly()) {\n    this.errstr = 'SCRIPT_ERR_SIG_PUSHONLY';\n    return false;\n  } // evaluate scriptSig\n\n\n  if (!this.evaluate()) {\n    return false;\n  }\n\n  if (flags & Interpreter.SCRIPT_VERIFY_P2SH) {\n    stackCopy = this.stack.slice();\n  }\n\n  var stack = this.stack;\n  this.initialize();\n  this.set({\n    script: scriptPubkey,\n    stack: stack,\n    tx: tx,\n    nin: nin,\n    flags: flags\n  }); // evaluate scriptPubkey\n\n  if (!this.evaluate()) {\n    return false;\n  }\n\n  if (this.stack.length === 0) {\n    this.errstr = 'SCRIPT_ERR_EVAL_FALSE_NO_RESULT';\n    return false;\n  }\n\n  var buf = this.stack[this.stack.length - 1];\n\n  if (!Interpreter.castToBool(buf)) {\n    this.errstr = 'SCRIPT_ERR_EVAL_FALSE_IN_STACK';\n    return false;\n  }\n\n  var hadWitness = false;\n\n  if (flags & Interpreter.SCRIPT_VERIFY_WITNESS) {\n    var witnessValues = {};\n\n    if (scriptPubkey.isWitnessProgram(witnessValues)) {\n      hadWitness = true;\n\n      if (scriptSig.toBuffer().length !== 0) {\n        return false;\n      }\n\n      if (!this.verifyWitnessProgram(witnessValues.version, witnessValues.program, witness, satoshis, this.flags)) {\n        return false;\n      }\n    }\n  } // Additional validation for spend-to-script-hash transactions:\n\n\n  if (flags & Interpreter.SCRIPT_VERIFY_P2SH && scriptPubkey.isScriptHashOut()) {\n    // scriptSig must be literals-only or validation fails\n    if (!scriptSig.isPushOnly()) {\n      this.errstr = 'SCRIPT_ERR_SIG_PUSHONLY';\n      return false;\n    } // stackCopy cannot be empty here, because if it was the\n    // P2SH  HASH <> EQUAL  scriptPubKey would be evaluated with\n    // an empty stack and the EvalScript above would return false.\n\n\n    if (stackCopy.length === 0) {\n      throw new Error('internal error - stack copy empty');\n    }\n\n    var redeemScriptSerialized = stackCopy[stackCopy.length - 1];\n    var redeemScript = Script.fromBuffer(redeemScriptSerialized);\n    stackCopy.pop();\n    this.initialize();\n    this.set({\n      script: redeemScript,\n      stack: stackCopy,\n      tx: tx,\n      nin: nin,\n      flags: flags\n    }); // evaluate redeemScript\n\n    if (!this.evaluate()) {\n      return false;\n    }\n\n    if (stackCopy.length === 0) {\n      this.errstr = 'SCRIPT_ERR_EVAL_FALSE_NO_P2SH_STACK';\n      return false;\n    }\n\n    if (!Interpreter.castToBool(stackCopy[stackCopy.length - 1])) {\n      this.errstr = 'SCRIPT_ERR_EVAL_FALSE_IN_P2SH_STACK';\n      return false;\n    }\n\n    if (flags & Interpreter.SCRIPT_VERIFY_WITNESS) {\n      var p2shWitnessValues = {};\n\n      if (redeemScript.isWitnessProgram(p2shWitnessValues)) {\n        hadWitness = true;\n        var redeemScriptPush = new Script();\n        redeemScriptPush.add(redeemScript.toBuffer());\n\n        if (scriptSig.toHex() !== redeemScriptPush.toHex()) {\n          this.errstr = 'SCRIPT_ERR_WITNESS_MALLEATED_P2SH';\n          return false;\n        }\n\n        if (!this.verifyWitnessProgram(p2shWitnessValues.version, p2shWitnessValues.program, witness, satoshis, this.flags)) {\n          return false;\n        } // Bypass the cleanstack check at the end. The actual stack is obviously not clean\n        // for witness programs.\n\n\n        stack = [stack[0]];\n      }\n    }\n  } // The CLEANSTACK check is only performed after potential P2SH evaluation,\n  // as the non-P2SH evaluation of a P2SH script will obviously not result in\n  // a clean stack (the P2SH inputs remain). The same holds for witness\n  // evaluation.\n\n\n  if ((this.flags & Interpreter.SCRIPT_VERIFY_CLEANSTACK) != 0) {\n    // Disallow CLEANSTACK without P2SH, as otherwise a switch\n    // CLEANSTACK->P2SH+CLEANSTACK would be possible, which is not a\n    // softfork (and P2SH should be one).\n    if ((this.flags & Interpreter.SCRIPT_VERIFY_P2SH) == 0) throw 'flags & SCRIPT_VERIFY_P2SH';\n\n    if (stackCopy.length != 1) {\n      this.errstr = 'SCRIPT_ERR_CLEANSTACK';\n      return false;\n    }\n  }\n\n  if (this.flags & Interpreter.SCRIPT_VERIFY_WITNESS) {\n    if (!hadWitness && witness.length > 0) {\n      this.errstr = 'SCRIPT_ERR_WITNESS_UNEXPECTED';\n      return false;\n    }\n  }\n\n  return true;\n};\n\nmodule.exports = Interpreter;\n\nInterpreter.prototype.initialize = function (obj) {\n  this.stack = [];\n  this.altstack = [];\n  this.pc = 0;\n  this.satoshis = 0;\n  this.sigversion = Interpreter.SIGVERSION_BASE;\n  this.pbegincodehash = 0;\n  this.nOpCount = 0;\n  this.vfExec = [];\n  this.errstr = '';\n  this.flags = 0;\n};\n\nInterpreter.prototype.set = function (obj) {\n  this.script = obj.script || this.script;\n  this.tx = obj.tx || this.tx;\n  this.nin = typeof obj.nin !== 'undefined' ? obj.nin : this.nin;\n  this.stack = obj.stack || this.stack;\n  this.altstack = obj.altack || this.altstack;\n  this.pc = typeof obj.pc !== 'undefined' ? obj.pc : this.pc;\n  this.pbegincodehash = typeof obj.pbegincodehash !== 'undefined' ? obj.pbegincodehash : this.pbegincodehash;\n  this.sigversion = typeof obj.sigversion !== 'undefined' ? obj.sigversion : this.sigversion;\n  this.satoshis = typeof obj.satoshis !== 'undefined' ? obj.satoshis : this.satoshis;\n  this.nOpCount = typeof obj.nOpCount !== 'undefined' ? obj.nOpCount : this.nOpCount;\n  this.vfExec = obj.vfExec || this.vfExec;\n  this.errstr = obj.errstr || this.errstr;\n  this.flags = typeof obj.flags !== 'undefined' ? obj.flags : this.flags;\n};\n\nInterpreter.true = Buffer.from([1]);\nInterpreter.false = Buffer.from([]);\nInterpreter.MAX_SCRIPT_ELEMENT_SIZE = 520;\nInterpreter.LOCKTIME_THRESHOLD = 500000000;\nInterpreter.LOCKTIME_THRESHOLD_BN = new BN(Interpreter.LOCKTIME_THRESHOLD); // flags taken from bitcoind\n// bitcoind commit: b5d1b1092998bc95313856d535c632ea5a8f9104\n\nInterpreter.SCRIPT_VERIFY_NONE = 0; // Making v1-v16 witness program non-standard\n\nInterpreter.SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_WITNESS_PROGRAM = 1 << 12; // Evaluate P2SH subscripts (softfork safe, BIP16).\n\nInterpreter.SCRIPT_VERIFY_P2SH = 1 << 0; // Passing a non-strict-DER signature or one with undefined hashtype to a checksig operation causes script failure.\n// Passing a pubkey that is not (0x04 + 64 bytes) or (0x02 or 0x03 + 32 bytes) to checksig causes that pubkey to be\n// skipped (not softfork safe: this flag can widen the validity of OP_CHECKSIG OP_NOT).\n\nInterpreter.SCRIPT_VERIFY_STRICTENC = 1 << 1; // Passing a non-strict-DER signature to a checksig operation causes script failure (softfork safe, BIP62 rule 1)\n\nInterpreter.SCRIPT_VERIFY_DERSIG = 1 << 2; // Passing a non-strict-DER signature or one with S > order/2 to a checksig operation causes script failure\n// (softfork safe, BIP62 rule 5).\n\nInterpreter.SCRIPT_VERIFY_LOW_S = 1 << 3; // verify dummy stack item consumed by CHECKMULTISIG is of zero-length (softfork safe, BIP62 rule 7).\n\nInterpreter.SCRIPT_VERIFY_NULLDUMMY = 1 << 4; // Using a non-push operator in the scriptSig causes script failure (softfork safe, BIP62 rule 2).\n\nInterpreter.SCRIPT_VERIFY_SIGPUSHONLY = 1 << 5; // Require minimal encodings for all push operations (OP_0... OP_16, OP_1NEGATE where possible, direct\n// pushes up to 75 bytes, OP_PUSHDATA up to 255 bytes, OP_PUSHDATA2 for anything larger). Evaluating\n// any other push causes the script to fail (BIP62 rule 3).\n// In addition, whenever a stack element is interpreted as a number, it must be of minimal length (BIP62 rule 4).\n// (softfork safe)\n\nInterpreter.SCRIPT_VERIFY_MINIMALDATA = 1 << 6; // Discourage use of NOPs reserved for upgrades (NOP1-10)\n//\n// Provided so that nodes can avoid accepting or mining transactions\n// containing executed NOP's whose meaning may change after a soft-fork,\n// thus rendering the script invalid; with this flag set executing\n// discouraged NOPs fails the script. This verification flag will never be\n// a mandatory flag applied to scripts in a block. NOPs that are not\n// executed, e.g.  within an unexecuted IF ENDIF block, are *not* rejected.\n\nInterpreter.SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_NOPS = 1 << 7; // Require that only a single stack element remains after evaluation. This\n// changes the success criterion from \"At least one stack element must\n// remain, and when interpreted as a boolean, it must be true\" to \"Exactly\n// one stack element must remain, and when interpreted as a boolean, it must\n// be true\".\n// (softfork safe, BIP62 rule 6)\n// Note: CLEANSTACK should never be used without P2SH or WITNESS.\n\nInterpreter.SCRIPT_VERIFY_CLEANSTACK = 1 << 8, // CLTV See BIP65 for details.\nInterpreter.SCRIPT_VERIFY_CHECKLOCKTIMEVERIFY = 1 << 9; // https://github.com/dogecoin/dogecoin/blob/f80bfe9068ac1a0619d48dad0d268894d926941e/src/script/interpreter.h#L92\n// Support segregated witness\n//\n\nInterpreter.SCRIPT_VERIFY_WITNESS = 1 << 11;\nInterpreter.SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_NOPS = 1 << 11; // support CHECKSEQUENCEVERIFY opcode\n//\n// See BIP112 for details\n\nInterpreter.SCRIPT_VERIFY_CHECKSEQUENCEVERIFY = 1 << 10; //\n// Segwit script only: Require the argument of OP_IF/NOTIF to be exactly\n// 0x01 or empty vector\n//\n\nInterpreter.SCRIPT_VERIFY_MINIMALIF = 1 << 13; // Signature(s) must be empty vector if an CHECK(MULTI)SIG operation failed\n//\n\nInterpreter.SCRIPT_VERIFY_NULLFAIL = 1 << 14; // Public keys in scripts must be compressed\n//\n\nInterpreter.SCRIPT_VERIFY_WITNESS_PUBKEYTYPE = 1 << 15; // Do we accept signature using SIGHASH_FORKID\n//\n\nInterpreter.SCRIPT_ENABLE_SIGHASH_FORKID = 1 << 16; // Do we accept activate replay protection using a different fork id.\n//\n\nInterpreter.SCRIPT_ENABLE_REPLAY_PROTECTION = 1 << 17; // Enable new opcodes.\n//\n\nInterpreter.SCRIPT_ENABLE_MONOLITH_OPCODES = 1 << 18;\n/* Below flags apply in the context of BIP 68*/\n\n/**\n * If this flag set, CTxIn::nSequence is NOT interpreted as a relative\n * lock-time.\n */\n\nInterpreter.SEQUENCE_LOCKTIME_DISABLE_FLAG = 1 << 31;\n/**\n * If CTxIn::nSequence encodes a relative lock-time and this flag is set,\n * the relative lock-time has units of 512 seconds, otherwise it specifies\n * blocks with a granularity of 1.\n */\n\nInterpreter.SEQUENCE_LOCKTIME_TYPE_FLAG = 1 << 22;\n/**\n * If CTxIn::nSequence encodes a relative lock-time, this mask is applied to\n * extract that lock-time from the sequence field.\n */\n\nInterpreter.SEQUENCE_LOCKTIME_MASK = 0x0000ffff;\nInterpreter.SIGVERSION_BASE = 0;\nInterpreter.SIGVERSION_WITNESS_V0 = 1;\n\nInterpreter.castToBool = function (buf) {\n  for (var i = 0; i < buf.length; i++) {\n    if (buf[i] !== 0) {\n      // can be negative zero\n      if (i === buf.length - 1 && buf[i] === 0x80) {\n        return false;\n      }\n\n      return true;\n    }\n  }\n\n  return false;\n};\n/**\n * Translated from bitcoind's CheckSignatureEncoding\n */\n\n\nInterpreter.prototype.checkSignatureEncoding = function (buf) {\n  var sig; // Empty signature. Not strictly DER encoded, but allowed to provide a\n  // compact way to provide an invalid signature for use with CHECK(MULTI)SIG\n\n  if (buf.length == 0) {\n    return true;\n  }\n\n  if ((this.flags & (Interpreter.SCRIPT_VERIFY_DERSIG | Interpreter.SCRIPT_VERIFY_LOW_S | Interpreter.SCRIPT_VERIFY_STRICTENC)) !== 0 && !Signature.isTxDER(buf)) {\n    this.errstr = 'SCRIPT_ERR_SIG_DER_INVALID_FORMAT';\n    return false;\n  } else if ((this.flags & Interpreter.SCRIPT_VERIFY_LOW_S) !== 0) {\n    sig = Signature.fromTxFormat(buf);\n\n    if (!sig.hasLowS()) {\n      this.errstr = 'SCRIPT_ERR_SIG_DER_HIGH_S';\n      return false;\n    }\n  } else if ((this.flags & Interpreter.SCRIPT_VERIFY_STRICTENC) !== 0) {\n    sig = Signature.fromTxFormat(buf);\n\n    if (!sig.hasDefinedHashtype()) {\n      this.errstr = 'SCRIPT_ERR_SIG_HASHTYPE';\n      return false;\n    }\n  }\n\n  return true;\n};\n/**\n * Translated from bitcoind's CheckPubKeyEncoding\n */\n\n\nInterpreter.prototype.checkPubkeyEncoding = function (buf) {\n  if ((this.flags & Interpreter.SCRIPT_VERIFY_STRICTENC) !== 0 && !PublicKey.isValid(buf)) {\n    this.errstr = 'SCRIPT_ERR_PUBKEYTYPE';\n    return false;\n  } // Only compressed keys are accepted in segwit\n\n\n  if ((this.flags & Interpreter.SCRIPT_VERIFY_WITNESS_PUBKEYTYPE) != 0 && this.sigversion == Interpreter.SIGVERSION_WITNESS_V0 && !PublicKey.fromBuffer(buf).compressed) {\n    this.errstr = 'SCRIPT_ERR_WITNESS_PUBKEYTYPE';\n    return false;\n  }\n\n  return true;\n};\n/**\n * Based on bitcoind's EvalScript function, with the inner loop moved to\n * Interpreter.prototype.step()\n * bitcoind commit: b5d1b1092998bc95313856d535c632ea5a8f9104\n */\n\n\nInterpreter.prototype.evaluate = function () {\n  if (this.script.toBuffer().length > 10000) {\n    this.errstr = 'SCRIPT_ERR_SCRIPT_SIZE';\n    return false;\n  }\n\n  try {\n    while (this.pc < this.script.chunks.length) {\n      var fSuccess = this.step();\n\n      if (!fSuccess) {\n        return false;\n      }\n    } // Size limits\n\n\n    if (this.stack.length + this.altstack.length > 1000) {\n      this.errstr = 'SCRIPT_ERR_STACK_SIZE';\n      return false;\n    }\n  } catch (e) {\n    this.errstr = 'SCRIPT_ERR_UNKNOWN_ERROR: ' + e;\n    return false;\n  }\n\n  if (this.vfExec.length > 0) {\n    this.errstr = 'SCRIPT_ERR_UNBALANCED_CONDITIONAL';\n    return false;\n  }\n\n  return true;\n};\n/**\n * Checks a locktime parameter with the transaction's locktime.\n * There are two times of nLockTime: lock-by-blockheight and lock-by-blocktime,\n * distinguished by whether nLockTime < LOCKTIME_THRESHOLD = 500000000\n *\n * See the corresponding code on bitcoin core:\n * https://github.com/bitcoin/bitcoin/blob/ffd75adce01a78b3461b3ff05bcc2b530a9ce994/src/script/interpreter.cpp#L1129\n *\n * @param {BN} nLockTime the locktime read from the script\n * @return {boolean} true if the transaction's locktime is less than or equal to\n *                   the transaction's locktime\n */\n\n\nInterpreter.prototype.checkLockTime = function (nLockTime) {\n  // We want to compare apples to apples, so fail the script\n  // unless the type of nLockTime being tested is the same as\n  // the nLockTime in the transaction.\n  if (!(this.tx.nLockTime < Interpreter.LOCKTIME_THRESHOLD && nLockTime.lt(Interpreter.LOCKTIME_THRESHOLD_BN) || this.tx.nLockTime >= Interpreter.LOCKTIME_THRESHOLD && nLockTime.gte(Interpreter.LOCKTIME_THRESHOLD_BN))) {\n    return false;\n  } // Now that we know we're comparing apples-to-apples, the\n  // comparison is a simple numeric one.\n\n\n  if (nLockTime.gt(new BN(this.tx.nLockTime))) {\n    return false;\n  } // Finally the nLockTime feature can be disabled and thus\n  // CHECKLOCKTIMEVERIFY bypassed if every txin has been\n  // finalized by setting nSequence to maxint. The\n  // transaction would be allowed into the blockchain, making\n  // the opcode ineffective.\n  //\n  // Testing if this vin is not final is sufficient to\n  // prevent this condition. Alternatively we could test all\n  // inputs, but testing just this input minimizes the data\n  // required to prove correct CHECKLOCKTIMEVERIFY execution.\n\n\n  if (!this.tx.inputs[this.nin].isFinal()) {\n    return false;\n  }\n\n  return true;\n};\n/**\n * Checks a sequence parameter with the transaction's sequence.\n * @param {BN} nSequence the sequence read from the script\n * @return {boolean} true if the transaction's sequence is less than or equal to\n *                   the transaction's sequence \n */\n\n\nInterpreter.prototype.checkSequence = function (nSequence) {\n  // Relative lock times are supported by comparing the passed in operand to\n  // the sequence number of the input.\n  var txToSequence = this.tx.inputs[this.nin].sequenceNumber; // Fail if the transaction's version number is not set high enough to\n  // trigger BIP 68 rules.\n\n  if (this.tx.version < 2) {\n    return false;\n  } // Sequence numbers with their most significant bit set are not consensus\n  // constrained. Testing that the transaction's sequence number do not have\n  // this bit set prevents using this property to get around a\n  // CHECKSEQUENCEVERIFY check.\n\n\n  var SEQUENCE_LOCKTIME_DISABLE_FLAG = Interpreter.SEQUENCE_LOCKTIME_DISABLE_FLAG;\n\n  if (txToSequence & SEQUENCE_LOCKTIME_DISABLE_FLAG) {\n    return false;\n  } // Mask off any bits that do not have consensus-enforced meaning before\n  // doing the integer comparisons\n\n\n  var nLockTimeMask = Interpreter.SEQUENCE_LOCKTIME_TYPE_FLAG | Interpreter.SEQUENCE_LOCKTIME_MASK;\n  var txToSequenceMasked = new BN(txToSequence & nLockTimeMask);\n  var nSequenceMasked = nSequence.and(new BN(nLockTimeMask)); // There are two kinds of nSequence: lock-by-blockheight and\n  // lock-by-blocktime, distinguished by whether nSequenceMasked <\n  // CTxIn::SEQUENCE_LOCKTIME_TYPE_FLAG.\n  //\n  // We want to compare apples to apples, so fail the script unless the type\n  // of nSequenceMasked being tested is the same as the nSequenceMasked in the\n  // transaction.\n\n  var SEQUENCE_LOCKTIME_TYPE_FLAG_BN = new BN(Interpreter.SEQUENCE_LOCKTIME_TYPE_FLAG);\n\n  if (!(txToSequenceMasked.lt(SEQUENCE_LOCKTIME_TYPE_FLAG_BN) && nSequenceMasked.lt(SEQUENCE_LOCKTIME_TYPE_FLAG_BN) || txToSequenceMasked.gte(SEQUENCE_LOCKTIME_TYPE_FLAG_BN) && nSequenceMasked.gte(SEQUENCE_LOCKTIME_TYPE_FLAG_BN))) {\n    return false;\n  } // Now that we know we're comparing apples-to-apples, the comparison is a\n  // simple numeric one.\n\n\n  if (nSequenceMasked.gt(txToSequenceMasked)) {\n    return false;\n  }\n\n  return true;\n};\n/** \n * Based on the inner loop of bitcoind's EvalScript function\n * bitcoind commit: b5d1b1092998bc95313856d535c632ea5a8f9104\n */\n\n\nInterpreter.prototype.step = function () {\n  var fRequireMinimal = (this.flags & Interpreter.SCRIPT_VERIFY_MINIMALDATA) !== 0; //bool fExec = !count(vfExec.begin(), vfExec.end(), false);\n\n  var fExec = this.vfExec.indexOf(false) === -1;\n  var buf, buf1, buf2, spliced, n, x1, x2, bn, bn1, bn2, bufSig, bufPubkey, subscript;\n  var sig, pubkey;\n  var fValue, fSuccess; // Read instruction\n\n  var chunk = this.script.chunks[this.pc];\n  this.pc++;\n  var opcodenum = chunk.opcodenum;\n\n  if (_.isUndefined(opcodenum)) {\n    this.errstr = 'SCRIPT_ERR_UNDEFINED_OPCODE';\n    return false;\n  }\n\n  if (chunk.buf && chunk.buf.length > Interpreter.MAX_SCRIPT_ELEMENT_SIZE) {\n    this.errstr = 'SCRIPT_ERR_PUSH_SIZE';\n    return false;\n  } // Note how Opcode.OP_RESERVED does not count towards the opcode limit.\n\n\n  if (opcodenum > Opcode.OP_16 && ++this.nOpCount > 201) {\n    this.errstr = 'SCRIPT_ERR_OP_COUNT';\n    return false;\n  }\n\n  if (opcodenum === Opcode.OP_CAT || opcodenum === Opcode.OP_SUBSTR || opcodenum === Opcode.OP_LEFT || opcodenum === Opcode.OP_RIGHT || opcodenum === Opcode.OP_INVERT || opcodenum === Opcode.OP_AND || opcodenum === Opcode.OP_OR || opcodenum === Opcode.OP_XOR || opcodenum === Opcode.OP_2MUL || opcodenum === Opcode.OP_2DIV || opcodenum === Opcode.OP_MUL || opcodenum === Opcode.OP_DIV || opcodenum === Opcode.OP_MOD || opcodenum === Opcode.OP_LSHIFT || opcodenum === Opcode.OP_RSHIFT) {\n    this.errstr = 'SCRIPT_ERR_DISABLED_OPCODE';\n    return false;\n  }\n\n  if (fExec && 0 <= opcodenum && opcodenum <= Opcode.OP_PUSHDATA4) {\n    if (fRequireMinimal && !this.script.checkMinimalPush(this.pc - 1)) {\n      this.errstr = 'SCRIPT_ERR_MINIMALDATA';\n      return false;\n    }\n\n    if (!chunk.buf) {\n      this.stack.push(Interpreter.false);\n    } else if (chunk.len !== chunk.buf.length) {\n      throw new Error('Length of push value not equal to length of data');\n    } else {\n      this.stack.push(chunk.buf);\n    }\n  } else if (fExec || Opcode.OP_IF <= opcodenum && opcodenum <= Opcode.OP_ENDIF) {\n    switch (opcodenum) {\n      // Push value\n      case Opcode.OP_1NEGATE:\n      case Opcode.OP_1:\n      case Opcode.OP_2:\n      case Opcode.OP_3:\n      case Opcode.OP_4:\n      case Opcode.OP_5:\n      case Opcode.OP_6:\n      case Opcode.OP_7:\n      case Opcode.OP_8:\n      case Opcode.OP_9:\n      case Opcode.OP_10:\n      case Opcode.OP_11:\n      case Opcode.OP_12:\n      case Opcode.OP_13:\n      case Opcode.OP_14:\n      case Opcode.OP_15:\n      case Opcode.OP_16:\n        {\n          // ( -- value)\n          // ScriptNum bn((int)opcode - (int)(Opcode.OP_1 - 1));\n          n = opcodenum - (Opcode.OP_1 - 1);\n          buf = new BN(n).toScriptNumBuffer();\n          this.stack.push(buf); // The result of these opcodes should always be the minimal way to push the data\n          // they push, so no need for a CheckMinimalPush here.\n        }\n        break;\n      //\n      // Control\n      //\n\n      case Opcode.OP_NOP:\n        break;\n\n      case Opcode.OP_NOP2:\n      case Opcode.OP_CHECKLOCKTIMEVERIFY:\n        if (!(this.flags & Interpreter.SCRIPT_VERIFY_CHECKLOCKTIMEVERIFY)) {\n          // not enabled; treat as a NOP2\n          if (this.flags & Interpreter.SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_NOPS) {\n            this.errstr = 'SCRIPT_ERR_DISCOURAGE_UPGRADABLE_NOPS';\n            return false;\n          }\n\n          break;\n        }\n\n        if (this.stack.length < 1) {\n          this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n          return false;\n        } // Note that elsewhere numeric opcodes are limited to\n        // operands in the range -2**31+1 to 2**31-1, however it is\n        // legal for opcodes to produce results exceeding that\n        // range. This limitation is implemented by CScriptNum's\n        // default 4-byte limit.\n        //\n        // If we kept to that limit we'd have a year 2038 problem,\n        // even though the nLockTime field in transactions\n        // themselves is uint32 which only becomes meaningless\n        // after the year 2106.\n        //\n        // Thus as a special case we tell CScriptNum to accept up\n        // to 5-byte bignums, which are good until 2**39-1, well\n        // beyond the 2**32-1 limit of the nLockTime field itself.\n\n\n        var nLockTime = BN.fromScriptNumBuffer(this.stack[this.stack.length - 1], fRequireMinimal, 5); // In the rare event that the argument may be < 0 due to\n        // some arithmetic being done first, you can always use\n        // 0 MAX CHECKLOCKTIMEVERIFY.\n\n        if (nLockTime.lt(new BN(0))) {\n          this.errstr = 'SCRIPT_ERR_NEGATIVE_LOCKTIME';\n          return false;\n        } // Actually compare the specified lock time with the transaction.\n\n\n        if (!this.checkLockTime(nLockTime)) {\n          this.errstr = 'SCRIPT_ERR_UNSATISFIED_LOCKTIME';\n          return false;\n        }\n\n        break;\n\n      case Opcode.OP_NOP3:\n      case Opcode.OP_CHECKSEQUENCEVERIFY:\n        if (!(this.flags & Interpreter.SCRIPT_VERIFY_CHECKSEQUENCEVERIFY)) {\n          // not enabled; treat as a NOP3\n          if (this.flags & Interpreter.SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_NOPS) {\n            this.errstr = 'SCRIPT_ERR_DISCOURAGE_UPGRADABLE_NOPS';\n            return false;\n          }\n\n          break;\n        }\n\n        if (this.stack.length < 1) {\n          this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n          return false;\n        } // nSequence, like nLockTime, is a 32-bit unsigned\n        // integer field. See the comment in CHECKLOCKTIMEVERIFY\n        // regarding 5-byte numeric operands.\n\n\n        var nSequence = BN.fromScriptNumBuffer(this.stack[this.stack.length - 1], fRequireMinimal, 5); // In the rare event that the argument may be < 0 due to\n        // some arithmetic being done first, you can always use\n        // 0 MAX CHECKSEQUENCEVERIFY.\n\n        if (nSequence.lt(new BN(0))) {\n          this.errstr = 'SCRIPT_ERR_NEGATIVE_LOCKTIME';\n          return false;\n        } // To provide for future soft-fork extensibility, if the\n        // operand has the disabled lock-time flag set,\n        // CHECKSEQUENCEVERIFY behaves as a NOP.\n\n\n        if ((nSequence & Interpreter.SEQUENCE_LOCKTIME_DISABLE_FLAG) != 0) {\n          break;\n        } // Actually compare the specified lock time with the transaction.\n\n\n        if (!this.checkSequence(nSequence)) {\n          this.errstr = 'SCRIPT_ERR_UNSATISFIED_LOCKTIME';\n          return false;\n        }\n\n        break;\n\n      case Opcode.OP_NOP1:\n      case Opcode.OP_NOP4:\n      case Opcode.OP_NOP5:\n      case Opcode.OP_NOP6:\n      case Opcode.OP_NOP7:\n      case Opcode.OP_NOP8:\n      case Opcode.OP_NOP9:\n      case Opcode.OP_NOP10:\n        {\n          if (this.flags & Interpreter.SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_NOPS) {\n            this.errstr = 'SCRIPT_ERR_DISCOURAGE_UPGRADABLE_NOPS';\n            return false;\n          }\n        }\n        break;\n\n      case Opcode.OP_IF:\n      case Opcode.OP_NOTIF:\n        {\n          // <expression> if [statements] [else [statements]] endif\n          // bool fValue = false;\n          fValue = false;\n\n          if (fExec) {\n            if (this.stack.length < 1) {\n              this.errstr = 'SCRIPT_ERR_UNBALANCED_CONDITIONAL';\n              return false;\n            }\n\n            buf = this.stack[this.stack.length - 1];\n\n            if (this.flags & Interpreter.SCRIPT_VERIFY_MINIMALIF) {\n              buf = this.stack[this.stack.length - 1];\n\n              if (buf.length > 1) {\n                this.errstr = 'SCRIPT_ERR_MINIMALIF';\n                return false;\n              }\n\n              if (buf.length == 1 && buf[0] != 1) {\n                this.errstr = 'SCRIPT_ERR_MINIMALIF';\n                return false;\n              }\n            }\n\n            fValue = Interpreter.castToBool(buf);\n\n            if (opcodenum === Opcode.OP_NOTIF) {\n              fValue = !fValue;\n            }\n\n            this.stack.pop();\n          }\n\n          this.vfExec.push(fValue);\n        }\n        break;\n\n      case Opcode.OP_ELSE:\n        {\n          if (this.vfExec.length === 0) {\n            this.errstr = 'SCRIPT_ERR_UNBALANCED_CONDITIONAL';\n            return false;\n          }\n\n          this.vfExec[this.vfExec.length - 1] = !this.vfExec[this.vfExec.length - 1];\n        }\n        break;\n\n      case Opcode.OP_ENDIF:\n        {\n          if (this.vfExec.length === 0) {\n            this.errstr = 'SCRIPT_ERR_UNBALANCED_CONDITIONAL';\n            return false;\n          }\n\n          this.vfExec.pop();\n        }\n        break;\n\n      case Opcode.OP_VERIFY:\n        {\n          // (true -- ) or\n          // (false -- false) and return\n          if (this.stack.length < 1) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n\n          buf = this.stack[this.stack.length - 1];\n          fValue = Interpreter.castToBool(buf);\n\n          if (fValue) {\n            this.stack.pop();\n          } else {\n            this.errstr = 'SCRIPT_ERR_VERIFY';\n            return false;\n          }\n        }\n        break;\n\n      case Opcode.OP_RETURN:\n        {\n          this.errstr = 'SCRIPT_ERR_OP_RETURN';\n          return false;\n        }\n        break;\n      //\n      // Stack ops\n      //\n\n      case Opcode.OP_TOALTSTACK:\n        {\n          if (this.stack.length < 1) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n\n          this.altstack.push(this.stack.pop());\n        }\n        break;\n\n      case Opcode.OP_FROMALTSTACK:\n        {\n          if (this.altstack.length < 1) {\n            this.errstr = 'SCRIPT_ERR_INVALID_ALTSTACK_OPERATION';\n            return false;\n          }\n\n          this.stack.push(this.altstack.pop());\n        }\n        break;\n\n      case Opcode.OP_2DROP:\n        {\n          // (x1 x2 -- )\n          if (this.stack.length < 2) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n\n          this.stack.pop();\n          this.stack.pop();\n        }\n        break;\n\n      case Opcode.OP_2DUP:\n        {\n          // (x1 x2 -- x1 x2 x1 x2)\n          if (this.stack.length < 2) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n\n          buf1 = this.stack[this.stack.length - 2];\n          buf2 = this.stack[this.stack.length - 1];\n          this.stack.push(buf1);\n          this.stack.push(buf2);\n        }\n        break;\n\n      case Opcode.OP_3DUP:\n        {\n          // (x1 x2 x3 -- x1 x2 x3 x1 x2 x3)\n          if (this.stack.length < 3) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n\n          buf1 = this.stack[this.stack.length - 3];\n          buf2 = this.stack[this.stack.length - 2];\n          var buf3 = this.stack[this.stack.length - 1];\n          this.stack.push(buf1);\n          this.stack.push(buf2);\n          this.stack.push(buf3);\n        }\n        break;\n\n      case Opcode.OP_2OVER:\n        {\n          // (x1 x2 x3 x4 -- x1 x2 x3 x4 x1 x2)\n          if (this.stack.length < 4) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n\n          buf1 = this.stack[this.stack.length - 4];\n          buf2 = this.stack[this.stack.length - 3];\n          this.stack.push(buf1);\n          this.stack.push(buf2);\n        }\n        break;\n\n      case Opcode.OP_2ROT:\n        {\n          // (x1 x2 x3 x4 x5 x6 -- x3 x4 x5 x6 x1 x2)\n          if (this.stack.length < 6) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n\n          spliced = this.stack.splice(this.stack.length - 6, 2);\n          this.stack.push(spliced[0]);\n          this.stack.push(spliced[1]);\n        }\n        break;\n\n      case Opcode.OP_2SWAP:\n        {\n          // (x1 x2 x3 x4 -- x3 x4 x1 x2)\n          if (this.stack.length < 4) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n\n          spliced = this.stack.splice(this.stack.length - 4, 2);\n          this.stack.push(spliced[0]);\n          this.stack.push(spliced[1]);\n        }\n        break;\n\n      case Opcode.OP_IFDUP:\n        {\n          // (x - 0 | x x)\n          if (this.stack.length < 1) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n\n          buf = this.stack[this.stack.length - 1];\n          fValue = Interpreter.castToBool(buf);\n\n          if (fValue) {\n            this.stack.push(buf);\n          }\n        }\n        break;\n\n      case Opcode.OP_DEPTH:\n        {\n          // -- stacksize\n          buf = new BN(this.stack.length).toScriptNumBuffer();\n          this.stack.push(buf);\n        }\n        break;\n\n      case Opcode.OP_DROP:\n        {\n          // (x -- )\n          if (this.stack.length < 1) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n\n          this.stack.pop();\n        }\n        break;\n\n      case Opcode.OP_DUP:\n        {\n          // (x -- x x)\n          if (this.stack.length < 1) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n\n          this.stack.push(this.stack[this.stack.length - 1]);\n        }\n        break;\n\n      case Opcode.OP_NIP:\n        {\n          // (x1 x2 -- x2)\n          if (this.stack.length < 2) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n\n          this.stack.splice(this.stack.length - 2, 1);\n        }\n        break;\n\n      case Opcode.OP_OVER:\n        {\n          // (x1 x2 -- x1 x2 x1)\n          if (this.stack.length < 2) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n\n          this.stack.push(this.stack[this.stack.length - 2]);\n        }\n        break;\n\n      case Opcode.OP_PICK:\n      case Opcode.OP_ROLL:\n        {\n          // (xn ... x2 x1 x0 n - xn ... x2 x1 x0 xn)\n          // (xn ... x2 x1 x0 n - ... x2 x1 x0 xn)\n          if (this.stack.length < 2) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n\n          buf = this.stack[this.stack.length - 1];\n          bn = BN.fromScriptNumBuffer(buf, fRequireMinimal);\n          n = bn.toNumber();\n          this.stack.pop();\n\n          if (n < 0 || n >= this.stack.length) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n\n          buf = this.stack[this.stack.length - n - 1];\n\n          if (opcodenum === Opcode.OP_ROLL) {\n            this.stack.splice(this.stack.length - n - 1, 1);\n          }\n\n          this.stack.push(buf);\n        }\n        break;\n\n      case Opcode.OP_ROT:\n        {\n          // (x1 x2 x3 -- x2 x3 x1)\n          //  x2 x1 x3  after first swap\n          //  x2 x3 x1  after second swap\n          if (this.stack.length < 3) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n\n          x1 = this.stack[this.stack.length - 3];\n          x2 = this.stack[this.stack.length - 2];\n          var x3 = this.stack[this.stack.length - 1];\n          this.stack[this.stack.length - 3] = x2;\n          this.stack[this.stack.length - 2] = x3;\n          this.stack[this.stack.length - 1] = x1;\n        }\n        break;\n\n      case Opcode.OP_SWAP:\n        {\n          // (x1 x2 -- x2 x1)\n          if (this.stack.length < 2) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n\n          x1 = this.stack[this.stack.length - 2];\n          x2 = this.stack[this.stack.length - 1];\n          this.stack[this.stack.length - 2] = x2;\n          this.stack[this.stack.length - 1] = x1;\n        }\n        break;\n\n      case Opcode.OP_TUCK:\n        {\n          // (x1 x2 -- x2 x1 x2)\n          if (this.stack.length < 2) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n\n          this.stack.splice(this.stack.length - 2, 0, this.stack[this.stack.length - 1]);\n        }\n        break;\n\n      case Opcode.OP_SIZE:\n        {\n          // (in -- in size)\n          if (this.stack.length < 1) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n\n          bn = new BN(this.stack[this.stack.length - 1].length);\n          this.stack.push(bn.toScriptNumBuffer());\n        }\n        break;\n      //\n      // Bitwise logic\n      //\n\n      case Opcode.OP_EQUAL:\n      case Opcode.OP_EQUALVERIFY:\n        //case Opcode.OP_NOTEQUAL: // use Opcode.OP_NUMNOTEQUAL\n        {\n          // (x1 x2 - bool)\n          if (this.stack.length < 2) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n\n          buf1 = this.stack[this.stack.length - 2];\n          buf2 = this.stack[this.stack.length - 1];\n          var fEqual = buf1.toString('hex') === buf2.toString('hex');\n          this.stack.pop();\n          this.stack.pop();\n          this.stack.push(fEqual ? Interpreter.true : Interpreter.false);\n\n          if (opcodenum === Opcode.OP_EQUALVERIFY) {\n            if (fEqual) {\n              this.stack.pop();\n            } else {\n              this.errstr = 'SCRIPT_ERR_EQUALVERIFY';\n              return false;\n            }\n          }\n        }\n        break;\n      //\n      // Numeric\n      //\n\n      case Opcode.OP_1ADD:\n      case Opcode.OP_1SUB:\n      case Opcode.OP_NEGATE:\n      case Opcode.OP_ABS:\n      case Opcode.OP_NOT:\n      case Opcode.OP_0NOTEQUAL:\n        {\n          // (in -- out)\n          if (this.stack.length < 1) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n\n          buf = this.stack[this.stack.length - 1];\n          bn = BN.fromScriptNumBuffer(buf, fRequireMinimal);\n\n          switch (opcodenum) {\n            case Opcode.OP_1ADD:\n              bn = bn.add(BN.One);\n              break;\n\n            case Opcode.OP_1SUB:\n              bn = bn.sub(BN.One);\n              break;\n\n            case Opcode.OP_NEGATE:\n              bn = bn.neg();\n              break;\n\n            case Opcode.OP_ABS:\n              if (bn.cmp(BN.Zero) < 0) {\n                bn = bn.neg();\n              }\n\n              break;\n\n            case Opcode.OP_NOT:\n              bn = new BN((bn.cmp(BN.Zero) === 0) + 0);\n              break;\n\n            case Opcode.OP_0NOTEQUAL:\n              bn = new BN((bn.cmp(BN.Zero) !== 0) + 0);\n              break;\n            //default:      assert(!'invalid opcode'); break; // TODO: does this ever occur?\n          }\n\n          this.stack.pop();\n          this.stack.push(bn.toScriptNumBuffer());\n        }\n        break;\n\n      case Opcode.OP_ADD:\n      case Opcode.OP_SUB:\n      case Opcode.OP_BOOLAND:\n      case Opcode.OP_BOOLOR:\n      case Opcode.OP_NUMEQUAL:\n      case Opcode.OP_NUMEQUALVERIFY:\n      case Opcode.OP_NUMNOTEQUAL:\n      case Opcode.OP_LESSTHAN:\n      case Opcode.OP_GREATERTHAN:\n      case Opcode.OP_LESSTHANOREQUAL:\n      case Opcode.OP_GREATERTHANOREQUAL:\n      case Opcode.OP_MIN:\n      case Opcode.OP_MAX:\n        {\n          // (x1 x2 -- out)\n          if (this.stack.length < 2) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n\n          bn1 = BN.fromScriptNumBuffer(this.stack[this.stack.length - 2], fRequireMinimal);\n          bn2 = BN.fromScriptNumBuffer(this.stack[this.stack.length - 1], fRequireMinimal);\n          bn = new BN(0);\n\n          switch (opcodenum) {\n            case Opcode.OP_ADD:\n              bn = bn1.add(bn2);\n              break;\n\n            case Opcode.OP_SUB:\n              bn = bn1.sub(bn2);\n              break;\n            // case Opcode.OP_BOOLAND:       bn = (bn1 != bnZero && bn2 != bnZero); break;\n\n            case Opcode.OP_BOOLAND:\n              bn = new BN((bn1.cmp(BN.Zero) !== 0 && bn2.cmp(BN.Zero) !== 0) + 0);\n              break;\n            // case Opcode.OP_BOOLOR:        bn = (bn1 != bnZero || bn2 != bnZero); break;\n\n            case Opcode.OP_BOOLOR:\n              bn = new BN((bn1.cmp(BN.Zero) !== 0 || bn2.cmp(BN.Zero) !== 0) + 0);\n              break;\n            // case Opcode.OP_NUMEQUAL:      bn = (bn1 == bn2); break;\n\n            case Opcode.OP_NUMEQUAL:\n              bn = new BN((bn1.cmp(bn2) === 0) + 0);\n              break;\n            // case Opcode.OP_NUMEQUALVERIFY:    bn = (bn1 == bn2); break;\n\n            case Opcode.OP_NUMEQUALVERIFY:\n              bn = new BN((bn1.cmp(bn2) === 0) + 0);\n              break;\n            // case Opcode.OP_NUMNOTEQUAL:     bn = (bn1 != bn2); break;\n\n            case Opcode.OP_NUMNOTEQUAL:\n              bn = new BN((bn1.cmp(bn2) !== 0) + 0);\n              break;\n            // case Opcode.OP_LESSTHAN:      bn = (bn1 < bn2); break;\n\n            case Opcode.OP_LESSTHAN:\n              bn = new BN((bn1.cmp(bn2) < 0) + 0);\n              break;\n            // case Opcode.OP_GREATERTHAN:     bn = (bn1 > bn2); break;\n\n            case Opcode.OP_GREATERTHAN:\n              bn = new BN((bn1.cmp(bn2) > 0) + 0);\n              break;\n            // case Opcode.OP_LESSTHANOREQUAL:   bn = (bn1 <= bn2); break;\n\n            case Opcode.OP_LESSTHANOREQUAL:\n              bn = new BN((bn1.cmp(bn2) <= 0) + 0);\n              break;\n            // case Opcode.OP_GREATERTHANOREQUAL:  bn = (bn1 >= bn2); break;\n\n            case Opcode.OP_GREATERTHANOREQUAL:\n              bn = new BN((bn1.cmp(bn2) >= 0) + 0);\n              break;\n\n            case Opcode.OP_MIN:\n              bn = bn1.cmp(bn2) < 0 ? bn1 : bn2;\n              break;\n\n            case Opcode.OP_MAX:\n              bn = bn1.cmp(bn2) > 0 ? bn1 : bn2;\n              break;\n            // default:           assert(!'invalid opcode'); break; //TODO: does this ever occur?\n          }\n\n          this.stack.pop();\n          this.stack.pop();\n          this.stack.push(bn.toScriptNumBuffer());\n\n          if (opcodenum === Opcode.OP_NUMEQUALVERIFY) {\n            // if (CastToBool(stacktop(-1)))\n            if (Interpreter.castToBool(this.stack[this.stack.length - 1])) {\n              this.stack.pop();\n            } else {\n              this.errstr = 'SCRIPT_ERR_NUMEQUALVERIFY';\n              return false;\n            }\n          }\n        }\n        break;\n\n      case Opcode.OP_WITHIN:\n        {\n          // (x min max -- out)\n          if (this.stack.length < 3) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n\n          bn1 = BN.fromScriptNumBuffer(this.stack[this.stack.length - 3], fRequireMinimal);\n          bn2 = BN.fromScriptNumBuffer(this.stack[this.stack.length - 2], fRequireMinimal);\n          var bn3 = BN.fromScriptNumBuffer(this.stack[this.stack.length - 1], fRequireMinimal); //bool fValue = (bn2 <= bn1 && bn1 < bn3);\n\n          fValue = bn2.cmp(bn1) <= 0 && bn1.cmp(bn3) < 0;\n          this.stack.pop();\n          this.stack.pop();\n          this.stack.pop();\n          this.stack.push(fValue ? Interpreter.true : Interpreter.false);\n        }\n        break;\n      //\n      // Crypto\n      //\n\n      case Opcode.OP_RIPEMD160:\n      case Opcode.OP_SHA1:\n      case Opcode.OP_SHA256:\n      case Opcode.OP_HASH160:\n      case Opcode.OP_HASH256:\n        {\n          // (in -- hash)\n          if (this.stack.length < 1) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n\n          buf = this.stack[this.stack.length - 1]; //valtype vchHash((opcode == Opcode.OP_RIPEMD160 ||\n          //                 opcode == Opcode.OP_SHA1 || opcode == Opcode.OP_HASH160) ? 20 : 32);\n\n          var bufHash;\n\n          if (opcodenum === Opcode.OP_RIPEMD160) {\n            bufHash = Hash.ripemd160(buf);\n          } else if (opcodenum === Opcode.OP_SHA1) {\n            bufHash = Hash.sha1(buf);\n          } else if (opcodenum === Opcode.OP_SHA256) {\n            bufHash = Hash.sha256(buf);\n          } else if (opcodenum === Opcode.OP_HASH160) {\n            bufHash = Hash.sha256ripemd160(buf);\n          } else if (opcodenum === Opcode.OP_HASH256) {\n            bufHash = Hash.sha256sha256(buf);\n          }\n\n          this.stack.pop();\n          this.stack.push(bufHash);\n        }\n        break;\n\n      case Opcode.OP_CODESEPARATOR:\n        {\n          // Hash starts after the code separator\n          this.pbegincodehash = this.pc;\n        }\n        break;\n\n      case Opcode.OP_CHECKSIG:\n      case Opcode.OP_CHECKSIGVERIFY:\n        {\n          // (sig pubkey -- bool)\n          if (this.stack.length < 2) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n\n          bufSig = this.stack[this.stack.length - 2];\n          bufPubkey = this.stack[this.stack.length - 1];\n\n          if (!this.checkSignatureEncoding(bufSig) || !this.checkPubkeyEncoding(bufPubkey)) {\n            return false;\n          } // Subset of script starting at the most recent codeseparator\n          // CScript scriptCode(pbegincodehash, pend);\n\n\n          subscript = new Script().set({\n            chunks: this.script.chunks.slice(this.pbegincodehash)\n          }); // Drop the signature, since there's no way for a signature to sign itself\n\n          if (this.sigversion === Interpreter.SIGVERSION_BASE) {\n            var tmpScript = new Script().add(bufSig);\n            subscript.findAndDelete(tmpScript);\n          }\n\n          try {\n            sig = Signature.fromTxFormat(bufSig);\n            pubkey = PublicKey.fromBuffer(bufPubkey, false);\n            fSuccess = this.tx.verifySignature(sig, pubkey, this.nin, subscript, this.sigversion, this.satoshis);\n          } catch (e) {\n            //invalid sig or pubkey\n            fSuccess = false;\n          }\n\n          if (!fSuccess && this.flags & Interpreter.SCRIPT_VERIFY_NULLFAIL && bufSig.length) {\n            this.errstr = 'SCRIPT_ERR_NULLFAIL';\n            return false;\n          }\n\n          this.stack.pop();\n          this.stack.pop(); // stack.push_back(fSuccess ? vchTrue : vchFalse);\n\n          this.stack.push(fSuccess ? Interpreter.true : Interpreter.false);\n\n          if (opcodenum === Opcode.OP_CHECKSIGVERIFY) {\n            if (fSuccess) {\n              this.stack.pop();\n            } else {\n              this.errstr = 'SCRIPT_ERR_CHECKSIGVERIFY';\n              return false;\n            }\n          }\n        }\n        break;\n\n      case Opcode.OP_CHECKMULTISIG:\n      case Opcode.OP_CHECKMULTISIGVERIFY:\n        {\n          // ([sig ...] num_of_signatures [pubkey ...] num_of_pubkeys -- bool)\n          var i = 1;\n\n          if (this.stack.length < i) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n\n          var nKeysCount = BN.fromScriptNumBuffer(this.stack[this.stack.length - i], fRequireMinimal).toNumber();\n\n          if (nKeysCount < 0 || nKeysCount > 20) {\n            this.errstr = 'SCRIPT_ERR_PUBKEY_COUNT';\n            return false;\n          }\n\n          this.nOpCount += nKeysCount;\n\n          if (this.nOpCount > 201) {\n            this.errstr = 'SCRIPT_ERR_OP_COUNT';\n            return false;\n          } // int ikey = ++i;\n\n\n          var ikey = ++i;\n          i += nKeysCount; // ikey2 is the position of last non-signature item in\n          // the stack. Top stack item = 1. With\n          // SCRIPT_VERIFY_NULLFAIL, this is used for cleanup if\n          // operation fails.\n\n          var ikey2 = nKeysCount + 2;\n\n          if (this.stack.length < i) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n\n          var nSigsCount = BN.fromScriptNumBuffer(this.stack[this.stack.length - i], fRequireMinimal).toNumber();\n\n          if (nSigsCount < 0 || nSigsCount > nKeysCount) {\n            this.errstr = 'SCRIPT_ERR_SIG_COUNT';\n            return false;\n          } // int isig = ++i;\n\n\n          var isig = ++i;\n          i += nSigsCount;\n\n          if (this.stack.length < i) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          } // Subset of script starting at the most recent codeseparator\n\n\n          subscript = new Script().set({\n            chunks: this.script.chunks.slice(this.pbegincodehash)\n          }); // Drop the signatures, since there's no way for a signature to sign itself\n\n          if (this.sigversion === Interpreter.SIGVERSION_BASE) {\n            for (var k = 0; k < nSigsCount; k++) {\n              bufSig = this.stack[this.stack.length - isig - k];\n              subscript.findAndDelete(new Script().add(bufSig));\n            }\n          }\n\n          fSuccess = true;\n\n          while (fSuccess && nSigsCount > 0) {\n            // valtype& vchSig  = stacktop(-isig);\n            bufSig = this.stack[this.stack.length - isig]; // valtype& vchPubKey = stacktop(-ikey);\n\n            bufPubkey = this.stack[this.stack.length - ikey];\n\n            if (!this.checkSignatureEncoding(bufSig) || !this.checkPubkeyEncoding(bufPubkey)) {\n              return false;\n            }\n\n            var fOk;\n\n            try {\n              sig = Signature.fromTxFormat(bufSig);\n              pubkey = PublicKey.fromBuffer(bufPubkey, false);\n              fOk = this.tx.verifySignature(sig, pubkey, this.nin, subscript, this.sigversion, this.satoshis);\n            } catch (e) {\n              //invalid sig or pubkey\n              fOk = false;\n            }\n\n            if (fOk) {\n              isig++;\n              nSigsCount--;\n            }\n\n            ikey++;\n            nKeysCount--; // If there are more signatures left than keys left,\n            // then too many signatures have failed\n\n            if (nSigsCount > nKeysCount) {\n              fSuccess = false;\n            }\n          } // Clean up stack of actual arguments\n\n\n          while (i-- > 1) {\n            if (!fSuccess && this.flags & Interpreter.SCRIPT_VERIFY_NULLFAIL && !ikey2 && this.stack[this.stack.length - 1].length) {\n              this.errstr = 'SCRIPT_ERR_NULLFAIL';\n              return false;\n            }\n\n            if (ikey2 > 0) {\n              ikey2--;\n            }\n\n            this.stack.pop();\n          } // A bug causes CHECKMULTISIG to consume one extra argument\n          // whose contents were not checked in any way.\n          //\n          // Unfortunately this is a potential source of mutability,\n          // so optionally verify it is exactly equal to zero prior\n          // to removing it from the stack.\n\n\n          if (this.stack.length < 1) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n\n          if (this.flags & Interpreter.SCRIPT_VERIFY_NULLDUMMY && this.stack[this.stack.length - 1].length) {\n            this.errstr = 'SCRIPT_ERR_SIG_NULLDUMMY';\n            return false;\n          }\n\n          this.stack.pop();\n          this.stack.push(fSuccess ? Interpreter.true : Interpreter.false);\n\n          if (opcodenum === Opcode.OP_CHECKMULTISIGVERIFY) {\n            if (fSuccess) {\n              this.stack.pop();\n            } else {\n              this.errstr = 'SCRIPT_ERR_CHECKMULTISIGVERIFY';\n              return false;\n            }\n          }\n        }\n        break;\n\n      default:\n        this.errstr = 'SCRIPT_ERR_BAD_OPCODE';\n        return false;\n    }\n  }\n\n  return true;\n};","map":{"version":3,"names":["_","require","Script","Opcode","BN","Hash","Signature","PublicKey","Interpreter","obj","initialize","set","prototype","verifyWitnessProgram","version","program","witness","satoshis","flags","scriptPubKey","stack","length","errstr","scriptPubKeyBuffer","hash","sha256","toString","slice","add","OP_DUP","OP_HASH160","OP_EQUALVERIFY","OP_CHECKSIG","SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_WITNESS_PROGRAM","script","sigversion","SIGVERSION_WITNESS_V0","s","MAX_SCRIPT_ELEMENT_SIZE","evaluate","buf","castToBool","verify","scriptSig","scriptPubkey","tx","nin","Transaction","isUndefined","SIGVERSION_BASE","stackCopy","SCRIPT_VERIFY_SIGPUSHONLY","isPushOnly","SCRIPT_VERIFY_P2SH","hadWitness","SCRIPT_VERIFY_WITNESS","witnessValues","isWitnessProgram","toBuffer","isScriptHashOut","Error","redeemScriptSerialized","redeemScript","fromBuffer","pop","p2shWitnessValues","redeemScriptPush","toHex","SCRIPT_VERIFY_CLEANSTACK","module","exports","altstack","pc","pbegincodehash","nOpCount","vfExec","altack","true","Buffer","from","false","LOCKTIME_THRESHOLD","LOCKTIME_THRESHOLD_BN","SCRIPT_VERIFY_NONE","SCRIPT_VERIFY_STRICTENC","SCRIPT_VERIFY_DERSIG","SCRIPT_VERIFY_LOW_S","SCRIPT_VERIFY_NULLDUMMY","SCRIPT_VERIFY_MINIMALDATA","SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_NOPS","SCRIPT_VERIFY_CHECKLOCKTIMEVERIFY","SCRIPT_VERIFY_CHECKSEQUENCEVERIFY","SCRIPT_VERIFY_MINIMALIF","SCRIPT_VERIFY_NULLFAIL","SCRIPT_VERIFY_WITNESS_PUBKEYTYPE","SCRIPT_ENABLE_SIGHASH_FORKID","SCRIPT_ENABLE_REPLAY_PROTECTION","SCRIPT_ENABLE_MONOLITH_OPCODES","SEQUENCE_LOCKTIME_DISABLE_FLAG","SEQUENCE_LOCKTIME_TYPE_FLAG","SEQUENCE_LOCKTIME_MASK","i","checkSignatureEncoding","sig","isTxDER","fromTxFormat","hasLowS","hasDefinedHashtype","checkPubkeyEncoding","isValid","compressed","chunks","fSuccess","step","e","checkLockTime","nLockTime","lt","gte","gt","inputs","isFinal","checkSequence","nSequence","txToSequence","sequenceNumber","nLockTimeMask","txToSequenceMasked","nSequenceMasked","and","SEQUENCE_LOCKTIME_TYPE_FLAG_BN","fRequireMinimal","fExec","indexOf","buf1","buf2","spliced","n","x1","x2","bn","bn1","bn2","bufSig","bufPubkey","subscript","pubkey","fValue","chunk","opcodenum","OP_16","OP_CAT","OP_SUBSTR","OP_LEFT","OP_RIGHT","OP_INVERT","OP_AND","OP_OR","OP_XOR","OP_2MUL","OP_2DIV","OP_MUL","OP_DIV","OP_MOD","OP_LSHIFT","OP_RSHIFT","OP_PUSHDATA4","checkMinimalPush","push","len","OP_IF","OP_ENDIF","OP_1NEGATE","OP_1","OP_2","OP_3","OP_4","OP_5","OP_6","OP_7","OP_8","OP_9","OP_10","OP_11","OP_12","OP_13","OP_14","OP_15","toScriptNumBuffer","OP_NOP","OP_NOP2","OP_CHECKLOCKTIMEVERIFY","fromScriptNumBuffer","OP_NOP3","OP_CHECKSEQUENCEVERIFY","OP_NOP1","OP_NOP4","OP_NOP5","OP_NOP6","OP_NOP7","OP_NOP8","OP_NOP9","OP_NOP10","OP_NOTIF","OP_ELSE","OP_VERIFY","OP_RETURN","OP_TOALTSTACK","OP_FROMALTSTACK","OP_2DROP","OP_2DUP","OP_3DUP","buf3","OP_2OVER","OP_2ROT","splice","OP_2SWAP","OP_IFDUP","OP_DEPTH","OP_DROP","OP_NIP","OP_OVER","OP_PICK","OP_ROLL","toNumber","OP_ROT","x3","OP_SWAP","OP_TUCK","OP_SIZE","OP_EQUAL","fEqual","OP_1ADD","OP_1SUB","OP_NEGATE","OP_ABS","OP_NOT","OP_0NOTEQUAL","One","sub","neg","cmp","Zero","OP_ADD","OP_SUB","OP_BOOLAND","OP_BOOLOR","OP_NUMEQUAL","OP_NUMEQUALVERIFY","OP_NUMNOTEQUAL","OP_LESSTHAN","OP_GREATERTHAN","OP_LESSTHANOREQUAL","OP_GREATERTHANOREQUAL","OP_MIN","OP_MAX","OP_WITHIN","bn3","OP_RIPEMD160","OP_SHA1","OP_SHA256","OP_HASH256","bufHash","ripemd160","sha1","sha256ripemd160","sha256sha256","OP_CODESEPARATOR","OP_CHECKSIGVERIFY","tmpScript","findAndDelete","verifySignature","OP_CHECKMULTISIG","OP_CHECKMULTISIGVERIFY","nKeysCount","ikey","ikey2","nSigsCount","isig","k","fOk"],"sources":["C:/Users/acer/node_modules/bitcore-lib-doge/lib/script/interpreter.js"],"sourcesContent":["'use strict';\n\nvar _ = require('lodash');\n\nvar Script = require('./script');\nvar Opcode = require('../opcode');\nvar BN = require('../crypto/bn');\nvar Hash = require('../crypto/hash');\nvar Signature = require('../crypto/signature');\nvar PublicKey = require('../publickey');\n\n/**\n * Bitcoin transactions contain scripts. Each input has a script called the\n * scriptSig, and each output has a script called the scriptPubkey. To validate\n * an input, the input's script is concatenated with the referenced output script,\n * and the result is executed. If at the end of execution the stack contains a\n * \"true\" value, then the transaction is valid.\n *\n * The primary way to use this class is via the verify function.\n * e.g., Interpreter().verify( ... );\n */\nvar Interpreter = function Interpreter(obj) {\n  if (!(this instanceof Interpreter)) {\n    return new Interpreter(obj);\n  }\n  if (obj) {\n    this.initialize();\n    this.set(obj);\n  } else {\n    this.initialize();\n  }\n};\n\nInterpreter.prototype.verifyWitnessProgram = function(version, program, witness, satoshis, flags) {\n\n  var scriptPubKey = new Script();\n  var stack = [];\n\n  if (version === 0) {\n    if (program.length === 32) {\n      if (witness.length === 0) {\n        this.errstr = 'SCRIPT_ERR_WITNESS_PROGRAM_WITNESS_EMPTY';\n        return false;\n      }\n\n      var scriptPubKeyBuffer = witness[witness.length - 1];\n      scriptPubKey = new Script(scriptPubKeyBuffer);\n      var hash = Hash.sha256(scriptPubKeyBuffer);\n      if (hash.toString('hex') !== program.toString('hex')) {\n        this.errstr = 'SCRIPT_ERR_WITNESS_PROGRAM_MISMATCH';\n        return false;\n      }\n\n      stack = witness.slice(0, -1);\n    } else if (program.length === 20) {\n      if (witness.length !== 2) {\n        this.errstr = 'SCRIPT_ERR_WITNESS_PROGRAM_MISMATCH';\n        return false;\n      }\n\n      scriptPubKey.add(Opcode.OP_DUP);\n      scriptPubKey.add(Opcode.OP_HASH160);\n      scriptPubKey.add(program);\n      scriptPubKey.add(Opcode.OP_EQUALVERIFY);\n      scriptPubKey.add(Opcode.OP_CHECKSIG);\n\n      stack = witness;\n\n    } else {\n      this.errstr = 'SCRIPT_ERR_WITNESS_PROGRAM_WRONG_LENGTH';\n      return false;\n    }\n  } else if ((flags & Interpreter.SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_WITNESS_PROGRAM)) {\n    this.errstr = 'SCRIPT_ERR_DISCOURAGE_UPGRADABLE_WITNESS_PROGRAM';\n    return false;\n  } else {\n    return true;\n  }\n\n  this.initialize();\n\n  this.set({\n    script: scriptPubKey,\n    stack: stack,\n    sigversion: Interpreter.SIGVERSION_WITNESS_V0,\n    satoshis: satoshis,\n    flags: flags,\n  });\n\n  // Disallow stack item size > MAX_SCRIPT_ELEMENT_SIZE in witness stack\n  for (let s of stack) {\n    if (s.length > Interpreter.MAX_SCRIPT_ELEMENT_SIZE) {\n      this.errstr = 'SCRIPT_ERR_PUSH_SIZE';\n      return false;\n    }\n  }\n\n  if (!this.evaluate()) {\n    return false;\n  }\n\n  if (this.stack.length !== 1) {\n    this.errstr = 'SCRIPT_ERR_EVAL_FALSE';\n    return false;\n  }\n\n  var buf = this.stack[this.stack.length - 1];\n  if (!Interpreter.castToBool(buf)) {\n    this.errstr = 'SCRIPT_ERR_EVAL_FALSE_IN_STACK';\n    return false;\n  }\n\n  return true;\n};\n\n\n\n/**\n * Verifies a Script by executing it and returns true if it is valid.\n * This function needs to be provided with the scriptSig and the scriptPubkey\n * separately.\n * @param {Script} scriptSig - the script's first part (corresponding to the tx input)\n * @param {Script} scriptPubkey - the script's last part (corresponding to the tx output)\n * @param {Transaction=} tx - the Transaction containing the scriptSig in one input (used\n *    to check signature validity for some opcodes like OP_CHECKSIG)\n * @param {number} nin - index of the transaction input containing the scriptSig verified.\n * @param {number} flags - evaluation flags. See Interpreter.SCRIPT_* constants\n * @param {number} witness - array of witness data\n * @param {number} satoshis - number of satoshis created by this output\n *\n * Translated from bitcoind's VerifyScript\n */\nInterpreter.prototype.verify = function(scriptSig, scriptPubkey, tx, nin, flags, witness, satoshis) {\n\n  var Transaction = require('../transaction');\n  if (_.isUndefined(tx)) {\n    tx = new Transaction();\n  }\n  if (_.isUndefined(nin)) {\n    nin = 0;\n  }\n  if (_.isUndefined(flags)) {\n    flags = 0;\n  }\n  if (_.isUndefined(witness)) {\n    witness = null;\n  }\n  if (_.isUndefined(satoshis)) {\n    satoshis = 0;\n  }\n\n  this.set({\n    script: scriptSig,\n    tx: tx,\n    nin: nin,\n    sigversion: Interpreter.SIGVERSION_BASE,\n    satoshis: 0,\n    flags: flags\n  });\n  var stackCopy;\n\n  if ((flags & Interpreter.SCRIPT_VERIFY_SIGPUSHONLY) !== 0 && !scriptSig.isPushOnly()) {\n    this.errstr = 'SCRIPT_ERR_SIG_PUSHONLY';\n    return false;\n  }\n\n  // evaluate scriptSig\n  if (!this.evaluate()) {\n    return false;\n  }\n\n  if (flags & Interpreter.SCRIPT_VERIFY_P2SH) {\n    stackCopy = this.stack.slice();\n  }\n\n  var stack = this.stack;\n  this.initialize();\n  this.set({\n    script: scriptPubkey,\n    stack: stack,\n    tx: tx,\n    nin: nin,\n    flags: flags\n  });\n\n  // evaluate scriptPubkey\n  if (!this.evaluate()) {\n    return false;\n  }\n\n  if (this.stack.length === 0) {\n    this.errstr = 'SCRIPT_ERR_EVAL_FALSE_NO_RESULT';\n    return false;\n  }\n\n  var buf = this.stack[this.stack.length - 1];\n  if (!Interpreter.castToBool(buf)) {\n    this.errstr = 'SCRIPT_ERR_EVAL_FALSE_IN_STACK';\n    return false;\n  }\n\n  var hadWitness = false;\n  if ((flags & Interpreter.SCRIPT_VERIFY_WITNESS)) {\n    var witnessValues = {};\n    if (scriptPubkey.isWitnessProgram(witnessValues)) {\n      hadWitness = true;\n      if (scriptSig.toBuffer().length !== 0) {\n        return false;\n      }\n      if (!this.verifyWitnessProgram(witnessValues.version, witnessValues.program, witness, satoshis, this.flags)) {\n        return false;\n      }\n    }\n  }\n\n  // Additional validation for spend-to-script-hash transactions:\n  if ((flags & Interpreter.SCRIPT_VERIFY_P2SH) && scriptPubkey.isScriptHashOut()) {\n    // scriptSig must be literals-only or validation fails\n    if (!scriptSig.isPushOnly()) {\n      this.errstr = 'SCRIPT_ERR_SIG_PUSHONLY';\n      return false;\n    }\n\n    // stackCopy cannot be empty here, because if it was the\n    // P2SH  HASH <> EQUAL  scriptPubKey would be evaluated with\n    // an empty stack and the EvalScript above would return false.\n    if (stackCopy.length === 0) {\n      throw new Error('internal error - stack copy empty');\n    }\n\n    var redeemScriptSerialized = stackCopy[stackCopy.length - 1];\n    var redeemScript = Script.fromBuffer(redeemScriptSerialized);\n    stackCopy.pop();\n\n    this.initialize();\n    this.set({\n      script: redeemScript,\n      stack: stackCopy,\n      tx: tx,\n      nin: nin,\n      flags: flags\n    });\n\n    // evaluate redeemScript\n    if (!this.evaluate()) {\n      return false;\n    }\n\n    if (stackCopy.length === 0) {\n      this.errstr = 'SCRIPT_ERR_EVAL_FALSE_NO_P2SH_STACK';\n      return false;\n    }\n\n    if (!Interpreter.castToBool(stackCopy[stackCopy.length - 1])) {\n      this.errstr = 'SCRIPT_ERR_EVAL_FALSE_IN_P2SH_STACK';\n      return false;\n    }\n    if ((flags & Interpreter.SCRIPT_VERIFY_WITNESS)) {\n      var p2shWitnessValues = {};\n      if (redeemScript.isWitnessProgram(p2shWitnessValues)) {\n        hadWitness = true;\n        var redeemScriptPush = new Script();\n        redeemScriptPush.add(redeemScript.toBuffer());\n        if (scriptSig.toHex() !== redeemScriptPush.toHex()) {\n          this.errstr = 'SCRIPT_ERR_WITNESS_MALLEATED_P2SH';\n          return false;\n        }\n\n        if (!this.verifyWitnessProgram(p2shWitnessValues.version, p2shWitnessValues.program, witness, satoshis, this.flags)) {\n          return false;\n        }\n        // Bypass the cleanstack check at the end. The actual stack is obviously not clean\n        // for witness programs.\n        stack = [stack[0]];\n      }\n    }\n  }\n\n  // The CLEANSTACK check is only performed after potential P2SH evaluation,\n  // as the non-P2SH evaluation of a P2SH script will obviously not result in\n  // a clean stack (the P2SH inputs remain). The same holds for witness\n  // evaluation.\n  if ((this.flags & Interpreter.SCRIPT_VERIFY_CLEANSTACK) != 0) {\n      // Disallow CLEANSTACK without P2SH, as otherwise a switch\n      // CLEANSTACK->P2SH+CLEANSTACK would be possible, which is not a\n      // softfork (and P2SH should be one).\n      if ((this.flags & Interpreter.SCRIPT_VERIFY_P2SH) == 0)\n        throw 'flags & SCRIPT_VERIFY_P2SH';\n\n      if (stackCopy.length != 1) {\n        this.errstr = 'SCRIPT_ERR_CLEANSTACK';\n        return false;\n      }\n  }\n\n  if ((this.flags & Interpreter.SCRIPT_VERIFY_WITNESS)) {\n    if (!hadWitness && witness.length > 0) {\n      this.errstr = 'SCRIPT_ERR_WITNESS_UNEXPECTED';\n      return false;\n    }\n  }\n\n  return true;\n};\n\nmodule.exports = Interpreter;\n\nInterpreter.prototype.initialize = function(obj) {\n  this.stack = [];\n  this.altstack = [];\n  this.pc = 0;\n  this.satoshis = 0;\n  this.sigversion = Interpreter.SIGVERSION_BASE;\n  this.pbegincodehash = 0;\n  this.nOpCount = 0;\n  this.vfExec = [];\n  this.errstr = '';\n  this.flags = 0;\n};\n\nInterpreter.prototype.set = function(obj) {\n  this.script = obj.script || this.script;\n  this.tx = obj.tx || this.tx;\n  this.nin = typeof obj.nin !== 'undefined' ? obj.nin : this.nin;\n  this.stack = obj.stack || this.stack;\n  this.altstack = obj.altack || this.altstack;\n  this.pc = typeof obj.pc !== 'undefined' ? obj.pc : this.pc;\n  this.pbegincodehash = typeof obj.pbegincodehash !== 'undefined' ? obj.pbegincodehash : this.pbegincodehash;\n  this.sigversion = typeof obj.sigversion !== 'undefined' ? obj.sigversion : this.sigversion;\n  this.satoshis = typeof obj.satoshis !== 'undefined' ? obj.satoshis : this.satoshis;\n  this.nOpCount = typeof obj.nOpCount !== 'undefined' ? obj.nOpCount : this.nOpCount;\n  this.vfExec = obj.vfExec || this.vfExec;\n  this.errstr = obj.errstr || this.errstr;\n  this.flags = typeof obj.flags !== 'undefined' ? obj.flags : this.flags;\n};\n\nInterpreter.true = Buffer.from([1]);\nInterpreter.false = Buffer.from([]);\n\nInterpreter.MAX_SCRIPT_ELEMENT_SIZE = 520;\n\nInterpreter.LOCKTIME_THRESHOLD = 500000000;\nInterpreter.LOCKTIME_THRESHOLD_BN = new BN(Interpreter.LOCKTIME_THRESHOLD);\n\n// flags taken from bitcoind\n// bitcoind commit: b5d1b1092998bc95313856d535c632ea5a8f9104\nInterpreter.SCRIPT_VERIFY_NONE = 0;\n\n// Making v1-v16 witness program non-standard\nInterpreter.SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_WITNESS_PROGRAM = (1 << 12);\n\n// Evaluate P2SH subscripts (softfork safe, BIP16).\nInterpreter.SCRIPT_VERIFY_P2SH = (1 << 0);\n\n// Passing a non-strict-DER signature or one with undefined hashtype to a checksig operation causes script failure.\n// Passing a pubkey that is not (0x04 + 64 bytes) or (0x02 or 0x03 + 32 bytes) to checksig causes that pubkey to be\n// skipped (not softfork safe: this flag can widen the validity of OP_CHECKSIG OP_NOT).\nInterpreter.SCRIPT_VERIFY_STRICTENC = (1 << 1);\n\n// Passing a non-strict-DER signature to a checksig operation causes script failure (softfork safe, BIP62 rule 1)\nInterpreter.SCRIPT_VERIFY_DERSIG = (1 << 2);\n\n// Passing a non-strict-DER signature or one with S > order/2 to a checksig operation causes script failure\n// (softfork safe, BIP62 rule 5).\nInterpreter.SCRIPT_VERIFY_LOW_S = (1 << 3);\n\n// verify dummy stack item consumed by CHECKMULTISIG is of zero-length (softfork safe, BIP62 rule 7).\nInterpreter.SCRIPT_VERIFY_NULLDUMMY = (1 << 4);\n\n// Using a non-push operator in the scriptSig causes script failure (softfork safe, BIP62 rule 2).\nInterpreter.SCRIPT_VERIFY_SIGPUSHONLY = (1 << 5);\n\n// Require minimal encodings for all push operations (OP_0... OP_16, OP_1NEGATE where possible, direct\n// pushes up to 75 bytes, OP_PUSHDATA up to 255 bytes, OP_PUSHDATA2 for anything larger). Evaluating\n// any other push causes the script to fail (BIP62 rule 3).\n// In addition, whenever a stack element is interpreted as a number, it must be of minimal length (BIP62 rule 4).\n// (softfork safe)\nInterpreter.SCRIPT_VERIFY_MINIMALDATA = (1 << 6);\n\n// Discourage use of NOPs reserved for upgrades (NOP1-10)\n//\n// Provided so that nodes can avoid accepting or mining transactions\n// containing executed NOP's whose meaning may change after a soft-fork,\n// thus rendering the script invalid; with this flag set executing\n// discouraged NOPs fails the script. This verification flag will never be\n// a mandatory flag applied to scripts in a block. NOPs that are not\n// executed, e.g.  within an unexecuted IF ENDIF block, are *not* rejected.\nInterpreter.SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_NOPS = (1 << 7);\n\n\n// Require that only a single stack element remains after evaluation. This\n// changes the success criterion from \"At least one stack element must\n// remain, and when interpreted as a boolean, it must be true\" to \"Exactly\n// one stack element must remain, and when interpreted as a boolean, it must\n// be true\".\n// (softfork safe, BIP62 rule 6)\n// Note: CLEANSTACK should never be used without P2SH or WITNESS.\nInterpreter.SCRIPT_VERIFY_CLEANSTACK = (1 << 8),\n\n// CLTV See BIP65 for details.\nInterpreter.SCRIPT_VERIFY_CHECKLOCKTIMEVERIFY = (1 << 9);\n\n// https://github.com/dogecoin/dogecoin/blob/f80bfe9068ac1a0619d48dad0d268894d926941e/src/script/interpreter.h#L92\n// Support segregated witness\n//\nInterpreter.SCRIPT_VERIFY_WITNESS = (1 << 11);\n\nInterpreter.SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_NOPS = (1 << 11);\n\n// support CHECKSEQUENCEVERIFY opcode\n//\n// See BIP112 for details\nInterpreter.SCRIPT_VERIFY_CHECKSEQUENCEVERIFY = (1 << 10);\n\n//\n// Segwit script only: Require the argument of OP_IF/NOTIF to be exactly\n// 0x01 or empty vector\n//\nInterpreter.SCRIPT_VERIFY_MINIMALIF = (1 << 13);\n\n\n// Signature(s) must be empty vector if an CHECK(MULTI)SIG operation failed\n//\nInterpreter.SCRIPT_VERIFY_NULLFAIL = (1 << 14);\n\n// Public keys in scripts must be compressed\n//\nInterpreter.SCRIPT_VERIFY_WITNESS_PUBKEYTYPE = (1 << 15);\n\n// Do we accept signature using SIGHASH_FORKID\n//\nInterpreter.SCRIPT_ENABLE_SIGHASH_FORKID = (1 << 16);\n\n// Do we accept activate replay protection using a different fork id.\n//\nInterpreter.SCRIPT_ENABLE_REPLAY_PROTECTION = (1 << 17);\n\n// Enable new opcodes.\n//\nInterpreter.SCRIPT_ENABLE_MONOLITH_OPCODES = (1 << 18);\n\n\n\n/* Below flags apply in the context of BIP 68*/\n/**\n * If this flag set, CTxIn::nSequence is NOT interpreted as a relative\n * lock-time.\n */\nInterpreter.SEQUENCE_LOCKTIME_DISABLE_FLAG = (1 << 31);\n\n/**\n * If CTxIn::nSequence encodes a relative lock-time and this flag is set,\n * the relative lock-time has units of 512 seconds, otherwise it specifies\n * blocks with a granularity of 1.\n */\nInterpreter.SEQUENCE_LOCKTIME_TYPE_FLAG = (1 << 22);\n\n/**\n * If CTxIn::nSequence encodes a relative lock-time, this mask is applied to\n * extract that lock-time from the sequence field.\n */\nInterpreter.SEQUENCE_LOCKTIME_MASK = 0x0000ffff;\n\n\nInterpreter.SIGVERSION_BASE = 0;\nInterpreter.SIGVERSION_WITNESS_V0 = 1;\n\n\nInterpreter.castToBool = function(buf) {\n  for (var i = 0; i < buf.length; i++) {\n    if (buf[i] !== 0) {\n      // can be negative zero\n      if (i === buf.length - 1 && buf[i] === 0x80) {\n        return false;\n      }\n      return true;\n    }\n  }\n  return false;\n};\n\n/**\n * Translated from bitcoind's CheckSignatureEncoding\n */\nInterpreter.prototype.checkSignatureEncoding = function(buf) {\n  var sig;\n\n    // Empty signature. Not strictly DER encoded, but allowed to provide a\n    // compact way to provide an invalid signature for use with CHECK(MULTI)SIG\n    if (buf.length == 0) {\n        return true;\n    }\n\n  if ((this.flags & (Interpreter.SCRIPT_VERIFY_DERSIG | Interpreter.SCRIPT_VERIFY_LOW_S | Interpreter.SCRIPT_VERIFY_STRICTENC)) !== 0 && !Signature.isTxDER(buf)) {\n    this.errstr = 'SCRIPT_ERR_SIG_DER_INVALID_FORMAT';\n    return false;\n  } else if ((this.flags & Interpreter.SCRIPT_VERIFY_LOW_S) !== 0) {\n    sig = Signature.fromTxFormat(buf);\n    if (!sig.hasLowS()) {\n      this.errstr = 'SCRIPT_ERR_SIG_DER_HIGH_S';\n      return false;\n    }\n  } else if ((this.flags & Interpreter.SCRIPT_VERIFY_STRICTENC) !== 0) {\n    sig = Signature.fromTxFormat(buf);\n    if (!sig.hasDefinedHashtype()) {\n      this.errstr = 'SCRIPT_ERR_SIG_HASHTYPE';\n      return false;\n    }\n  }\n\n  return true;\n};\n\n/**\n * Translated from bitcoind's CheckPubKeyEncoding\n */\nInterpreter.prototype.checkPubkeyEncoding = function(buf) {\n  if ((this.flags & Interpreter.SCRIPT_VERIFY_STRICTENC) !== 0 && !PublicKey.isValid(buf)) {\n    this.errstr = 'SCRIPT_ERR_PUBKEYTYPE';\n    return false;\n  }\n\n  // Only compressed keys are accepted in segwit\n  if ((this.flags & Interpreter.SCRIPT_VERIFY_WITNESS_PUBKEYTYPE) != 0 && this.sigversion == Interpreter.SIGVERSION_WITNESS_V0 && !PublicKey.fromBuffer(buf).compressed) {\n    this.errstr = 'SCRIPT_ERR_WITNESS_PUBKEYTYPE';\n    return false;\n  }\n\n  return true;\n};\n\n/**\n * Based on bitcoind's EvalScript function, with the inner loop moved to\n * Interpreter.prototype.step()\n * bitcoind commit: b5d1b1092998bc95313856d535c632ea5a8f9104\n */\nInterpreter.prototype.evaluate = function() {\n  if (this.script.toBuffer().length > 10000) {\n    this.errstr = 'SCRIPT_ERR_SCRIPT_SIZE';\n    return false;\n  }\n\n  try {\n    while (this.pc < this.script.chunks.length) {\n      var fSuccess = this.step();\n      if (!fSuccess) {\n        return false;\n      }\n    }\n\n    // Size limits\n    if (this.stack.length + this.altstack.length > 1000) {\n      this.errstr = 'SCRIPT_ERR_STACK_SIZE';\n      return false;\n    }\n  } catch (e) {\n    this.errstr = 'SCRIPT_ERR_UNKNOWN_ERROR: ' + e;\n    return false;\n  }\n\n  if (this.vfExec.length > 0) {\n    this.errstr = 'SCRIPT_ERR_UNBALANCED_CONDITIONAL';\n    return false;\n  }\n\n  return true;\n};\n\n/**\n * Checks a locktime parameter with the transaction's locktime.\n * There are two times of nLockTime: lock-by-blockheight and lock-by-blocktime,\n * distinguished by whether nLockTime < LOCKTIME_THRESHOLD = 500000000\n *\n * See the corresponding code on bitcoin core:\n * https://github.com/bitcoin/bitcoin/blob/ffd75adce01a78b3461b3ff05bcc2b530a9ce994/src/script/interpreter.cpp#L1129\n *\n * @param {BN} nLockTime the locktime read from the script\n * @return {boolean} true if the transaction's locktime is less than or equal to\n *                   the transaction's locktime\n */\nInterpreter.prototype.checkLockTime = function(nLockTime) {\n\n  // We want to compare apples to apples, so fail the script\n  // unless the type of nLockTime being tested is the same as\n  // the nLockTime in the transaction.\n  if (!(\n    (this.tx.nLockTime <  Interpreter.LOCKTIME_THRESHOLD && nLockTime.lt(Interpreter.LOCKTIME_THRESHOLD_BN)) ||\n    (this.tx.nLockTime >= Interpreter.LOCKTIME_THRESHOLD && nLockTime.gte(Interpreter.LOCKTIME_THRESHOLD_BN))\n  )) {\n    return false;\n  }\n\n  // Now that we know we're comparing apples-to-apples, the\n  // comparison is a simple numeric one.\n  if (nLockTime.gt(new BN(this.tx.nLockTime))) {\n    return false;\n  }\n\n  // Finally the nLockTime feature can be disabled and thus\n  // CHECKLOCKTIMEVERIFY bypassed if every txin has been\n  // finalized by setting nSequence to maxint. The\n  // transaction would be allowed into the blockchain, making\n  // the opcode ineffective.\n  //\n  // Testing if this vin is not final is sufficient to\n  // prevent this condition. Alternatively we could test all\n  // inputs, but testing just this input minimizes the data\n  // required to prove correct CHECKLOCKTIMEVERIFY execution.\n  if (!this.tx.inputs[this.nin].isFinal()) {\n    return false;\n  }\n\n  return true;\n}\n\n\n/**\n * Checks a sequence parameter with the transaction's sequence.\n * @param {BN} nSequence the sequence read from the script\n * @return {boolean} true if the transaction's sequence is less than or equal to\n *                   the transaction's sequence \n */\nInterpreter.prototype.checkSequence = function(nSequence) {\n\n    // Relative lock times are supported by comparing the passed in operand to\n    // the sequence number of the input.\n    var txToSequence = this.tx.inputs[this.nin].sequenceNumber;\n\n    // Fail if the transaction's version number is not set high enough to\n    // trigger BIP 68 rules.\n    if (this.tx.version < 2) {\n        return false;\n    }\n\n    // Sequence numbers with their most significant bit set are not consensus\n    // constrained. Testing that the transaction's sequence number do not have\n    // this bit set prevents using this property to get around a\n    // CHECKSEQUENCEVERIFY check.\n    var SEQUENCE_LOCKTIME_DISABLE_FLAG = Interpreter.SEQUENCE_LOCKTIME_DISABLE_FLAG;\n    if (txToSequence & SEQUENCE_LOCKTIME_DISABLE_FLAG) {\n        return false;\n    }\n\n    // Mask off any bits that do not have consensus-enforced meaning before\n    // doing the integer comparisons\n    var nLockTimeMask =\n        Interpreter.SEQUENCE_LOCKTIME_TYPE_FLAG | Interpreter.SEQUENCE_LOCKTIME_MASK;\n    var txToSequenceMasked = new BN(txToSequence & nLockTimeMask);\n    var nSequenceMasked = nSequence.and(new BN(nLockTimeMask));\n\n    // There are two kinds of nSequence: lock-by-blockheight and\n    // lock-by-blocktime, distinguished by whether nSequenceMasked <\n    // CTxIn::SEQUENCE_LOCKTIME_TYPE_FLAG.\n    //\n    // We want to compare apples to apples, so fail the script unless the type\n    // of nSequenceMasked being tested is the same as the nSequenceMasked in the\n    // transaction.\n    var SEQUENCE_LOCKTIME_TYPE_FLAG_BN = new BN(Interpreter.SEQUENCE_LOCKTIME_TYPE_FLAG);\n    \n    if (!((txToSequenceMasked.lt(SEQUENCE_LOCKTIME_TYPE_FLAG_BN)  &&\n           nSequenceMasked.lt(SEQUENCE_LOCKTIME_TYPE_FLAG_BN)) ||\n          (txToSequenceMasked.gte(SEQUENCE_LOCKTIME_TYPE_FLAG_BN) &&\n           nSequenceMasked.gte(SEQUENCE_LOCKTIME_TYPE_FLAG_BN)))) {\n        return false;\n    }\n\n    // Now that we know we're comparing apples-to-apples, the comparison is a\n    // simple numeric one.\n    if (nSequenceMasked.gt(txToSequenceMasked)) {\n        return false;\n    }\n    return true;\n  }\n\n/** \n * Based on the inner loop of bitcoind's EvalScript function\n * bitcoind commit: b5d1b1092998bc95313856d535c632ea5a8f9104\n */\nInterpreter.prototype.step = function() {\n  var fRequireMinimal = (this.flags & Interpreter.SCRIPT_VERIFY_MINIMALDATA) !== 0;\n\n  //bool fExec = !count(vfExec.begin(), vfExec.end(), false);\n  var fExec = (this.vfExec.indexOf(false) === -1);\n  var buf, buf1, buf2, spliced, n, x1, x2, bn, bn1, bn2, bufSig, bufPubkey, subscript;\n  var sig, pubkey;\n  var fValue, fSuccess;\n\n  // Read instruction\n  var chunk = this.script.chunks[this.pc];\n  this.pc++;\n  var opcodenum = chunk.opcodenum;\n  if (_.isUndefined(opcodenum)) {\n    this.errstr = 'SCRIPT_ERR_UNDEFINED_OPCODE';\n    return false;\n  }\n  if (chunk.buf && chunk.buf.length > Interpreter.MAX_SCRIPT_ELEMENT_SIZE) {\n    this.errstr = 'SCRIPT_ERR_PUSH_SIZE';\n    return false;\n  }\n\n  // Note how Opcode.OP_RESERVED does not count towards the opcode limit.\n  if (opcodenum > Opcode.OP_16 && ++(this.nOpCount) > 201) {\n    this.errstr = 'SCRIPT_ERR_OP_COUNT';\n    return false;\n  }\n\n\n  if (opcodenum === Opcode.OP_CAT ||\n    opcodenum === Opcode.OP_SUBSTR ||\n    opcodenum === Opcode.OP_LEFT ||\n    opcodenum === Opcode.OP_RIGHT ||\n    opcodenum === Opcode.OP_INVERT ||\n    opcodenum === Opcode.OP_AND ||\n    opcodenum === Opcode.OP_OR ||\n    opcodenum === Opcode.OP_XOR ||\n    opcodenum === Opcode.OP_2MUL ||\n    opcodenum === Opcode.OP_2DIV ||\n    opcodenum === Opcode.OP_MUL ||\n    opcodenum === Opcode.OP_DIV ||\n    opcodenum === Opcode.OP_MOD ||\n    opcodenum === Opcode.OP_LSHIFT ||\n    opcodenum === Opcode.OP_RSHIFT) {\n    this.errstr = 'SCRIPT_ERR_DISABLED_OPCODE';\n    return false;\n  }\n\n  if (fExec && 0 <= opcodenum && opcodenum <= Opcode.OP_PUSHDATA4) {\n    if (fRequireMinimal && !this.script.checkMinimalPush(this.pc - 1)) {\n      this.errstr = 'SCRIPT_ERR_MINIMALDATA';\n      return false;\n    }\n    if (!chunk.buf) {\n      this.stack.push(Interpreter.false);\n    } else if (chunk.len !== chunk.buf.length) {\n      throw new Error('Length of push value not equal to length of data');\n    } else {\n      this.stack.push(chunk.buf);\n    }\n  } else if (fExec || (Opcode.OP_IF <= opcodenum && opcodenum <= Opcode.OP_ENDIF)) {\n    switch (opcodenum) {\n      // Push value\n      case Opcode.OP_1NEGATE:\n      case Opcode.OP_1:\n      case Opcode.OP_2:\n      case Opcode.OP_3:\n      case Opcode.OP_4:\n      case Opcode.OP_5:\n      case Opcode.OP_6:\n      case Opcode.OP_7:\n      case Opcode.OP_8:\n      case Opcode.OP_9:\n      case Opcode.OP_10:\n      case Opcode.OP_11:\n      case Opcode.OP_12:\n      case Opcode.OP_13:\n      case Opcode.OP_14:\n      case Opcode.OP_15:\n      case Opcode.OP_16:\n        {\n          // ( -- value)\n          // ScriptNum bn((int)opcode - (int)(Opcode.OP_1 - 1));\n          n = opcodenum - (Opcode.OP_1 - 1);\n          buf = new BN(n).toScriptNumBuffer();\n          this.stack.push(buf);\n          // The result of these opcodes should always be the minimal way to push the data\n          // they push, so no need for a CheckMinimalPush here.\n        }\n        break;\n\n\n        //\n        // Control\n        //\n      case Opcode.OP_NOP:\n        break;\n\n      case Opcode.OP_NOP2:\n      case Opcode.OP_CHECKLOCKTIMEVERIFY:\n\n        if (!(this.flags & Interpreter.SCRIPT_VERIFY_CHECKLOCKTIMEVERIFY)) {\n          // not enabled; treat as a NOP2\n          if (this.flags & Interpreter.SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_NOPS) {\n            this.errstr = 'SCRIPT_ERR_DISCOURAGE_UPGRADABLE_NOPS';\n            return false;\n          }\n          break;\n        }\n\n        if (this.stack.length < 1) {\n          this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n          return false;\n        }\n\n        // Note that elsewhere numeric opcodes are limited to\n        // operands in the range -2**31+1 to 2**31-1, however it is\n        // legal for opcodes to produce results exceeding that\n        // range. This limitation is implemented by CScriptNum's\n        // default 4-byte limit.\n        //\n        // If we kept to that limit we'd have a year 2038 problem,\n        // even though the nLockTime field in transactions\n        // themselves is uint32 which only becomes meaningless\n        // after the year 2106.\n        //\n        // Thus as a special case we tell CScriptNum to accept up\n        // to 5-byte bignums, which are good until 2**39-1, well\n        // beyond the 2**32-1 limit of the nLockTime field itself.\n        var nLockTime = BN.fromScriptNumBuffer(this.stack[this.stack.length - 1], fRequireMinimal, 5);\n\n        // In the rare event that the argument may be < 0 due to\n        // some arithmetic being done first, you can always use\n        // 0 MAX CHECKLOCKTIMEVERIFY.\n        if (nLockTime.lt(new BN(0))) {\n          this.errstr = 'SCRIPT_ERR_NEGATIVE_LOCKTIME';\n          return false;\n        }\n\n        // Actually compare the specified lock time with the transaction.\n        if (!this.checkLockTime(nLockTime)) {\n          this.errstr = 'SCRIPT_ERR_UNSATISFIED_LOCKTIME';\n          return false;\n        }\n        break;\n\n      case Opcode.OP_NOP3:\n      case Opcode.OP_CHECKSEQUENCEVERIFY:\n\n        if (!(this.flags & Interpreter.SCRIPT_VERIFY_CHECKSEQUENCEVERIFY)) {\n          // not enabled; treat as a NOP3\n          if (this.flags & Interpreter.SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_NOPS) {\n            this.errstr = 'SCRIPT_ERR_DISCOURAGE_UPGRADABLE_NOPS';\n            return false;\n          }\n          break;\n        }\n\n        if (this.stack.length < 1) {\n          this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n          return false;\n        }\n\n\n        // nSequence, like nLockTime, is a 32-bit unsigned\n        // integer field. See the comment in CHECKLOCKTIMEVERIFY\n        // regarding 5-byte numeric operands.\n\n        var nSequence = BN.fromScriptNumBuffer(this.stack[this.stack.length - 1], fRequireMinimal, 5);\n\n\n        // In the rare event that the argument may be < 0 due to\n        // some arithmetic being done first, you can always use\n        // 0 MAX CHECKSEQUENCEVERIFY.\n        if (nSequence.lt(new BN(0))) {\n          this.errstr = 'SCRIPT_ERR_NEGATIVE_LOCKTIME';\n          return false;\n        }\n\n        // To provide for future soft-fork extensibility, if the\n        // operand has the disabled lock-time flag set,\n        // CHECKSEQUENCEVERIFY behaves as a NOP.\n        if ((nSequence &\n          Interpreter.SEQUENCE_LOCKTIME_DISABLE_FLAG) != 0) {\n          break;\n        }\n\n        // Actually compare the specified lock time with the transaction.\n        if (!this.checkSequence(nSequence)) {\n          this.errstr = 'SCRIPT_ERR_UNSATISFIED_LOCKTIME';\n          return false;\n        }\n        break;\n\n\n\n      case Opcode.OP_NOP1:\n      case Opcode.OP_NOP4:\n      case Opcode.OP_NOP5:\n      case Opcode.OP_NOP6:\n      case Opcode.OP_NOP7:\n      case Opcode.OP_NOP8:\n      case Opcode.OP_NOP9:\n      case Opcode.OP_NOP10:\n        {\n          if (this.flags & Interpreter.SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_NOPS) {\n            this.errstr = 'SCRIPT_ERR_DISCOURAGE_UPGRADABLE_NOPS';\n            return false;\n          }\n        }\n        break;\n\n      case Opcode.OP_IF:\n      case Opcode.OP_NOTIF:\n        {\n          // <expression> if [statements] [else [statements]] endif\n          // bool fValue = false;\n          fValue = false;\n          if (fExec) {\n            if (this.stack.length < 1) {\n              this.errstr = 'SCRIPT_ERR_UNBALANCED_CONDITIONAL';\n              return false;\n            }\n\n            buf = this.stack[this.stack.length - 1];\n\n            if (this.flags & Interpreter.SCRIPT_VERIFY_MINIMALIF) {\n              buf = this.stack[this.stack.length - 1];\n              if (buf.length > 1) {\n                this.errstr = 'SCRIPT_ERR_MINIMALIF';\n                return false;\n              }\n              if (buf.length == 1 && buf[0]!=1) {\n                this.errstr = 'SCRIPT_ERR_MINIMALIF';\n                return false;\n              }\n            }\n            fValue = Interpreter.castToBool(buf);\n            if (opcodenum === Opcode.OP_NOTIF) {\n              fValue = !fValue;\n            }\n            this.stack.pop();\n          }\n          this.vfExec.push(fValue);\n        }\n        break;\n\n      case Opcode.OP_ELSE:\n        {\n          if (this.vfExec.length === 0) {\n            this.errstr = 'SCRIPT_ERR_UNBALANCED_CONDITIONAL';\n            return false;\n          }\n          this.vfExec[this.vfExec.length - 1] = !this.vfExec[this.vfExec.length - 1];\n        }\n        break;\n\n      case Opcode.OP_ENDIF:\n        {\n          if (this.vfExec.length === 0) {\n            this.errstr = 'SCRIPT_ERR_UNBALANCED_CONDITIONAL';\n            return false;\n          }\n          this.vfExec.pop();\n        }\n        break;\n\n      case Opcode.OP_VERIFY:\n        {\n          // (true -- ) or\n          // (false -- false) and return\n          if (this.stack.length < 1) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n          buf = this.stack[this.stack.length - 1];\n          fValue = Interpreter.castToBool(buf);\n          if (fValue) {\n            this.stack.pop();\n          } else {\n            this.errstr = 'SCRIPT_ERR_VERIFY';\n            return false;\n          }\n        }\n        break;\n\n      case Opcode.OP_RETURN:\n        {\n          this.errstr = 'SCRIPT_ERR_OP_RETURN';\n          return false;\n        }\n        break;\n\n\n        //\n        // Stack ops\n        //\n      case Opcode.OP_TOALTSTACK:\n        {\n          if (this.stack.length < 1) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n          this.altstack.push(this.stack.pop());\n        }\n        break;\n\n      case Opcode.OP_FROMALTSTACK:\n        {\n          if (this.altstack.length < 1) {\n            this.errstr = 'SCRIPT_ERR_INVALID_ALTSTACK_OPERATION';\n            return false;\n          }\n          this.stack.push(this.altstack.pop());\n        }\n        break;\n\n      case Opcode.OP_2DROP:\n        {\n          // (x1 x2 -- )\n          if (this.stack.length < 2) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n          this.stack.pop();\n          this.stack.pop();\n        }\n        break;\n\n      case Opcode.OP_2DUP:\n        {\n          // (x1 x2 -- x1 x2 x1 x2)\n          if (this.stack.length < 2) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n          buf1 = this.stack[this.stack.length - 2];\n          buf2 = this.stack[this.stack.length - 1];\n          this.stack.push(buf1);\n          this.stack.push(buf2);\n        }\n        break;\n\n      case Opcode.OP_3DUP:\n        {\n          // (x1 x2 x3 -- x1 x2 x3 x1 x2 x3)\n          if (this.stack.length < 3) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n          buf1 = this.stack[this.stack.length - 3];\n          buf2 = this.stack[this.stack.length - 2];\n          var buf3 = this.stack[this.stack.length - 1];\n          this.stack.push(buf1);\n          this.stack.push(buf2);\n          this.stack.push(buf3);\n        }\n        break;\n\n      case Opcode.OP_2OVER:\n        {\n          // (x1 x2 x3 x4 -- x1 x2 x3 x4 x1 x2)\n          if (this.stack.length < 4) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n          buf1 = this.stack[this.stack.length - 4];\n          buf2 = this.stack[this.stack.length - 3];\n          this.stack.push(buf1);\n          this.stack.push(buf2);\n        }\n        break;\n\n      case Opcode.OP_2ROT:\n        {\n          // (x1 x2 x3 x4 x5 x6 -- x3 x4 x5 x6 x1 x2)\n          if (this.stack.length < 6) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n          spliced = this.stack.splice(this.stack.length - 6, 2);\n          this.stack.push(spliced[0]);\n          this.stack.push(spliced[1]);\n        }\n        break;\n\n      case Opcode.OP_2SWAP:\n        {\n          // (x1 x2 x3 x4 -- x3 x4 x1 x2)\n          if (this.stack.length < 4) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n          spliced = this.stack.splice(this.stack.length - 4, 2);\n          this.stack.push(spliced[0]);\n          this.stack.push(spliced[1]);\n        }\n        break;\n\n      case Opcode.OP_IFDUP:\n        {\n          // (x - 0 | x x)\n          if (this.stack.length < 1) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n          buf = this.stack[this.stack.length - 1];\n          fValue = Interpreter.castToBool(buf);\n          if (fValue) {\n            this.stack.push(buf);\n          }\n        }\n        break;\n\n      case Opcode.OP_DEPTH:\n        {\n          // -- stacksize\n          buf = new BN(this.stack.length).toScriptNumBuffer();\n          this.stack.push(buf);\n        }\n        break;\n\n      case Opcode.OP_DROP:\n        {\n          // (x -- )\n          if (this.stack.length < 1) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n          this.stack.pop();\n        }\n        break;\n\n      case Opcode.OP_DUP:\n        {\n          // (x -- x x)\n          if (this.stack.length < 1) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n          this.stack.push(this.stack[this.stack.length - 1]);\n        }\n        break;\n\n      case Opcode.OP_NIP:\n        {\n          // (x1 x2 -- x2)\n          if (this.stack.length < 2) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n          this.stack.splice(this.stack.length - 2, 1);\n        }\n        break;\n\n      case Opcode.OP_OVER:\n        {\n          // (x1 x2 -- x1 x2 x1)\n          if (this.stack.length < 2) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n          this.stack.push(this.stack[this.stack.length - 2]);\n        }\n        break;\n\n      case Opcode.OP_PICK:\n      case Opcode.OP_ROLL:\n        {\n          // (xn ... x2 x1 x0 n - xn ... x2 x1 x0 xn)\n          // (xn ... x2 x1 x0 n - ... x2 x1 x0 xn)\n          if (this.stack.length < 2) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n          buf = this.stack[this.stack.length - 1];\n          bn = BN.fromScriptNumBuffer(buf, fRequireMinimal);\n          n = bn.toNumber();\n          this.stack.pop();\n          if (n < 0 || n >= this.stack.length) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n          buf = this.stack[this.stack.length - n - 1];\n          if (opcodenum === Opcode.OP_ROLL) {\n            this.stack.splice(this.stack.length - n - 1, 1);\n          }\n          this.stack.push(buf);\n        }\n        break;\n\n      case Opcode.OP_ROT:\n        {\n          // (x1 x2 x3 -- x2 x3 x1)\n          //  x2 x1 x3  after first swap\n          //  x2 x3 x1  after second swap\n          if (this.stack.length < 3) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n          x1 = this.stack[this.stack.length - 3];\n          x2 = this.stack[this.stack.length - 2];\n          var x3 = this.stack[this.stack.length - 1];\n          this.stack[this.stack.length - 3] = x2;\n          this.stack[this.stack.length - 2] = x3;\n          this.stack[this.stack.length - 1] = x1;\n        }\n        break;\n\n      case Opcode.OP_SWAP:\n        {\n          // (x1 x2 -- x2 x1)\n          if (this.stack.length < 2) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n          x1 = this.stack[this.stack.length - 2];\n          x2 = this.stack[this.stack.length - 1];\n          this.stack[this.stack.length - 2] = x2;\n          this.stack[this.stack.length - 1] = x1;\n        }\n        break;\n\n      case Opcode.OP_TUCK:\n        {\n          // (x1 x2 -- x2 x1 x2)\n          if (this.stack.length < 2) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n          this.stack.splice(this.stack.length - 2, 0, this.stack[this.stack.length - 1]);\n        }\n        break;\n\n\n      case Opcode.OP_SIZE:\n        {\n          // (in -- in size)\n          if (this.stack.length < 1) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n          bn = new BN(this.stack[this.stack.length - 1].length);\n          this.stack.push(bn.toScriptNumBuffer());\n        }\n        break;\n\n\n        //\n        // Bitwise logic\n        //\n      case Opcode.OP_EQUAL:\n      case Opcode.OP_EQUALVERIFY:\n        //case Opcode.OP_NOTEQUAL: // use Opcode.OP_NUMNOTEQUAL\n        {\n          // (x1 x2 - bool)\n          if (this.stack.length < 2) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n          buf1 = this.stack[this.stack.length - 2];\n          buf2 = this.stack[this.stack.length - 1];\n          var fEqual = buf1.toString('hex') === buf2.toString('hex');\n          this.stack.pop();\n          this.stack.pop();\n          this.stack.push(fEqual ? Interpreter.true : Interpreter.false);\n          if (opcodenum === Opcode.OP_EQUALVERIFY) {\n            if (fEqual) {\n              this.stack.pop();\n            } else {\n              this.errstr = 'SCRIPT_ERR_EQUALVERIFY';\n              return false;\n            }\n          }\n        }\n        break;\n\n\n        //\n        // Numeric\n        //\n      case Opcode.OP_1ADD:\n      case Opcode.OP_1SUB:\n      case Opcode.OP_NEGATE:\n      case Opcode.OP_ABS:\n      case Opcode.OP_NOT:\n      case Opcode.OP_0NOTEQUAL:\n        {\n          // (in -- out)\n          if (this.stack.length < 1) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n          buf = this.stack[this.stack.length - 1];\n          bn = BN.fromScriptNumBuffer(buf, fRequireMinimal);\n          switch (opcodenum) {\n            case Opcode.OP_1ADD:\n              bn = bn.add(BN.One);\n              break;\n            case Opcode.OP_1SUB:\n              bn = bn.sub(BN.One);\n              break;\n            case Opcode.OP_NEGATE:\n              bn = bn.neg();\n              break;\n            case Opcode.OP_ABS:\n              if (bn.cmp(BN.Zero) < 0) {\n                bn = bn.neg();\n              }\n              break;\n            case Opcode.OP_NOT:\n              bn = new BN((bn.cmp(BN.Zero) === 0) + 0);\n              break;\n            case Opcode.OP_0NOTEQUAL:\n              bn = new BN((bn.cmp(BN.Zero) !== 0) + 0);\n              break;\n              //default:      assert(!'invalid opcode'); break; // TODO: does this ever occur?\n          }\n          this.stack.pop();\n          this.stack.push(bn.toScriptNumBuffer());\n        }\n        break;\n\n      case Opcode.OP_ADD:\n      case Opcode.OP_SUB:\n      case Opcode.OP_BOOLAND:\n      case Opcode.OP_BOOLOR:\n      case Opcode.OP_NUMEQUAL:\n      case Opcode.OP_NUMEQUALVERIFY:\n      case Opcode.OP_NUMNOTEQUAL:\n      case Opcode.OP_LESSTHAN:\n      case Opcode.OP_GREATERTHAN:\n      case Opcode.OP_LESSTHANOREQUAL:\n      case Opcode.OP_GREATERTHANOREQUAL:\n      case Opcode.OP_MIN:\n      case Opcode.OP_MAX:\n        {\n          // (x1 x2 -- out)\n          if (this.stack.length < 2) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n          bn1 = BN.fromScriptNumBuffer(this.stack[this.stack.length - 2], fRequireMinimal);\n          bn2 = BN.fromScriptNumBuffer(this.stack[this.stack.length - 1], fRequireMinimal);\n          bn = new BN(0);\n\n          switch (opcodenum) {\n            case Opcode.OP_ADD:\n              bn = bn1.add(bn2);\n              break;\n\n            case Opcode.OP_SUB:\n              bn = bn1.sub(bn2);\n              break;\n\n              // case Opcode.OP_BOOLAND:       bn = (bn1 != bnZero && bn2 != bnZero); break;\n            case Opcode.OP_BOOLAND:\n              bn = new BN(((bn1.cmp(BN.Zero) !== 0) && (bn2.cmp(BN.Zero) !== 0)) + 0);\n              break;\n              // case Opcode.OP_BOOLOR:        bn = (bn1 != bnZero || bn2 != bnZero); break;\n            case Opcode.OP_BOOLOR:\n              bn = new BN(((bn1.cmp(BN.Zero) !== 0) || (bn2.cmp(BN.Zero) !== 0)) + 0);\n              break;\n              // case Opcode.OP_NUMEQUAL:      bn = (bn1 == bn2); break;\n            case Opcode.OP_NUMEQUAL:\n              bn = new BN((bn1.cmp(bn2) === 0) + 0);\n              break;\n              // case Opcode.OP_NUMEQUALVERIFY:    bn = (bn1 == bn2); break;\n            case Opcode.OP_NUMEQUALVERIFY:\n              bn = new BN((bn1.cmp(bn2) === 0) + 0);\n              break;\n              // case Opcode.OP_NUMNOTEQUAL:     bn = (bn1 != bn2); break;\n            case Opcode.OP_NUMNOTEQUAL:\n              bn = new BN((bn1.cmp(bn2) !== 0) + 0);\n              break;\n              // case Opcode.OP_LESSTHAN:      bn = (bn1 < bn2); break;\n            case Opcode.OP_LESSTHAN:\n              bn = new BN((bn1.cmp(bn2) < 0) + 0);\n              break;\n              // case Opcode.OP_GREATERTHAN:     bn = (bn1 > bn2); break;\n            case Opcode.OP_GREATERTHAN:\n              bn = new BN((bn1.cmp(bn2) > 0) + 0);\n              break;\n              // case Opcode.OP_LESSTHANOREQUAL:   bn = (bn1 <= bn2); break;\n            case Opcode.OP_LESSTHANOREQUAL:\n              bn = new BN((bn1.cmp(bn2) <= 0) + 0);\n              break;\n              // case Opcode.OP_GREATERTHANOREQUAL:  bn = (bn1 >= bn2); break;\n            case Opcode.OP_GREATERTHANOREQUAL:\n              bn = new BN((bn1.cmp(bn2) >= 0) + 0);\n              break;\n            case Opcode.OP_MIN:\n              bn = (bn1.cmp(bn2) < 0 ? bn1 : bn2);\n              break;\n            case Opcode.OP_MAX:\n              bn = (bn1.cmp(bn2) > 0 ? bn1 : bn2);\n              break;\n              // default:           assert(!'invalid opcode'); break; //TODO: does this ever occur?\n          }\n          this.stack.pop();\n          this.stack.pop();\n          this.stack.push(bn.toScriptNumBuffer());\n\n          if (opcodenum === Opcode.OP_NUMEQUALVERIFY) {\n            // if (CastToBool(stacktop(-1)))\n            if (Interpreter.castToBool(this.stack[this.stack.length - 1])) {\n              this.stack.pop();\n            } else {\n              this.errstr = 'SCRIPT_ERR_NUMEQUALVERIFY';\n              return false;\n            }\n          }\n        }\n        break;\n\n      case Opcode.OP_WITHIN:\n        {\n          // (x min max -- out)\n          if (this.stack.length < 3) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n          bn1 = BN.fromScriptNumBuffer(this.stack[this.stack.length - 3], fRequireMinimal);\n          bn2 = BN.fromScriptNumBuffer(this.stack[this.stack.length - 2], fRequireMinimal);\n          var bn3 = BN.fromScriptNumBuffer(this.stack[this.stack.length - 1], fRequireMinimal);\n          //bool fValue = (bn2 <= bn1 && bn1 < bn3);\n          fValue = (bn2.cmp(bn1) <= 0) && (bn1.cmp(bn3) < 0);\n          this.stack.pop();\n          this.stack.pop();\n          this.stack.pop();\n          this.stack.push(fValue ? Interpreter.true : Interpreter.false);\n        }\n        break;\n\n\n        //\n        // Crypto\n        //\n      case Opcode.OP_RIPEMD160:\n      case Opcode.OP_SHA1:\n      case Opcode.OP_SHA256:\n      case Opcode.OP_HASH160:\n      case Opcode.OP_HASH256:\n        {\n          // (in -- hash)\n          if (this.stack.length < 1) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n          buf = this.stack[this.stack.length - 1];\n          //valtype vchHash((opcode == Opcode.OP_RIPEMD160 ||\n          //                 opcode == Opcode.OP_SHA1 || opcode == Opcode.OP_HASH160) ? 20 : 32);\n          var bufHash;\n          if (opcodenum === Opcode.OP_RIPEMD160) {\n            bufHash = Hash.ripemd160(buf);\n          } else if (opcodenum === Opcode.OP_SHA1) {\n            bufHash = Hash.sha1(buf);\n          } else if (opcodenum === Opcode.OP_SHA256) {\n            bufHash = Hash.sha256(buf);\n          } else if (opcodenum === Opcode.OP_HASH160) {\n            bufHash = Hash.sha256ripemd160(buf);\n          } else if (opcodenum === Opcode.OP_HASH256) {\n            bufHash = Hash.sha256sha256(buf);\n          }\n          this.stack.pop();\n          this.stack.push(bufHash);\n        }\n        break;\n\n      case Opcode.OP_CODESEPARATOR:\n        {\n          // Hash starts after the code separator\n          this.pbegincodehash = this.pc;\n        }\n        break;\n\n      case Opcode.OP_CHECKSIG:\n      case Opcode.OP_CHECKSIGVERIFY:\n        {\n          // (sig pubkey -- bool)\n          if (this.stack.length < 2) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n\n          bufSig = this.stack[this.stack.length - 2];\n          bufPubkey = this.stack[this.stack.length - 1];\n          if (!this.checkSignatureEncoding(bufSig) || !this.checkPubkeyEncoding(bufPubkey)) {\n            return false;\n          }\n\n          // Subset of script starting at the most recent codeseparator\n          // CScript scriptCode(pbegincodehash, pend);\n          subscript = new Script().set({\n            chunks: this.script.chunks.slice(this.pbegincodehash)\n          });\n\n          // Drop the signature, since there's no way for a signature to sign itself\n          if (this.sigversion === Interpreter.SIGVERSION_BASE) {\n            var tmpScript = new Script().add(bufSig);\n            subscript.findAndDelete(tmpScript);\n          }\n\n          try {\n            sig = Signature.fromTxFormat(bufSig);\n            pubkey = PublicKey.fromBuffer(bufPubkey, false);\n            fSuccess = this.tx.verifySignature(sig, pubkey, this.nin, subscript, this.sigversion, this.satoshis);\n          } catch (e) {\n            //invalid sig or pubkey\n            fSuccess = false;\n          }\n\n          if (!fSuccess && (this.flags & Interpreter.SCRIPT_VERIFY_NULLFAIL) &&\n            bufSig.length) {\n            this.errstr = 'SCRIPT_ERR_NULLFAIL';\n            return false;\n          }\n\n          this.stack.pop();\n          this.stack.pop();\n\n          // stack.push_back(fSuccess ? vchTrue : vchFalse);\n          this.stack.push(fSuccess ? Interpreter.true : Interpreter.false);\n          if (opcodenum === Opcode.OP_CHECKSIGVERIFY) {\n            if (fSuccess) {\n              this.stack.pop();\n            } else {\n              this.errstr = 'SCRIPT_ERR_CHECKSIGVERIFY';\n              return false;\n            }\n          }\n        }\n        break;\n\n      case Opcode.OP_CHECKMULTISIG:\n      case Opcode.OP_CHECKMULTISIGVERIFY:\n        {\n          // ([sig ...] num_of_signatures [pubkey ...] num_of_pubkeys -- bool)\n\n          var i = 1;\n          if (this.stack.length < i) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n\n          var nKeysCount = BN.fromScriptNumBuffer(this.stack[this.stack.length - i], fRequireMinimal).toNumber();\n          if (nKeysCount < 0 || nKeysCount > 20) {\n            this.errstr = 'SCRIPT_ERR_PUBKEY_COUNT';\n            return false;\n          }\n          this.nOpCount += nKeysCount;\n          if (this.nOpCount > 201) {\n            this.errstr = 'SCRIPT_ERR_OP_COUNT';\n            return false;\n          }\n          // int ikey = ++i;\n          var ikey = ++i;\n          i += nKeysCount;\n\n          // ikey2 is the position of last non-signature item in\n          // the stack. Top stack item = 1. With\n          // SCRIPT_VERIFY_NULLFAIL, this is used for cleanup if\n          // operation fails.\n          var ikey2 = nKeysCount + 2;\n\n          if (this.stack.length < i) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n\n          var nSigsCount = BN.fromScriptNumBuffer(this.stack[this.stack.length - i], fRequireMinimal).toNumber();\n          if (nSigsCount < 0 || nSigsCount > nKeysCount) {\n            this.errstr = 'SCRIPT_ERR_SIG_COUNT';\n            return false;\n          }\n          // int isig = ++i;\n          var isig = ++i;\n          i += nSigsCount;\n          if (this.stack.length < i) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n\n          // Subset of script starting at the most recent codeseparator\n          subscript = new Script().set({\n            chunks: this.script.chunks.slice(this.pbegincodehash)\n          });\n\n          // Drop the signatures, since there's no way for a signature to sign itself\n          if (this.sigversion === Interpreter.SIGVERSION_BASE) {\n            for (var k = 0; k < nSigsCount; k++) {\n              bufSig = this.stack[this.stack.length - isig - k];\n              subscript.findAndDelete(new Script().add(bufSig));\n            }\n          }\n\n          fSuccess = true;\n          while (fSuccess && nSigsCount > 0) {\n            // valtype& vchSig  = stacktop(-isig);\n            bufSig = this.stack[this.stack.length - isig];\n            // valtype& vchPubKey = stacktop(-ikey);\n            bufPubkey = this.stack[this.stack.length - ikey];\n\n            if (!this.checkSignatureEncoding(bufSig) || !this.checkPubkeyEncoding(bufPubkey)) {\n              return false;\n            }\n\n            var fOk;\n            try {\n              sig = Signature.fromTxFormat(bufSig);\n              pubkey = PublicKey.fromBuffer(bufPubkey, false);\n              fOk = this.tx.verifySignature(sig, pubkey, this.nin, subscript, this.sigversion, this.satoshis);\n            } catch (e) {\n              //invalid sig or pubkey\n              fOk = false;\n            }\n\n            if (fOk) {\n              isig++;\n              nSigsCount--;\n            }\n            ikey++;\n            nKeysCount--;\n\n            // If there are more signatures left than keys left,\n            // then too many signatures have failed\n            if (nSigsCount > nKeysCount) {\n              fSuccess = false;\n            }\n          }\n\n\n          // Clean up stack of actual arguments\n          while (i-- > 1) {\n            if (!fSuccess && (this.flags & Interpreter.SCRIPT_VERIFY_NULLFAIL) &&\n              !ikey2 && this.stack[this.stack.length - 1].length) {\n\n              this.errstr = 'SCRIPT_ERR_NULLFAIL';\n              return false;\n            }\n\n            if (ikey2 > 0) {\n              ikey2--;\n            }\n\n            this.stack.pop();\n          }\n\n          // A bug causes CHECKMULTISIG to consume one extra argument\n          // whose contents were not checked in any way.\n          //\n          // Unfortunately this is a potential source of mutability,\n          // so optionally verify it is exactly equal to zero prior\n          // to removing it from the stack.\n          if (this.stack.length < 1) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n          if ((this.flags & Interpreter.SCRIPT_VERIFY_NULLDUMMY) && this.stack[this.stack.length - 1].length) {\n            this.errstr = 'SCRIPT_ERR_SIG_NULLDUMMY';\n            return false;\n          }\n          this.stack.pop();\n\n          this.stack.push(fSuccess ? Interpreter.true : Interpreter.false);\n\n          if (opcodenum === Opcode.OP_CHECKMULTISIGVERIFY) {\n            if (fSuccess) {\n              this.stack.pop();\n            } else {\n              this.errstr = 'SCRIPT_ERR_CHECKMULTISIGVERIFY';\n              return false;\n            }\n          }\n        }\n        break;\n\n      default:\n        this.errstr = 'SCRIPT_ERR_BAD_OPCODE';\n        return false;\n    }\n  }\n\n  return true;\n};\n\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}