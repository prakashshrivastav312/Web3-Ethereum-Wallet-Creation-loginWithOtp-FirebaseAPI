{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar TransformOperationExecutor_1 = require(\"../TransformOperationExecutor\");\n/**\n * Storage all library metadata.\n */\n\n\nvar MetadataStorage =\n/** @class */\nfunction () {\n  function MetadataStorage() {\n    // -------------------------------------------------------------------------\n    // Properties\n    // -------------------------------------------------------------------------\n    this._typeMetadatas = new Map();\n    this._transformMetadatas = new Map();\n    this._exposeMetadatas = new Map();\n    this._excludeMetadatas = new Map();\n    this._ancestorsMap = new Map();\n  } // -------------------------------------------------------------------------\n  // Adder Methods\n  // -------------------------------------------------------------------------\n\n\n  MetadataStorage.prototype.addTypeMetadata = function (metadata) {\n    if (!this._typeMetadatas.has(metadata.target)) {\n      this._typeMetadatas.set(metadata.target, new Map());\n    }\n\n    this._typeMetadatas.get(metadata.target).set(metadata.propertyName, metadata);\n  };\n\n  MetadataStorage.prototype.addTransformMetadata = function (metadata) {\n    if (!this._transformMetadatas.has(metadata.target)) {\n      this._transformMetadatas.set(metadata.target, new Map());\n    }\n\n    if (!this._transformMetadatas.get(metadata.target).has(metadata.propertyName)) {\n      this._transformMetadatas.get(metadata.target).set(metadata.propertyName, []);\n    }\n\n    this._transformMetadatas.get(metadata.target).get(metadata.propertyName).push(metadata);\n  };\n\n  MetadataStorage.prototype.addExposeMetadata = function (metadata) {\n    if (!this._exposeMetadatas.has(metadata.target)) {\n      this._exposeMetadatas.set(metadata.target, new Map());\n    }\n\n    this._exposeMetadatas.get(metadata.target).set(metadata.propertyName, metadata);\n  };\n\n  MetadataStorage.prototype.addExcludeMetadata = function (metadata) {\n    if (!this._excludeMetadatas.has(metadata.target)) {\n      this._excludeMetadatas.set(metadata.target, new Map());\n    }\n\n    this._excludeMetadatas.get(metadata.target).set(metadata.propertyName, metadata);\n  }; // -------------------------------------------------------------------------\n  // Public Methods\n  // -------------------------------------------------------------------------\n\n\n  MetadataStorage.prototype.findTransformMetadatas = function (target, propertyName, transformationType) {\n    return this.findMetadatas(this._transformMetadatas, target, propertyName).filter(function (metadata) {\n      if (!metadata.options) return true;\n      if (metadata.options.toClassOnly === true && metadata.options.toPlainOnly === true) return true;\n\n      if (metadata.options.toClassOnly === true) {\n        return transformationType === TransformOperationExecutor_1.TransformationType.CLASS_TO_CLASS || transformationType === TransformOperationExecutor_1.TransformationType.PLAIN_TO_CLASS;\n      }\n\n      if (metadata.options.toPlainOnly === true) {\n        return transformationType === TransformOperationExecutor_1.TransformationType.CLASS_TO_PLAIN;\n      }\n\n      return true;\n    });\n  };\n\n  MetadataStorage.prototype.findExcludeMetadata = function (target, propertyName) {\n    return this.findMetadata(this._excludeMetadatas, target, propertyName);\n  };\n\n  MetadataStorage.prototype.findExposeMetadata = function (target, propertyName) {\n    return this.findMetadata(this._exposeMetadatas, target, propertyName);\n  };\n\n  MetadataStorage.prototype.findExposeMetadataByCustomName = function (target, name) {\n    return this.getExposedMetadatas(target).find(function (metadata) {\n      return metadata.options && metadata.options.name === name;\n    });\n  };\n\n  MetadataStorage.prototype.findTypeMetadata = function (target, propertyName) {\n    return this.findMetadata(this._typeMetadatas, target, propertyName);\n  };\n\n  MetadataStorage.prototype.getStrategy = function (target) {\n    var excludeMap = this._excludeMetadatas.get(target);\n\n    var exclude = excludeMap && excludeMap.get(undefined);\n\n    var exposeMap = this._exposeMetadatas.get(target);\n\n    var expose = exposeMap && exposeMap.get(undefined);\n    if (exclude && expose || !exclude && !expose) return \"none\";\n    return exclude ? \"excludeAll\" : \"exposeAll\";\n  };\n\n  MetadataStorage.prototype.getExposedMetadatas = function (target) {\n    return this.getMetadata(this._exposeMetadatas, target);\n  };\n\n  MetadataStorage.prototype.getExcludedMetadatas = function (target) {\n    return this.getMetadata(this._excludeMetadatas, target);\n  };\n\n  MetadataStorage.prototype.getExposedProperties = function (target, transformationType) {\n    return this.getExposedMetadatas(target).filter(function (metadata) {\n      if (!metadata.options) return true;\n      if (metadata.options.toClassOnly === true && metadata.options.toPlainOnly === true) return true;\n\n      if (metadata.options.toClassOnly === true) {\n        return transformationType === TransformOperationExecutor_1.TransformationType.CLASS_TO_CLASS || transformationType === TransformOperationExecutor_1.TransformationType.PLAIN_TO_CLASS;\n      }\n\n      if (metadata.options.toPlainOnly === true) {\n        return transformationType === TransformOperationExecutor_1.TransformationType.CLASS_TO_PLAIN;\n      }\n\n      return true;\n    }).map(function (metadata) {\n      return metadata.propertyName;\n    });\n  };\n\n  MetadataStorage.prototype.getExcludedProperties = function (target, transformationType) {\n    return this.getExcludedMetadatas(target).filter(function (metadata) {\n      if (!metadata.options) return true;\n      if (metadata.options.toClassOnly === true && metadata.options.toPlainOnly === true) return true;\n\n      if (metadata.options.toClassOnly === true) {\n        return transformationType === TransformOperationExecutor_1.TransformationType.CLASS_TO_CLASS || transformationType === TransformOperationExecutor_1.TransformationType.PLAIN_TO_CLASS;\n      }\n\n      if (metadata.options.toPlainOnly === true) {\n        return transformationType === TransformOperationExecutor_1.TransformationType.CLASS_TO_PLAIN;\n      }\n\n      return true;\n    }).map(function (metadata) {\n      return metadata.propertyName;\n    });\n  };\n\n  MetadataStorage.prototype.clear = function () {\n    this._typeMetadatas.clear();\n\n    this._exposeMetadatas.clear();\n\n    this._excludeMetadatas.clear();\n\n    this._ancestorsMap.clear();\n  }; // -------------------------------------------------------------------------\n  // Private Methods\n  // -------------------------------------------------------------------------\n\n\n  MetadataStorage.prototype.getMetadata = function (metadatas, target) {\n    var metadataFromTargetMap = metadatas.get(target);\n    var metadataFromTarget;\n\n    if (metadataFromTargetMap) {\n      metadataFromTarget = Array.from(metadataFromTargetMap.values()).filter(function (meta) {\n        return meta.propertyName !== undefined;\n      });\n    }\n\n    var metadataFromAncestors = [];\n\n    for (var _i = 0, _a = this.getAncestors(target); _i < _a.length; _i++) {\n      var ancestor = _a[_i];\n      var ancestorMetadataMap = metadatas.get(ancestor);\n\n      if (ancestorMetadataMap) {\n        var metadataFromAncestor = Array.from(ancestorMetadataMap.values()).filter(function (meta) {\n          return meta.propertyName !== undefined;\n        });\n        metadataFromAncestors.push.apply(metadataFromAncestors, metadataFromAncestor);\n      }\n    }\n\n    return metadataFromAncestors.concat(metadataFromTarget || []);\n  };\n\n  MetadataStorage.prototype.findMetadata = function (metadatas, target, propertyName) {\n    var metadataFromTargetMap = metadatas.get(target);\n\n    if (metadataFromTargetMap) {\n      var metadataFromTarget = metadataFromTargetMap.get(propertyName);\n\n      if (metadataFromTarget) {\n        return metadataFromTarget;\n      }\n    }\n\n    for (var _i = 0, _a = this.getAncestors(target); _i < _a.length; _i++) {\n      var ancestor = _a[_i];\n      var ancestorMetadataMap = metadatas.get(ancestor);\n\n      if (ancestorMetadataMap) {\n        var ancestorResult = ancestorMetadataMap.get(propertyName);\n\n        if (ancestorResult) {\n          return ancestorResult;\n        }\n      }\n    }\n\n    return undefined;\n  };\n\n  MetadataStorage.prototype.findMetadatas = function (metadatas, target, propertyName) {\n    var metadataFromTargetMap = metadatas.get(target);\n    var metadataFromTarget;\n\n    if (metadataFromTargetMap) {\n      metadataFromTarget = metadataFromTargetMap.get(propertyName);\n    }\n\n    var metadataFromAncestorsTarget = [];\n\n    for (var _i = 0, _a = this.getAncestors(target); _i < _a.length; _i++) {\n      var ancestor = _a[_i];\n      var ancestorMetadataMap = metadatas.get(ancestor);\n\n      if (ancestorMetadataMap) {\n        if (ancestorMetadataMap.has(propertyName)) {\n          metadataFromAncestorsTarget.push.apply(metadataFromAncestorsTarget, ancestorMetadataMap.get(propertyName));\n        }\n      }\n    }\n\n    return metadataFromAncestorsTarget.reverse().concat((metadataFromTarget || []).reverse());\n  };\n\n  MetadataStorage.prototype.getAncestors = function (target) {\n    if (!target) return [];\n\n    if (!this._ancestorsMap.has(target)) {\n      var ancestors = [];\n\n      for (var baseClass = Object.getPrototypeOf(target.prototype.constructor); typeof baseClass.prototype !== \"undefined\"; baseClass = Object.getPrototypeOf(baseClass.prototype.constructor)) {\n        ancestors.push(baseClass);\n      }\n\n      this._ancestorsMap.set(target, ancestors);\n    }\n\n    return this._ancestorsMap.get(target);\n  };\n\n  return MetadataStorage;\n}();\n\nexports.MetadataStorage = MetadataStorage;","map":{"version":3,"mappings":"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","names":["Map","MetadataStorage","metadata","_typeMetadatas","has","target","set","get","propertyName","_transformMetadatas","push","_exposeMetadatas","_excludeMetadatas","transformationType","findMetadatas","filter","options","toClassOnly","toPlainOnly","TransformOperationExecutor_1","CLASS_TO_CLASS","PLAIN_TO_CLASS","CLASS_TO_PLAIN","findMetadata","name","getExposedMetadatas","find","excludeMap","exclude","undefined","exposeMap","expose","getMetadata","map","getExcludedMetadatas","clear","_ancestorsMap","metadatas","metadataFromTargetMap","metadataFromTarget","Array","from","values","metadataFromAncestors","getAncestors","_i","ancestor","ancestorMetadataMap","metadataFromAncestor","apply","concat","ancestorResult","metadataFromAncestorsTarget","reverse","ancestors","baseClass","Object","getPrototypeOf","prototype","constructor","exports"],"sourceRoot":"..","sources":["../../src/metadata/MetadataStorage.ts"],"sourcesContent":["import {TypeMetadata} from \"./TypeMetadata\";\nimport {ExposeMetadata} from \"./ExposeMetadata\";\nimport {ExcludeMetadata} from \"./ExcludeMetadata\";\nimport {TransformationType} from \"../TransformOperationExecutor\";\nimport {TransformMetadata} from \"./TransformMetadata\";\n\n/**\n * Storage all library metadata.\n */\nexport class MetadataStorage {\n\n    // -------------------------------------------------------------------------\n    // Properties\n    // -------------------------------------------------------------------------\n\n    private _typeMetadatas = new Map<Function, Map<string, TypeMetadata>>();\n    private _transformMetadatas = new Map<Function, Map<string, TransformMetadata[]>>();\n    private _exposeMetadatas = new Map<Function, Map<string, ExposeMetadata>>();\n    private _excludeMetadatas = new Map<Function, Map<string, ExcludeMetadata>>();\n    private _ancestorsMap = new Map<Function, Function[]>();\n\n    // -------------------------------------------------------------------------\n    // Adder Methods\n    // -------------------------------------------------------------------------\n\n    addTypeMetadata(metadata: TypeMetadata) {\n        if (!this._typeMetadatas.has(metadata.target)) {\n            this._typeMetadatas.set(metadata.target, new Map<string, TypeMetadata>());\n    }\n        this._typeMetadatas.get(metadata.target).set(metadata.propertyName, metadata);\n    }\n\n    addTransformMetadata(metadata: TransformMetadata) {\n        if (!this._transformMetadatas.has(metadata.target)) {\n            this._transformMetadatas.set(metadata.target, new Map<string, TransformMetadata[]>());\n    }\n        if (!this._transformMetadatas.get(metadata.target).has(metadata.propertyName)) {\n            this._transformMetadatas.get(metadata.target).set(metadata.propertyName, []);\n        }\n        this._transformMetadatas.get(metadata.target).get(metadata.propertyName).push(metadata);\n    }\n\n    addExposeMetadata(metadata: ExposeMetadata) {\n        if (!this._exposeMetadatas.has(metadata.target)) {\n            this._exposeMetadatas.set(metadata.target, new Map<string, ExposeMetadata>());\n    }\n        this._exposeMetadatas.get(metadata.target).set(metadata.propertyName, metadata);\n    }\n\n    addExcludeMetadata(metadata: ExcludeMetadata) {\n        if (!this._excludeMetadatas.has(metadata.target)) {\n            this._excludeMetadatas.set(metadata.target, new Map<string, ExcludeMetadata>());\n    }\n        this._excludeMetadatas.get(metadata.target).set(metadata.propertyName, metadata);\n    }\n\n    // -------------------------------------------------------------------------\n    // Public Methods\n    // -------------------------------------------------------------------------\n\n    findTransformMetadatas(target: Function, propertyName: string, transformationType: TransformationType): TransformMetadata[] {\n        return this.findMetadatas(this._transformMetadatas, target, propertyName)\n            .filter(metadata => {\n                if (!metadata.options)\n                    return true;\n                if (metadata.options.toClassOnly === true && metadata.options.toPlainOnly === true)\n                    return true;\n\n                if (metadata.options.toClassOnly === true) {\n                    return transformationType === TransformationType.CLASS_TO_CLASS ||  transformationType === TransformationType.PLAIN_TO_CLASS;\n                }\n                if (metadata.options.toPlainOnly === true) {\n                    return transformationType === TransformationType.CLASS_TO_PLAIN;\n                }\n\n                return true;\n            });\n    }\n\n    findExcludeMetadata(target: Function, propertyName: string): ExcludeMetadata {\n        return this.findMetadata(this._excludeMetadatas, target, propertyName);\n    }\n\n    findExposeMetadata(target: Function, propertyName: string): ExposeMetadata {\n        return this.findMetadata(this._exposeMetadatas, target, propertyName);\n    }\n\n    findExposeMetadataByCustomName(target: Function, name: string): ExposeMetadata {\n        return this.getExposedMetadatas(target).find(metadata => {\n            return metadata.options && metadata.options.name === name;\n        });\n    }\n\n    findTypeMetadata(target: Function, propertyName: string) {\n        return this.findMetadata(this._typeMetadatas, target, propertyName);\n    }\n\n    getStrategy(target: Function): \"excludeAll\"|\"exposeAll\"|\"none\" {\n        const excludeMap = this._excludeMetadatas.get(target);\n        const exclude = excludeMap && excludeMap.get(undefined);\n        const exposeMap = this._exposeMetadatas.get(target);\n        const expose = exposeMap && exposeMap.get(undefined);\n        if ((exclude && expose) || (!exclude && !expose)) return \"none\";\n        return exclude ? \"excludeAll\" : \"exposeAll\";\n    }\n\n    getExposedMetadatas(target: Function): ExposeMetadata[] {\n        return this.getMetadata(this._exposeMetadatas, target);\n    }\n\n    getExcludedMetadatas(target: Function): ExcludeMetadata[] {\n        return this.getMetadata(this._excludeMetadatas, target);\n    }\n\n    getExposedProperties(target: Function, transformationType: TransformationType): string[] {\n        return this.getExposedMetadatas(target)\n            .filter(metadata => {\n                if (!metadata.options)\n                    return true;\n                if (metadata.options.toClassOnly === true && metadata.options.toPlainOnly === true)\n                    return true;\n\n                if (metadata.options.toClassOnly === true) {\n                    return transformationType === TransformationType.CLASS_TO_CLASS ||  transformationType === TransformationType.PLAIN_TO_CLASS;\n                }\n                if (metadata.options.toPlainOnly === true) {\n                    return transformationType === TransformationType.CLASS_TO_PLAIN;\n                }\n\n                return true;\n            })\n            .map(metadata => metadata.propertyName);\n    }\n\n    getExcludedProperties(target: Function, transformationType: TransformationType): string[] {\n        return this.getExcludedMetadatas(target)\n            .filter(metadata => {\n                if (!metadata.options)\n                    return true;\n                if (metadata.options.toClassOnly === true && metadata.options.toPlainOnly === true)\n                    return true;\n\n                if (metadata.options.toClassOnly === true) {\n                    return transformationType === TransformationType.CLASS_TO_CLASS ||  transformationType === TransformationType.PLAIN_TO_CLASS;\n                }\n                if (metadata.options.toPlainOnly === true) {\n                    return transformationType === TransformationType.CLASS_TO_PLAIN;\n                }\n\n                return true;\n            })\n            .map(metadata => metadata.propertyName);\n    }\n\n    clear() {\n        this._typeMetadatas.clear();\n        this._exposeMetadatas.clear();\n        this._excludeMetadatas.clear();\n        this._ancestorsMap.clear();\n    }\n\n    // -------------------------------------------------------------------------\n    // Private Methods\n    // -------------------------------------------------------------------------\n\n    private getMetadata<T extends { target: Function, propertyName: string }>(metadatas: Map<Function, Map<String, T>>, target: Function): T[] {\n        const metadataFromTargetMap = metadatas.get(target);\n        let metadataFromTarget: T[];\n        if (metadataFromTargetMap) {\n            metadataFromTarget = Array.from(metadataFromTargetMap.values()).filter(meta => meta.propertyName !== undefined);\n        }\n        let metadataFromAncestors: T[] = [];\n        for (const ancestor of this.getAncestors(target)) {\n            const ancestorMetadataMap = metadatas.get(ancestor);\n            if (ancestorMetadataMap) {\n                const metadataFromAncestor = Array.from(ancestorMetadataMap.values()).filter(meta => meta.propertyName !== undefined);\n                metadataFromAncestors.push(...metadataFromAncestor);\n            }\n        }        \n        return metadataFromAncestors.concat(metadataFromTarget || []);\n    }\n\n    private findMetadata<T extends { target: Function, propertyName: string }>(metadatas: Map<Function, Map<string, T>>, target: Function, propertyName: string): T {\n        const metadataFromTargetMap = metadatas.get(target);\n        if (metadataFromTargetMap) {\n            const metadataFromTarget = metadataFromTargetMap.get(propertyName);  \n            if (metadataFromTarget) {\n                return metadataFromTarget;\n            }\n        }\n        for (const ancestor of this.getAncestors(target)) {\n            const ancestorMetadataMap = metadatas.get(ancestor);\n            if (ancestorMetadataMap) {\n                const ancestorResult = ancestorMetadataMap.get(propertyName);\n                if (ancestorResult) {\n                  return ancestorResult;\n                }\n            }\n        }\n        return undefined;\n    }\n\n    private findMetadatas<T extends { target: Function, propertyName: string }>(metadatas: Map<Function, Map<string, T[]>>, target: Function, propertyName: string): T[] {\n        const metadataFromTargetMap = metadatas.get(target);\n        let metadataFromTarget: T[];\n        if (metadataFromTargetMap) {\n            metadataFromTarget = metadataFromTargetMap.get(propertyName);    \n        }\n        let metadataFromAncestorsTarget: T[] = [];\n        for (const ancestor of this.getAncestors(target)) {\n            const ancestorMetadataMap = metadatas.get(ancestor);\n            if (ancestorMetadataMap) {\n                if (ancestorMetadataMap.has(propertyName)) {\n                  metadataFromAncestorsTarget.push(...ancestorMetadataMap.get(propertyName));\n                }\n            }\n        }\n        return (metadataFromAncestorsTarget).reverse().concat((metadataFromTarget || []).reverse());\n    }\n\n    private getAncestors(target: Function): Function[] {\n        if (!target) return [];\n        if (!this._ancestorsMap.has(target)) {\n            let ancestors: Function[] = [];\n            for (let baseClass = Object.getPrototypeOf(target.prototype.constructor);\n                 typeof baseClass.prototype !== \"undefined\";\n                 baseClass = Object.getPrototypeOf(baseClass.prototype.constructor)) {\n                ancestors.push(baseClass);\n            }\n            this._ancestorsMap.set(target, ancestors);\n        }\n        return this._ancestorsMap.get(target);\n    }\n}\n"]},"metadata":{},"sourceType":"script"}