{"ast":null,"code":"\"use strict\";\n\nvar __rest = this && this.__rest || function (s, e) {\n  var t = {};\n\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.sendTronOffchainTransaction = void 0;\n\nconst tatum_1 = require(\"../connector/tatum\");\n\nconst constants_1 = require(\"../constants\");\n\nconst ledger_1 = require(\"../ledger\");\n\nconst request_1 = require(\"../model/request\");\n\nconst transaction_1 = require(\"../transaction\");\n\nconst wallet_1 = require(\"../wallet\");\n\nconst common_1 = require(\"./common\");\n\nconst kms_1 = require(\"./kms\");\n/**\n * Send Tron transaction from Tatum Ledger account to the blockchain. This method broadcasts signed transaction to the blockchain.\n * This operation is irreversible.\n * @param testnet mainnet or testnet version\n * @param body content of the transaction to broadcast\n * @returns transaction id of the transaction in the blockchain or id of the withdrawal, if it was not cancelled automatically\n */\n\n\nconst sendTronOffchainTransaction = async (testnet, body) => {\n  if (body.signatureId) {\n    return kms_1.offchainTransferTronKMS(body);\n  }\n\n  await tatum_1.validateBody(body, request_1.TransferTrxOffchain);\n\n  const {\n    mnemonic,\n    index,\n    fromPrivateKey\n  } = body,\n        withdrawal = __rest(body, [\"mnemonic\", \"index\", \"fromPrivateKey\"]);\n\n  const {\n    amount,\n    address\n  } = withdrawal;\n  let fromPriv;\n\n  if (mnemonic && index !== undefined) {\n    fromPriv = mnemonic && index ? await wallet_1.generatePrivateKeyFromMnemonic(request_1.Currency.TRON, testnet, mnemonic, index) : fromPrivateKey;\n  } else if (fromPrivateKey) {\n    fromPriv = fromPrivateKey;\n  } else {\n    throw new Error('No mnemonic or private key is present.');\n  }\n\n  withdrawal.fee = withdrawal.fee || '2.5';\n  const account = await ledger_1.getAccountById(withdrawal.senderAccountId);\n  let txData;\n\n  if (account.currency === request_1.Currency.TRON) {\n    txData = await transaction_1.prepareTronSignedTransaction(testnet, {\n      amount,\n      fromPrivateKey: fromPriv,\n      to: address\n    });\n  } else if (account.currency === request_1.Currency.USDT_TRON || account.currency === request_1.Currency.INRT_TRON) {\n    txData = await transaction_1.prepareTronTrc20SignedTransaction(testnet, {\n      amount,\n      fromPrivateKey: fromPriv,\n      to: address,\n      tokenAddress: constants_1.CONTRACT_ADDRESSES[account.currency],\n      feeLimit: parseFloat(withdrawal.fee)\n    });\n  } else {\n    const vc = await ledger_1.getVirtualCurrencyByName(account.currency);\n\n    if (vc.trcType === request_1.TrcType.TRC10) {\n      txData = await transaction_1.prepareTronTrc10SignedTransaction(testnet, {\n        amount,\n        fromPrivateKey: fromPriv,\n        to: address,\n        tokenId: vc.erc20Address\n      }, vc.precision);\n    } else if (vc.trcType === request_1.TrcType.TRC20) {\n      txData = await transaction_1.prepareTronTrc20SignedTransaction(testnet, {\n        amount,\n        feeLimit: parseFloat(withdrawal.fee),\n        fromPrivateKey: fromPriv,\n        to: address,\n        tokenAddress: vc.erc20Address\n      });\n    } else {\n      throw new Error('Unsupported account.');\n    }\n  }\n\n  const {\n    id\n  } = await common_1.offchainStoreWithdrawal(withdrawal);\n\n  try {\n    return Object.assign(Object.assign({}, await common_1.offchainBroadcast({\n      txData,\n      withdrawalId: id,\n      currency: request_1.Currency.TRON\n    })), {\n      id\n    });\n  } catch (e) {\n    console.error(e);\n\n    try {\n      await common_1.offchainCancelWithdrawal(id);\n    } catch (e1) {\n      console.log(e);\n      return {\n        id\n      };\n    }\n  }\n};\n\nexports.sendTronOffchainTransaction = sendTronOffchainTransaction;","map":{"version":3,"mappings":"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","names":["sendTronOffchainTransaction","testnet","body","signatureId","kms_1","tatum_1","request_1","mnemonic","index","fromPrivateKey","withdrawal","amount","address","fromPriv","undefined","wallet_1","TRON","Error","fee","account","ledger_1","senderAccountId","txData","currency","transaction_1","to","USDT_TRON","INRT_TRON","tokenAddress","constants_1","feeLimit","parseFloat","vc","trcType","TRC10","tokenId","erc20Address","precision","TRC20","id","common_1","withdrawalId","e","console","error","e1","log","exports"],"sourceRoot":"","sources":["../../../src/offchain/tron.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}