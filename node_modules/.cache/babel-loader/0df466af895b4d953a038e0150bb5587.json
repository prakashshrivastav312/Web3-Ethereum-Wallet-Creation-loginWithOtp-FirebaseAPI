{"ast":null,"code":"'use strict';\n\nvar Signature = require('../crypto/signature');\n\nvar Script = require('../script');\n\nvar Output = require('./output');\n\nvar BufferReader = require('../encoding/bufferreader');\n\nvar BufferWriter = require('../encoding/bufferwriter');\n\nvar BN = require('../crypto/bn');\n\nvar Hash = require('../crypto/hash');\n\nvar ECDSA = require('../crypto/ecdsa');\n\nvar $ = require('../util/preconditions');\n\nvar _ = require('lodash');\n\nvar SIGHASH_SINGLE_BUG = '0000000000000000000000000000000000000000000000000000000000000001';\nvar BITS_64_ON = 'ffffffffffffffff';\n/**\n * Returns a buffer of length 32 bytes with the hash that needs to be signed\n * for OP_CHECKSIG.\n *\n * @name Signing.sighash\n * @param {Transaction} transaction the transaction to sign\n * @param {number} sighashType the type of the hash\n * @param {number} inputNumber the input index for the signature\n * @param {Script} subscript the script that will be signed\n */\n\nvar sighash = function sighash(transaction, sighashType, inputNumber, subscript) {\n  var Transaction = require('./transaction');\n\n  var Input = require('./input');\n\n  var i; // Copy transaction\n\n  var txcopy = Transaction.shallowCopy(transaction); // Copy script\n\n  subscript = new Script(subscript);\n  subscript.removeCodeseparators();\n\n  for (i = 0; i < txcopy.inputs.length; i++) {\n    // Blank signatures for other inputs\n    txcopy.inputs[i] = new Input(txcopy.inputs[i]).setScript(Script.empty());\n  }\n\n  txcopy.inputs[inputNumber] = new Input(txcopy.inputs[inputNumber]).setScript(subscript);\n\n  if ((sighashType & 31) === Signature.SIGHASH_NONE || (sighashType & 31) === Signature.SIGHASH_SINGLE) {\n    // clear all sequenceNumbers\n    for (i = 0; i < txcopy.inputs.length; i++) {\n      if (i !== inputNumber) {\n        txcopy.inputs[i].sequenceNumber = 0;\n      }\n    }\n  }\n\n  if ((sighashType & 31) === Signature.SIGHASH_NONE) {\n    txcopy.outputs = [];\n  } else if ((sighashType & 31) === Signature.SIGHASH_SINGLE) {\n    // The SIGHASH_SINGLE bug.\n    // https://bitcointalk.org/index.php?topic=260595.0\n    if (inputNumber >= txcopy.outputs.length) {\n      return Buffer.from(SIGHASH_SINGLE_BUG, 'hex');\n    }\n\n    txcopy.outputs.length = inputNumber + 1;\n\n    for (i = 0; i < inputNumber; i++) {\n      txcopy.outputs[i] = new Output({\n        satoshis: BN.fromBuffer(Buffer.from(BITS_64_ON, 'hex')),\n        script: Script.empty()\n      });\n    }\n  }\n\n  if (sighashType & Signature.SIGHASH_ANYONECANPAY) {\n    txcopy.inputs = [txcopy.inputs[inputNumber]];\n  }\n\n  var buf = new BufferWriter().write(txcopy.toBuffer(true)).writeInt32LE(sighashType).toBuffer();\n  var ret = Hash.sha256sha256(buf);\n  ret = new BufferReader(ret).readReverse();\n  return ret;\n};\n/**\n * Create a signature\n *\n * @name Signing.sign\n * @param {Transaction} transaction\n * @param {PrivateKey} privateKey\n * @param {number} sighash\n * @param {number} inputIndex\n * @param {Script} subscript\n * @param {String} signingMethod - method used to sign - 'ecdsa' or 'schnorr' (future signing method)\n * @return {Signature}\n */\n\n\nfunction sign(transaction, privateKey, sighashType, inputIndex, subscript, signingMethod) {\n  signingMethod = signingMethod || 'ecdsa';\n  var sig;\n\n  if (signingMethod === 'ecdsa') {\n    var hashbuf = sighash(transaction, sighashType, inputIndex, subscript);\n    sig = ECDSA.sign(hashbuf, privateKey, 'little').set({\n      nhashtype: sighashType\n    });\n    return sig;\n  }\n\n  throw new Error('signingMethod not supported ', signingMethod);\n}\n/**\n * Verify a signature\n *\n * @name Signing.verify\n * @param {Transaction} transaction\n * @param {Signature} signature\n * @param {PublicKey} publicKey\n * @param {number} inputIndex\n * @param {Script} subscript\n * @param {String} signingMethod - method used to sign - 'ecdsa' or 'schnorr'\n * @return {boolean}\n */\n\n\nfunction verify(transaction, signature, publicKey, inputIndex, subscript, signingMethod) {\n  $.checkArgument(!_.isUndefined(transaction), 'Transaction Undefined');\n  $.checkArgument(!_.isUndefined(signature) && !_.isUndefined(signature.nhashtype), \"Signature Undefined\");\n  signingMethod = signingMethod || 'ecdsa';\n\n  if (signingMethod === 'ecdsa') {\n    var hashbuf = sighash(transaction, signature.nhashtype, inputIndex, subscript);\n    return ECDSA.verify(hashbuf, signature, publicKey, 'little');\n  }\n\n  throw new Error('signingMethod not supported ', signingMethod);\n}\n/**\n * @namespace Signing\n */\n\n\nmodule.exports = {\n  sighash: sighash,\n  sign: sign,\n  verify: verify\n};","map":{"version":3,"names":["Signature","require","Script","Output","BufferReader","BufferWriter","BN","Hash","ECDSA","$","_","SIGHASH_SINGLE_BUG","BITS_64_ON","sighash","transaction","sighashType","inputNumber","subscript","Transaction","Input","i","txcopy","shallowCopy","removeCodeseparators","inputs","length","setScript","empty","SIGHASH_NONE","SIGHASH_SINGLE","sequenceNumber","outputs","Buffer","from","satoshis","fromBuffer","script","SIGHASH_ANYONECANPAY","buf","write","toBuffer","writeInt32LE","ret","sha256sha256","readReverse","sign","privateKey","inputIndex","signingMethod","sig","hashbuf","set","nhashtype","Error","verify","signature","publicKey","checkArgument","isUndefined","module","exports"],"sources":["C:/Users/acer/node_modules/bitcore-lib-ltc/lib/transaction/sighash.js"],"sourcesContent":["'use strict';\n\nvar Signature = require('../crypto/signature');\nvar Script = require('../script');\nvar Output = require('./output');\nvar BufferReader = require('../encoding/bufferreader');\nvar BufferWriter = require('../encoding/bufferwriter');\nvar BN = require('../crypto/bn');\nvar Hash = require('../crypto/hash');\nvar ECDSA = require('../crypto/ecdsa');\nvar $ = require('../util/preconditions');\nvar _ = require('lodash');\n\nvar SIGHASH_SINGLE_BUG = '0000000000000000000000000000000000000000000000000000000000000001';\nvar BITS_64_ON = 'ffffffffffffffff';\n\n/**\n * Returns a buffer of length 32 bytes with the hash that needs to be signed\n * for OP_CHECKSIG.\n *\n * @name Signing.sighash\n * @param {Transaction} transaction the transaction to sign\n * @param {number} sighashType the type of the hash\n * @param {number} inputNumber the input index for the signature\n * @param {Script} subscript the script that will be signed\n */\nvar sighash = function sighash(transaction, sighashType, inputNumber, subscript) {\n  var Transaction = require('./transaction');\n  var Input = require('./input');\n\n  var i;\n  // Copy transaction\n  var txcopy = Transaction.shallowCopy(transaction);\n\n  // Copy script\n  subscript = new Script(subscript);\n  subscript.removeCodeseparators();\n\n  for (i = 0; i < txcopy.inputs.length; i++) {\n    // Blank signatures for other inputs\n    txcopy.inputs[i] = new Input(txcopy.inputs[i]).setScript(Script.empty());\n  }\n\n  txcopy.inputs[inputNumber] = new Input(txcopy.inputs[inputNumber]).setScript(subscript);\n\n  if ((sighashType & 31) === Signature.SIGHASH_NONE ||\n    (sighashType & 31) === Signature.SIGHASH_SINGLE) {\n\n    // clear all sequenceNumbers\n    for (i = 0; i < txcopy.inputs.length; i++) {\n      if (i !== inputNumber) {\n        txcopy.inputs[i].sequenceNumber = 0;\n      }\n    }\n  }\n\n  if ((sighashType & 31) === Signature.SIGHASH_NONE) {\n    txcopy.outputs = [];\n\n  } else if ((sighashType & 31) === Signature.SIGHASH_SINGLE) {\n    // The SIGHASH_SINGLE bug.\n    // https://bitcointalk.org/index.php?topic=260595.0\n    if (inputNumber >= txcopy.outputs.length) {\n      return Buffer.from(SIGHASH_SINGLE_BUG, 'hex');\n    }\n\n    txcopy.outputs.length = inputNumber + 1;\n\n    for (i = 0; i < inputNumber; i++) {\n      txcopy.outputs[i] = new Output({\n        satoshis: BN.fromBuffer(Buffer.from(BITS_64_ON, 'hex')),\n        script: Script.empty()\n      });\n    }\n  }\n\n  if (sighashType & Signature.SIGHASH_ANYONECANPAY) {\n    txcopy.inputs = [txcopy.inputs[inputNumber]];\n  }\n\n  var buf = new BufferWriter()\n    .write(txcopy.toBuffer(true))\n    .writeInt32LE(sighashType)\n    .toBuffer();\n  var ret = Hash.sha256sha256(buf);\n  ret = new BufferReader(ret).readReverse();\n  return ret;\n};\n\n/**\n * Create a signature\n *\n * @name Signing.sign\n * @param {Transaction} transaction\n * @param {PrivateKey} privateKey\n * @param {number} sighash\n * @param {number} inputIndex\n * @param {Script} subscript\n * @param {String} signingMethod - method used to sign - 'ecdsa' or 'schnorr' (future signing method)\n * @return {Signature}\n */\nfunction sign(transaction, privateKey, sighashType, inputIndex, subscript, signingMethod) {\n  signingMethod = signingMethod || 'ecdsa';\n\n  var sig;\n  if(signingMethod === 'ecdsa') {\n    var hashbuf = sighash(transaction, sighashType, inputIndex, subscript);\n    sig = ECDSA.sign(hashbuf, privateKey, 'little').set({\n    nhashtype: sighashType\n  });\n  return sig;\n }\n  throw new Error('signingMethod not supported ', signingMethod);\n}\n\n/**\n * Verify a signature\n *\n * @name Signing.verify\n * @param {Transaction} transaction\n * @param {Signature} signature\n * @param {PublicKey} publicKey\n * @param {number} inputIndex\n * @param {Script} subscript\n * @param {String} signingMethod - method used to sign - 'ecdsa' or 'schnorr'\n * @return {boolean}\n */\nfunction verify(transaction, signature, publicKey, inputIndex, subscript, signingMethod) {\n  $.checkArgument(!_.isUndefined(transaction), 'Transaction Undefined');\n  $.checkArgument(!_.isUndefined(signature) && !_.isUndefined(signature.nhashtype), \"Signature Undefined\");\n\n  signingMethod = signingMethod || 'ecdsa';\n  if (signingMethod === 'ecdsa') {\n    var hashbuf = sighash(transaction, signature.nhashtype, inputIndex, subscript);\n    return ECDSA.verify(hashbuf, signature, publicKey, 'little');\n  }\n  throw new Error('signingMethod not supported ', signingMethod);\n}\n\n/**\n * @namespace Signing\n */\nmodule.exports = {\n  sighash: sighash,\n  sign: sign,\n  verify: verify\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}