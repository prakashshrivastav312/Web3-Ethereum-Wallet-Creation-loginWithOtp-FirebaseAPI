{"ast":null,"code":"'use strict';\n\nconst normalizeNodes = require('./utils').normalizeNodes;\n\nconst BigNumber = require('bignumber.js');\n\nfunction parsePaymentChannelStatus(node) {\n  if (node.diffType === 'CreatedNode') {\n    return 'created';\n  }\n\n  if (node.diffType === 'ModifiedNode') {\n    return 'modified';\n  }\n\n  if (node.diffType === 'DeletedNode') {\n    return 'deleted';\n  }\n\n  return undefined;\n}\n\nfunction summarizePaymentChannel(node) {\n  const final = node.diffType === 'CreatedNode' ? node.newFields : node.finalFields;\n  const prev = node.previousFields || {};\n  const summary = {\n    // Status may be 'created', 'modified', or 'deleted'.\n    status: parsePaymentChannelStatus(node),\n    // The LedgerIndex indicates the Channel ID,\n    // which is necessary to sign claims.\n    channelId: node.ledgerIndex,\n    // The source address that owns this payment channel.\n    // This comes from the sending address of the\n    // transaction that created the channel.\n    source: final.Account,\n    // The destination address for this payment channel.\n    // While the payment channel is open, this address is the only one that can receive\n    // XRP from the channel. This comes from the Destination field of the transaction\n    // that created the channel.\n    destination: final.Destination,\n    // Total XRP, in drops, that has been allocated to this channel.\n    // This includes XRP that has been paid to the destination address.\n    // This is initially set by the transaction that created the channel and\n    // can be increased if the source address sends a PaymentChannelFund transaction.\n    channelAmountDrops: new BigNumber(final.Amount || 0).toString(10),\n    // Total XRP, in drops, already paid out by the channel.\n    // The difference between this value and the Amount field is how much XRP can still\n    // be paid to the destination address with PaymentChannelClaim transactions.\n    // If the channel closes, the remaining difference is returned to the source address.\n    channelBalanceDrops: new BigNumber(final.Balance || 0).toString(10)\n  };\n\n  if (prev.Amount) {\n    // The change in the number of XRP drops allocated to this channel.\n    // This is positive if this is a PaymentChannelFund transaction.\n    summary.channelAmountChangeDrops = new BigNumber(final.Amount).minus(new BigNumber(prev.Amount || 0)).toString(10);\n  }\n\n  if (prev.Balance) {\n    // The change in the number of XRP drops already paid out by the channel.\n    summary.channelBalanceChangeDrops = new BigNumber(final.Balance).minus(new BigNumber(prev.Balance || 0)).toString(10);\n  }\n\n  if (node.PreviousTxnID) {\n    // The identifying hash of the transaction that\n    // most recently modified this payment channel object.\n    // You can use this to retrieve the object's history.\n    summary.previousTxnId = node.PreviousTxnID;\n  }\n\n  return summary;\n}\n\nfunction parseChannelChanges(metadata) {\n  const paymentChannels = normalizeNodes(metadata).filter(n => {\n    return n.entryType === 'PayChannel';\n  });\n  return paymentChannels.length === 1 ? summarizePaymentChannel(paymentChannels[0]) : undefined;\n}\n\nmodule.exports.parseChannelChanges = parseChannelChanges;","map":{"version":3,"names":["normalizeNodes","require","BigNumber","parsePaymentChannelStatus","node","diffType","undefined","summarizePaymentChannel","final","newFields","finalFields","prev","previousFields","summary","status","channelId","ledgerIndex","source","Account","destination","Destination","channelAmountDrops","Amount","toString","channelBalanceDrops","Balance","channelAmountChangeDrops","minus","channelBalanceChangeDrops","PreviousTxnID","previousTxnId","parseChannelChanges","metadata","paymentChannels","filter","n","entryType","length","module","exports"],"sources":["C:/Users/acer/node_modules/ripple-lib-transactionparser/src/channelchanges.js"],"sourcesContent":["'use strict'\n\nconst normalizeNodes = require('./utils').normalizeNodes\nconst BigNumber = require('bignumber.js')\n\nfunction parsePaymentChannelStatus(node) {\n  if (node.diffType === 'CreatedNode') {\n    return 'created'\n  }\n\n  if (node.diffType === 'ModifiedNode') {\n    return 'modified'\n  }\n\n  if (node.diffType === 'DeletedNode') {\n    return 'deleted'\n  }\n  return undefined\n}\n\nfunction summarizePaymentChannel(node) {\n\n  const final = (node.diffType === 'CreatedNode') ?\n    node.newFields : node.finalFields\n  const prev = node.previousFields || {}\n\n  const summary = {\n    // Status may be 'created', 'modified', or 'deleted'.\n    status: parsePaymentChannelStatus(node),\n\n    // The LedgerIndex indicates the Channel ID,\n    // which is necessary to sign claims.\n    channelId: node.ledgerIndex,\n\n    // The source address that owns this payment channel.\n    // This comes from the sending address of the\n    // transaction that created the channel.\n    source: final.Account,\n\n    // The destination address for this payment channel.\n    // While the payment channel is open, this address is the only one that can receive\n    // XRP from the channel. This comes from the Destination field of the transaction\n    // that created the channel.\n    destination: final.Destination,\n\n    // Total XRP, in drops, that has been allocated to this channel.\n    // This includes XRP that has been paid to the destination address.\n    // This is initially set by the transaction that created the channel and\n    // can be increased if the source address sends a PaymentChannelFund transaction.\n    channelAmountDrops:\n          new BigNumber(final.Amount || 0).toString(10),\n\n    // Total XRP, in drops, already paid out by the channel.\n    // The difference between this value and the Amount field is how much XRP can still\n    // be paid to the destination address with PaymentChannelClaim transactions.\n    // If the channel closes, the remaining difference is returned to the source address.\n    channelBalanceDrops:\n          new BigNumber(final.Balance || 0).toString(10)\n  }\n\n  if (prev.Amount) {\n    // The change in the number of XRP drops allocated to this channel.\n    // This is positive if this is a PaymentChannelFund transaction.\n    summary.channelAmountChangeDrops = new BigNumber(final.Amount)\n      .minus(new BigNumber(prev.Amount || 0))\n      .toString(10)\n  }\n\n  if (prev.Balance) {\n    // The change in the number of XRP drops already paid out by the channel.\n    summary.channelBalanceChangeDrops = new BigNumber(final.Balance)\n      .minus(new BigNumber(prev.Balance || 0))\n      .toString(10)\n  }\n\n  if (node.PreviousTxnID) {\n    // The identifying hash of the transaction that\n    // most recently modified this payment channel object.\n    // You can use this to retrieve the object's history.\n    summary.previousTxnId = node.PreviousTxnID\n  }\n\n  return summary\n}\n\nfunction parseChannelChanges(metadata) {\n  const paymentChannels = normalizeNodes(metadata)\n    .filter(n => {\n      return n.entryType === 'PayChannel'\n    })\n\n  return (paymentChannels.length === 1) ?\n    summarizePaymentChannel(paymentChannels[0]) :\n    undefined\n}\n\nmodule.exports.parseChannelChanges = parseChannelChanges\n"],"mappings":"AAAA;;AAEA,MAAMA,cAAc,GAAGC,OAAO,CAAC,SAAD,CAAP,CAAmBD,cAA1C;;AACA,MAAME,SAAS,GAAGD,OAAO,CAAC,cAAD,CAAzB;;AAEA,SAASE,yBAAT,CAAmCC,IAAnC,EAAyC;EACvC,IAAIA,IAAI,CAACC,QAAL,KAAkB,aAAtB,EAAqC;IACnC,OAAO,SAAP;EACD;;EAED,IAAID,IAAI,CAACC,QAAL,KAAkB,cAAtB,EAAsC;IACpC,OAAO,UAAP;EACD;;EAED,IAAID,IAAI,CAACC,QAAL,KAAkB,aAAtB,EAAqC;IACnC,OAAO,SAAP;EACD;;EACD,OAAOC,SAAP;AACD;;AAED,SAASC,uBAAT,CAAiCH,IAAjC,EAAuC;EAErC,MAAMI,KAAK,GAAIJ,IAAI,CAACC,QAAL,KAAkB,aAAnB,GACZD,IAAI,CAACK,SADO,GACKL,IAAI,CAACM,WADxB;EAEA,MAAMC,IAAI,GAAGP,IAAI,CAACQ,cAAL,IAAuB,EAApC;EAEA,MAAMC,OAAO,GAAG;IACd;IACAC,MAAM,EAAEX,yBAAyB,CAACC,IAAD,CAFnB;IAId;IACA;IACAW,SAAS,EAAEX,IAAI,CAACY,WANF;IAQd;IACA;IACA;IACAC,MAAM,EAAET,KAAK,CAACU,OAXA;IAad;IACA;IACA;IACA;IACAC,WAAW,EAAEX,KAAK,CAACY,WAjBL;IAmBd;IACA;IACA;IACA;IACAC,kBAAkB,EACZ,IAAInB,SAAJ,CAAcM,KAAK,CAACc,MAAN,IAAgB,CAA9B,EAAiCC,QAAjC,CAA0C,EAA1C,CAxBQ;IA0Bd;IACA;IACA;IACA;IACAC,mBAAmB,EACb,IAAItB,SAAJ,CAAcM,KAAK,CAACiB,OAAN,IAAiB,CAA/B,EAAkCF,QAAlC,CAA2C,EAA3C;EA/BQ,CAAhB;;EAkCA,IAAIZ,IAAI,CAACW,MAAT,EAAiB;IACf;IACA;IACAT,OAAO,CAACa,wBAAR,GAAmC,IAAIxB,SAAJ,CAAcM,KAAK,CAACc,MAApB,EAChCK,KADgC,CAC1B,IAAIzB,SAAJ,CAAcS,IAAI,CAACW,MAAL,IAAe,CAA7B,CAD0B,EAEhCC,QAFgC,CAEvB,EAFuB,CAAnC;EAGD;;EAED,IAAIZ,IAAI,CAACc,OAAT,EAAkB;IAChB;IACAZ,OAAO,CAACe,yBAAR,GAAoC,IAAI1B,SAAJ,CAAcM,KAAK,CAACiB,OAApB,EACjCE,KADiC,CAC3B,IAAIzB,SAAJ,CAAcS,IAAI,CAACc,OAAL,IAAgB,CAA9B,CAD2B,EAEjCF,QAFiC,CAExB,EAFwB,CAApC;EAGD;;EAED,IAAInB,IAAI,CAACyB,aAAT,EAAwB;IACtB;IACA;IACA;IACAhB,OAAO,CAACiB,aAAR,GAAwB1B,IAAI,CAACyB,aAA7B;EACD;;EAED,OAAOhB,OAAP;AACD;;AAED,SAASkB,mBAAT,CAA6BC,QAA7B,EAAuC;EACrC,MAAMC,eAAe,GAAGjC,cAAc,CAACgC,QAAD,CAAd,CACrBE,MADqB,CACdC,CAAC,IAAI;IACX,OAAOA,CAAC,CAACC,SAAF,KAAgB,YAAvB;EACD,CAHqB,CAAxB;EAKA,OAAQH,eAAe,CAACI,MAAhB,KAA2B,CAA5B,GACL9B,uBAAuB,CAAC0B,eAAe,CAAC,CAAD,CAAhB,CADlB,GAEL3B,SAFF;AAGD;;AAEDgC,MAAM,CAACC,OAAP,CAAeR,mBAAf,GAAqCA,mBAArC"},"metadata":{},"sourceType":"script"}