{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n\nconst bufferutils_1 = require('./bufferutils');\n\nconst bcrypto = require('./crypto');\n\nconst bscript = require('./script');\n\nconst script_1 = require('./script');\n\nconst types = require('./types');\n\nconst typeforce = require('typeforce');\n\nconst varuint = require('varuint-bitcoin');\n\nfunction varSliceSize(someScript) {\n  const length = someScript.length;\n  return varuint.encodingLength(length) + length;\n}\n\nfunction vectorSize(someVector) {\n  const length = someVector.length;\n  return varuint.encodingLength(length) + someVector.reduce((sum, witness) => {\n    return sum + varSliceSize(witness);\n  }, 0);\n}\n\nconst EMPTY_SCRIPT = Buffer.allocUnsafe(0);\nconst EMPTY_WITNESS = [];\nconst ZERO = Buffer.from('0000000000000000000000000000000000000000000000000000000000000000', 'hex');\nconst ONE = Buffer.from('0000000000000000000000000000000000000000000000000000000000000001', 'hex');\nconst VALUE_UINT64_MAX = Buffer.from('ffffffffffffffff', 'hex');\nconst BLANK_OUTPUT = {\n  script: EMPTY_SCRIPT,\n  valueBuffer: VALUE_UINT64_MAX\n};\n\nfunction isOutput(out) {\n  return out.value !== undefined;\n}\n\nclass Transaction {\n  constructor() {\n    this.version = 1;\n    this.locktime = 0;\n    this.ins = [];\n    this.outs = [];\n  }\n\n  static fromBuffer(buffer, _NO_STRICT) {\n    const bufferReader = new bufferutils_1.BufferReader(buffer);\n    const tx = new Transaction();\n    tx.version = bufferReader.readInt32();\n    const marker = bufferReader.readUInt8();\n    const flag = bufferReader.readUInt8();\n    let hasWitnesses = false;\n\n    if (marker === Transaction.ADVANCED_TRANSACTION_MARKER && flag === Transaction.ADVANCED_TRANSACTION_FLAG) {\n      hasWitnesses = true;\n    } else {\n      bufferReader.offset -= 2;\n    }\n\n    const vinLen = bufferReader.readVarInt();\n\n    for (let i = 0; i < vinLen; ++i) {\n      tx.ins.push({\n        hash: bufferReader.readSlice(32),\n        index: bufferReader.readUInt32(),\n        script: bufferReader.readVarSlice(),\n        sequence: bufferReader.readUInt32(),\n        witness: EMPTY_WITNESS\n      });\n    }\n\n    const voutLen = bufferReader.readVarInt();\n\n    for (let i = 0; i < voutLen; ++i) {\n      tx.outs.push({\n        value: bufferReader.readUInt64(),\n        script: bufferReader.readVarSlice()\n      });\n    }\n\n    if (hasWitnesses) {\n      for (let i = 0; i < vinLen; ++i) {\n        tx.ins[i].witness = bufferReader.readVector();\n      } // was this pointless?\n\n\n      if (!tx.hasWitnesses()) throw new Error('Transaction has superfluous witness data');\n    }\n\n    tx.locktime = bufferReader.readUInt32();\n    if (_NO_STRICT) return tx;\n    if (bufferReader.offset !== buffer.length) throw new Error('Transaction has unexpected data');\n    return tx;\n  }\n\n  static fromHex(hex) {\n    return Transaction.fromBuffer(Buffer.from(hex, 'hex'), false);\n  }\n\n  static isCoinbaseHash(buffer) {\n    typeforce(types.Hash256bit, buffer);\n\n    for (let i = 0; i < 32; ++i) {\n      if (buffer[i] !== 0) return false;\n    }\n\n    return true;\n  }\n\n  isCoinbase() {\n    return this.ins.length === 1 && Transaction.isCoinbaseHash(this.ins[0].hash);\n  }\n\n  addInput(hash, index, sequence, scriptSig) {\n    typeforce(types.tuple(types.Hash256bit, types.UInt32, types.maybe(types.UInt32), types.maybe(types.Buffer)), arguments);\n\n    if (types.Null(sequence)) {\n      sequence = Transaction.DEFAULT_SEQUENCE;\n    } // Add the input and return the input's index\n\n\n    return this.ins.push({\n      hash,\n      index,\n      script: scriptSig || EMPTY_SCRIPT,\n      sequence: sequence,\n      witness: EMPTY_WITNESS\n    }) - 1;\n  }\n\n  addOutput(scriptPubKey, value) {\n    typeforce(types.tuple(types.Buffer, types.Satoshi), arguments); // Add the output and return the output's index\n\n    return this.outs.push({\n      script: scriptPubKey,\n      value\n    }) - 1;\n  }\n\n  hasWitnesses() {\n    return this.ins.some(x => {\n      return x.witness.length !== 0;\n    });\n  }\n\n  weight() {\n    const base = this.byteLength(false);\n    const total = this.byteLength(true);\n    return base * 3 + total;\n  }\n\n  virtualSize() {\n    return Math.ceil(this.weight() / 4);\n  }\n\n  byteLength() {\n    let _ALLOW_WITNESS = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n\n    const hasWitnesses = _ALLOW_WITNESS && this.hasWitnesses();\n\n    return (hasWitnesses ? 10 : 8) + varuint.encodingLength(this.ins.length) + varuint.encodingLength(this.outs.length) + this.ins.reduce((sum, input) => {\n      return sum + 40 + varSliceSize(input.script);\n    }, 0) + this.outs.reduce((sum, output) => {\n      return sum + 8 + varSliceSize(output.script);\n    }, 0) + (hasWitnesses ? this.ins.reduce((sum, input) => {\n      return sum + vectorSize(input.witness);\n    }, 0) : 0);\n  }\n\n  clone() {\n    const newTx = new Transaction();\n    newTx.version = this.version;\n    newTx.locktime = this.locktime;\n    newTx.ins = this.ins.map(txIn => {\n      return {\n        hash: txIn.hash,\n        index: txIn.index,\n        script: txIn.script,\n        sequence: txIn.sequence,\n        witness: txIn.witness\n      };\n    });\n    newTx.outs = this.outs.map(txOut => {\n      return {\n        script: txOut.script,\n        value: txOut.value\n      };\n    });\n    return newTx;\n  }\n  /**\n   * Hash transaction for signing a specific input.\n   *\n   * Bitcoin uses a different hash for each signed transaction input.\n   * This method copies the transaction, makes the necessary changes based on the\n   * hashType, and then hashes the result.\n   * This hash can then be used to sign the provided transaction input.\n   */\n\n\n  hashForSignature(inIndex, prevOutScript, hashType) {\n    typeforce(types.tuple(types.UInt32, types.Buffer,\n    /* types.UInt8 */\n    types.Number), arguments); // https://github.com/bitcoin/bitcoin/blob/master/src/test/sighash_tests.cpp#L29\n\n    if (inIndex >= this.ins.length) return ONE; // ignore OP_CODESEPARATOR\n\n    const ourScript = bscript.compile(bscript.decompile(prevOutScript).filter(x => {\n      return x !== script_1.OPS.OP_CODESEPARATOR;\n    }));\n    const txTmp = this.clone(); // SIGHASH_NONE: ignore all outputs? (wildcard payee)\n\n    if ((hashType & 0x1f) === Transaction.SIGHASH_NONE) {\n      txTmp.outs = []; // ignore sequence numbers (except at inIndex)\n\n      txTmp.ins.forEach((input, i) => {\n        if (i === inIndex) return;\n        input.sequence = 0;\n      }); // SIGHASH_SINGLE: ignore all outputs, except at the same index?\n    } else if ((hashType & 0x1f) === Transaction.SIGHASH_SINGLE) {\n      // https://github.com/bitcoin/bitcoin/blob/master/src/test/sighash_tests.cpp#L60\n      if (inIndex >= this.outs.length) return ONE; // truncate outputs after\n\n      txTmp.outs.length = inIndex + 1; // \"blank\" outputs before\n\n      for (let i = 0; i < inIndex; i++) {\n        txTmp.outs[i] = BLANK_OUTPUT;\n      } // ignore sequence numbers (except at inIndex)\n\n\n      txTmp.ins.forEach((input, y) => {\n        if (y === inIndex) return;\n        input.sequence = 0;\n      });\n    } // SIGHASH_ANYONECANPAY: ignore inputs entirely?\n\n\n    if (hashType & Transaction.SIGHASH_ANYONECANPAY) {\n      txTmp.ins = [txTmp.ins[inIndex]];\n      txTmp.ins[0].script = ourScript; // SIGHASH_ALL: only ignore input scripts\n    } else {\n      // \"blank\" others input scripts\n      txTmp.ins.forEach(input => {\n        input.script = EMPTY_SCRIPT;\n      });\n      txTmp.ins[inIndex].script = ourScript;\n    } // serialize and hash\n\n\n    const buffer = Buffer.allocUnsafe(txTmp.byteLength(false) + 4);\n    buffer.writeInt32LE(hashType, buffer.length - 4);\n\n    txTmp.__toBuffer(buffer, 0, false);\n\n    return bcrypto.hash256(buffer);\n  }\n\n  hashForWitnessV0(inIndex, prevOutScript, value, hashType) {\n    typeforce(types.tuple(types.UInt32, types.Buffer, types.Satoshi, types.UInt32), arguments);\n    let tbuffer = Buffer.from([]);\n    let bufferWriter;\n    let hashOutputs = ZERO;\n    let hashPrevouts = ZERO;\n    let hashSequence = ZERO;\n\n    if (!(hashType & Transaction.SIGHASH_ANYONECANPAY)) {\n      tbuffer = Buffer.allocUnsafe(36 * this.ins.length);\n      bufferWriter = new bufferutils_1.BufferWriter(tbuffer, 0);\n      this.ins.forEach(txIn => {\n        bufferWriter.writeSlice(txIn.hash);\n        bufferWriter.writeUInt32(txIn.index);\n      });\n      hashPrevouts = bcrypto.hash256(tbuffer);\n    }\n\n    if (!(hashType & Transaction.SIGHASH_ANYONECANPAY) && (hashType & 0x1f) !== Transaction.SIGHASH_SINGLE && (hashType & 0x1f) !== Transaction.SIGHASH_NONE) {\n      tbuffer = Buffer.allocUnsafe(4 * this.ins.length);\n      bufferWriter = new bufferutils_1.BufferWriter(tbuffer, 0);\n      this.ins.forEach(txIn => {\n        bufferWriter.writeUInt32(txIn.sequence);\n      });\n      hashSequence = bcrypto.hash256(tbuffer);\n    }\n\n    if ((hashType & 0x1f) !== Transaction.SIGHASH_SINGLE && (hashType & 0x1f) !== Transaction.SIGHASH_NONE) {\n      const txOutsSize = this.outs.reduce((sum, output) => {\n        return sum + 8 + varSliceSize(output.script);\n      }, 0);\n      tbuffer = Buffer.allocUnsafe(txOutsSize);\n      bufferWriter = new bufferutils_1.BufferWriter(tbuffer, 0);\n      this.outs.forEach(out => {\n        bufferWriter.writeUInt64(out.value);\n        bufferWriter.writeVarSlice(out.script);\n      });\n      hashOutputs = bcrypto.hash256(tbuffer);\n    } else if ((hashType & 0x1f) === Transaction.SIGHASH_SINGLE && inIndex < this.outs.length) {\n      const output = this.outs[inIndex];\n      tbuffer = Buffer.allocUnsafe(8 + varSliceSize(output.script));\n      bufferWriter = new bufferutils_1.BufferWriter(tbuffer, 0);\n      bufferWriter.writeUInt64(output.value);\n      bufferWriter.writeVarSlice(output.script);\n      hashOutputs = bcrypto.hash256(tbuffer);\n    }\n\n    tbuffer = Buffer.allocUnsafe(156 + varSliceSize(prevOutScript));\n    bufferWriter = new bufferutils_1.BufferWriter(tbuffer, 0);\n    const input = this.ins[inIndex];\n    bufferWriter.writeUInt32(this.version);\n    bufferWriter.writeSlice(hashPrevouts);\n    bufferWriter.writeSlice(hashSequence);\n    bufferWriter.writeSlice(input.hash);\n    bufferWriter.writeUInt32(input.index);\n    bufferWriter.writeVarSlice(prevOutScript);\n    bufferWriter.writeUInt64(value);\n    bufferWriter.writeUInt32(input.sequence);\n    bufferWriter.writeSlice(hashOutputs);\n    bufferWriter.writeUInt32(this.locktime);\n    bufferWriter.writeUInt32(hashType);\n    return bcrypto.hash256(tbuffer);\n  }\n\n  getHash(forWitness) {\n    // wtxid for coinbase is always 32 bytes of 0x00\n    if (forWitness && this.isCoinbase()) return Buffer.alloc(32, 0);\n    return bcrypto.hash256(this.__toBuffer(undefined, undefined, forWitness));\n  }\n\n  getId() {\n    // transaction hash's are displayed in reverse order\n    return bufferutils_1.reverseBuffer(this.getHash(false)).toString('hex');\n  }\n\n  toBuffer(buffer, initialOffset) {\n    return this.__toBuffer(buffer, initialOffset, true);\n  }\n\n  toHex() {\n    return this.toBuffer(undefined, undefined).toString('hex');\n  }\n\n  setInputScript(index, scriptSig) {\n    typeforce(types.tuple(types.Number, types.Buffer), arguments);\n    this.ins[index].script = scriptSig;\n  }\n\n  setWitness(index, witness) {\n    typeforce(types.tuple(types.Number, [types.Buffer]), arguments);\n    this.ins[index].witness = witness;\n  }\n\n  __toBuffer(buffer, initialOffset) {\n    let _ALLOW_WITNESS = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\n    if (!buffer) buffer = Buffer.allocUnsafe(this.byteLength(_ALLOW_WITNESS));\n    const bufferWriter = new bufferutils_1.BufferWriter(buffer, initialOffset || 0);\n    bufferWriter.writeInt32(this.version);\n\n    const hasWitnesses = _ALLOW_WITNESS && this.hasWitnesses();\n\n    if (hasWitnesses) {\n      bufferWriter.writeUInt8(Transaction.ADVANCED_TRANSACTION_MARKER);\n      bufferWriter.writeUInt8(Transaction.ADVANCED_TRANSACTION_FLAG);\n    }\n\n    bufferWriter.writeVarInt(this.ins.length);\n    this.ins.forEach(txIn => {\n      bufferWriter.writeSlice(txIn.hash);\n      bufferWriter.writeUInt32(txIn.index);\n      bufferWriter.writeVarSlice(txIn.script);\n      bufferWriter.writeUInt32(txIn.sequence);\n    });\n    bufferWriter.writeVarInt(this.outs.length);\n    this.outs.forEach(txOut => {\n      if (isOutput(txOut)) {\n        bufferWriter.writeUInt64(txOut.value);\n      } else {\n        bufferWriter.writeSlice(txOut.valueBuffer);\n      }\n\n      bufferWriter.writeVarSlice(txOut.script);\n    });\n\n    if (hasWitnesses) {\n      this.ins.forEach(input => {\n        bufferWriter.writeVector(input.witness);\n      });\n    }\n\n    bufferWriter.writeUInt32(this.locktime); // avoid slicing unless necessary\n\n    if (initialOffset !== undefined) return buffer.slice(initialOffset, bufferWriter.offset);\n    return buffer;\n  }\n\n}\n\nTransaction.DEFAULT_SEQUENCE = 0xffffffff;\nTransaction.SIGHASH_ALL = 0x01;\nTransaction.SIGHASH_NONE = 0x02;\nTransaction.SIGHASH_SINGLE = 0x03;\nTransaction.SIGHASH_ANYONECANPAY = 0x80;\nTransaction.ADVANCED_TRANSACTION_MARKER = 0x00;\nTransaction.ADVANCED_TRANSACTION_FLAG = 0x01;\nexports.Transaction = Transaction;","map":{"version":3,"names":["Object","defineProperty","exports","value","bufferutils_1","require","bcrypto","bscript","script_1","types","typeforce","varuint","varSliceSize","someScript","length","encodingLength","vectorSize","someVector","reduce","sum","witness","EMPTY_SCRIPT","Buffer","allocUnsafe","EMPTY_WITNESS","ZERO","from","ONE","VALUE_UINT64_MAX","BLANK_OUTPUT","script","valueBuffer","isOutput","out","undefined","Transaction","constructor","version","locktime","ins","outs","fromBuffer","buffer","_NO_STRICT","bufferReader","BufferReader","tx","readInt32","marker","readUInt8","flag","hasWitnesses","ADVANCED_TRANSACTION_MARKER","ADVANCED_TRANSACTION_FLAG","offset","vinLen","readVarInt","i","push","hash","readSlice","index","readUInt32","readVarSlice","sequence","voutLen","readUInt64","readVector","Error","fromHex","hex","isCoinbaseHash","Hash256bit","isCoinbase","addInput","scriptSig","tuple","UInt32","maybe","arguments","Null","DEFAULT_SEQUENCE","addOutput","scriptPubKey","Satoshi","some","x","weight","base","byteLength","total","virtualSize","Math","ceil","_ALLOW_WITNESS","input","output","clone","newTx","map","txIn","txOut","hashForSignature","inIndex","prevOutScript","hashType","Number","ourScript","compile","decompile","filter","OPS","OP_CODESEPARATOR","txTmp","SIGHASH_NONE","forEach","SIGHASH_SINGLE","y","SIGHASH_ANYONECANPAY","writeInt32LE","__toBuffer","hash256","hashForWitnessV0","tbuffer","bufferWriter","hashOutputs","hashPrevouts","hashSequence","BufferWriter","writeSlice","writeUInt32","txOutsSize","writeUInt64","writeVarSlice","getHash","forWitness","alloc","getId","reverseBuffer","toString","toBuffer","initialOffset","toHex","setInputScript","setWitness","writeInt32","writeUInt8","writeVarInt","writeVector","slice","SIGHASH_ALL"],"sources":["C:/Users/acer/node_modules/bitcoinjs-lib/src/transaction.js"],"sourcesContent":["'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nconst bufferutils_1 = require('./bufferutils');\nconst bcrypto = require('./crypto');\nconst bscript = require('./script');\nconst script_1 = require('./script');\nconst types = require('./types');\nconst typeforce = require('typeforce');\nconst varuint = require('varuint-bitcoin');\nfunction varSliceSize(someScript) {\n  const length = someScript.length;\n  return varuint.encodingLength(length) + length;\n}\nfunction vectorSize(someVector) {\n  const length = someVector.length;\n  return (\n    varuint.encodingLength(length) +\n    someVector.reduce((sum, witness) => {\n      return sum + varSliceSize(witness);\n    }, 0)\n  );\n}\nconst EMPTY_SCRIPT = Buffer.allocUnsafe(0);\nconst EMPTY_WITNESS = [];\nconst ZERO = Buffer.from(\n  '0000000000000000000000000000000000000000000000000000000000000000',\n  'hex',\n);\nconst ONE = Buffer.from(\n  '0000000000000000000000000000000000000000000000000000000000000001',\n  'hex',\n);\nconst VALUE_UINT64_MAX = Buffer.from('ffffffffffffffff', 'hex');\nconst BLANK_OUTPUT = {\n  script: EMPTY_SCRIPT,\n  valueBuffer: VALUE_UINT64_MAX,\n};\nfunction isOutput(out) {\n  return out.value !== undefined;\n}\nclass Transaction {\n  constructor() {\n    this.version = 1;\n    this.locktime = 0;\n    this.ins = [];\n    this.outs = [];\n  }\n  static fromBuffer(buffer, _NO_STRICT) {\n    const bufferReader = new bufferutils_1.BufferReader(buffer);\n    const tx = new Transaction();\n    tx.version = bufferReader.readInt32();\n    const marker = bufferReader.readUInt8();\n    const flag = bufferReader.readUInt8();\n    let hasWitnesses = false;\n    if (\n      marker === Transaction.ADVANCED_TRANSACTION_MARKER &&\n      flag === Transaction.ADVANCED_TRANSACTION_FLAG\n    ) {\n      hasWitnesses = true;\n    } else {\n      bufferReader.offset -= 2;\n    }\n    const vinLen = bufferReader.readVarInt();\n    for (let i = 0; i < vinLen; ++i) {\n      tx.ins.push({\n        hash: bufferReader.readSlice(32),\n        index: bufferReader.readUInt32(),\n        script: bufferReader.readVarSlice(),\n        sequence: bufferReader.readUInt32(),\n        witness: EMPTY_WITNESS,\n      });\n    }\n    const voutLen = bufferReader.readVarInt();\n    for (let i = 0; i < voutLen; ++i) {\n      tx.outs.push({\n        value: bufferReader.readUInt64(),\n        script: bufferReader.readVarSlice(),\n      });\n    }\n    if (hasWitnesses) {\n      for (let i = 0; i < vinLen; ++i) {\n        tx.ins[i].witness = bufferReader.readVector();\n      }\n      // was this pointless?\n      if (!tx.hasWitnesses())\n        throw new Error('Transaction has superfluous witness data');\n    }\n    tx.locktime = bufferReader.readUInt32();\n    if (_NO_STRICT) return tx;\n    if (bufferReader.offset !== buffer.length)\n      throw new Error('Transaction has unexpected data');\n    return tx;\n  }\n  static fromHex(hex) {\n    return Transaction.fromBuffer(Buffer.from(hex, 'hex'), false);\n  }\n  static isCoinbaseHash(buffer) {\n    typeforce(types.Hash256bit, buffer);\n    for (let i = 0; i < 32; ++i) {\n      if (buffer[i] !== 0) return false;\n    }\n    return true;\n  }\n  isCoinbase() {\n    return (\n      this.ins.length === 1 && Transaction.isCoinbaseHash(this.ins[0].hash)\n    );\n  }\n  addInput(hash, index, sequence, scriptSig) {\n    typeforce(\n      types.tuple(\n        types.Hash256bit,\n        types.UInt32,\n        types.maybe(types.UInt32),\n        types.maybe(types.Buffer),\n      ),\n      arguments,\n    );\n    if (types.Null(sequence)) {\n      sequence = Transaction.DEFAULT_SEQUENCE;\n    }\n    // Add the input and return the input's index\n    return (\n      this.ins.push({\n        hash,\n        index,\n        script: scriptSig || EMPTY_SCRIPT,\n        sequence: sequence,\n        witness: EMPTY_WITNESS,\n      }) - 1\n    );\n  }\n  addOutput(scriptPubKey, value) {\n    typeforce(types.tuple(types.Buffer, types.Satoshi), arguments);\n    // Add the output and return the output's index\n    return (\n      this.outs.push({\n        script: scriptPubKey,\n        value,\n      }) - 1\n    );\n  }\n  hasWitnesses() {\n    return this.ins.some(x => {\n      return x.witness.length !== 0;\n    });\n  }\n  weight() {\n    const base = this.byteLength(false);\n    const total = this.byteLength(true);\n    return base * 3 + total;\n  }\n  virtualSize() {\n    return Math.ceil(this.weight() / 4);\n  }\n  byteLength(_ALLOW_WITNESS = true) {\n    const hasWitnesses = _ALLOW_WITNESS && this.hasWitnesses();\n    return (\n      (hasWitnesses ? 10 : 8) +\n      varuint.encodingLength(this.ins.length) +\n      varuint.encodingLength(this.outs.length) +\n      this.ins.reduce((sum, input) => {\n        return sum + 40 + varSliceSize(input.script);\n      }, 0) +\n      this.outs.reduce((sum, output) => {\n        return sum + 8 + varSliceSize(output.script);\n      }, 0) +\n      (hasWitnesses\n        ? this.ins.reduce((sum, input) => {\n            return sum + vectorSize(input.witness);\n          }, 0)\n        : 0)\n    );\n  }\n  clone() {\n    const newTx = new Transaction();\n    newTx.version = this.version;\n    newTx.locktime = this.locktime;\n    newTx.ins = this.ins.map(txIn => {\n      return {\n        hash: txIn.hash,\n        index: txIn.index,\n        script: txIn.script,\n        sequence: txIn.sequence,\n        witness: txIn.witness,\n      };\n    });\n    newTx.outs = this.outs.map(txOut => {\n      return {\n        script: txOut.script,\n        value: txOut.value,\n      };\n    });\n    return newTx;\n  }\n  /**\n   * Hash transaction for signing a specific input.\n   *\n   * Bitcoin uses a different hash for each signed transaction input.\n   * This method copies the transaction, makes the necessary changes based on the\n   * hashType, and then hashes the result.\n   * This hash can then be used to sign the provided transaction input.\n   */\n  hashForSignature(inIndex, prevOutScript, hashType) {\n    typeforce(\n      types.tuple(types.UInt32, types.Buffer, /* types.UInt8 */ types.Number),\n      arguments,\n    );\n    // https://github.com/bitcoin/bitcoin/blob/master/src/test/sighash_tests.cpp#L29\n    if (inIndex >= this.ins.length) return ONE;\n    // ignore OP_CODESEPARATOR\n    const ourScript = bscript.compile(\n      bscript.decompile(prevOutScript).filter(x => {\n        return x !== script_1.OPS.OP_CODESEPARATOR;\n      }),\n    );\n    const txTmp = this.clone();\n    // SIGHASH_NONE: ignore all outputs? (wildcard payee)\n    if ((hashType & 0x1f) === Transaction.SIGHASH_NONE) {\n      txTmp.outs = [];\n      // ignore sequence numbers (except at inIndex)\n      txTmp.ins.forEach((input, i) => {\n        if (i === inIndex) return;\n        input.sequence = 0;\n      });\n      // SIGHASH_SINGLE: ignore all outputs, except at the same index?\n    } else if ((hashType & 0x1f) === Transaction.SIGHASH_SINGLE) {\n      // https://github.com/bitcoin/bitcoin/blob/master/src/test/sighash_tests.cpp#L60\n      if (inIndex >= this.outs.length) return ONE;\n      // truncate outputs after\n      txTmp.outs.length = inIndex + 1;\n      // \"blank\" outputs before\n      for (let i = 0; i < inIndex; i++) {\n        txTmp.outs[i] = BLANK_OUTPUT;\n      }\n      // ignore sequence numbers (except at inIndex)\n      txTmp.ins.forEach((input, y) => {\n        if (y === inIndex) return;\n        input.sequence = 0;\n      });\n    }\n    // SIGHASH_ANYONECANPAY: ignore inputs entirely?\n    if (hashType & Transaction.SIGHASH_ANYONECANPAY) {\n      txTmp.ins = [txTmp.ins[inIndex]];\n      txTmp.ins[0].script = ourScript;\n      // SIGHASH_ALL: only ignore input scripts\n    } else {\n      // \"blank\" others input scripts\n      txTmp.ins.forEach(input => {\n        input.script = EMPTY_SCRIPT;\n      });\n      txTmp.ins[inIndex].script = ourScript;\n    }\n    // serialize and hash\n    const buffer = Buffer.allocUnsafe(txTmp.byteLength(false) + 4);\n    buffer.writeInt32LE(hashType, buffer.length - 4);\n    txTmp.__toBuffer(buffer, 0, false);\n    return bcrypto.hash256(buffer);\n  }\n  hashForWitnessV0(inIndex, prevOutScript, value, hashType) {\n    typeforce(\n      types.tuple(types.UInt32, types.Buffer, types.Satoshi, types.UInt32),\n      arguments,\n    );\n    let tbuffer = Buffer.from([]);\n    let bufferWriter;\n    let hashOutputs = ZERO;\n    let hashPrevouts = ZERO;\n    let hashSequence = ZERO;\n    if (!(hashType & Transaction.SIGHASH_ANYONECANPAY)) {\n      tbuffer = Buffer.allocUnsafe(36 * this.ins.length);\n      bufferWriter = new bufferutils_1.BufferWriter(tbuffer, 0);\n      this.ins.forEach(txIn => {\n        bufferWriter.writeSlice(txIn.hash);\n        bufferWriter.writeUInt32(txIn.index);\n      });\n      hashPrevouts = bcrypto.hash256(tbuffer);\n    }\n    if (\n      !(hashType & Transaction.SIGHASH_ANYONECANPAY) &&\n      (hashType & 0x1f) !== Transaction.SIGHASH_SINGLE &&\n      (hashType & 0x1f) !== Transaction.SIGHASH_NONE\n    ) {\n      tbuffer = Buffer.allocUnsafe(4 * this.ins.length);\n      bufferWriter = new bufferutils_1.BufferWriter(tbuffer, 0);\n      this.ins.forEach(txIn => {\n        bufferWriter.writeUInt32(txIn.sequence);\n      });\n      hashSequence = bcrypto.hash256(tbuffer);\n    }\n    if (\n      (hashType & 0x1f) !== Transaction.SIGHASH_SINGLE &&\n      (hashType & 0x1f) !== Transaction.SIGHASH_NONE\n    ) {\n      const txOutsSize = this.outs.reduce((sum, output) => {\n        return sum + 8 + varSliceSize(output.script);\n      }, 0);\n      tbuffer = Buffer.allocUnsafe(txOutsSize);\n      bufferWriter = new bufferutils_1.BufferWriter(tbuffer, 0);\n      this.outs.forEach(out => {\n        bufferWriter.writeUInt64(out.value);\n        bufferWriter.writeVarSlice(out.script);\n      });\n      hashOutputs = bcrypto.hash256(tbuffer);\n    } else if (\n      (hashType & 0x1f) === Transaction.SIGHASH_SINGLE &&\n      inIndex < this.outs.length\n    ) {\n      const output = this.outs[inIndex];\n      tbuffer = Buffer.allocUnsafe(8 + varSliceSize(output.script));\n      bufferWriter = new bufferutils_1.BufferWriter(tbuffer, 0);\n      bufferWriter.writeUInt64(output.value);\n      bufferWriter.writeVarSlice(output.script);\n      hashOutputs = bcrypto.hash256(tbuffer);\n    }\n    tbuffer = Buffer.allocUnsafe(156 + varSliceSize(prevOutScript));\n    bufferWriter = new bufferutils_1.BufferWriter(tbuffer, 0);\n    const input = this.ins[inIndex];\n    bufferWriter.writeUInt32(this.version);\n    bufferWriter.writeSlice(hashPrevouts);\n    bufferWriter.writeSlice(hashSequence);\n    bufferWriter.writeSlice(input.hash);\n    bufferWriter.writeUInt32(input.index);\n    bufferWriter.writeVarSlice(prevOutScript);\n    bufferWriter.writeUInt64(value);\n    bufferWriter.writeUInt32(input.sequence);\n    bufferWriter.writeSlice(hashOutputs);\n    bufferWriter.writeUInt32(this.locktime);\n    bufferWriter.writeUInt32(hashType);\n    return bcrypto.hash256(tbuffer);\n  }\n  getHash(forWitness) {\n    // wtxid for coinbase is always 32 bytes of 0x00\n    if (forWitness && this.isCoinbase()) return Buffer.alloc(32, 0);\n    return bcrypto.hash256(this.__toBuffer(undefined, undefined, forWitness));\n  }\n  getId() {\n    // transaction hash's are displayed in reverse order\n    return bufferutils_1.reverseBuffer(this.getHash(false)).toString('hex');\n  }\n  toBuffer(buffer, initialOffset) {\n    return this.__toBuffer(buffer, initialOffset, true);\n  }\n  toHex() {\n    return this.toBuffer(undefined, undefined).toString('hex');\n  }\n  setInputScript(index, scriptSig) {\n    typeforce(types.tuple(types.Number, types.Buffer), arguments);\n    this.ins[index].script = scriptSig;\n  }\n  setWitness(index, witness) {\n    typeforce(types.tuple(types.Number, [types.Buffer]), arguments);\n    this.ins[index].witness = witness;\n  }\n  __toBuffer(buffer, initialOffset, _ALLOW_WITNESS = false) {\n    if (!buffer) buffer = Buffer.allocUnsafe(this.byteLength(_ALLOW_WITNESS));\n    const bufferWriter = new bufferutils_1.BufferWriter(\n      buffer,\n      initialOffset || 0,\n    );\n    bufferWriter.writeInt32(this.version);\n    const hasWitnesses = _ALLOW_WITNESS && this.hasWitnesses();\n    if (hasWitnesses) {\n      bufferWriter.writeUInt8(Transaction.ADVANCED_TRANSACTION_MARKER);\n      bufferWriter.writeUInt8(Transaction.ADVANCED_TRANSACTION_FLAG);\n    }\n    bufferWriter.writeVarInt(this.ins.length);\n    this.ins.forEach(txIn => {\n      bufferWriter.writeSlice(txIn.hash);\n      bufferWriter.writeUInt32(txIn.index);\n      bufferWriter.writeVarSlice(txIn.script);\n      bufferWriter.writeUInt32(txIn.sequence);\n    });\n    bufferWriter.writeVarInt(this.outs.length);\n    this.outs.forEach(txOut => {\n      if (isOutput(txOut)) {\n        bufferWriter.writeUInt64(txOut.value);\n      } else {\n        bufferWriter.writeSlice(txOut.valueBuffer);\n      }\n      bufferWriter.writeVarSlice(txOut.script);\n    });\n    if (hasWitnesses) {\n      this.ins.forEach(input => {\n        bufferWriter.writeVector(input.witness);\n      });\n    }\n    bufferWriter.writeUInt32(this.locktime);\n    // avoid slicing unless necessary\n    if (initialOffset !== undefined)\n      return buffer.slice(initialOffset, bufferWriter.offset);\n    return buffer;\n  }\n}\nTransaction.DEFAULT_SEQUENCE = 0xffffffff;\nTransaction.SIGHASH_ALL = 0x01;\nTransaction.SIGHASH_NONE = 0x02;\nTransaction.SIGHASH_SINGLE = 0x03;\nTransaction.SIGHASH_ANYONECANPAY = 0x80;\nTransaction.ADVANCED_TRANSACTION_MARKER = 0x00;\nTransaction.ADVANCED_TRANSACTION_FLAG = 0x01;\nexports.Transaction = Transaction;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}