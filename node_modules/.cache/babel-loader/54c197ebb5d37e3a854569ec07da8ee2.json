{"ast":null,"code":"'use strict';\n\nvar _ = require('lodash');\n\nvar PrivateKey = require('./privatekey');\n\nvar PublicKey = require('./publickey');\n\nvar Address = require('./address');\n\nvar BufferWriter = require('./encoding/bufferwriter');\n\nvar ECDSA = require('./crypto/ecdsa');\n\nvar Signature = require('./crypto/signature');\n\nvar sha256sha256 = require('./crypto/hash').sha256sha256;\n\nvar JSUtil = require('./util/js');\n\nvar $ = require('./util/preconditions');\n\nfunction Message(message) {\n  if (!(this instanceof Message)) {\n    return new Message(message);\n  }\n\n  $.checkArgument(_.isString(message), 'First argument should be a string');\n  this.message = message;\n  return this;\n}\n\nMessage.MAGIC_BYTES = Buffer.from('Bitcoin Signed Message:\\n');\n\nMessage.prototype.magicHash = function magicHash() {\n  var prefix1 = BufferWriter.varintBufNum(Message.MAGIC_BYTES.length);\n  var messageBuffer = Buffer.from(this.message);\n  var prefix2 = BufferWriter.varintBufNum(messageBuffer.length);\n  var buf = Buffer.concat([prefix1, Message.MAGIC_BYTES, prefix2, messageBuffer]);\n  var hash = sha256sha256(buf);\n  return hash;\n};\n\nMessage.prototype._sign = function _sign(privateKey) {\n  $.checkArgument(privateKey instanceof PrivateKey, 'First argument should be an instance of PrivateKey');\n  var hash = this.magicHash();\n  var ecdsa = new ECDSA();\n  ecdsa.hashbuf = hash;\n  ecdsa.privkey = privateKey;\n  ecdsa.pubkey = privateKey.toPublicKey();\n  ecdsa.signRandomK();\n  ecdsa.calci();\n  return ecdsa.sig;\n};\n/**\n * Will sign a message with a given bitcoin private key.\n *\n * @param {PrivateKey} privateKey - An instance of PrivateKey\n * @returns {String} A base64 encoded compact signature\n */\n\n\nMessage.prototype.sign = function sign(privateKey) {\n  var signature = this._sign(privateKey);\n\n  return signature.toCompact().toString('base64');\n};\n\nMessage.prototype._verify = function _verify(publicKey, signature) {\n  $.checkArgument(publicKey instanceof PublicKey, 'First argument should be an instance of PublicKey');\n  $.checkArgument(signature instanceof Signature, 'Second argument should be an instance of Signature');\n  var hash = this.magicHash();\n  var verified = ECDSA.verify(hash, signature, publicKey);\n\n  if (!verified) {\n    this.error = 'The signature was invalid';\n  }\n\n  return verified;\n};\n/**\n * Will return a boolean of the signature is valid for a given bitcoin address.\n * If it isn't the specific reason is accessible via the \"error\" member.\n *\n * @param {Address|String} bitcoinAddress - A bitcoin address\n * @param {String} signatureString - A base64 encoded compact signature\n * @returns {Boolean}\n */\n\n\nMessage.prototype.verify = function verify(bitcoinAddress, signatureString) {\n  $.checkArgument(bitcoinAddress);\n  $.checkArgument(signatureString && _.isString(signatureString));\n\n  if (_.isString(bitcoinAddress)) {\n    bitcoinAddress = Address.fromString(bitcoinAddress);\n  }\n\n  var signature = Signature.fromCompact(Buffer.from(signatureString, 'base64')); // recover the public key\n\n  var ecdsa = new ECDSA();\n  ecdsa.hashbuf = this.magicHash();\n  ecdsa.sig = signature;\n  var publicKey = ecdsa.toPublicKey();\n  var signatureAddress = Address.fromPublicKey(publicKey, bitcoinAddress.network); // check that the recovered address and specified address match\n\n  if (bitcoinAddress.toString() !== signatureAddress.toString()) {\n    this.error = 'The signature did not match the message digest';\n    return false;\n  }\n\n  return this._verify(publicKey, signature);\n};\n/**\n * Will return a public key string if the provided signature and the message digest is correct\n * If it isn't the specific reason is accessible via the \"error\" member.\n *\n * @param {Address|String} bitcoinAddress - A bitcoin address\n * @param {String} signatureString - A base64 encoded compact signature\n * @returns {String}\n */\n\n\nMessage.prototype.recoverPublicKey = function recoverPublicKey(bitcoinAddress, signatureString) {\n  $.checkArgument(bitcoinAddress);\n  $.checkArgument(signatureString && _.isString(signatureString));\n\n  if (_.isString(bitcoinAddress)) {\n    bitcoinAddress = Address.fromString(bitcoinAddress);\n  }\n\n  var signature = Signature.fromCompact(Buffer.from(signatureString, 'base64')); // recover the public key\n\n  var ecdsa = new ECDSA();\n  ecdsa.hashbuf = this.magicHash();\n  ecdsa.sig = signature;\n  var publicKey = ecdsa.toPublicKey();\n  var signatureAddress = Address.fromPublicKey(publicKey, bitcoinAddress.network); // check that the recovered address and specified address match\n\n  if (bitcoinAddress.toString() !== signatureAddress.toString()) {\n    this.error = 'The signature did not match the message digest';\n  }\n\n  return publicKey.toString();\n};\n/**\n * Instantiate a message from a message string\n *\n * @param {String} str - A string of the message\n * @returns {Message} A new instance of a Message\n */\n\n\nMessage.fromString = function (str) {\n  return new Message(str);\n};\n/**\n * Instantiate a message from JSON\n *\n * @param {String} json - An JSON string or Object with keys: message\n * @returns {Message} A new instance of a Message\n */\n\n\nMessage.fromJSON = function fromJSON(json) {\n  if (JSUtil.isValidJSON(json)) {\n    json = JSON.parse(json);\n  }\n\n  return new Message(json.message);\n};\n/**\n * @returns {Object} A plain object with the message information\n */\n\n\nMessage.prototype.toObject = function toObject() {\n  return {\n    message: this.message\n  };\n};\n/**\n * @returns {String} A JSON representation of the message information\n */\n\n\nMessage.prototype.toJSON = function toJSON() {\n  return JSON.stringify(this.toObject());\n};\n/**\n * Will return a the string representation of the message\n *\n * @returns {String} Message\n */\n\n\nMessage.prototype.toString = function () {\n  return this.message;\n};\n/**\n * Will return a string formatted for the console\n *\n * @returns {String} Message\n */\n\n\nMessage.prototype.inspect = function () {\n  return '<Message: ' + this.toString() + '>';\n};\n\nmodule.exports = Message;\n\nvar Script = require('./script');","map":{"version":3,"names":["_","require","PrivateKey","PublicKey","Address","BufferWriter","ECDSA","Signature","sha256sha256","JSUtil","$","Message","message","checkArgument","isString","MAGIC_BYTES","Buffer","from","prototype","magicHash","prefix1","varintBufNum","length","messageBuffer","prefix2","buf","concat","hash","_sign","privateKey","ecdsa","hashbuf","privkey","pubkey","toPublicKey","signRandomK","calci","sig","sign","signature","toCompact","toString","_verify","publicKey","verified","verify","error","bitcoinAddress","signatureString","fromString","fromCompact","signatureAddress","fromPublicKey","network","recoverPublicKey","str","fromJSON","json","isValidJSON","JSON","parse","toObject","toJSON","stringify","inspect","module","exports","Script"],"sources":["C:/Users/acer/node_modules/bitcore-lib/lib/message.js"],"sourcesContent":["'use strict';\n\nvar _ = require('lodash');\nvar PrivateKey = require('./privatekey');\nvar PublicKey = require('./publickey');\nvar Address = require('./address');\nvar BufferWriter = require('./encoding/bufferwriter');\nvar ECDSA = require('./crypto/ecdsa');\nvar Signature = require('./crypto/signature');\nvar sha256sha256 = require('./crypto/hash').sha256sha256;\nvar JSUtil = require('./util/js');\nvar $ = require('./util/preconditions');\n\nfunction Message(message) {\n  if (!(this instanceof Message)) {\n    return new Message(message);\n  }\n  $.checkArgument(_.isString(message), 'First argument should be a string');\n  this.message = message;\n\n  return this;\n}\n\nMessage.MAGIC_BYTES = Buffer.from('Bitcoin Signed Message:\\n');\n\nMessage.prototype.magicHash = function magicHash() {\n  var prefix1 = BufferWriter.varintBufNum(Message.MAGIC_BYTES.length);\n  var messageBuffer = Buffer.from(this.message);\n  var prefix2 = BufferWriter.varintBufNum(messageBuffer.length);\n  var buf = Buffer.concat([prefix1, Message.MAGIC_BYTES, prefix2, messageBuffer]);\n  var hash = sha256sha256(buf);\n  return hash;\n};\n\nMessage.prototype._sign = function _sign(privateKey) {\n  $.checkArgument(privateKey instanceof PrivateKey, 'First argument should be an instance of PrivateKey');\n  var hash = this.magicHash();\n  var ecdsa = new ECDSA();\n  ecdsa.hashbuf = hash;\n  ecdsa.privkey = privateKey;\n  ecdsa.pubkey = privateKey.toPublicKey();\n  ecdsa.signRandomK();\n  ecdsa.calci();\n  return ecdsa.sig;\n};\n\n/**\n * Will sign a message with a given bitcoin private key.\n *\n * @param {PrivateKey} privateKey - An instance of PrivateKey\n * @returns {String} A base64 encoded compact signature\n */\nMessage.prototype.sign = function sign(privateKey) {\n  var signature = this._sign(privateKey);\n  return signature.toCompact().toString('base64');\n};\n\nMessage.prototype._verify = function _verify(publicKey, signature) {\n  $.checkArgument(publicKey instanceof PublicKey, 'First argument should be an instance of PublicKey');\n  $.checkArgument(signature instanceof Signature, 'Second argument should be an instance of Signature');\n  var hash = this.magicHash();\n  var verified = ECDSA.verify(hash, signature, publicKey);\n  if (!verified) {\n    this.error = 'The signature was invalid';\n  }\n  return verified;\n};\n\n/**\n * Will return a boolean of the signature is valid for a given bitcoin address.\n * If it isn't the specific reason is accessible via the \"error\" member.\n *\n * @param {Address|String} bitcoinAddress - A bitcoin address\n * @param {String} signatureString - A base64 encoded compact signature\n * @returns {Boolean}\n */\nMessage.prototype.verify = function verify(bitcoinAddress, signatureString) {\n  $.checkArgument(bitcoinAddress);\n  $.checkArgument(signatureString && _.isString(signatureString));\n\n  if (_.isString(bitcoinAddress)) {\n    bitcoinAddress = Address.fromString(bitcoinAddress);\n  }\n  var signature = Signature.fromCompact(Buffer.from(signatureString, 'base64'));\n\n  // recover the public key\n  var ecdsa = new ECDSA();\n  ecdsa.hashbuf = this.magicHash();\n  ecdsa.sig = signature;\n  var publicKey = ecdsa.toPublicKey();\n\n  var signatureAddress = Address.fromPublicKey(publicKey, bitcoinAddress.network);\n\n  // check that the recovered address and specified address match\n  if (bitcoinAddress.toString() !== signatureAddress.toString()) {\n    this.error = 'The signature did not match the message digest';\n    return false;\n  }\n\n  return this._verify(publicKey, signature);\n};\n\n/**\n * Will return a public key string if the provided signature and the message digest is correct\n * If it isn't the specific reason is accessible via the \"error\" member.\n *\n * @param {Address|String} bitcoinAddress - A bitcoin address\n * @param {String} signatureString - A base64 encoded compact signature\n * @returns {String}\n */\nMessage.prototype.recoverPublicKey = function recoverPublicKey(bitcoinAddress, signatureString) {\n  $.checkArgument(bitcoinAddress);\n  $.checkArgument(signatureString && _.isString(signatureString));\n\n  if (_.isString(bitcoinAddress)) {\n    bitcoinAddress = Address.fromString(bitcoinAddress);\n  }\n  var signature = Signature.fromCompact(Buffer.from(signatureString, 'base64'));\n\n  // recover the public key\n  var ecdsa = new ECDSA();\n  ecdsa.hashbuf = this.magicHash();\n  ecdsa.sig = signature;\n  var publicKey = ecdsa.toPublicKey();\n\n  var signatureAddress = Address.fromPublicKey(publicKey, bitcoinAddress.network);\n\n  // check that the recovered address and specified address match\n  if (bitcoinAddress.toString() !== signatureAddress.toString()) {\n    this.error = 'The signature did not match the message digest';\n  }\n\n  return publicKey.toString();\n};\n\n/**\n * Instantiate a message from a message string\n *\n * @param {String} str - A string of the message\n * @returns {Message} A new instance of a Message\n */\nMessage.fromString = function(str) {\n  return new Message(str);\n};\n\n/**\n * Instantiate a message from JSON\n *\n * @param {String} json - An JSON string or Object with keys: message\n * @returns {Message} A new instance of a Message\n */\nMessage.fromJSON = function fromJSON(json) {\n  if (JSUtil.isValidJSON(json)) {\n    json = JSON.parse(json);\n  }\n  return new Message(json.message);\n};\n\n/**\n * @returns {Object} A plain object with the message information\n */\nMessage.prototype.toObject = function toObject() {\n  return {\n    message: this.message\n  };\n};\n\n/**\n * @returns {String} A JSON representation of the message information\n */\nMessage.prototype.toJSON = function toJSON() {\n  return JSON.stringify(this.toObject());\n};\n\n/**\n * Will return a the string representation of the message\n *\n * @returns {String} Message\n */\nMessage.prototype.toString = function() {\n  return this.message;\n};\n\n/**\n * Will return a string formatted for the console\n *\n * @returns {String} Message\n */\nMessage.prototype.inspect = function() {\n  return '<Message: ' + this.toString() + '>';\n};\n\nmodule.exports = Message;\n\nvar Script = require('./script');\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}