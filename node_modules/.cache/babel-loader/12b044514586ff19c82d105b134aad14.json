{"ast":null,"code":"var Buffer = require('safe-buffer').Buffer;\n\nvar base58check = require('bs58check');\n\nvar bcrypto = require('./crypto');\n\nvar createHmac = require('create-hmac');\n\nvar typeforce = require('typeforce');\n\nvar types = require('./types');\n\nvar NETWORKS = require('./networks');\n\nvar BigInteger = require('bigi');\n\nvar ECPair = require('./ecpair');\n\nvar ecurve = require('ecurve');\n\nvar curve = ecurve.getCurveByName('secp256k1');\n\nfunction HDNode(keyPair, chainCode) {\n  typeforce(types.tuple('ECPair', types.Buffer256bit), arguments);\n  if (!keyPair.compressed) throw new TypeError('BIP32 only allows compressed keyPairs');\n  this.keyPair = keyPair;\n  this.chainCode = chainCode;\n  this.depth = 0;\n  this.index = 0;\n  this.parentFingerprint = 0x00000000;\n}\n\nHDNode.HIGHEST_BIT = 0x80000000;\nHDNode.LENGTH = 78;\nHDNode.MASTER_SECRET = Buffer.from('Bitcoin seed', 'utf8');\n\nHDNode.fromSeedBuffer = function (seed, network) {\n  typeforce(types.tuple(types.Buffer, types.maybe(types.Network)), arguments);\n  if (seed.length < 16) throw new TypeError('Seed should be at least 128 bits');\n  if (seed.length > 64) throw new TypeError('Seed should be at most 512 bits');\n  var I = createHmac('sha512', HDNode.MASTER_SECRET).update(seed).digest();\n  var IL = I.slice(0, 32);\n  var IR = I.slice(32); // In case IL is 0 or >= n, the master key is invalid\n  // This is handled by the ECPair constructor\n\n  var pIL = BigInteger.fromBuffer(IL);\n  var keyPair = new ECPair(pIL, null, {\n    network: network\n  });\n  return new HDNode(keyPair, IR);\n};\n\nHDNode.fromSeedHex = function (hex, network) {\n  return HDNode.fromSeedBuffer(Buffer.from(hex, 'hex'), network);\n};\n\nHDNode.fromBase58 = function (string, networks) {\n  var buffer = base58check.decode(string);\n  if (buffer.length !== 78) throw new Error('Invalid buffer length'); // 4 bytes: version bytes\n\n  var version = buffer.readUInt32BE(0);\n  var network; // list of networks?\n\n  if (Array.isArray(networks)) {\n    network = networks.filter(function (x) {\n      return version === x.bip32.private || version === x.bip32.public;\n    }).pop();\n    if (!network) throw new Error('Unknown network version'); // otherwise, assume a network object (or default to bitcoin)\n  } else {\n    network = networks || NETWORKS.bitcoin;\n  }\n\n  if (version !== network.bip32.private && version !== network.bip32.public) throw new Error('Invalid network version'); // 1 byte: depth: 0x00 for master nodes, 0x01 for level-1 descendants, ...\n\n  var depth = buffer[4]; // 4 bytes: the fingerprint of the parent's key (0x00000000 if master key)\n\n  var parentFingerprint = buffer.readUInt32BE(5);\n\n  if (depth === 0) {\n    if (parentFingerprint !== 0x00000000) throw new Error('Invalid parent fingerprint');\n  } // 4 bytes: child number. This is the number i in xi = xpar/i, with xi the key being serialized.\n  // This is encoded in MSB order. (0x00000000 if master key)\n\n\n  var index = buffer.readUInt32BE(9);\n  if (depth === 0 && index !== 0) throw new Error('Invalid index'); // 32 bytes: the chain code\n\n  var chainCode = buffer.slice(13, 45);\n  var keyPair; // 33 bytes: private key data (0x00 + k)\n\n  if (version === network.bip32.private) {\n    if (buffer.readUInt8(45) !== 0x00) throw new Error('Invalid private key');\n    var d = BigInteger.fromBuffer(buffer.slice(46, 78));\n    keyPair = new ECPair(d, null, {\n      network: network\n    }); // 33 bytes: public key data (0x02 + X or 0x03 + X)\n  } else {\n    var Q = ecurve.Point.decodeFrom(curve, buffer.slice(45, 78)); // Q.compressed is assumed, if somehow this assumption is broken, `new HDNode` will throw\n    // Verify that the X coordinate in the public point corresponds to a point on the curve.\n    // If not, the extended public key is invalid.\n\n    curve.validate(Q);\n    keyPair = new ECPair(null, Q, {\n      network: network\n    });\n  }\n\n  var hd = new HDNode(keyPair, chainCode);\n  hd.depth = depth;\n  hd.index = index;\n  hd.parentFingerprint = parentFingerprint;\n  return hd;\n};\n\nHDNode.prototype.getAddress = function () {\n  return this.keyPair.getAddress();\n};\n\nHDNode.prototype.getIdentifier = function () {\n  return bcrypto.hash160(this.keyPair.getPublicKeyBuffer());\n};\n\nHDNode.prototype.getFingerprint = function () {\n  return this.getIdentifier().slice(0, 4);\n};\n\nHDNode.prototype.getNetwork = function () {\n  return this.keyPair.getNetwork();\n};\n\nHDNode.prototype.getPublicKeyBuffer = function () {\n  return this.keyPair.getPublicKeyBuffer();\n};\n\nHDNode.prototype.neutered = function () {\n  var neuteredKeyPair = new ECPair(null, this.keyPair.Q, {\n    network: this.keyPair.network\n  });\n  var neutered = new HDNode(neuteredKeyPair, this.chainCode);\n  neutered.depth = this.depth;\n  neutered.index = this.index;\n  neutered.parentFingerprint = this.parentFingerprint;\n  return neutered;\n};\n\nHDNode.prototype.sign = function (hash) {\n  return this.keyPair.sign(hash);\n};\n\nHDNode.prototype.verify = function (hash, signature) {\n  return this.keyPair.verify(hash, signature);\n};\n\nHDNode.prototype.toBase58 = function (__isPrivate) {\n  if (__isPrivate !== undefined) throw new TypeError('Unsupported argument in 2.0.0'); // Version\n\n  var network = this.keyPair.network;\n  var version = !this.isNeutered() ? network.bip32.private : network.bip32.public;\n  var buffer = Buffer.allocUnsafe(78); // 4 bytes: version bytes\n\n  buffer.writeUInt32BE(version, 0); // 1 byte: depth: 0x00 for master nodes, 0x01 for level-1 descendants, ....\n\n  buffer.writeUInt8(this.depth, 4); // 4 bytes: the fingerprint of the parent's key (0x00000000 if master key)\n\n  buffer.writeUInt32BE(this.parentFingerprint, 5); // 4 bytes: child number. This is the number i in xi = xpar/i, with xi the key being serialized.\n  // This is encoded in big endian. (0x00000000 if master key)\n\n  buffer.writeUInt32BE(this.index, 9); // 32 bytes: the chain code\n\n  this.chainCode.copy(buffer, 13); // 33 bytes: the public key or private key data\n\n  if (!this.isNeutered()) {\n    // 0x00 + k for private keys\n    buffer.writeUInt8(0, 45);\n    this.keyPair.d.toBuffer(32).copy(buffer, 46); // 33 bytes: the public key\n  } else {\n    // X9.62 encoding for public keys\n    this.keyPair.getPublicKeyBuffer().copy(buffer, 45);\n  }\n\n  return base58check.encode(buffer);\n}; // https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki#child-key-derivation-ckd-functions\n\n\nHDNode.prototype.derive = function (index) {\n  typeforce(types.UInt32, index);\n  var isHardened = index >= HDNode.HIGHEST_BIT;\n  var data = Buffer.allocUnsafe(37); // Hardened child\n\n  if (isHardened) {\n    if (this.isNeutered()) throw new TypeError('Could not derive hardened child key'); // data = 0x00 || ser256(kpar) || ser32(index)\n\n    data[0] = 0x00;\n    this.keyPair.d.toBuffer(32).copy(data, 1);\n    data.writeUInt32BE(index, 33); // Normal child\n  } else {\n    // data = serP(point(kpar)) || ser32(index)\n    //      = serP(Kpar) || ser32(index)\n    this.keyPair.getPublicKeyBuffer().copy(data, 0);\n    data.writeUInt32BE(index, 33);\n  }\n\n  var I = createHmac('sha512', this.chainCode).update(data).digest();\n  var IL = I.slice(0, 32);\n  var IR = I.slice(32);\n  var pIL = BigInteger.fromBuffer(IL); // In case parse256(IL) >= n, proceed with the next value for i\n\n  if (pIL.compareTo(curve.n) >= 0) {\n    return this.derive(index + 1);\n  } // Private parent key -> private child key\n\n\n  var derivedKeyPair;\n\n  if (!this.isNeutered()) {\n    // ki = parse256(IL) + kpar (mod n)\n    var ki = pIL.add(this.keyPair.d).mod(curve.n); // In case ki == 0, proceed with the next value for i\n\n    if (ki.signum() === 0) {\n      return this.derive(index + 1);\n    }\n\n    derivedKeyPair = new ECPair(ki, null, {\n      network: this.keyPair.network\n    }); // Public parent key -> public child key\n  } else {\n    // Ki = point(parse256(IL)) + Kpar\n    //    = G*IL + Kpar\n    var Ki = curve.G.multiply(pIL).add(this.keyPair.Q); // In case Ki is the point at infinity, proceed with the next value for i\n\n    if (curve.isInfinity(Ki)) {\n      return this.derive(index + 1);\n    }\n\n    derivedKeyPair = new ECPair(null, Ki, {\n      network: this.keyPair.network\n    });\n  }\n\n  var hd = new HDNode(derivedKeyPair, IR);\n  hd.depth = this.depth + 1;\n  hd.index = index;\n  hd.parentFingerprint = this.getFingerprint().readUInt32BE(0);\n  return hd;\n};\n\nHDNode.prototype.deriveHardened = function (index) {\n  typeforce(types.UInt31, index); // Only derives hardened private keys by default\n\n  return this.derive(index + HDNode.HIGHEST_BIT);\n}; // Private === not neutered\n// Public === neutered\n\n\nHDNode.prototype.isNeutered = function () {\n  return !this.keyPair.d;\n};\n\nHDNode.prototype.derivePath = function (path) {\n  typeforce(types.BIP32Path, path);\n  var splitPath = path.split('/');\n\n  if (splitPath[0] === 'm') {\n    if (this.parentFingerprint) {\n      throw new Error('Not a master node');\n    }\n\n    splitPath = splitPath.slice(1);\n  }\n\n  return splitPath.reduce(function (prevHd, indexStr) {\n    var index;\n\n    if (indexStr.slice(-1) === \"'\") {\n      index = parseInt(indexStr.slice(0, -1), 10);\n      return prevHd.deriveHardened(index);\n    } else {\n      index = parseInt(indexStr, 10);\n      return prevHd.derive(index);\n    }\n  }, this);\n};\n\nmodule.exports = HDNode;","map":{"version":3,"names":["Buffer","require","base58check","bcrypto","createHmac","typeforce","types","NETWORKS","BigInteger","ECPair","ecurve","curve","getCurveByName","HDNode","keyPair","chainCode","tuple","Buffer256bit","arguments","compressed","TypeError","depth","index","parentFingerprint","HIGHEST_BIT","LENGTH","MASTER_SECRET","from","fromSeedBuffer","seed","network","maybe","Network","length","I","update","digest","IL","slice","IR","pIL","fromBuffer","fromSeedHex","hex","fromBase58","string","networks","buffer","decode","Error","version","readUInt32BE","Array","isArray","filter","x","bip32","private","public","pop","bitcoin","readUInt8","d","Q","Point","decodeFrom","validate","hd","prototype","getAddress","getIdentifier","hash160","getPublicKeyBuffer","getFingerprint","getNetwork","neutered","neuteredKeyPair","sign","hash","verify","signature","toBase58","__isPrivate","undefined","isNeutered","allocUnsafe","writeUInt32BE","writeUInt8","copy","toBuffer","encode","derive","UInt32","isHardened","data","compareTo","n","derivedKeyPair","ki","add","mod","signum","Ki","G","multiply","isInfinity","deriveHardened","UInt31","derivePath","path","BIP32Path","splitPath","split","reduce","prevHd","indexStr","parseInt","module","exports"],"sources":["C:/Users/acer/node_modules/@tatumio/bitcoincashjs2-lib/src/hdnode.js"],"sourcesContent":["var Buffer = require('safe-buffer').Buffer\nvar base58check = require('bs58check')\nvar bcrypto = require('./crypto')\nvar createHmac = require('create-hmac')\nvar typeforce = require('typeforce')\nvar types = require('./types')\nvar NETWORKS = require('./networks')\n\nvar BigInteger = require('bigi')\nvar ECPair = require('./ecpair')\n\nvar ecurve = require('ecurve')\nvar curve = ecurve.getCurveByName('secp256k1')\n\nfunction HDNode (keyPair, chainCode) {\n  typeforce(types.tuple('ECPair', types.Buffer256bit), arguments)\n\n  if (!keyPair.compressed) throw new TypeError('BIP32 only allows compressed keyPairs')\n\n  this.keyPair = keyPair\n  this.chainCode = chainCode\n  this.depth = 0\n  this.index = 0\n  this.parentFingerprint = 0x00000000\n}\n\nHDNode.HIGHEST_BIT = 0x80000000\nHDNode.LENGTH = 78\nHDNode.MASTER_SECRET = Buffer.from('Bitcoin seed', 'utf8')\n\nHDNode.fromSeedBuffer = function (seed, network) {\n  typeforce(types.tuple(types.Buffer, types.maybe(types.Network)), arguments)\n\n  if (seed.length < 16) throw new TypeError('Seed should be at least 128 bits')\n  if (seed.length > 64) throw new TypeError('Seed should be at most 512 bits')\n\n  var I = createHmac('sha512', HDNode.MASTER_SECRET).update(seed).digest()\n  var IL = I.slice(0, 32)\n  var IR = I.slice(32)\n\n  // In case IL is 0 or >= n, the master key is invalid\n  // This is handled by the ECPair constructor\n  var pIL = BigInteger.fromBuffer(IL)\n  var keyPair = new ECPair(pIL, null, {\n    network: network\n  })\n\n  return new HDNode(keyPair, IR)\n}\n\nHDNode.fromSeedHex = function (hex, network) {\n  return HDNode.fromSeedBuffer(Buffer.from(hex, 'hex'), network)\n}\n\nHDNode.fromBase58 = function (string, networks) {\n  var buffer = base58check.decode(string)\n  if (buffer.length !== 78) throw new Error('Invalid buffer length')\n\n  // 4 bytes: version bytes\n  var version = buffer.readUInt32BE(0)\n  var network\n\n  // list of networks?\n  if (Array.isArray(networks)) {\n    network = networks.filter(function (x) {\n      return version === x.bip32.private ||\n             version === x.bip32.public\n    }).pop()\n\n    if (!network) throw new Error('Unknown network version')\n\n  // otherwise, assume a network object (or default to bitcoin)\n  } else {\n    network = networks || NETWORKS.bitcoin\n  }\n\n  if (version !== network.bip32.private &&\n    version !== network.bip32.public) throw new Error('Invalid network version')\n\n  // 1 byte: depth: 0x00 for master nodes, 0x01 for level-1 descendants, ...\n  var depth = buffer[4]\n\n  // 4 bytes: the fingerprint of the parent's key (0x00000000 if master key)\n  var parentFingerprint = buffer.readUInt32BE(5)\n  if (depth === 0) {\n    if (parentFingerprint !== 0x00000000) throw new Error('Invalid parent fingerprint')\n  }\n\n  // 4 bytes: child number. This is the number i in xi = xpar/i, with xi the key being serialized.\n  // This is encoded in MSB order. (0x00000000 if master key)\n  var index = buffer.readUInt32BE(9)\n  if (depth === 0 && index !== 0) throw new Error('Invalid index')\n\n  // 32 bytes: the chain code\n  var chainCode = buffer.slice(13, 45)\n  var keyPair\n\n  // 33 bytes: private key data (0x00 + k)\n  if (version === network.bip32.private) {\n    if (buffer.readUInt8(45) !== 0x00) throw new Error('Invalid private key')\n\n    var d = BigInteger.fromBuffer(buffer.slice(46, 78))\n    keyPair = new ECPair(d, null, { network: network })\n\n  // 33 bytes: public key data (0x02 + X or 0x03 + X)\n  } else {\n    var Q = ecurve.Point.decodeFrom(curve, buffer.slice(45, 78))\n    // Q.compressed is assumed, if somehow this assumption is broken, `new HDNode` will throw\n\n    // Verify that the X coordinate in the public point corresponds to a point on the curve.\n    // If not, the extended public key is invalid.\n    curve.validate(Q)\n\n    keyPair = new ECPair(null, Q, { network: network })\n  }\n\n  var hd = new HDNode(keyPair, chainCode)\n  hd.depth = depth\n  hd.index = index\n  hd.parentFingerprint = parentFingerprint\n\n  return hd\n}\n\nHDNode.prototype.getAddress = function () {\n  return this.keyPair.getAddress()\n}\n\nHDNode.prototype.getIdentifier = function () {\n  return bcrypto.hash160(this.keyPair.getPublicKeyBuffer())\n}\n\nHDNode.prototype.getFingerprint = function () {\n  return this.getIdentifier().slice(0, 4)\n}\n\nHDNode.prototype.getNetwork = function () {\n  return this.keyPair.getNetwork()\n}\n\nHDNode.prototype.getPublicKeyBuffer = function () {\n  return this.keyPair.getPublicKeyBuffer()\n}\n\nHDNode.prototype.neutered = function () {\n  var neuteredKeyPair = new ECPair(null, this.keyPair.Q, {\n    network: this.keyPair.network\n  })\n\n  var neutered = new HDNode(neuteredKeyPair, this.chainCode)\n  neutered.depth = this.depth\n  neutered.index = this.index\n  neutered.parentFingerprint = this.parentFingerprint\n\n  return neutered\n}\n\nHDNode.prototype.sign = function (hash) {\n  return this.keyPair.sign(hash)\n}\n\nHDNode.prototype.verify = function (hash, signature) {\n  return this.keyPair.verify(hash, signature)\n}\n\nHDNode.prototype.toBase58 = function (__isPrivate) {\n  if (__isPrivate !== undefined) throw new TypeError('Unsupported argument in 2.0.0')\n\n  // Version\n  var network = this.keyPair.network\n  var version = (!this.isNeutered()) ? network.bip32.private : network.bip32.public\n  var buffer = Buffer.allocUnsafe(78)\n\n  // 4 bytes: version bytes\n  buffer.writeUInt32BE(version, 0)\n\n  // 1 byte: depth: 0x00 for master nodes, 0x01 for level-1 descendants, ....\n  buffer.writeUInt8(this.depth, 4)\n\n  // 4 bytes: the fingerprint of the parent's key (0x00000000 if master key)\n  buffer.writeUInt32BE(this.parentFingerprint, 5)\n\n  // 4 bytes: child number. This is the number i in xi = xpar/i, with xi the key being serialized.\n  // This is encoded in big endian. (0x00000000 if master key)\n  buffer.writeUInt32BE(this.index, 9)\n\n  // 32 bytes: the chain code\n  this.chainCode.copy(buffer, 13)\n\n  // 33 bytes: the public key or private key data\n  if (!this.isNeutered()) {\n    // 0x00 + k for private keys\n    buffer.writeUInt8(0, 45)\n    this.keyPair.d.toBuffer(32).copy(buffer, 46)\n\n  // 33 bytes: the public key\n  } else {\n    // X9.62 encoding for public keys\n    this.keyPair.getPublicKeyBuffer().copy(buffer, 45)\n  }\n\n  return base58check.encode(buffer)\n}\n\n// https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki#child-key-derivation-ckd-functions\nHDNode.prototype.derive = function (index) {\n  typeforce(types.UInt32, index)\n\n  var isHardened = index >= HDNode.HIGHEST_BIT\n  var data = Buffer.allocUnsafe(37)\n\n  // Hardened child\n  if (isHardened) {\n    if (this.isNeutered()) throw new TypeError('Could not derive hardened child key')\n\n    // data = 0x00 || ser256(kpar) || ser32(index)\n    data[0] = 0x00\n    this.keyPair.d.toBuffer(32).copy(data, 1)\n    data.writeUInt32BE(index, 33)\n\n  // Normal child\n  } else {\n    // data = serP(point(kpar)) || ser32(index)\n    //      = serP(Kpar) || ser32(index)\n    this.keyPair.getPublicKeyBuffer().copy(data, 0)\n    data.writeUInt32BE(index, 33)\n  }\n\n  var I = createHmac('sha512', this.chainCode).update(data).digest()\n  var IL = I.slice(0, 32)\n  var IR = I.slice(32)\n\n  var pIL = BigInteger.fromBuffer(IL)\n\n  // In case parse256(IL) >= n, proceed with the next value for i\n  if (pIL.compareTo(curve.n) >= 0) {\n    return this.derive(index + 1)\n  }\n\n  // Private parent key -> private child key\n  var derivedKeyPair\n  if (!this.isNeutered()) {\n    // ki = parse256(IL) + kpar (mod n)\n    var ki = pIL.add(this.keyPair.d).mod(curve.n)\n\n    // In case ki == 0, proceed with the next value for i\n    if (ki.signum() === 0) {\n      return this.derive(index + 1)\n    }\n\n    derivedKeyPair = new ECPair(ki, null, {\n      network: this.keyPair.network\n    })\n\n  // Public parent key -> public child key\n  } else {\n    // Ki = point(parse256(IL)) + Kpar\n    //    = G*IL + Kpar\n    var Ki = curve.G.multiply(pIL).add(this.keyPair.Q)\n\n    // In case Ki is the point at infinity, proceed with the next value for i\n    if (curve.isInfinity(Ki)) {\n      return this.derive(index + 1)\n    }\n\n    derivedKeyPair = new ECPair(null, Ki, {\n      network: this.keyPair.network\n    })\n  }\n\n  var hd = new HDNode(derivedKeyPair, IR)\n  hd.depth = this.depth + 1\n  hd.index = index\n  hd.parentFingerprint = this.getFingerprint().readUInt32BE(0)\n\n  return hd\n}\n\nHDNode.prototype.deriveHardened = function (index) {\n  typeforce(types.UInt31, index)\n\n  // Only derives hardened private keys by default\n  return this.derive(index + HDNode.HIGHEST_BIT)\n}\n\n// Private === not neutered\n// Public === neutered\nHDNode.prototype.isNeutered = function () {\n  return !(this.keyPair.d)\n}\n\nHDNode.prototype.derivePath = function (path) {\n  typeforce(types.BIP32Path, path)\n\n  var splitPath = path.split('/')\n  if (splitPath[0] === 'm') {\n    if (this.parentFingerprint) {\n      throw new Error('Not a master node')\n    }\n\n    splitPath = splitPath.slice(1)\n  }\n\n  return splitPath.reduce(function (prevHd, indexStr) {\n    var index\n    if (indexStr.slice(-1) === \"'\") {\n      index = parseInt(indexStr.slice(0, -1), 10)\n      return prevHd.deriveHardened(index)\n    } else {\n      index = parseInt(indexStr, 10)\n      return prevHd.derive(index)\n    }\n  }, this)\n}\n\nmodule.exports = HDNode\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}