{"ast":null,"code":"'use strict';\n\nvar BN = require('bn.js');\n\nvar $ = require('../util/preconditions');\n\nvar _ = require('lodash');\n\nvar reversebuf = function (buf) {\n  var buf2 = Buffer.alloc(buf.length);\n\n  for (var i = 0; i < buf.length; i++) {\n    buf2[i] = buf[buf.length - 1 - i];\n  }\n\n  return buf2;\n};\n\nBN.Zero = new BN(0);\nBN.One = new BN(1);\nBN.Minus1 = new BN(-1);\n\nBN.fromNumber = function (n) {\n  $.checkArgument(_.isNumber(n));\n  return new BN(n);\n};\n\nBN.fromString = function (str, base) {\n  $.checkArgument(_.isString(str));\n  return new BN(str, base);\n};\n\nBN.fromBuffer = function (buf, opts) {\n  if (typeof opts !== 'undefined' && opts.endian === 'little') {\n    buf = reversebuf(buf);\n  }\n\n  var hex = buf.toString('hex');\n  var bn = new BN(hex, 16);\n  return bn;\n};\n/**\n * Instantiate a BigNumber from a \"signed magnitude buffer\"\n * (a buffer where the most significant bit represents the sign (0 = positive, -1 = negative))\n */\n\n\nBN.fromSM = function (buf, opts) {\n  var ret;\n\n  if (buf.length === 0) {\n    return BN.fromBuffer(Buffer.from([0]));\n  }\n\n  var endian = 'big';\n\n  if (opts) {\n    endian = opts.endian;\n  }\n\n  if (endian === 'little') {\n    buf = reversebuf(buf);\n  }\n\n  if (buf[0] & 0x80) {\n    buf[0] = buf[0] & 0x7f;\n    ret = BN.fromBuffer(buf);\n    ret.neg().copy(ret);\n  } else {\n    ret = BN.fromBuffer(buf);\n  }\n\n  return ret;\n};\n\nBN.prototype.toNumber = function () {\n  return parseInt(this.toString(10), 10);\n};\n\nBN.prototype.toBuffer = function (opts) {\n  var buf, hex;\n\n  if (opts && opts.size) {\n    hex = this.toString(16, 2);\n    var natlen = hex.length / 2;\n    buf = Buffer.from(hex, 'hex');\n\n    if (natlen === opts.size) {\n      buf = buf;\n    } else if (natlen > opts.size) {\n      buf = BN.trim(buf, natlen);\n    } else if (natlen < opts.size) {\n      buf = BN.pad(buf, natlen, opts.size);\n    }\n  } else {\n    hex = this.toString(16, 2);\n    buf = Buffer.from(hex, 'hex');\n  }\n\n  if (typeof opts !== 'undefined' && opts.endian === 'little') {\n    buf = reversebuf(buf);\n  }\n\n  return buf;\n};\n\nBN.prototype.toSMBigEndian = function () {\n  var buf;\n\n  if (this.cmp(BN.Zero) === -1) {\n    buf = this.neg().toBuffer();\n\n    if (buf[0] & 0x80) {\n      buf = Buffer.concat([Buffer.from([0x80]), buf]);\n    } else {\n      buf[0] = buf[0] | 0x80;\n    }\n  } else {\n    buf = this.toBuffer();\n\n    if (buf[0] & 0x80) {\n      buf = Buffer.concat([Buffer.from([0x00]), buf]);\n    }\n  }\n\n  if (buf.length === 1 & buf[0] === 0) {\n    buf = Buffer.from([]);\n  }\n\n  return buf;\n};\n\nBN.prototype.toSM = function (opts) {\n  var endian = opts ? opts.endian : 'big';\n  var buf = this.toSMBigEndian();\n\n  if (endian === 'little') {\n    buf = reversebuf(buf);\n  }\n\n  return buf;\n};\n/**\n * Create a BN from a \"ScriptNum\":\n * This is analogous to the constructor for CScriptNum in bitcoind. Many ops in\n * bitcoind's script interpreter use CScriptNum, which is not really a proper\n * bignum. Instead, an error is thrown if trying to input a number bigger than\n * 4 bytes. We copy that behavior here. A third argument, `size`, is provided to\n * extend the hard limit of 4 bytes, as some usages require more than 4 bytes.\n */\n\n\nBN.fromScriptNumBuffer = function (buf, fRequireMinimal, size) {\n  var nMaxNumSize = size || 4;\n  $.checkArgument(buf.length <= nMaxNumSize, new Error('script number overflow'));\n\n  if (fRequireMinimal && buf.length > 0) {\n    // Check that the number is encoded with the minimum possible\n    // number of bytes.\n    //\n    // If the most-significant-byte - excluding the sign bit - is zero\n    // then we're not minimal. Note how this test also rejects the\n    // negative-zero encoding, 0x80.\n    if ((buf[buf.length - 1] & 0x7f) === 0) {\n      // One exception: if there's more than one byte and the most\n      // significant bit of the second-most-significant-byte is set\n      // it would conflict with the sign bit. An example of this case\n      // is +-255, which encode to 0xff00 and 0xff80 respectively.\n      // (big-endian).\n      if (buf.length <= 1 || (buf[buf.length - 2] & 0x80) === 0) {\n        throw new Error('non-minimally encoded script number');\n      }\n    }\n  }\n\n  return BN.fromSM(buf, {\n    endian: 'little'\n  });\n};\n/**\n * The corollary to the above, with the notable exception that we do not throw\n * an error if the output is larger than four bytes. (Which can happen if\n * performing a numerical operation that results in an overflow to more than 4\n * bytes).\n */\n\n\nBN.prototype.toScriptNumBuffer = function () {\n  return this.toSM({\n    endian: 'little'\n  });\n};\n\nBN.prototype.gt = function (b) {\n  return this.cmp(b) > 0;\n};\n\nBN.prototype.gte = function (b) {\n  return this.cmp(b) >= 0;\n};\n\nBN.prototype.lt = function (b) {\n  return this.cmp(b) < 0;\n};\n\nBN.trim = function (buf, natlen) {\n  return buf.slice(natlen - buf.length, buf.length);\n};\n\nBN.pad = function (buf, natlen, size) {\n  var rbuf = Buffer.alloc(size);\n\n  for (var i = 0; i < buf.length; i++) {\n    rbuf[rbuf.length - 1 - i] = buf[buf.length - 1 - i];\n  }\n\n  for (i = 0; i < size - natlen; i++) {\n    rbuf[i] = 0;\n  }\n\n  return rbuf;\n};\n\nmodule.exports = BN;","map":{"version":3,"names":["BN","require","$","_","reversebuf","buf","buf2","Buffer","alloc","length","i","Zero","One","Minus1","fromNumber","n","checkArgument","isNumber","fromString","str","base","isString","fromBuffer","opts","endian","hex","toString","bn","fromSM","ret","from","neg","copy","prototype","toNumber","parseInt","toBuffer","size","natlen","trim","pad","toSMBigEndian","cmp","concat","toSM","fromScriptNumBuffer","fRequireMinimal","nMaxNumSize","Error","toScriptNumBuffer","gt","b","gte","lt","slice","rbuf","module","exports"],"sources":["C:/Users/acer/node_modules/bitcore-lib-doge/lib/crypto/bn.js"],"sourcesContent":["'use strict';\n\nvar BN = require('bn.js');\nvar $ = require('../util/preconditions');\nvar _ = require('lodash');\n\nvar reversebuf = function(buf) {\n  var buf2 = Buffer.alloc(buf.length);\n  for (var i = 0; i < buf.length; i++) {\n    buf2[i] = buf[buf.length - 1 - i];\n  }\n  return buf2;\n};\n\nBN.Zero = new BN(0);\nBN.One = new BN(1);\nBN.Minus1 = new BN(-1);\n\nBN.fromNumber = function(n) {\n  $.checkArgument(_.isNumber(n));\n  return new BN(n);\n};\n\nBN.fromString = function(str, base) {\n  $.checkArgument(_.isString(str));\n  return new BN(str, base);\n};\n\nBN.fromBuffer = function(buf, opts) {\n  if (typeof opts !== 'undefined' && opts.endian === 'little') {\n    buf = reversebuf(buf);\n  }\n  var hex = buf.toString('hex');\n  var bn = new BN(hex, 16);\n  return bn;\n};\n\n/**\n * Instantiate a BigNumber from a \"signed magnitude buffer\"\n * (a buffer where the most significant bit represents the sign (0 = positive, -1 = negative))\n */\nBN.fromSM = function(buf, opts) {\n  var ret;\n  if (buf.length === 0) {\n    return BN.fromBuffer(Buffer.from([0]));\n  }\n\n  var endian = 'big';\n  if (opts) {\n    endian = opts.endian;\n  }\n  if (endian === 'little') {\n    buf = reversebuf(buf);\n  }\n\n  if (buf[0] & 0x80) {\n    buf[0] = buf[0] & 0x7f;\n    ret = BN.fromBuffer(buf);\n    ret.neg().copy(ret);\n  } else {\n    ret = BN.fromBuffer(buf);\n  }\n  return ret;\n};\n\n\nBN.prototype.toNumber = function() {\n  return parseInt(this.toString(10), 10);\n};\n\nBN.prototype.toBuffer = function(opts) {\n  var buf, hex;\n  if (opts && opts.size) {\n    hex = this.toString(16, 2);\n    var natlen = hex.length / 2;\n    buf = Buffer.from(hex, 'hex');\n\n    if (natlen === opts.size) {\n      buf = buf;\n    } else if (natlen > opts.size) {\n      buf = BN.trim(buf, natlen);\n    } else if (natlen < opts.size) {\n      buf = BN.pad(buf, natlen, opts.size);\n    }\n  } else {\n    hex = this.toString(16, 2);\n    buf = Buffer.from(hex, 'hex');\n  }\n\n  if (typeof opts !== 'undefined' && opts.endian === 'little') {\n    buf = reversebuf(buf);\n  }\n\n  return buf;\n};\n\nBN.prototype.toSMBigEndian = function() {\n  var buf;\n  if (this.cmp(BN.Zero) === -1) {\n    buf = this.neg().toBuffer();\n    if (buf[0] & 0x80) {\n      buf = Buffer.concat([Buffer.from([0x80]), buf]);\n    } else {\n      buf[0] = buf[0] | 0x80;\n    }\n  } else {\n    buf = this.toBuffer();\n    if (buf[0] & 0x80) {\n      buf = Buffer.concat([Buffer.from([0x00]), buf]);\n    }\n  }\n\n  if (buf.length === 1 & buf[0] === 0) {\n    buf = Buffer.from([]);\n  }\n  return buf;\n};\n\nBN.prototype.toSM = function(opts) {\n  var endian = opts ? opts.endian : 'big';\n  var buf = this.toSMBigEndian();\n\n  if (endian === 'little') {\n    buf = reversebuf(buf);\n  }\n  return buf;\n};\n\n/**\n * Create a BN from a \"ScriptNum\":\n * This is analogous to the constructor for CScriptNum in bitcoind. Many ops in\n * bitcoind's script interpreter use CScriptNum, which is not really a proper\n * bignum. Instead, an error is thrown if trying to input a number bigger than\n * 4 bytes. We copy that behavior here. A third argument, `size`, is provided to\n * extend the hard limit of 4 bytes, as some usages require more than 4 bytes.\n */\nBN.fromScriptNumBuffer = function(buf, fRequireMinimal, size) {\n  var nMaxNumSize = size || 4;\n  $.checkArgument(buf.length <= nMaxNumSize, new Error('script number overflow'));\n  if (fRequireMinimal && buf.length > 0) {\n    // Check that the number is encoded with the minimum possible\n    // number of bytes.\n    //\n    // If the most-significant-byte - excluding the sign bit - is zero\n    // then we're not minimal. Note how this test also rejects the\n    // negative-zero encoding, 0x80.\n    if ((buf[buf.length - 1] & 0x7f) === 0) {\n      // One exception: if there's more than one byte and the most\n      // significant bit of the second-most-significant-byte is set\n      // it would conflict with the sign bit. An example of this case\n      // is +-255, which encode to 0xff00 and 0xff80 respectively.\n      // (big-endian).\n      if (buf.length <= 1 || (buf[buf.length - 2] & 0x80) === 0) {\n        throw new Error('non-minimally encoded script number');\n      }\n    }\n  }\n  return BN.fromSM(buf, {\n    endian: 'little'\n  });\n};\n\n/**\n * The corollary to the above, with the notable exception that we do not throw\n * an error if the output is larger than four bytes. (Which can happen if\n * performing a numerical operation that results in an overflow to more than 4\n * bytes).\n */\nBN.prototype.toScriptNumBuffer = function() {\n  return this.toSM({\n    endian: 'little'\n  });\n};\n\nBN.prototype.gt = function(b) {\n  return this.cmp(b) > 0;\n};\n\nBN.prototype.gte = function(b) {\n  return this.cmp(b) >= 0;\n};\n\nBN.prototype.lt = function(b) {\n  return this.cmp(b) < 0;\n};\n\nBN.trim = function(buf, natlen) {\n  return buf.slice(natlen - buf.length, buf.length);\n};\n\nBN.pad = function(buf, natlen, size) {\n  var rbuf = Buffer.alloc(size);\n  for (var i = 0; i < buf.length; i++) {\n    rbuf[rbuf.length - 1 - i] = buf[buf.length - 1 - i];\n  }\n  for (i = 0; i < size - natlen; i++) {\n    rbuf[i] = 0;\n  }\n  return rbuf;\n};\n\nmodule.exports = BN;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}