{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.accountPublicFromPublicGenerator = exports.derivePrivateKey = void 0;\n\nconst elliptic = require(\"elliptic\");\n\nconst Sha512_1 = require(\"./Sha512\");\n\nconst secp256k1 = elliptic.ec('secp256k1');\n\nfunction deriveScalar(bytes, discrim) {\n  const order = secp256k1.curve.n;\n\n  for (let i = 0; i <= 0xffffffff; i++) {\n    // We hash the bytes to find a 256 bit number, looping until we are sure it\n    // is less than the order of the curve.\n    const hasher = new Sha512_1.default().add(bytes); // If the optional discriminator index was passed in, update the hash.\n\n    if (discrim !== undefined) {\n      hasher.addU32(discrim);\n    }\n\n    hasher.addU32(i);\n    const key = hasher.first256BN();\n    /* istanbul ignore else */\n\n    if (key.cmpn(0) > 0 && key.cmp(order) < 0) {\n      return key;\n    }\n  } // This error is practically impossible to reach.\n  // The order of the curve describes the (finite) amount of points on the curve\n  // https://github.com/indutny/elliptic/blob/master/lib/elliptic/curves.js#L182\n  // How often will an (essentially) random number generated by Sha512 be larger than that?\n  // There's 2^32 chances (the for loop) to get a number smaller than the order,\n  // and it's rare that you'll even get past the first loop iteration.\n  // Note that in TypeScript we actually need the throw, otherwise the function signature would be BN | undefined\n  //\n\n  /* istanbul ignore next */\n\n\n  throw new Error('impossible unicorn ;)');\n}\n/**\n * @param seed - Bytes.\n * @param [opts] - Object.\n * @param [opts.accountIndex=0] - The account number to generate.\n * @param [opts.validator=false] - Generate root key-pair,\n *                                              as used by validators.\n * @returns {bn.js} 256 bit scalar value.\n *\n */\n\n\nfunction derivePrivateKey(seed) {\n  let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const root = opts.validator;\n  const order = secp256k1.curve.n; // This private generator represents the `root` private key, and is what's\n  // used by validators for signing when a keypair is generated from a seed.\n\n  const privateGen = deriveScalar(seed);\n\n  if (root) {\n    // As returned by validation_create for a given seed\n    return privateGen;\n  }\n\n  const publicGen = secp256k1.g.mul(privateGen); // A seed can generate many keypairs as a function of the seed and a uint32.\n  // Almost everyone just uses the first account, `0`.\n\n  const accountIndex = opts.accountIndex || 0;\n  return deriveScalar(publicGen.encodeCompressed(), accountIndex).add(privateGen).mod(order);\n}\n\nexports.derivePrivateKey = derivePrivateKey;\n\nfunction accountPublicFromPublicGenerator(publicGenBytes) {\n  const rootPubPoint = secp256k1.curve.decodePoint(publicGenBytes);\n  const scalar = deriveScalar(publicGenBytes, 0);\n  const point = secp256k1.g.mul(scalar);\n  const offset = rootPubPoint.add(point);\n  return offset.encodeCompressed();\n}\n\nexports.accountPublicFromPublicGenerator = accountPublicFromPublicGenerator;","map":{"version":3,"mappings":";;;;;;;AAAA;;AAEA;;AAEA,MAAMA,SAAS,GAAGC,QAAQ,CAACC,EAAT,CAAY,WAAZ,CAAlB;;AAEA,SAASC,YAAT,CAAsBC,KAAtB,EAA6BC,OAA7B,EAA6C;EAC3C,MAAMC,KAAK,GAAGN,SAAS,CAACO,KAAV,CAAgBC,CAA9B;;EACA,KAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,IAAI,UAArB,EAAiCA,CAAC,EAAlC,EAAsC;IACpC;IACA;IACA,MAAMC,MAAM,GAAG,IAAIC,gBAAJ,GAAaC,GAAb,CAAiBR,KAAjB,CAAf,CAHoC,CAIpC;;IACA,IAAIC,OAAO,KAAKQ,SAAhB,EAA2B;MACzBH,MAAM,CAACI,MAAP,CAAcT,OAAd;IACD;;IACDK,MAAM,CAACI,MAAP,CAAcL,CAAd;IACA,MAAMM,GAAG,GAAGL,MAAM,CAACM,UAAP,EAAZ;IACA;;IACA,IAAID,GAAG,CAACE,IAAJ,CAAS,CAAT,IAAc,CAAd,IAAmBF,GAAG,CAACG,GAAJ,CAAQZ,KAAR,IAAiB,CAAxC,EAA2C;MACzC,OAAOS,GAAP;IACD;EACF,CAhB0C,CAiB3C;EACA;EACA;EACA;EACA;EACA;EACA;EACA;;EACA;;;EACA,MAAM,IAAII,KAAJ,CAAU,uBAAV,CAAN;AACD;AAED;;;;;;;;;;;AASA,SAAgBC,gBAAhB,CACEC,IADF,EAKQ;EAAA,IAHNC,IAGM,uEAAF,EAAE;EAEN,MAAMC,IAAI,GAAGD,IAAI,CAACE,SAAlB;EACA,MAAMlB,KAAK,GAAGN,SAAS,CAACO,KAAV,CAAgBC,CAA9B,CAHM,CAKN;EACA;;EACA,MAAMiB,UAAU,GAAGtB,YAAY,CAACkB,IAAD,CAA/B;;EACA,IAAIE,IAAJ,EAAU;IACR;IACA,OAAOE,UAAP;EACD;;EACD,MAAMC,SAAS,GAAG1B,SAAS,CAAC2B,CAAV,CAAYC,GAAZ,CAAgBH,UAAhB,CAAlB,CAZM,CAaN;EACA;;EACA,MAAMI,YAAY,GAAGP,IAAI,CAACO,YAAL,IAAqB,CAA1C;EACA,OAAO1B,YAAY,CAACuB,SAAS,CAACI,gBAAV,EAAD,EAA+BD,YAA/B,CAAZ,CACJjB,GADI,CACAa,UADA,EAEJM,GAFI,CAEAzB,KAFA,CAAP;AAGD;;AAxBD0B;;AA0BA,SAAgBC,gCAAhB,CAAiDC,cAAjD,EAA+D;EAC7D,MAAMC,YAAY,GAAGnC,SAAS,CAACO,KAAV,CAAgB6B,WAAhB,CAA4BF,cAA5B,CAArB;EACA,MAAMG,MAAM,GAAGlC,YAAY,CAAC+B,cAAD,EAAiB,CAAjB,CAA3B;EACA,MAAMI,KAAK,GAAGtC,SAAS,CAAC2B,CAAV,CAAYC,GAAZ,CAAgBS,MAAhB,CAAd;EACA,MAAME,MAAM,GAAGJ,YAAY,CAACvB,GAAb,CAAiB0B,KAAjB,CAAf;EACA,OAAOC,MAAM,CAACT,gBAAP,EAAP;AACD;;AANDE","names":["secp256k1","elliptic","ec","deriveScalar","bytes","discrim","order","curve","n","i","hasher","Sha512_1","add","undefined","addU32","key","first256BN","cmpn","cmp","Error","derivePrivateKey","seed","opts","root","validator","privateGen","publicGen","g","mul","accountIndex","encodeCompressed","mod","exports","accountPublicFromPublicGenerator","publicGenBytes","rootPubPoint","decodePoint","scalar","point","offset"],"sourceRoot":"","sources":["../src/secp256k1.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}