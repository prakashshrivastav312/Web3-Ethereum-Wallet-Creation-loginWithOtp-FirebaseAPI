{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.NullType = exports.TypePlaceholder = exports.isTyped = exports.PrimitiveValue = exports.TypedValue = exports.CustomType = exports.PrimitiveType = exports.TypeCardinality = exports.Type = void 0;\n\nconst utils_1 = require(\"../../utils\");\n/**\n * An abstraction that represents a Type. Handles both generic and non-generic types.\n * Once instantiated as a Type, a generic type is \"closed\" (as opposed to \"open\").\n */\n\n\nclass Type {\n  constructor(name) {\n    let typeParameters = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n    let cardinality = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : TypeCardinality.fixed(1);\n    utils_1.guardValueIsSet(\"name\", name);\n    this.name = name;\n    this.typeParameters = typeParameters;\n    this.cardinality = cardinality;\n  }\n\n  getName() {\n    return this.name;\n  }\n\n  getTypeParameters() {\n    return this.typeParameters;\n  }\n\n  isGenericType() {\n    return this.typeParameters.length > 0;\n  }\n\n  getFirstTypeParameter() {\n    utils_1.guardTrue(this.typeParameters.length > 0, \"type parameters length > 0\");\n    return this.typeParameters[0];\n  }\n  /**\n   * Generates type expressions similar to elrond-wasm-rs.\n   */\n\n\n  toString() {\n    let typeParameters = this.getTypeParameters().map(type => type.toString()).join(\", \");\n    let typeParametersExpression = typeParameters ? `<${typeParameters}>` : \"\";\n    return `${this.name}${typeParametersExpression}`;\n  }\n\n  equals(other) {\n    return Type.equals(this, other);\n  }\n\n  static equals(a, b) {\n    // Workaround that seems to always work properly. Most probable reasons: \n    // - ES6 is quite strict about enumerating over the properties on an object.\n    // - toJSON() returns an object literal (most probably, this results in deterministic iteration in all browser implementations).\n    let aJson = JSON.stringify(a.toJSON());\n    let bJson = JSON.stringify(b.toJSON());\n    return aJson == bJson;\n  }\n\n  static equalsMany(a, b) {\n    return a.every((type, i) => type.equals(b[i]));\n  }\n\n  static isAssignableFromMany(a, b) {\n    return a.every((type, i) => type.isAssignableFrom(b[i]));\n  }\n\n  differs(other) {\n    return !this.equals(other);\n  }\n\n  valueOf() {\n    return this.name;\n  }\n  /**\n   * Inspired from: https://docs.microsoft.com/en-us/dotnet/api/system.type.isassignablefrom\n   * For (most) generics, type invariance is expected (assumed) - neither covariance, nor contravariance are supported yet (will be supported in a next release).\n   *\n   * One exception though: for {@link OptionType}, we simulate covariance for missing (not provided) values.\n   * For example, Option<u32> is assignable from Option<?>.\n   * For more details, see the implementation of {@link OptionType}.\n   *\n   * Also see:\n   *  - https://en.wikipedia.org/wiki/Covariance_and_contravariance_(computer_science)\n   *  - https://docs.microsoft.com/en-us/dotnet/standard/generics/covariance-and-contravariance\n   */\n\n\n  isAssignableFrom(type) {\n    let invariantTypeParameters = Type.equalsMany(this.getTypeParameters(), type.getTypeParameters());\n    return type instanceof this.constructor && invariantTypeParameters;\n  }\n  /**\n   * Converts the account to a pretty, plain JavaScript object.\n   */\n\n\n  toJSON() {\n    return {\n      name: this.name,\n      typeParameters: this.typeParameters.map(item => item.toJSON())\n    };\n  }\n\n  getCardinality() {\n    return this.cardinality;\n  }\n\n}\n\nexports.Type = Type;\n/**\n * TODO: Simplify this class, keep only what is needed.\n *\n * An abstraction for defining and operating with the cardinality of a (composite or simple) type.\n *\n * Simple types (the ones that are directly encodable) have a fixed cardinality: [lower = 1, upper = 1].\n * Composite types (not directly encodable) do not follow this constraint. For example:\n *  - VarArgs: [lower = 0, upper = *]\n *  - OptionalResult: [lower = 0, upper = 1]\n */\n\nclass TypeCardinality {\n  constructor(lowerBound, upperBound) {\n    this.lowerBound = lowerBound;\n    this.upperBound = upperBound;\n  }\n\n  static fixed(value) {\n    return new TypeCardinality(value, value);\n  }\n\n  static variable(value) {\n    return new TypeCardinality(0, value);\n  }\n\n  isSingular() {\n    return this.lowerBound == 1 && this.upperBound == 1;\n  }\n\n  isSingularOrNone() {\n    return this.lowerBound == 0 && this.upperBound == 1;\n  }\n\n  isComposite() {\n    return !this.isSingular();\n  }\n\n  isFixed() {\n    return this.lowerBound == this.upperBound;\n  }\n\n  getLowerBound() {\n    return this.lowerBound;\n  }\n\n  getUpperBound() {\n    return this.upperBound || TypeCardinality.MaxCardinality;\n  }\n\n}\n\nexports.TypeCardinality = TypeCardinality;\n/**\n * An arbitrarily chosen, reasonably large number.\n */\n\nTypeCardinality.MaxCardinality = 4096;\n\nclass PrimitiveType extends Type {\n  constructor(name) {\n    super(name);\n  }\n\n}\n\nexports.PrimitiveType = PrimitiveType;\n\nclass CustomType extends Type {}\n\nexports.CustomType = CustomType;\n\nclass TypedValue {\n  constructor(type) {\n    this.type = type;\n  }\n\n  getType() {\n    return this.type;\n  }\n\n}\n\nexports.TypedValue = TypedValue;\n\nclass PrimitiveValue extends TypedValue {\n  constructor(type) {\n    super(type);\n  }\n\n}\n\nexports.PrimitiveValue = PrimitiveValue;\n\nfunction isTyped(value) {\n  return value instanceof TypedValue;\n}\n\nexports.isTyped = isTyped;\n\nclass TypePlaceholder extends Type {\n  constructor() {\n    super(\"...\");\n  }\n\n}\n\nexports.TypePlaceholder = TypePlaceholder;\n\nclass NullType extends Type {\n  constructor() {\n    super(\"?\");\n  }\n\n}\n\nexports.NullType = NullType;","map":{"version":3,"mappings":"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","names":["Type","constructor","name","typeParameters","cardinality","TypeCardinality","fixed","utils_1","getName","getTypeParameters","isGenericType","length","getFirstTypeParameter","toString","map","type","join","typeParametersExpression","equals","other","a","b","aJson","JSON","stringify","toJSON","bJson","equalsMany","every","i","isAssignableFromMany","isAssignableFrom","differs","valueOf","invariantTypeParameters","item","getCardinality","exports","lowerBound","upperBound","value","variable","isSingular","isSingularOrNone","isComposite","isFixed","getLowerBound","getUpperBound","MaxCardinality","PrimitiveType","CustomType","TypedValue","getType","PrimitiveValue","isTyped","TypePlaceholder","NullType"],"sourceRoot":"","sources":["../../../src/smartcontracts/typesystem/types.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}