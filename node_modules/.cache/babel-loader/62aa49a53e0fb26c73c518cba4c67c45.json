{"ast":null,"code":"'use strict';\n\nvar helpers = require('./helpers');\n/** @type ValidatorResult */\n\n\nvar ValidatorResult = helpers.ValidatorResult;\n/** @type SchemaError */\n\nvar SchemaError = helpers.SchemaError;\nvar attribute = {};\nattribute.ignoreProperties = {\n  // informative properties\n  'id': true,\n  'default': true,\n  'description': true,\n  'title': true,\n  // arguments to other properties\n  'exclusiveMinimum': true,\n  'exclusiveMaximum': true,\n  'additionalItems': true,\n  // special-handled properties\n  '$schema': true,\n  '$ref': true,\n  'extends': true\n};\n/**\n * @name validators\n */\n\nvar validators = attribute.validators = {};\n/**\n * Validates whether the instance if of a certain type\n * @param instance\n * @param schema\n * @param options\n * @param ctx\n * @return {ValidatorResult|null}\n */\n\nvalidators.type = function validateType(instance, schema, options, ctx) {\n  // Ignore undefined instances\n  if (instance === undefined) {\n    return null;\n  }\n\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  var types = Array.isArray(schema.type) ? schema.type : [schema.type];\n\n  if (!types.some(this.testType.bind(this, instance, schema, options, ctx))) {\n    var list = types.map(function (v) {\n      return v.id && '<' + v.id + '>' || v + '';\n    });\n    result.addError({\n      name: 'type',\n      argument: list,\n      message: \"is not of a type(s) \" + list\n    });\n  }\n\n  return result;\n};\n\nfunction testSchema(instance, options, ctx, callback, schema) {\n  var res = this.validateSchema(instance, schema, options, ctx);\n\n  if (!res.valid && callback instanceof Function) {\n    callback(res);\n  }\n\n  return res.valid;\n}\n/**\n * Validates whether the instance matches some of the given schemas\n * @param instance\n * @param schema\n * @param options\n * @param ctx\n * @return {ValidatorResult|null}\n */\n\n\nvalidators.anyOf = function validateAnyOf(instance, schema, options, ctx) {\n  // Ignore undefined instances\n  if (instance === undefined) {\n    return null;\n  }\n\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  var inner = new ValidatorResult(instance, schema, options, ctx);\n\n  if (!Array.isArray(schema.anyOf)) {\n    throw new SchemaError(\"anyOf must be an array\");\n  }\n\n  if (!schema.anyOf.some(testSchema.bind(this, instance, options, ctx, function (res) {\n    inner.importErrors(res);\n  }))) {\n    var list = schema.anyOf.map(function (v, i) {\n      return v.id && '<' + v.id + '>' || v.title && JSON.stringify(v.title) || v['$ref'] && '<' + v['$ref'] + '>' || '[subschema ' + i + ']';\n    });\n\n    if (options.nestedErrors) {\n      result.importErrors(inner);\n    }\n\n    result.addError({\n      name: 'anyOf',\n      argument: list,\n      message: \"is not any of \" + list.join(',')\n    });\n  }\n\n  return result;\n};\n/**\n * Validates whether the instance matches every given schema\n * @param instance\n * @param schema\n * @param options\n * @param ctx\n * @return {String|null}\n */\n\n\nvalidators.allOf = function validateAllOf(instance, schema, options, ctx) {\n  // Ignore undefined instances\n  if (instance === undefined) {\n    return null;\n  }\n\n  if (!Array.isArray(schema.allOf)) {\n    throw new SchemaError(\"allOf must be an array\");\n  }\n\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  var self = this;\n  schema.allOf.forEach(function (v, i) {\n    var valid = self.validateSchema(instance, v, options, ctx);\n\n    if (!valid.valid) {\n      var msg = v.id && '<' + v.id + '>' || v.title && JSON.stringify(v.title) || v['$ref'] && '<' + v['$ref'] + '>' || '[subschema ' + i + ']';\n      result.addError({\n        name: 'allOf',\n        argument: {\n          id: msg,\n          length: valid.errors.length,\n          valid: valid\n        },\n        message: 'does not match allOf schema ' + msg + ' with ' + valid.errors.length + ' error[s]:'\n      });\n      result.importErrors(valid);\n    }\n  });\n  return result;\n};\n/**\n * Validates whether the instance matches exactly one of the given schemas\n * @param instance\n * @param schema\n * @param options\n * @param ctx\n * @return {String|null}\n */\n\n\nvalidators.oneOf = function validateOneOf(instance, schema, options, ctx) {\n  // Ignore undefined instances\n  if (instance === undefined) {\n    return null;\n  }\n\n  if (!Array.isArray(schema.oneOf)) {\n    throw new SchemaError(\"oneOf must be an array\");\n  }\n\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  var inner = new ValidatorResult(instance, schema, options, ctx);\n  var count = schema.oneOf.filter(testSchema.bind(this, instance, options, ctx, function (res) {\n    inner.importErrors(res);\n  })).length;\n  var list = schema.oneOf.map(function (v, i) {\n    return v.id && '<' + v.id + '>' || v.title && JSON.stringify(v.title) || v['$ref'] && '<' + v['$ref'] + '>' || '[subschema ' + i + ']';\n  });\n\n  if (count !== 1) {\n    if (options.nestedErrors) {\n      result.importErrors(inner);\n    }\n\n    result.addError({\n      name: 'oneOf',\n      argument: list,\n      message: \"is not exactly one from \" + list.join(',')\n    });\n  }\n\n  return result;\n};\n/**\n * Validates properties\n * @param instance\n * @param schema\n * @param options\n * @param ctx\n * @return {String|null|ValidatorResult}\n */\n\n\nvalidators.properties = function validateProperties(instance, schema, options, ctx) {\n  if (instance === undefined || !(instance instanceof Object)) return;\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  var properties = schema.properties || {};\n\n  for (var property in properties) {\n    if (typeof options.preValidateProperty == 'function') {\n      options.preValidateProperty(instance, property, properties[property], options, ctx);\n    }\n\n    var prop = (instance || undefined) && instance[property];\n    var res = this.validateSchema(prop, properties[property], options, ctx.makeChild(properties[property], property));\n    if (res.instance !== result.instance[property]) result.instance[property] = res.instance;\n    result.importErrors(res);\n  }\n\n  return result;\n};\n/**\n * Test a specific property within in instance against the additionalProperties schema attribute\n * This ignores properties with definitions in the properties schema attribute, but no other attributes.\n * If too many more types of property-existance tests pop up they may need their own class of tests (like `type` has)\n * @private\n * @return {boolean}\n */\n\n\nfunction testAdditionalProperty(instance, schema, options, ctx, property, result) {\n  if (schema.properties && schema.properties[property] !== undefined) {\n    return;\n  }\n\n  if (schema.additionalProperties === false) {\n    result.addError({\n      name: 'additionalProperties',\n      argument: property,\n      message: \"additionalProperty \" + JSON.stringify(property) + \" exists in instance when not allowed\"\n    });\n  } else {\n    var additionalProperties = schema.additionalProperties || {};\n\n    if (typeof options.preValidateProperty == 'function') {\n      options.preValidateProperty(instance, property, additionalProperties, options, ctx);\n    }\n\n    var res = this.validateSchema(instance[property], additionalProperties, options, ctx.makeChild(additionalProperties, property));\n    if (res.instance !== result.instance[property]) result.instance[property] = res.instance;\n    result.importErrors(res);\n  }\n}\n/**\n * Validates patternProperties\n * @param instance\n * @param schema\n * @param options\n * @param ctx\n * @return {String|null|ValidatorResult}\n */\n\n\nvalidators.patternProperties = function validatePatternProperties(instance, schema, options, ctx) {\n  if (instance === undefined) return;\n  if (!this.types.object(instance)) return;\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  var patternProperties = schema.patternProperties || {};\n\n  for (var property in instance) {\n    var test = true;\n\n    for (var pattern in patternProperties) {\n      var expr = new RegExp(pattern);\n\n      if (!expr.test(property)) {\n        continue;\n      }\n\n      test = false;\n\n      if (typeof options.preValidateProperty == 'function') {\n        options.preValidateProperty(instance, property, patternProperties[pattern], options, ctx);\n      }\n\n      var res = this.validateSchema(instance[property], patternProperties[pattern], options, ctx.makeChild(patternProperties[pattern], property));\n      if (res.instance !== result.instance[property]) result.instance[property] = res.instance;\n      result.importErrors(res);\n    }\n\n    if (test) {\n      testAdditionalProperty.call(this, instance, schema, options, ctx, property, result);\n    }\n  }\n\n  return result;\n};\n/**\n * Validates additionalProperties\n * @param instance\n * @param schema\n * @param options\n * @param ctx\n * @return {String|null|ValidatorResult}\n */\n\n\nvalidators.additionalProperties = function validateAdditionalProperties(instance, schema, options, ctx) {\n  if (instance === undefined) return;\n  if (!this.types.object(instance)) return; // if patternProperties is defined then we'll test when that one is called instead\n\n  if (schema.patternProperties) {\n    return null;\n  }\n\n  var result = new ValidatorResult(instance, schema, options, ctx);\n\n  for (var property in instance) {\n    testAdditionalProperty.call(this, instance, schema, options, ctx, property, result);\n  }\n\n  return result;\n};\n/**\n * Validates whether the instance value is at least of a certain length, when the instance value is a string.\n * @param instance\n * @param schema\n * @return {String|null}\n */\n\n\nvalidators.minProperties = function validateMinProperties(instance, schema, options, ctx) {\n  if (!instance || typeof instance !== 'object') {\n    return null;\n  }\n\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  var keys = Object.keys(instance);\n\n  if (!(keys.length >= schema.minProperties)) {\n    result.addError({\n      name: 'minProperties',\n      argument: schema.minProperties,\n      message: \"does not meet minimum property length of \" + schema.minProperties\n    });\n  }\n\n  return result;\n};\n/**\n * Validates whether the instance value is at most of a certain length, when the instance value is a string.\n * @param instance\n * @param schema\n * @return {String|null}\n */\n\n\nvalidators.maxProperties = function validateMaxProperties(instance, schema, options, ctx) {\n  if (!instance || typeof instance !== 'object') {\n    return null;\n  }\n\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  var keys = Object.keys(instance);\n\n  if (!(keys.length <= schema.maxProperties)) {\n    result.addError({\n      name: 'maxProperties',\n      argument: schema.maxProperties,\n      message: \"does not meet maximum property length of \" + schema.maxProperties\n    });\n  }\n\n  return result;\n};\n/**\n * Validates items when instance is an array\n * @param instance\n * @param schema\n * @param options\n * @param ctx\n * @return {String|null|ValidatorResult}\n */\n\n\nvalidators.items = function validateItems(instance, schema, options, ctx) {\n  if (!Array.isArray(instance)) {\n    return null;\n  }\n\n  var self = this;\n  var result = new ValidatorResult(instance, schema, options, ctx);\n\n  if (instance === undefined || !schema.items) {\n    return result;\n  }\n\n  instance.every(function (value, i) {\n    var items = Array.isArray(schema.items) ? schema.items[i] || schema.additionalItems : schema.items;\n\n    if (items === undefined) {\n      return true;\n    }\n\n    if (items === false) {\n      result.addError({\n        name: 'items',\n        message: \"additionalItems not permitted\"\n      });\n      return false;\n    }\n\n    var res = self.validateSchema(value, items, options, ctx.makeChild(items, i));\n    if (res.instance !== result.instance[i]) result.instance[i] = res.instance;\n    result.importErrors(res);\n    return true;\n  });\n  return result;\n};\n/**\n * Validates minimum and exclusiveMinimum when the type of the instance value is a number.\n * @param instance\n * @param schema\n * @return {String|null}\n */\n\n\nvalidators.minimum = function validateMinimum(instance, schema, options, ctx) {\n  if (typeof instance !== 'number') {\n    return null;\n  }\n\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  var valid = true;\n\n  if (schema.exclusiveMinimum && schema.exclusiveMinimum === true) {\n    valid = instance > schema.minimum;\n  } else {\n    valid = instance >= schema.minimum;\n  }\n\n  if (!valid) {\n    result.addError({\n      name: 'minimum',\n      argument: schema.minimum,\n      message: \"must have a minimum value of \" + schema.minimum\n    });\n  }\n\n  return result;\n};\n/**\n * Validates maximum and exclusiveMaximum when the type of the instance value is a number.\n * @param instance\n * @param schema\n * @return {String|null}\n */\n\n\nvalidators.maximum = function validateMaximum(instance, schema, options, ctx) {\n  if (typeof instance !== 'number') {\n    return null;\n  }\n\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  var valid;\n\n  if (schema.exclusiveMaximum && schema.exclusiveMaximum === true) {\n    valid = instance < schema.maximum;\n  } else {\n    valid = instance <= schema.maximum;\n  }\n\n  if (!valid) {\n    result.addError({\n      name: 'maximum',\n      argument: schema.maximum,\n      message: \"must have a maximum value of \" + schema.maximum\n    });\n  }\n\n  return result;\n};\n/**\n * Perform validation for multipleOf and divisibleBy, which are essentially the same.\n * @param instance\n * @param schema\n * @param validationType\n * @param errorMessage\n * @returns {String|null}\n */\n\n\nvar validateMultipleOfOrDivisbleBy = function validateMultipleOfOrDivisbleBy(instance, schema, options, ctx, validationType, errorMessage) {\n  if (typeof instance !== 'number') {\n    return null;\n  }\n\n  var validationArgument = schema[validationType];\n\n  if (validationArgument == 0) {\n    throw new SchemaError(validationType + \" cannot be zero\");\n  }\n\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  var instanceDecimals = helpers.getDecimalPlaces(instance);\n  var divisorDecimals = helpers.getDecimalPlaces(validationArgument);\n  var maxDecimals = Math.max(instanceDecimals, divisorDecimals);\n  var multiplier = Math.pow(10, maxDecimals);\n\n  if (Math.round(instance * multiplier) % Math.round(validationArgument * multiplier) !== 0) {\n    result.addError({\n      name: validationType,\n      argument: validationArgument,\n      message: errorMessage + JSON.stringify(validationArgument)\n    });\n  }\n\n  return result;\n};\n/**\n * Validates divisibleBy when the type of the instance value is a number.\n * @param instance\n * @param schema\n * @return {String|null}\n */\n\n\nvalidators.multipleOf = function validateMultipleOf(instance, schema, options, ctx) {\n  return validateMultipleOfOrDivisbleBy(instance, schema, options, ctx, \"multipleOf\", \"is not a multiple of (divisible by) \");\n};\n/**\n * Validates multipleOf when the type of the instance value is a number.\n * @param instance\n * @param schema\n * @return {String|null}\n */\n\n\nvalidators.divisibleBy = function validateDivisibleBy(instance, schema, options, ctx) {\n  return validateMultipleOfOrDivisbleBy(instance, schema, options, ctx, \"divisibleBy\", \"is not divisible by (multiple of) \");\n};\n/**\n * Validates whether the instance value is present.\n * @param instance\n * @param schema\n * @return {String|null}\n */\n\n\nvalidators.required = function validateRequired(instance, schema, options, ctx) {\n  var result = new ValidatorResult(instance, schema, options, ctx);\n\n  if (instance === undefined && schema.required === true) {\n    // A boolean form is implemented for reverse-compatability with schemas written against older drafts\n    result.addError({\n      name: 'required',\n      message: \"is required\"\n    });\n  } else if (instance && typeof instance === 'object' && Array.isArray(schema.required)) {\n    schema.required.forEach(function (n) {\n      if (instance[n] === undefined) {\n        result.addError({\n          name: 'required',\n          argument: n,\n          message: \"requires property \" + JSON.stringify(n)\n        });\n      }\n    });\n  }\n\n  return result;\n};\n/**\n * Validates whether the instance value matches the regular expression, when the instance value is a string.\n * @param instance\n * @param schema\n * @return {String|null}\n */\n\n\nvalidators.pattern = function validatePattern(instance, schema, options, ctx) {\n  if (typeof instance !== 'string') {\n    return null;\n  }\n\n  var result = new ValidatorResult(instance, schema, options, ctx);\n\n  if (!instance.match(schema.pattern)) {\n    result.addError({\n      name: 'pattern',\n      argument: schema.pattern,\n      message: \"does not match pattern \" + JSON.stringify(schema.pattern)\n    });\n  }\n\n  return result;\n};\n/**\n * Validates whether the instance value is of a certain defined format or a custom\n * format.\n * The following formats are supported for string types:\n *   - date-time\n *   - date\n *   - time\n *   - ip-address\n *   - ipv6\n *   - uri\n *   - color\n *   - host-name\n *   - alpha\n *   - alpha-numeric\n *   - utc-millisec\n * @param instance\n * @param schema\n * @param [options]\n * @param [ctx]\n * @return {String|null}\n */\n\n\nvalidators.format = function validateFormat(instance, schema, options, ctx) {\n  var result = new ValidatorResult(instance, schema, options, ctx);\n\n  if (!result.disableFormat && !helpers.isFormat(instance, schema.format, this)) {\n    result.addError({\n      name: 'format',\n      argument: schema.format,\n      message: \"does not conform to the \" + JSON.stringify(schema.format) + \" format\"\n    });\n  }\n\n  return result;\n};\n/**\n * Validates whether the instance value is at least of a certain length, when the instance value is a string.\n * @param instance\n * @param schema\n * @return {String|null}\n */\n\n\nvalidators.minLength = function validateMinLength(instance, schema, options, ctx) {\n  if (!(typeof instance === 'string')) {\n    return null;\n  }\n\n  var result = new ValidatorResult(instance, schema, options, ctx);\n\n  if (!(instance.length >= schema.minLength)) {\n    result.addError({\n      name: 'minLength',\n      argument: schema.minLength,\n      message: \"does not meet minimum length of \" + schema.minLength\n    });\n  }\n\n  return result;\n};\n/**\n * Validates whether the instance value is at most of a certain length, when the instance value is a string.\n * @param instance\n * @param schema\n * @return {String|null}\n */\n\n\nvalidators.maxLength = function validateMaxLength(instance, schema, options, ctx) {\n  if (!(typeof instance === 'string')) {\n    return null;\n  }\n\n  var result = new ValidatorResult(instance, schema, options, ctx);\n\n  if (!(instance.length <= schema.maxLength)) {\n    result.addError({\n      name: 'maxLength',\n      argument: schema.maxLength,\n      message: \"does not meet maximum length of \" + schema.maxLength\n    });\n  }\n\n  return result;\n};\n/**\n * Validates whether instance contains at least a minimum number of items, when the instance is an Array.\n * @param instance\n * @param schema\n * @return {String|null}\n */\n\n\nvalidators.minItems = function validateMinItems(instance, schema, options, ctx) {\n  if (!Array.isArray(instance)) {\n    return null;\n  }\n\n  var result = new ValidatorResult(instance, schema, options, ctx);\n\n  if (!(instance.length >= schema.minItems)) {\n    result.addError({\n      name: 'minItems',\n      argument: schema.minItems,\n      message: \"does not meet minimum length of \" + schema.minItems\n    });\n  }\n\n  return result;\n};\n/**\n * Validates whether instance contains no more than a maximum number of items, when the instance is an Array.\n * @param instance\n * @param schema\n * @return {String|null}\n */\n\n\nvalidators.maxItems = function validateMaxItems(instance, schema, options, ctx) {\n  if (!Array.isArray(instance)) {\n    return null;\n  }\n\n  var result = new ValidatorResult(instance, schema, options, ctx);\n\n  if (!(instance.length <= schema.maxItems)) {\n    result.addError({\n      name: 'maxItems',\n      argument: schema.maxItems,\n      message: \"does not meet maximum length of \" + schema.maxItems\n    });\n  }\n\n  return result;\n};\n/**\n * Validates that every item in an instance array is unique, when instance is an array\n * @param instance\n * @param schema\n * @param options\n * @param ctx\n * @return {String|null|ValidatorResult}\n */\n\n\nvalidators.uniqueItems = function validateUniqueItems(instance, schema, options, ctx) {\n  var result = new ValidatorResult(instance, schema, options, ctx);\n\n  if (!Array.isArray(instance)) {\n    return result;\n  }\n\n  function testArrays(v, i, a) {\n    for (var j = i + 1; j < a.length; j++) if (helpers.deepCompareStrict(v, a[j])) {\n      return false;\n    }\n\n    return true;\n  }\n\n  if (!instance.every(testArrays)) {\n    result.addError({\n      name: 'uniqueItems',\n      message: \"contains duplicate item\"\n    });\n  }\n\n  return result;\n};\n/**\n * Deep compares arrays for duplicates\n * @param v\n * @param i\n * @param a\n * @private\n * @return {boolean}\n */\n\n\nfunction testArrays(v, i, a) {\n  var j,\n      len = a.length;\n\n  for (j = i + 1, len; j < len; j++) {\n    if (helpers.deepCompareStrict(v, a[j])) {\n      return false;\n    }\n  }\n\n  return true;\n}\n/**\n * Validates whether there are no duplicates, when the instance is an Array.\n * @param instance\n * @return {String|null}\n */\n\n\nvalidators.uniqueItems = function validateUniqueItems(instance, schema, options, ctx) {\n  if (!Array.isArray(instance)) {\n    return null;\n  }\n\n  var result = new ValidatorResult(instance, schema, options, ctx);\n\n  if (!instance.every(testArrays)) {\n    result.addError({\n      name: 'uniqueItems',\n      message: \"contains duplicate item\"\n    });\n  }\n\n  return result;\n};\n/**\n * Validate for the presence of dependency properties, if the instance is an object.\n * @param instance\n * @param schema\n * @param options\n * @param ctx\n * @return {null|ValidatorResult}\n */\n\n\nvalidators.dependencies = function validateDependencies(instance, schema, options, ctx) {\n  if (!instance || typeof instance != 'object') {\n    return null;\n  }\n\n  var result = new ValidatorResult(instance, schema, options, ctx);\n\n  for (var property in schema.dependencies) {\n    if (instance[property] === undefined) {\n      continue;\n    }\n\n    var dep = schema.dependencies[property];\n    var childContext = ctx.makeChild(dep, property);\n\n    if (typeof dep == 'string') {\n      dep = [dep];\n    }\n\n    if (Array.isArray(dep)) {\n      dep.forEach(function (prop) {\n        if (instance[prop] === undefined) {\n          result.addError({\n            // FIXME there's two different \"dependencies\" errors here with slightly different outputs\n            // Can we make these the same? Or should we create different error types?\n            name: 'dependencies',\n            argument: childContext.propertyPath,\n            message: \"property \" + prop + \" not found, required by \" + childContext.propertyPath\n          });\n        }\n      });\n    } else {\n      var res = this.validateSchema(instance, dep, options, childContext);\n      if (result.instance !== res.instance) result.instance = res.instance;\n\n      if (res && res.errors.length) {\n        result.addError({\n          name: 'dependencies',\n          argument: childContext.propertyPath,\n          message: \"does not meet dependency required by \" + childContext.propertyPath\n        });\n        result.importErrors(res);\n      }\n    }\n  }\n\n  return result;\n};\n/**\n * Validates whether the instance value is one of the enumerated values.\n *\n * @param instance\n * @param schema\n * @return {ValidatorResult|null}\n */\n\n\nvalidators['enum'] = function validateEnum(instance, schema, options, ctx) {\n  if (!Array.isArray(schema['enum'])) {\n    throw new SchemaError(\"enum expects an array\", schema);\n  }\n\n  if (instance === undefined) {\n    return null;\n  }\n\n  var result = new ValidatorResult(instance, schema, options, ctx);\n\n  if (!schema['enum'].some(helpers.deepCompareStrict.bind(null, instance))) {\n    result.addError({\n      name: 'enum',\n      argument: schema['enum'],\n      message: \"is not one of enum values: \" + schema['enum'].join(',')\n    });\n  }\n\n  return result;\n};\n/**\n * Validates whether the instance exactly matches a given value\n *\n * @param instance\n * @param schema\n * @return {ValidatorResult|null}\n */\n\n\nvalidators['const'] = function validateEnum(instance, schema, options, ctx) {\n  var result = new ValidatorResult(instance, schema, options, ctx);\n\n  if (!helpers.deepCompareStrict(schema['const'], instance)) {\n    result.addError({\n      name: 'const',\n      argument: schema['const'],\n      message: \"does not exactly match expected constant: \" + schema['const']\n    });\n  }\n\n  return result;\n};\n/**\n * Validates whether the instance if of a prohibited type.\n * @param instance\n * @param schema\n * @param options\n * @param ctx\n * @return {null|ValidatorResult}\n */\n\n\nvalidators.not = validators.disallow = function validateNot(instance, schema, options, ctx) {\n  var self = this;\n  if (instance === undefined) return null;\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  var notTypes = schema.not || schema.disallow;\n  if (!notTypes) return null;\n  if (!Array.isArray(notTypes)) notTypes = [notTypes];\n  notTypes.forEach(function (type) {\n    if (self.testType(instance, schema, options, ctx, type)) {\n      var schemaId = type && type.id && '<' + type.id + '>' || type;\n      result.addError({\n        name: 'not',\n        argument: schemaId,\n        message: \"is of prohibited type \" + schemaId\n      });\n    }\n  });\n  return result;\n};\n\nmodule.exports = attribute;","map":{"version":3,"names":["helpers","require","ValidatorResult","SchemaError","attribute","ignoreProperties","validators","type","validateType","instance","schema","options","ctx","undefined","result","types","Array","isArray","some","testType","bind","list","map","v","id","addError","name","argument","message","testSchema","callback","res","validateSchema","valid","Function","anyOf","validateAnyOf","inner","importErrors","i","title","JSON","stringify","nestedErrors","join","allOf","validateAllOf","self","forEach","msg","length","errors","oneOf","validateOneOf","count","filter","properties","validateProperties","Object","property","preValidateProperty","prop","makeChild","testAdditionalProperty","additionalProperties","patternProperties","validatePatternProperties","object","test","pattern","expr","RegExp","call","validateAdditionalProperties","minProperties","validateMinProperties","keys","maxProperties","validateMaxProperties","items","validateItems","every","value","additionalItems","minimum","validateMinimum","exclusiveMinimum","maximum","validateMaximum","exclusiveMaximum","validateMultipleOfOrDivisbleBy","validationType","errorMessage","validationArgument","instanceDecimals","getDecimalPlaces","divisorDecimals","maxDecimals","Math","max","multiplier","pow","round","multipleOf","validateMultipleOf","divisibleBy","validateDivisibleBy","required","validateRequired","n","validatePattern","match","format","validateFormat","disableFormat","isFormat","minLength","validateMinLength","maxLength","validateMaxLength","minItems","validateMinItems","maxItems","validateMaxItems","uniqueItems","validateUniqueItems","testArrays","a","j","deepCompareStrict","len","dependencies","validateDependencies","dep","childContext","propertyPath","validateEnum","not","disallow","validateNot","notTypes","schemaId","module","exports"],"sources":["C:/Users/acer/node_modules/jsonschema/lib/attribute.js"],"sourcesContent":["'use strict';\n\nvar helpers = require('./helpers');\n\n/** @type ValidatorResult */\nvar ValidatorResult = helpers.ValidatorResult;\n/** @type SchemaError */\nvar SchemaError = helpers.SchemaError;\n\nvar attribute = {};\n\nattribute.ignoreProperties = {\n  // informative properties\n  'id': true,\n  'default': true,\n  'description': true,\n  'title': true,\n  // arguments to other properties\n  'exclusiveMinimum': true,\n  'exclusiveMaximum': true,\n  'additionalItems': true,\n  // special-handled properties\n  '$schema': true,\n  '$ref': true,\n  'extends': true\n};\n\n/**\n * @name validators\n */\nvar validators = attribute.validators = {};\n\n/**\n * Validates whether the instance if of a certain type\n * @param instance\n * @param schema\n * @param options\n * @param ctx\n * @return {ValidatorResult|null}\n */\nvalidators.type = function validateType (instance, schema, options, ctx) {\n  // Ignore undefined instances\n  if (instance === undefined) {\n    return null;\n  }\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  var types = Array.isArray(schema.type) ? schema.type : [schema.type];\n  if (!types.some(this.testType.bind(this, instance, schema, options, ctx))) {\n    var list = types.map(function (v) {\n      return v.id && ('<' + v.id + '>') || (v+'');\n    });\n    result.addError({\n      name: 'type',\n      argument: list,\n      message: \"is not of a type(s) \" + list,\n    });\n  }\n  return result;\n};\n\nfunction testSchema(instance, options, ctx, callback, schema){\n  var res = this.validateSchema(instance, schema, options, ctx);\n  if (! res.valid && callback instanceof Function) {\n    callback(res);\n  }\n  return res.valid;\n}\n\n/**\n * Validates whether the instance matches some of the given schemas\n * @param instance\n * @param schema\n * @param options\n * @param ctx\n * @return {ValidatorResult|null}\n */\nvalidators.anyOf = function validateAnyOf (instance, schema, options, ctx) {\n  // Ignore undefined instances\n  if (instance === undefined) {\n    return null;\n  }\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  var inner = new ValidatorResult(instance, schema, options, ctx);\n  if (!Array.isArray(schema.anyOf)){\n    throw new SchemaError(\"anyOf must be an array\");\n  }\n  if (!schema.anyOf.some(\n    testSchema.bind(\n      this, instance, options, ctx, function(res){inner.importErrors(res);}\n      ))) {\n    var list = schema.anyOf.map(function (v, i) {\n      return (v.id && ('<' + v.id + '>')) || (v.title && JSON.stringify(v.title)) || (v['$ref'] && ('<' + v['$ref'] + '>')) || '[subschema '+i+']';\n    });\n    if (options.nestedErrors) {\n      result.importErrors(inner);\n    }\n    result.addError({\n      name: 'anyOf',\n      argument: list,\n      message: \"is not any of \" + list.join(','),\n    });\n  }\n  return result;\n};\n\n/**\n * Validates whether the instance matches every given schema\n * @param instance\n * @param schema\n * @param options\n * @param ctx\n * @return {String|null}\n */\nvalidators.allOf = function validateAllOf (instance, schema, options, ctx) {\n  // Ignore undefined instances\n  if (instance === undefined) {\n    return null;\n  }\n  if (!Array.isArray(schema.allOf)){\n    throw new SchemaError(\"allOf must be an array\");\n  }\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  var self = this;\n  schema.allOf.forEach(function(v, i){\n    var valid = self.validateSchema(instance, v, options, ctx);\n    if(!valid.valid){\n      var msg = (v.id && ('<' + v.id + '>')) || (v.title && JSON.stringify(v.title)) || (v['$ref'] && ('<' + v['$ref'] + '>')) || '[subschema '+i+']';\n      result.addError({\n        name: 'allOf',\n        argument: { id: msg, length: valid.errors.length, valid: valid },\n        message: 'does not match allOf schema ' + msg + ' with ' + valid.errors.length + ' error[s]:',\n      });\n      result.importErrors(valid);\n    }\n  });\n  return result;\n};\n\n/**\n * Validates whether the instance matches exactly one of the given schemas\n * @param instance\n * @param schema\n * @param options\n * @param ctx\n * @return {String|null}\n */\nvalidators.oneOf = function validateOneOf (instance, schema, options, ctx) {\n  // Ignore undefined instances\n  if (instance === undefined) {\n    return null;\n  }\n  if (!Array.isArray(schema.oneOf)){\n    throw new SchemaError(\"oneOf must be an array\");\n  }\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  var inner = new ValidatorResult(instance, schema, options, ctx);\n  var count = schema.oneOf.filter(\n    testSchema.bind(\n      this, instance, options, ctx, function(res) {inner.importErrors(res);}\n      ) ).length;\n  var list = schema.oneOf.map(function (v, i) {\n    return (v.id && ('<' + v.id + '>')) || (v.title && JSON.stringify(v.title)) || (v['$ref'] && ('<' + v['$ref'] + '>')) || '[subschema '+i+']';\n  });\n  if (count!==1) {\n    if (options.nestedErrors) {\n      result.importErrors(inner);\n    }\n    result.addError({\n      name: 'oneOf',\n      argument: list,\n      message: \"is not exactly one from \" + list.join(','),\n    });\n  }\n  return result;\n};\n\n/**\n * Validates properties\n * @param instance\n * @param schema\n * @param options\n * @param ctx\n * @return {String|null|ValidatorResult}\n */\nvalidators.properties = function validateProperties (instance, schema, options, ctx) {\n  if(instance === undefined || !(instance instanceof Object)) return;\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  var properties = schema.properties || {};\n  for (var property in properties) {\n    if (typeof options.preValidateProperty == 'function') {\n      options.preValidateProperty(instance, property, properties[property], options, ctx);\n    }\n\n    var prop = (instance || undefined) && instance[property];\n    var res = this.validateSchema(prop, properties[property], options, ctx.makeChild(properties[property], property));\n    if(res.instance !== result.instance[property]) result.instance[property] = res.instance;\n    result.importErrors(res);\n  }\n  return result;\n};\n\n/**\n * Test a specific property within in instance against the additionalProperties schema attribute\n * This ignores properties with definitions in the properties schema attribute, but no other attributes.\n * If too many more types of property-existance tests pop up they may need their own class of tests (like `type` has)\n * @private\n * @return {boolean}\n */\nfunction testAdditionalProperty (instance, schema, options, ctx, property, result) {\n  if (schema.properties && schema.properties[property] !== undefined) {\n    return;\n  }\n  if (schema.additionalProperties === false) {\n    result.addError({\n      name: 'additionalProperties',\n      argument: property,\n      message: \"additionalProperty \" + JSON.stringify(property) + \" exists in instance when not allowed\",\n    });\n  } else {\n    var additionalProperties = schema.additionalProperties || {};\n\n    if (typeof options.preValidateProperty == 'function') {\n      options.preValidateProperty(instance, property, additionalProperties, options, ctx);\n    }\n\n    var res = this.validateSchema(instance[property], additionalProperties, options, ctx.makeChild(additionalProperties, property));\n    if(res.instance !== result.instance[property]) result.instance[property] = res.instance;\n    result.importErrors(res);\n  }\n}\n\n/**\n * Validates patternProperties\n * @param instance\n * @param schema\n * @param options\n * @param ctx\n * @return {String|null|ValidatorResult}\n */\nvalidators.patternProperties = function validatePatternProperties (instance, schema, options, ctx) {\n  if(instance === undefined) return;\n  if(!this.types.object(instance)) return;\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  var patternProperties = schema.patternProperties || {};\n\n  for (var property in instance) {\n    var test = true;\n    for (var pattern in patternProperties) {\n      var expr = new RegExp(pattern);\n      if (!expr.test(property)) {\n        continue;\n      }\n      test = false;\n\n      if (typeof options.preValidateProperty == 'function') {\n        options.preValidateProperty(instance, property, patternProperties[pattern], options, ctx);\n      }\n\n      var res = this.validateSchema(instance[property], patternProperties[pattern], options, ctx.makeChild(patternProperties[pattern], property));\n      if(res.instance !== result.instance[property]) result.instance[property] = res.instance;\n      result.importErrors(res);\n    }\n    if (test) {\n      testAdditionalProperty.call(this, instance, schema, options, ctx, property, result);\n    }\n  }\n\n  return result;\n};\n\n/**\n * Validates additionalProperties\n * @param instance\n * @param schema\n * @param options\n * @param ctx\n * @return {String|null|ValidatorResult}\n */\nvalidators.additionalProperties = function validateAdditionalProperties (instance, schema, options, ctx) {\n  if(instance === undefined) return;\n  if(!this.types.object(instance)) return;\n  // if patternProperties is defined then we'll test when that one is called instead\n  if (schema.patternProperties) {\n    return null;\n  }\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  for (var property in instance) {\n    testAdditionalProperty.call(this, instance, schema, options, ctx, property, result);\n  }\n  return result;\n};\n\n/**\n * Validates whether the instance value is at least of a certain length, when the instance value is a string.\n * @param instance\n * @param schema\n * @return {String|null}\n */\nvalidators.minProperties = function validateMinProperties (instance, schema, options, ctx) {\n  if (!instance || typeof instance !== 'object') {\n    return null;\n  }\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  var keys = Object.keys(instance);\n  if (!(keys.length >= schema.minProperties)) {\n    result.addError({\n      name: 'minProperties',\n      argument: schema.minProperties,\n      message: \"does not meet minimum property length of \" + schema.minProperties,\n    })\n  }\n  return result;\n};\n\n/**\n * Validates whether the instance value is at most of a certain length, when the instance value is a string.\n * @param instance\n * @param schema\n * @return {String|null}\n */\nvalidators.maxProperties = function validateMaxProperties (instance, schema, options, ctx) {\n  if (!instance || typeof instance !== 'object') {\n    return null;\n  }\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  var keys = Object.keys(instance);\n  if (!(keys.length <= schema.maxProperties)) {\n    result.addError({\n      name: 'maxProperties',\n      argument: schema.maxProperties,\n      message: \"does not meet maximum property length of \" + schema.maxProperties,\n    });\n  }\n  return result;\n};\n\n/**\n * Validates items when instance is an array\n * @param instance\n * @param schema\n * @param options\n * @param ctx\n * @return {String|null|ValidatorResult}\n */\nvalidators.items = function validateItems (instance, schema, options, ctx) {\n  if (!Array.isArray(instance)) {\n    return null;\n  }\n  var self = this;\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  if (instance === undefined || !schema.items) {\n    return result;\n  }\n  instance.every(function (value, i) {\n    var items = Array.isArray(schema.items) ? (schema.items[i] || schema.additionalItems) : schema.items;\n    if (items === undefined) {\n      return true;\n    }\n    if (items === false) {\n      result.addError({\n        name: 'items',\n        message: \"additionalItems not permitted\",\n      });\n      return false;\n    }\n    var res = self.validateSchema(value, items, options, ctx.makeChild(items, i));\n    if(res.instance !== result.instance[i]) result.instance[i] = res.instance;\n    result.importErrors(res);\n    return true;\n  });\n  return result;\n};\n\n/**\n * Validates minimum and exclusiveMinimum when the type of the instance value is a number.\n * @param instance\n * @param schema\n * @return {String|null}\n */\nvalidators.minimum = function validateMinimum (instance, schema, options, ctx) {\n  if (typeof instance !== 'number') {\n    return null;\n  }\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  var valid = true;\n  if (schema.exclusiveMinimum && schema.exclusiveMinimum === true) {\n    valid = instance > schema.minimum;\n  } else {\n    valid = instance >= schema.minimum;\n  }\n  if (!valid) {\n    result.addError({\n      name: 'minimum',\n      argument: schema.minimum,\n      message: \"must have a minimum value of \" + schema.minimum,\n    });\n  }\n  return result;\n};\n\n/**\n * Validates maximum and exclusiveMaximum when the type of the instance value is a number.\n * @param instance\n * @param schema\n * @return {String|null}\n */\nvalidators.maximum = function validateMaximum (instance, schema, options, ctx) {\n  if (typeof instance !== 'number') {\n    return null;\n  }\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  var valid;\n  if (schema.exclusiveMaximum && schema.exclusiveMaximum === true) {\n    valid = instance < schema.maximum;\n  } else {\n    valid = instance <= schema.maximum;\n  }\n  if (!valid) {\n    result.addError({\n      name: 'maximum',\n      argument: schema.maximum,\n      message: \"must have a maximum value of \" + schema.maximum,\n    });\n  }\n  return result;\n};\n\n/**\n * Perform validation for multipleOf and divisibleBy, which are essentially the same.\n * @param instance\n * @param schema\n * @param validationType\n * @param errorMessage\n * @returns {String|null}\n */\nvar validateMultipleOfOrDivisbleBy = function validateMultipleOfOrDivisbleBy (instance, schema, options, ctx, validationType, errorMessage) {\n  if (typeof instance !== 'number') {\n    return null;\n  }\n\n  var validationArgument = schema[validationType];\n  if (validationArgument == 0) {\n    throw new SchemaError(validationType + \" cannot be zero\");\n  }\n\n  var result = new ValidatorResult(instance, schema, options, ctx);\n\n  var instanceDecimals = helpers.getDecimalPlaces(instance);\n  var divisorDecimals = helpers.getDecimalPlaces(validationArgument);\n\n  var maxDecimals = Math.max(instanceDecimals , divisorDecimals);\n  var multiplier = Math.pow(10, maxDecimals);\n\n  if (Math.round(instance * multiplier) % Math.round(validationArgument * multiplier) !== 0) {\n    result.addError({\n      name: validationType,\n      argument:  validationArgument,\n      message: errorMessage + JSON.stringify(validationArgument)\n    });\n  }\n\n  return result;\n};\n\n/**\n * Validates divisibleBy when the type of the instance value is a number.\n * @param instance\n * @param schema\n * @return {String|null}\n */\nvalidators.multipleOf = function validateMultipleOf (instance, schema, options, ctx) {\n return validateMultipleOfOrDivisbleBy(instance, schema, options, ctx, \"multipleOf\", \"is not a multiple of (divisible by) \");\n};\n\n/**\n * Validates multipleOf when the type of the instance value is a number.\n * @param instance\n * @param schema\n * @return {String|null}\n */\nvalidators.divisibleBy = function validateDivisibleBy (instance, schema, options, ctx) {\n  return validateMultipleOfOrDivisbleBy(instance, schema, options, ctx, \"divisibleBy\", \"is not divisible by (multiple of) \");\n};\n\n/**\n * Validates whether the instance value is present.\n * @param instance\n * @param schema\n * @return {String|null}\n */\nvalidators.required = function validateRequired (instance, schema, options, ctx) {\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  if (instance === undefined && schema.required === true) {\n    // A boolean form is implemented for reverse-compatability with schemas written against older drafts\n    result.addError({\n      name: 'required',\n      message: \"is required\"\n    });\n  } else if (instance && typeof instance==='object' && Array.isArray(schema.required)) {\n    schema.required.forEach(function(n){\n      if(instance[n]===undefined){\n        result.addError({\n          name: 'required',\n          argument: n,\n          message: \"requires property \" + JSON.stringify(n),\n        });\n      }\n    });\n  }\n  return result;\n};\n\n/**\n * Validates whether the instance value matches the regular expression, when the instance value is a string.\n * @param instance\n * @param schema\n * @return {String|null}\n */\nvalidators.pattern = function validatePattern (instance, schema, options, ctx) {\n  if (typeof instance !== 'string') {\n    return null;\n  }\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  if (!instance.match(schema.pattern)) {\n    result.addError({\n      name: 'pattern',\n      argument: schema.pattern,\n      message: \"does not match pattern \" + JSON.stringify(schema.pattern),\n    });\n  }\n  return result;\n};\n\n/**\n * Validates whether the instance value is of a certain defined format or a custom\n * format.\n * The following formats are supported for string types:\n *   - date-time\n *   - date\n *   - time\n *   - ip-address\n *   - ipv6\n *   - uri\n *   - color\n *   - host-name\n *   - alpha\n *   - alpha-numeric\n *   - utc-millisec\n * @param instance\n * @param schema\n * @param [options]\n * @param [ctx]\n * @return {String|null}\n */\nvalidators.format = function validateFormat (instance, schema, options, ctx) {\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  if (!result.disableFormat && !helpers.isFormat(instance, schema.format, this)) {\n    result.addError({\n      name: 'format',\n      argument: schema.format,\n      message: \"does not conform to the \" + JSON.stringify(schema.format) + \" format\",\n    });\n  }\n  return result;\n};\n\n/**\n * Validates whether the instance value is at least of a certain length, when the instance value is a string.\n * @param instance\n * @param schema\n * @return {String|null}\n */\nvalidators.minLength = function validateMinLength (instance, schema, options, ctx) {\n  if (!(typeof instance === 'string')) {\n    return null;\n  }\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  if (!(instance.length >= schema.minLength)) {\n    result.addError({\n      name: 'minLength',\n      argument: schema.minLength,\n      message: \"does not meet minimum length of \" + schema.minLength,\n    });\n  }\n  return result;\n};\n\n/**\n * Validates whether the instance value is at most of a certain length, when the instance value is a string.\n * @param instance\n * @param schema\n * @return {String|null}\n */\nvalidators.maxLength = function validateMaxLength (instance, schema, options, ctx) {\n  if (!(typeof instance === 'string')) {\n    return null;\n  }\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  if (!(instance.length <= schema.maxLength)) {\n    result.addError({\n      name: 'maxLength',\n      argument: schema.maxLength,\n      message: \"does not meet maximum length of \" + schema.maxLength,\n    });\n  }\n  return result;\n};\n\n/**\n * Validates whether instance contains at least a minimum number of items, when the instance is an Array.\n * @param instance\n * @param schema\n * @return {String|null}\n */\nvalidators.minItems = function validateMinItems (instance, schema, options, ctx) {\n  if (!Array.isArray(instance)) {\n    return null;\n  }\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  if (!(instance.length >= schema.minItems)) {\n    result.addError({\n      name: 'minItems',\n      argument: schema.minItems,\n      message: \"does not meet minimum length of \" + schema.minItems,\n    });\n  }\n  return result;\n};\n\n/**\n * Validates whether instance contains no more than a maximum number of items, when the instance is an Array.\n * @param instance\n * @param schema\n * @return {String|null}\n */\nvalidators.maxItems = function validateMaxItems (instance, schema, options, ctx) {\n  if (!Array.isArray(instance)) {\n    return null;\n  }\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  if (!(instance.length <= schema.maxItems)) {\n    result.addError({\n      name: 'maxItems',\n      argument: schema.maxItems,\n      message: \"does not meet maximum length of \" + schema.maxItems,\n    });\n  }\n  return result;\n};\n\n/**\n * Validates that every item in an instance array is unique, when instance is an array\n * @param instance\n * @param schema\n * @param options\n * @param ctx\n * @return {String|null|ValidatorResult}\n */\nvalidators.uniqueItems = function validateUniqueItems (instance, schema, options, ctx) {\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  if (!Array.isArray(instance)) {\n    return result;\n  }\n  function testArrays (v, i, a) {\n    for (var j = i + 1; j < a.length; j++) if (helpers.deepCompareStrict(v, a[j])) {\n      return false;\n    }\n    return true;\n  }\n  if (!instance.every(testArrays)) {\n    result.addError({\n      name: 'uniqueItems',\n      message: \"contains duplicate item\",\n    });\n  }\n  return result;\n};\n\n/**\n * Deep compares arrays for duplicates\n * @param v\n * @param i\n * @param a\n * @private\n * @return {boolean}\n */\nfunction testArrays (v, i, a) {\n  var j, len = a.length;\n  for (j = i + 1, len; j < len; j++) {\n    if (helpers.deepCompareStrict(v, a[j])) {\n      return false;\n    }\n  }\n  return true;\n}\n\n/**\n * Validates whether there are no duplicates, when the instance is an Array.\n * @param instance\n * @return {String|null}\n */\nvalidators.uniqueItems = function validateUniqueItems (instance, schema, options, ctx) {\n  if (!Array.isArray(instance)) {\n    return null;\n  }\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  if (!instance.every(testArrays)) {\n    result.addError({\n      name: 'uniqueItems',\n      message: \"contains duplicate item\",\n    });\n  }\n  return result;\n};\n\n/**\n * Validate for the presence of dependency properties, if the instance is an object.\n * @param instance\n * @param schema\n * @param options\n * @param ctx\n * @return {null|ValidatorResult}\n */\nvalidators.dependencies = function validateDependencies (instance, schema, options, ctx) {\n  if (!instance || typeof instance != 'object') {\n    return null;\n  }\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  for (var property in schema.dependencies) {\n    if (instance[property] === undefined) {\n      continue;\n    }\n    var dep = schema.dependencies[property];\n    var childContext = ctx.makeChild(dep, property);\n    if (typeof dep == 'string') {\n      dep = [dep];\n    }\n    if (Array.isArray(dep)) {\n      dep.forEach(function (prop) {\n        if (instance[prop] === undefined) {\n          result.addError({\n            // FIXME there's two different \"dependencies\" errors here with slightly different outputs\n            // Can we make these the same? Or should we create different error types?\n            name: 'dependencies',\n            argument: childContext.propertyPath,\n            message: \"property \" + prop + \" not found, required by \" + childContext.propertyPath,\n          });\n        }\n      });\n    } else {\n      var res = this.validateSchema(instance, dep, options, childContext);\n      if(result.instance !== res.instance) result.instance = res.instance;\n      if (res && res.errors.length) {\n        result.addError({\n          name: 'dependencies',\n          argument: childContext.propertyPath,\n          message: \"does not meet dependency required by \" + childContext.propertyPath,\n        });\n        result.importErrors(res);\n      }\n    }\n  }\n  return result;\n};\n\n/**\n * Validates whether the instance value is one of the enumerated values.\n *\n * @param instance\n * @param schema\n * @return {ValidatorResult|null}\n */\nvalidators['enum'] = function validateEnum (instance, schema, options, ctx) {\n  if (!Array.isArray(schema['enum'])) {\n    throw new SchemaError(\"enum expects an array\", schema);\n  }\n  if (instance === undefined) {\n    return null;\n  }\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  if (!schema['enum'].some(helpers.deepCompareStrict.bind(null, instance))) {\n    result.addError({\n      name: 'enum',\n      argument: schema['enum'],\n      message: \"is not one of enum values: \" + schema['enum'].join(','),\n    });\n  }\n  return result;\n};\n\n/**\n * Validates whether the instance exactly matches a given value\n *\n * @param instance\n * @param schema\n * @return {ValidatorResult|null}\n */\nvalidators['const'] = function validateEnum (instance, schema, options, ctx) {\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  if (!helpers.deepCompareStrict(schema['const'], instance)) {\n    result.addError({\n      name: 'const',\n      argument: schema['const'],\n      message: \"does not exactly match expected constant: \" + schema['const'],\n    });\n  }\n  return result;\n};\n\n/**\n * Validates whether the instance if of a prohibited type.\n * @param instance\n * @param schema\n * @param options\n * @param ctx\n * @return {null|ValidatorResult}\n */\nvalidators.not = validators.disallow = function validateNot (instance, schema, options, ctx) {\n  var self = this;\n  if(instance===undefined) return null;\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  var notTypes = schema.not || schema.disallow;\n  if(!notTypes) return null;\n  if(!Array.isArray(notTypes)) notTypes=[notTypes];\n  notTypes.forEach(function (type) {\n    if (self.testType(instance, schema, options, ctx, type)) {\n      var schemaId = type && type.id && ('<' + type.id + '>') || type;\n      result.addError({\n        name: 'not',\n        argument: schemaId,\n        message: \"is of prohibited type \" + schemaId,\n      });\n    }\n  });\n  return result;\n};\n\nmodule.exports = attribute;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}