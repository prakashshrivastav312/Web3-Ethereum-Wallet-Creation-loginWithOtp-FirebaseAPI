{"ast":null,"code":"'use strict';\n\nvar BN = require('./bn');\n\nvar BufferUtil = require('../util/buffer');\n\nvar EC = require('elliptic').ec;\n\nvar ec = new EC('secp256k1');\nvar ecPoint = ec.curve.point.bind(ec.curve);\nvar ecPointFromX = ec.curve.pointFromX.bind(ec.curve);\n/**\n *\n * Instantiate a valid secp256k1 Point from the X and Y coordinates.\n *\n * @param {BN|String} x - The X coordinate\n * @param {BN|String} y - The Y coordinate\n * @link https://github.com/indutny/elliptic\n * @augments elliptic.curve.point\n * @throws {Error} A validation error if exists\n * @returns {Point} An instance of Point\n * @constructor\n */\n\nvar Point = function Point(x, y, isRed) {\n  try {\n    var point = ecPoint(x, y, isRed);\n  } catch (e) {\n    throw new Error('Invalid Point');\n  }\n\n  point.validate();\n  return point;\n};\n\nPoint.prototype = Object.getPrototypeOf(ec.curve.point());\n/**\n *\n * Instantiate a valid secp256k1 Point from only the X coordinate\n *\n * @param {boolean} odd - If the Y coordinate is odd\n * @param {BN|String} x - The X coordinate\n * @throws {Error} A validation error if exists\n * @returns {Point} An instance of Point\n */\n\nPoint.fromX = function fromX(odd, x) {\n  try {\n    var point = ecPointFromX(x, odd);\n  } catch (e) {\n    throw new Error('Invalid X');\n  }\n\n  point.validate();\n  return point;\n};\n/**\n *\n * Will return a secp256k1 ECDSA base point.\n *\n * @link https://en.bitcoin.it/wiki/Secp256k1\n * @returns {Point} An instance of the base point.\n */\n\n\nPoint.getG = function getG() {\n  return ec.curve.g;\n};\n/**\n *\n * Will return the max of range of valid private keys as governed by the secp256k1 ECDSA standard.\n *\n * @link https://en.bitcoin.it/wiki/Private_key#Range_of_valid_ECDSA_private_keys\n * @returns {BN} A BN instance of the number of points on the curve\n */\n\n\nPoint.getN = function getN() {\n  return new BN(ec.curve.n.toArray());\n};\n\nif (!Point.prototype._getX) Point.prototype._getX = Point.prototype.getX;\n/**\n *\n * Will return the X coordinate of the Point\n *\n * @returns {BN} A BN instance of the X coordinate\n */\n\nPoint.prototype.getX = function getX() {\n  return new BN(this._getX().toArray());\n};\n\nif (!Point.prototype._getY) Point.prototype._getY = Point.prototype.getY;\n/**\n *\n * Will return the Y coordinate of the Point\n *\n * @returns {BN} A BN instance of the Y coordinate\n */\n\nPoint.prototype.getY = function getY() {\n  return new BN(this._getY().toArray());\n};\n/**\n *\n * Will determine if the point is valid\n *\n * @link https://www.iacr.org/archive/pkc2003/25670211/25670211.pdf\n * @param {Point} An instance of Point\n * @throws {Error} A validation error if exists\n * @returns {Point} An instance of the same Point\n */\n\n\nPoint.prototype.validate = function validate() {\n  if (this.isInfinity()) {\n    throw new Error('Point cannot be equal to Infinity');\n  }\n\n  var p2;\n\n  try {\n    p2 = ecPointFromX(this.getX(), this.getY().isOdd());\n  } catch (e) {\n    throw new Error('Point does not lie on the curve');\n  }\n\n  if (p2.y.cmp(this.y) !== 0) {\n    throw new Error('Invalid y value for curve.');\n  } //todo: needs test case\n\n\n  if (!this.mul(Point.getN()).isInfinity()) {\n    throw new Error('Point times N must be infinity');\n  }\n\n  return this;\n};\n\nPoint.pointToCompressed = function pointToCompressed(point) {\n  var xbuf = point.getX().toBuffer({\n    size: 32\n  });\n  var ybuf = point.getY().toBuffer({\n    size: 32\n  });\n  var prefix;\n  var odd = ybuf[ybuf.length - 1] % 2;\n\n  if (odd) {\n    prefix = Buffer.from([0x03]);\n  } else {\n    prefix = Buffer.from([0x02]);\n  }\n\n  return BufferUtil.concat([prefix, xbuf]);\n};\n\nmodule.exports = Point;","map":{"version":3,"names":["BN","require","BufferUtil","EC","ec","ecPoint","curve","point","bind","ecPointFromX","pointFromX","Point","x","y","isRed","e","Error","validate","prototype","Object","getPrototypeOf","fromX","odd","getG","g","getN","n","toArray","_getX","getX","_getY","getY","isInfinity","p2","isOdd","cmp","mul","pointToCompressed","xbuf","toBuffer","size","ybuf","prefix","length","Buffer","from","concat","module","exports"],"sources":["C:/Users/acer/node_modules/bitcore-lib-ltc/lib/crypto/point.js"],"sourcesContent":["'use strict';\n\nvar BN = require('./bn');\nvar BufferUtil = require('../util/buffer');\n\nvar EC = require('elliptic').ec;\nvar ec = new EC('secp256k1');\nvar ecPoint = ec.curve.point.bind(ec.curve);\nvar ecPointFromX = ec.curve.pointFromX.bind(ec.curve);\n\n/**\n *\n * Instantiate a valid secp256k1 Point from the X and Y coordinates.\n *\n * @param {BN|String} x - The X coordinate\n * @param {BN|String} y - The Y coordinate\n * @link https://github.com/indutny/elliptic\n * @augments elliptic.curve.point\n * @throws {Error} A validation error if exists\n * @returns {Point} An instance of Point\n * @constructor\n */\nvar Point = function Point(x, y, isRed) {\n  try {\n    var point = ecPoint(x, y, isRed);\n  } catch (e) {\n    throw new Error('Invalid Point');\n  }\n  point.validate();\n  return point;\n};\n\nPoint.prototype = Object.getPrototypeOf(ec.curve.point());\n\n/**\n *\n * Instantiate a valid secp256k1 Point from only the X coordinate\n *\n * @param {boolean} odd - If the Y coordinate is odd\n * @param {BN|String} x - The X coordinate\n * @throws {Error} A validation error if exists\n * @returns {Point} An instance of Point\n */\nPoint.fromX = function fromX(odd, x){\n  try {\n    var point = ecPointFromX(x, odd);\n  } catch (e) {\n    throw new Error('Invalid X');\n  }\n  point.validate();\n  return point;\n};\n\n/**\n *\n * Will return a secp256k1 ECDSA base point.\n *\n * @link https://en.bitcoin.it/wiki/Secp256k1\n * @returns {Point} An instance of the base point.\n */\nPoint.getG = function getG() {\n  return ec.curve.g;\n};\n\n/**\n *\n * Will return the max of range of valid private keys as governed by the secp256k1 ECDSA standard.\n *\n * @link https://en.bitcoin.it/wiki/Private_key#Range_of_valid_ECDSA_private_keys\n * @returns {BN} A BN instance of the number of points on the curve\n */\nPoint.getN = function getN() {\n  return new BN(ec.curve.n.toArray());\n};\n\nif (!Point.prototype._getX)\nPoint.prototype._getX = Point.prototype.getX;\n\n/**\n *\n * Will return the X coordinate of the Point\n *\n * @returns {BN} A BN instance of the X coordinate\n */\nPoint.prototype.getX = function getX() {\n  return new BN(this._getX().toArray());\n};\n\nif (!Point.prototype._getY)\nPoint.prototype._getY = Point.prototype.getY;\n\n/**\n *\n * Will return the Y coordinate of the Point\n *\n * @returns {BN} A BN instance of the Y coordinate\n */\nPoint.prototype.getY = function getY() {\n  return new BN(this._getY().toArray());\n};\n\n/**\n *\n * Will determine if the point is valid\n *\n * @link https://www.iacr.org/archive/pkc2003/25670211/25670211.pdf\n * @param {Point} An instance of Point\n * @throws {Error} A validation error if exists\n * @returns {Point} An instance of the same Point\n */\nPoint.prototype.validate = function validate() {\n\n  if (this.isInfinity()){\n    throw new Error('Point cannot be equal to Infinity');\n  }\n\n  var p2;\n  try {\n    p2 = ecPointFromX(this.getX(), this.getY().isOdd());\n  } catch (e) {\n    throw new Error('Point does not lie on the curve');\n  }\n\n  if (p2.y.cmp(this.y) !== 0) {\n    throw new Error('Invalid y value for curve.');\n  }\n\n\n  //todo: needs test case\n  if (!(this.mul(Point.getN()).isInfinity())) {\n    throw new Error('Point times N must be infinity');\n  }\n\n  return this;\n\n};\n\nPoint.pointToCompressed = function pointToCompressed(point) {\n  var xbuf = point.getX().toBuffer({size: 32});\n  var ybuf = point.getY().toBuffer({size: 32});\n\n  var prefix;\n  var odd = ybuf[ybuf.length - 1] % 2;\n  if (odd) {\n    prefix = Buffer.from([0x03]);\n  } else {\n    prefix = Buffer.from([0x02]);\n  }\n  return BufferUtil.concat([prefix, xbuf]);\n};\n\nmodule.exports = Point;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}