{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n\nconst bip174_1 = require('bip174');\n\nconst varuint = require('bip174/src/lib/converter/varint');\n\nconst utils_1 = require('bip174/src/lib/utils');\n\nconst address_1 = require('./address');\n\nconst bufferutils_1 = require('./bufferutils');\n\nconst crypto_1 = require('./crypto');\n\nconst ecpair_1 = require('./ecpair');\n\nconst networks_1 = require('./networks');\n\nconst payments = require('./payments');\n\nconst bscript = require('./script');\n\nconst transaction_1 = require('./transaction');\n/**\n * These are the default arguments for a Psbt instance.\n */\n\n\nconst DEFAULT_OPTS = {\n  /**\n   * A bitcoinjs Network object. This is only used if you pass an `address`\n   * parameter to addOutput. Otherwise it is not needed and can be left default.\n   */\n  network: networks_1.bitcoin,\n\n  /**\n   * When extractTransaction is called, the fee rate is checked.\n   * THIS IS NOT TO BE RELIED ON.\n   * It is only here as a last ditch effort to prevent sending a 500 BTC fee etc.\n   */\n  maximumFeeRate: 5000\n};\n/**\n * Psbt class can parse and generate a PSBT binary based off of the BIP174.\n * There are 6 roles that this class fulfills. (Explained in BIP174)\n *\n * Creator: This can be done with `new Psbt()`\n * Updater: This can be done with `psbt.addInput(input)`, `psbt.addInputs(inputs)`,\n *   `psbt.addOutput(output)`, `psbt.addOutputs(outputs)` when you are looking to\n *   add new inputs and outputs to the PSBT, and `psbt.updateGlobal(itemObject)`,\n *   `psbt.updateInput(itemObject)`, `psbt.updateOutput(itemObject)`\n *   addInput requires hash: Buffer | string; and index: number; as attributes\n *   and can also include any attributes that are used in updateInput method.\n *   addOutput requires script: Buffer; and value: number; and likewise can include\n *   data for updateOutput.\n *   For a list of what attributes should be what types. Check the bip174 library.\n *   Also, check the integration tests for some examples of usage.\n * Signer: There are a few methods. signAllInputs and signAllInputsAsync, which will search all input\n *   information for your pubkey or pubkeyhash, and only sign inputs where it finds\n *   your info. Or you can explicitly sign a specific input with signInput and\n *   signInputAsync. For the async methods you can create a SignerAsync object\n *   and use something like a hardware wallet to sign with. (You must implement this)\n * Combiner: psbts can be combined easily with `psbt.combine(psbt2, psbt3, psbt4 ...)`\n *   the psbt calling combine will always have precedence when a conflict occurs.\n *   Combine checks if the internal bitcoin transaction is the same, so be sure that\n *   all sequences, version, locktime, etc. are the same before combining.\n * Input Finalizer: This role is fairly important. Not only does it need to construct\n *   the input scriptSigs and witnesses, but it SHOULD verify the signatures etc.\n *   Before running `psbt.finalizeAllInputs()` please run `psbt.validateSignaturesOfAllInputs()`\n *   Running any finalize method will delete any data in the input(s) that are no longer\n *   needed due to the finalized scripts containing the information.\n * Transaction Extractor: This role will perform some checks before returning a\n *   Transaction object. Such as fee rate not being larger than maximumFeeRate etc.\n */\n\nclass Psbt {\n  constructor() {\n    let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    let data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new bip174_1.Psbt(new PsbtTransaction());\n    this.data = data; // set defaults\n\n    this.opts = Object.assign({}, DEFAULT_OPTS, opts);\n    this.__CACHE = {\n      __NON_WITNESS_UTXO_TX_CACHE: [],\n      __NON_WITNESS_UTXO_BUF_CACHE: [],\n      __TX_IN_CACHE: {},\n      __TX: this.data.globalMap.unsignedTx.tx,\n      // Old TransactionBuilder behavior was to not confirm input values\n      // before signing. Even though we highly encourage people to get\n      // the full parent transaction to verify values, the ability to\n      // sign non-segwit inputs without the full transaction was often\n      // requested. So the only way to activate is to use @ts-ignore.\n      // We will disable exporting the Psbt when unsafe sign is active.\n      // because it is not BIP174 compliant.\n      __UNSAFE_SIGN_NONSEGWIT: false\n    };\n    if (this.data.inputs.length === 0) this.setVersion(2); // Make data hidden when enumerating\n\n    const dpew = (obj, attr, enumerable, writable) => Object.defineProperty(obj, attr, {\n      enumerable,\n      writable\n    });\n\n    dpew(this, '__CACHE', false, true);\n    dpew(this, 'opts', false, true);\n  }\n\n  static fromBase64(data) {\n    let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const buffer = Buffer.from(data, 'base64');\n    return this.fromBuffer(buffer, opts);\n  }\n\n  static fromHex(data) {\n    let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const buffer = Buffer.from(data, 'hex');\n    return this.fromBuffer(buffer, opts);\n  }\n\n  static fromBuffer(buffer) {\n    let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const psbtBase = bip174_1.Psbt.fromBuffer(buffer, transactionFromBuffer);\n    const psbt = new Psbt(opts, psbtBase);\n    checkTxForDupeIns(psbt.__CACHE.__TX, psbt.__CACHE);\n    return psbt;\n  }\n\n  get inputCount() {\n    return this.data.inputs.length;\n  }\n\n  get version() {\n    return this.__CACHE.__TX.version;\n  }\n\n  set version(version) {\n    this.setVersion(version);\n  }\n\n  get locktime() {\n    return this.__CACHE.__TX.locktime;\n  }\n\n  set locktime(locktime) {\n    this.setLocktime(locktime);\n  }\n\n  get txInputs() {\n    return this.__CACHE.__TX.ins.map(input => ({\n      hash: bufferutils_1.cloneBuffer(input.hash),\n      index: input.index,\n      sequence: input.sequence\n    }));\n  }\n\n  get txOutputs() {\n    return this.__CACHE.__TX.outs.map(output => {\n      let address;\n\n      try {\n        address = address_1.fromOutputScript(output.script, this.opts.network);\n      } catch (_) {}\n\n      return {\n        script: bufferutils_1.cloneBuffer(output.script),\n        value: output.value,\n        address\n      };\n    });\n  }\n\n  combine() {\n    for (var _len = arguments.length, those = new Array(_len), _key = 0; _key < _len; _key++) {\n      those[_key] = arguments[_key];\n    }\n\n    this.data.combine(...those.map(o => o.data));\n    return this;\n  }\n\n  clone() {\n    // TODO: more efficient cloning\n    const res = Psbt.fromBuffer(this.data.toBuffer());\n    res.opts = JSON.parse(JSON.stringify(this.opts));\n    return res;\n  }\n\n  setMaximumFeeRate(satoshiPerByte) {\n    check32Bit(satoshiPerByte); // 42.9 BTC per byte IS excessive... so throw\n\n    this.opts.maximumFeeRate = satoshiPerByte;\n  }\n\n  setVersion(version) {\n    check32Bit(version);\n    checkInputsForPartialSig(this.data.inputs, 'setVersion');\n    const c = this.__CACHE;\n    c.__TX.version = version;\n    c.__EXTRACTED_TX = undefined;\n    return this;\n  }\n\n  setLocktime(locktime) {\n    check32Bit(locktime);\n    checkInputsForPartialSig(this.data.inputs, 'setLocktime');\n    const c = this.__CACHE;\n    c.__TX.locktime = locktime;\n    c.__EXTRACTED_TX = undefined;\n    return this;\n  }\n\n  setInputSequence(inputIndex, sequence) {\n    check32Bit(sequence);\n    checkInputsForPartialSig(this.data.inputs, 'setInputSequence');\n    const c = this.__CACHE;\n\n    if (c.__TX.ins.length <= inputIndex) {\n      throw new Error('Input index too high');\n    }\n\n    c.__TX.ins[inputIndex].sequence = sequence;\n    c.__EXTRACTED_TX = undefined;\n    return this;\n  }\n\n  addInputs(inputDatas) {\n    inputDatas.forEach(inputData => this.addInput(inputData));\n    return this;\n  }\n\n  addInput(inputData) {\n    if (arguments.length > 1 || !inputData || inputData.hash === undefined || inputData.index === undefined) {\n      throw new Error(`Invalid arguments for Psbt.addInput. ` + `Requires single object with at least [hash] and [index]`);\n    }\n\n    checkInputsForPartialSig(this.data.inputs, 'addInput');\n    if (inputData.witnessScript) checkInvalidP2WSH(inputData.witnessScript);\n    const c = this.__CACHE;\n    this.data.addInput(inputData);\n    const txIn = c.__TX.ins[c.__TX.ins.length - 1];\n    checkTxInputCache(c, txIn);\n    const inputIndex = this.data.inputs.length - 1;\n    const input = this.data.inputs[inputIndex];\n\n    if (input.nonWitnessUtxo) {\n      addNonWitnessTxCache(this.__CACHE, input, inputIndex);\n    }\n\n    c.__FEE = undefined;\n    c.__FEE_RATE = undefined;\n    c.__EXTRACTED_TX = undefined;\n    return this;\n  }\n\n  addOutputs(outputDatas) {\n    outputDatas.forEach(outputData => this.addOutput(outputData));\n    return this;\n  }\n\n  addOutput(outputData) {\n    if (arguments.length > 1 || !outputData || outputData.value === undefined || outputData.address === undefined && outputData.script === undefined) {\n      throw new Error(`Invalid arguments for Psbt.addOutput. ` + `Requires single object with at least [script or address] and [value]`);\n    }\n\n    checkInputsForPartialSig(this.data.inputs, 'addOutput');\n    const {\n      address\n    } = outputData;\n\n    if (typeof address === 'string') {\n      const {\n        network\n      } = this.opts;\n      const script = address_1.toOutputScript(address, network);\n      outputData = Object.assign(outputData, {\n        script\n      });\n    }\n\n    const c = this.__CACHE;\n    this.data.addOutput(outputData);\n    c.__FEE = undefined;\n    c.__FEE_RATE = undefined;\n    c.__EXTRACTED_TX = undefined;\n    return this;\n  }\n\n  extractTransaction(disableFeeCheck) {\n    if (!this.data.inputs.every(isFinalized)) throw new Error('Not finalized');\n    const c = this.__CACHE;\n\n    if (!disableFeeCheck) {\n      checkFees(this, c, this.opts);\n    }\n\n    if (c.__EXTRACTED_TX) return c.__EXTRACTED_TX;\n\n    const tx = c.__TX.clone();\n\n    inputFinalizeGetAmts(this.data.inputs, tx, c, true);\n    return tx;\n  }\n\n  getFeeRate() {\n    return getTxCacheValue('__FEE_RATE', 'fee rate', this.data.inputs, this.__CACHE);\n  }\n\n  getFee() {\n    return getTxCacheValue('__FEE', 'fee', this.data.inputs, this.__CACHE);\n  }\n\n  finalizeAllInputs() {\n    utils_1.checkForInput(this.data.inputs, 0); // making sure we have at least one\n\n    range(this.data.inputs.length).forEach(idx => this.finalizeInput(idx));\n    return this;\n  }\n\n  finalizeInput(inputIndex) {\n    let finalScriptsFunc = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : getFinalScripts;\n    const input = utils_1.checkForInput(this.data.inputs, inputIndex);\n    const {\n      script,\n      isP2SH,\n      isP2WSH,\n      isSegwit\n    } = getScriptFromInput(inputIndex, input, this.__CACHE);\n    if (!script) throw new Error(`No script found for input #${inputIndex}`);\n    checkPartialSigSighashes(input);\n    const {\n      finalScriptSig,\n      finalScriptWitness\n    } = finalScriptsFunc(inputIndex, input, script, isSegwit, isP2SH, isP2WSH);\n    if (finalScriptSig) this.data.updateInput(inputIndex, {\n      finalScriptSig\n    });\n    if (finalScriptWitness) this.data.updateInput(inputIndex, {\n      finalScriptWitness\n    });\n    if (!finalScriptSig && !finalScriptWitness) throw new Error(`Unknown error finalizing input #${inputIndex}`);\n    this.data.clearFinalizedInput(inputIndex);\n    return this;\n  }\n\n  getInputType(inputIndex) {\n    const input = utils_1.checkForInput(this.data.inputs, inputIndex);\n    const script = getScriptFromUtxo(inputIndex, input, this.__CACHE);\n    const result = getMeaningfulScript(script, inputIndex, 'input', input.redeemScript || redeemFromFinalScriptSig(input.finalScriptSig), input.witnessScript || redeemFromFinalWitnessScript(input.finalScriptWitness));\n    const type = result.type === 'raw' ? '' : result.type + '-';\n    const mainType = classifyScript(result.meaningfulScript);\n    return type + mainType;\n  }\n\n  inputHasPubkey(inputIndex, pubkey) {\n    const input = utils_1.checkForInput(this.data.inputs, inputIndex);\n    return pubkeyInInput(pubkey, input, inputIndex, this.__CACHE);\n  }\n\n  inputHasHDKey(inputIndex, root) {\n    const input = utils_1.checkForInput(this.data.inputs, inputIndex);\n    const derivationIsMine = bip32DerivationIsMine(root);\n    return !!input.bip32Derivation && input.bip32Derivation.some(derivationIsMine);\n  }\n\n  outputHasPubkey(outputIndex, pubkey) {\n    const output = utils_1.checkForOutput(this.data.outputs, outputIndex);\n    return pubkeyInOutput(pubkey, output, outputIndex, this.__CACHE);\n  }\n\n  outputHasHDKey(outputIndex, root) {\n    const output = utils_1.checkForOutput(this.data.outputs, outputIndex);\n    const derivationIsMine = bip32DerivationIsMine(root);\n    return !!output.bip32Derivation && output.bip32Derivation.some(derivationIsMine);\n  }\n\n  validateSignaturesOfAllInputs() {\n    utils_1.checkForInput(this.data.inputs, 0); // making sure we have at least one\n\n    const results = range(this.data.inputs.length).map(idx => this.validateSignaturesOfInput(idx));\n    return results.reduce((final, res) => res === true && final, true);\n  }\n\n  validateSignaturesOfInput(inputIndex, pubkey) {\n    const input = this.data.inputs[inputIndex];\n    const partialSig = (input || {}).partialSig;\n    if (!input || !partialSig || partialSig.length < 1) throw new Error('No signatures to validate');\n    const mySigs = pubkey ? partialSig.filter(sig => sig.pubkey.equals(pubkey)) : partialSig;\n    if (mySigs.length < 1) throw new Error('No signatures for this pubkey');\n    const results = [];\n    let hashCache;\n    let scriptCache;\n    let sighashCache;\n\n    for (const pSig of mySigs) {\n      const sig = bscript.signature.decode(pSig.signature);\n      const {\n        hash,\n        script\n      } = sighashCache !== sig.hashType ? getHashForSig(inputIndex, Object.assign({}, input, {\n        sighashType: sig.hashType\n      }), this.__CACHE, true) : {\n        hash: hashCache,\n        script: scriptCache\n      };\n      sighashCache = sig.hashType;\n      hashCache = hash;\n      scriptCache = script;\n      checkScriptForPubkey(pSig.pubkey, script, 'verify');\n      const keypair = ecpair_1.fromPublicKey(pSig.pubkey);\n      results.push(keypair.verify(hash, sig.signature));\n    }\n\n    return results.every(res => res === true);\n  }\n\n  signAllInputsHD(hdKeyPair) {\n    let sighashTypes = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [transaction_1.Transaction.SIGHASH_ALL];\n\n    if (!hdKeyPair || !hdKeyPair.publicKey || !hdKeyPair.fingerprint) {\n      throw new Error('Need HDSigner to sign input');\n    }\n\n    const results = [];\n\n    for (const i of range(this.data.inputs.length)) {\n      try {\n        this.signInputHD(i, hdKeyPair, sighashTypes);\n        results.push(true);\n      } catch (err) {\n        results.push(false);\n      }\n    }\n\n    if (results.every(v => v === false)) {\n      throw new Error('No inputs were signed');\n    }\n\n    return this;\n  }\n\n  signAllInputsHDAsync(hdKeyPair) {\n    let sighashTypes = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [transaction_1.Transaction.SIGHASH_ALL];\n    return new Promise((resolve, reject) => {\n      if (!hdKeyPair || !hdKeyPair.publicKey || !hdKeyPair.fingerprint) {\n        return reject(new Error('Need HDSigner to sign input'));\n      }\n\n      const results = [];\n      const promises = [];\n\n      for (const i of range(this.data.inputs.length)) {\n        promises.push(this.signInputHDAsync(i, hdKeyPair, sighashTypes).then(() => {\n          results.push(true);\n        }, () => {\n          results.push(false);\n        }));\n      }\n\n      return Promise.all(promises).then(() => {\n        if (results.every(v => v === false)) {\n          return reject(new Error('No inputs were signed'));\n        }\n\n        resolve();\n      });\n    });\n  }\n\n  signInputHD(inputIndex, hdKeyPair) {\n    let sighashTypes = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [transaction_1.Transaction.SIGHASH_ALL];\n\n    if (!hdKeyPair || !hdKeyPair.publicKey || !hdKeyPair.fingerprint) {\n      throw new Error('Need HDSigner to sign input');\n    }\n\n    const signers = getSignersFromHD(inputIndex, this.data.inputs, hdKeyPair);\n    signers.forEach(signer => this.signInput(inputIndex, signer, sighashTypes));\n    return this;\n  }\n\n  signInputHDAsync(inputIndex, hdKeyPair) {\n    let sighashTypes = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [transaction_1.Transaction.SIGHASH_ALL];\n    return new Promise((resolve, reject) => {\n      if (!hdKeyPair || !hdKeyPair.publicKey || !hdKeyPair.fingerprint) {\n        return reject(new Error('Need HDSigner to sign input'));\n      }\n\n      const signers = getSignersFromHD(inputIndex, this.data.inputs, hdKeyPair);\n      const promises = signers.map(signer => this.signInputAsync(inputIndex, signer, sighashTypes));\n      return Promise.all(promises).then(() => {\n        resolve();\n      }).catch(reject);\n    });\n  }\n\n  signAllInputs(keyPair) {\n    let sighashTypes = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [transaction_1.Transaction.SIGHASH_ALL];\n    if (!keyPair || !keyPair.publicKey) throw new Error('Need Signer to sign input'); // TODO: Add a pubkey/pubkeyhash cache to each input\n    // as input information is added, then eventually\n    // optimize this method.\n\n    const results = [];\n\n    for (const i of range(this.data.inputs.length)) {\n      try {\n        this.signInput(i, keyPair, sighashTypes);\n        results.push(true);\n      } catch (err) {\n        results.push(false);\n      }\n    }\n\n    if (results.every(v => v === false)) {\n      throw new Error('No inputs were signed');\n    }\n\n    return this;\n  }\n\n  signAllInputsAsync(keyPair) {\n    let sighashTypes = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [transaction_1.Transaction.SIGHASH_ALL];\n    return new Promise((resolve, reject) => {\n      if (!keyPair || !keyPair.publicKey) return reject(new Error('Need Signer to sign input')); // TODO: Add a pubkey/pubkeyhash cache to each input\n      // as input information is added, then eventually\n      // optimize this method.\n\n      const results = [];\n      const promises = [];\n\n      for (const [i] of this.data.inputs.entries()) {\n        promises.push(this.signInputAsync(i, keyPair, sighashTypes).then(() => {\n          results.push(true);\n        }, () => {\n          results.push(false);\n        }));\n      }\n\n      return Promise.all(promises).then(() => {\n        if (results.every(v => v === false)) {\n          return reject(new Error('No inputs were signed'));\n        }\n\n        resolve();\n      });\n    });\n  }\n\n  signInput(inputIndex, keyPair) {\n    let sighashTypes = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [transaction_1.Transaction.SIGHASH_ALL];\n    if (!keyPair || !keyPair.publicKey) throw new Error('Need Signer to sign input');\n    const {\n      hash,\n      sighashType\n    } = getHashAndSighashType(this.data.inputs, inputIndex, keyPair.publicKey, this.__CACHE, sighashTypes);\n    const partialSig = [{\n      pubkey: keyPair.publicKey,\n      signature: bscript.signature.encode(keyPair.sign(hash), sighashType)\n    }];\n    this.data.updateInput(inputIndex, {\n      partialSig\n    });\n    return this;\n  }\n\n  signInputAsync(inputIndex, keyPair) {\n    let sighashTypes = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [transaction_1.Transaction.SIGHASH_ALL];\n    return Promise.resolve().then(() => {\n      if (!keyPair || !keyPair.publicKey) throw new Error('Need Signer to sign input');\n      const {\n        hash,\n        sighashType\n      } = getHashAndSighashType(this.data.inputs, inputIndex, keyPair.publicKey, this.__CACHE, sighashTypes);\n      return Promise.resolve(keyPair.sign(hash)).then(signature => {\n        const partialSig = [{\n          pubkey: keyPair.publicKey,\n          signature: bscript.signature.encode(signature, sighashType)\n        }];\n        this.data.updateInput(inputIndex, {\n          partialSig\n        });\n      });\n    });\n  }\n\n  toBuffer() {\n    checkCache(this.__CACHE);\n    return this.data.toBuffer();\n  }\n\n  toHex() {\n    checkCache(this.__CACHE);\n    return this.data.toHex();\n  }\n\n  toBase64() {\n    checkCache(this.__CACHE);\n    return this.data.toBase64();\n  }\n\n  updateGlobal(updateData) {\n    this.data.updateGlobal(updateData);\n    return this;\n  }\n\n  updateInput(inputIndex, updateData) {\n    if (updateData.witnessScript) checkInvalidP2WSH(updateData.witnessScript);\n    this.data.updateInput(inputIndex, updateData);\n\n    if (updateData.nonWitnessUtxo) {\n      addNonWitnessTxCache(this.__CACHE, this.data.inputs[inputIndex], inputIndex);\n    }\n\n    return this;\n  }\n\n  updateOutput(outputIndex, updateData) {\n    this.data.updateOutput(outputIndex, updateData);\n    return this;\n  }\n\n  addUnknownKeyValToGlobal(keyVal) {\n    this.data.addUnknownKeyValToGlobal(keyVal);\n    return this;\n  }\n\n  addUnknownKeyValToInput(inputIndex, keyVal) {\n    this.data.addUnknownKeyValToInput(inputIndex, keyVal);\n    return this;\n  }\n\n  addUnknownKeyValToOutput(outputIndex, keyVal) {\n    this.data.addUnknownKeyValToOutput(outputIndex, keyVal);\n    return this;\n  }\n\n  clearFinalizedInput(inputIndex) {\n    this.data.clearFinalizedInput(inputIndex);\n    return this;\n  }\n\n}\n\nexports.Psbt = Psbt;\n/**\n * This function is needed to pass to the bip174 base class's fromBuffer.\n * It takes the \"transaction buffer\" portion of the psbt buffer and returns a\n * Transaction (From the bip174 library) interface.\n */\n\nconst transactionFromBuffer = buffer => new PsbtTransaction(buffer);\n/**\n * This class implements the Transaction interface from bip174 library.\n * It contains a bitcoinjs-lib Transaction object.\n */\n\n\nclass PsbtTransaction {\n  constructor() {\n    let buffer = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : Buffer.from([2, 0, 0, 0, 0, 0, 0, 0, 0, 0]);\n    this.tx = transaction_1.Transaction.fromBuffer(buffer);\n    checkTxEmpty(this.tx);\n    Object.defineProperty(this, 'tx', {\n      enumerable: false,\n      writable: true\n    });\n  }\n\n  getInputOutputCounts() {\n    return {\n      inputCount: this.tx.ins.length,\n      outputCount: this.tx.outs.length\n    };\n  }\n\n  addInput(input) {\n    if (input.hash === undefined || input.index === undefined || !Buffer.isBuffer(input.hash) && typeof input.hash !== 'string' || typeof input.index !== 'number') {\n      throw new Error('Error adding input.');\n    }\n\n    const hash = typeof input.hash === 'string' ? bufferutils_1.reverseBuffer(Buffer.from(input.hash, 'hex')) : input.hash;\n    this.tx.addInput(hash, input.index, input.sequence);\n  }\n\n  addOutput(output) {\n    if (output.script === undefined || output.value === undefined || !Buffer.isBuffer(output.script) || typeof output.value !== 'number') {\n      throw new Error('Error adding output.');\n    }\n\n    this.tx.addOutput(output.script, output.value);\n  }\n\n  toBuffer() {\n    return this.tx.toBuffer();\n  }\n\n}\n\nfunction canFinalize(input, script, scriptType) {\n  switch (scriptType) {\n    case 'pubkey':\n    case 'pubkeyhash':\n    case 'witnesspubkeyhash':\n      return hasSigs(1, input.partialSig);\n\n    case 'multisig':\n      const p2ms = payments.p2ms({\n        output: script\n      });\n      return hasSigs(p2ms.m, input.partialSig, p2ms.pubkeys);\n\n    default:\n      return false;\n  }\n}\n\nfunction checkCache(cache) {\n  if (cache.__UNSAFE_SIGN_NONSEGWIT !== false) {\n    throw new Error('Not BIP174 compliant, can not export');\n  }\n}\n\nfunction hasSigs(neededSigs, partialSig, pubkeys) {\n  if (!partialSig) return false;\n  let sigs;\n\n  if (pubkeys) {\n    sigs = pubkeys.map(pkey => {\n      const pubkey = ecpair_1.fromPublicKey(pkey, {\n        compressed: true\n      }).publicKey;\n      return partialSig.find(pSig => pSig.pubkey.equals(pubkey));\n    }).filter(v => !!v);\n  } else {\n    sigs = partialSig;\n  }\n\n  if (sigs.length > neededSigs) throw new Error('Too many signatures');\n  return sigs.length === neededSigs;\n}\n\nfunction isFinalized(input) {\n  return !!input.finalScriptSig || !!input.finalScriptWitness;\n}\n\nfunction isPaymentFactory(payment) {\n  return script => {\n    try {\n      payment({\n        output: script\n      });\n      return true;\n    } catch (err) {\n      return false;\n    }\n  };\n}\n\nconst isP2MS = isPaymentFactory(payments.p2ms);\nconst isP2PK = isPaymentFactory(payments.p2pk);\nconst isP2PKH = isPaymentFactory(payments.p2pkh);\nconst isP2WPKH = isPaymentFactory(payments.p2wpkh);\nconst isP2WSHScript = isPaymentFactory(payments.p2wsh);\nconst isP2SHScript = isPaymentFactory(payments.p2sh);\n\nfunction bip32DerivationIsMine(root) {\n  return d => {\n    if (!d.masterFingerprint.equals(root.fingerprint)) return false;\n    if (!root.derivePath(d.path).publicKey.equals(d.pubkey)) return false;\n    return true;\n  };\n}\n\nfunction check32Bit(num) {\n  if (typeof num !== 'number' || num !== Math.floor(num) || num > 0xffffffff || num < 0) {\n    throw new Error('Invalid 32 bit integer');\n  }\n}\n\nfunction checkFees(psbt, cache, opts) {\n  const feeRate = cache.__FEE_RATE || psbt.getFeeRate();\n\n  const vsize = cache.__EXTRACTED_TX.virtualSize();\n\n  const satoshis = feeRate * vsize;\n\n  if (feeRate >= opts.maximumFeeRate) {\n    throw new Error(`Warning: You are paying around ${(satoshis / 1e8).toFixed(8)} in ` + `fees, which is ${feeRate} satoshi per byte for a transaction ` + `with a VSize of ${vsize} bytes (segwit counted as 0.25 byte per ` + `byte). Use setMaximumFeeRate method to raise your threshold, or ` + `pass true to the first arg of extractTransaction.`);\n  }\n}\n\nfunction checkInputsForPartialSig(inputs, action) {\n  inputs.forEach(input => {\n    let throws = false;\n    let pSigs = [];\n\n    if ((input.partialSig || []).length === 0) {\n      if (!input.finalScriptSig && !input.finalScriptWitness) return;\n      pSigs = getPsigsFromInputFinalScripts(input);\n    } else {\n      pSigs = input.partialSig;\n    }\n\n    pSigs.forEach(pSig => {\n      const {\n        hashType\n      } = bscript.signature.decode(pSig.signature);\n      const whitelist = [];\n      const isAnyoneCanPay = hashType & transaction_1.Transaction.SIGHASH_ANYONECANPAY;\n      if (isAnyoneCanPay) whitelist.push('addInput');\n      const hashMod = hashType & 0x1f;\n\n      switch (hashMod) {\n        case transaction_1.Transaction.SIGHASH_ALL:\n          break;\n\n        case transaction_1.Transaction.SIGHASH_SINGLE:\n        case transaction_1.Transaction.SIGHASH_NONE:\n          whitelist.push('addOutput');\n          whitelist.push('setInputSequence');\n          break;\n      }\n\n      if (whitelist.indexOf(action) === -1) {\n        throws = true;\n      }\n    });\n\n    if (throws) {\n      throw new Error('Can not modify transaction, signatures exist.');\n    }\n  });\n}\n\nfunction checkPartialSigSighashes(input) {\n  if (!input.sighashType || !input.partialSig) return;\n  const {\n    partialSig,\n    sighashType\n  } = input;\n  partialSig.forEach(pSig => {\n    const {\n      hashType\n    } = bscript.signature.decode(pSig.signature);\n\n    if (sighashType !== hashType) {\n      throw new Error('Signature sighash does not match input sighash type');\n    }\n  });\n}\n\nfunction checkScriptForPubkey(pubkey, script, action) {\n  if (!pubkeyInScript(pubkey, script)) {\n    throw new Error(`Can not ${action} for this input with the key ${pubkey.toString('hex')}`);\n  }\n}\n\nfunction checkTxEmpty(tx) {\n  const isEmpty = tx.ins.every(input => input.script && input.script.length === 0 && input.witness && input.witness.length === 0);\n\n  if (!isEmpty) {\n    throw new Error('Format Error: Transaction ScriptSigs are not empty');\n  }\n}\n\nfunction checkTxForDupeIns(tx, cache) {\n  tx.ins.forEach(input => {\n    checkTxInputCache(cache, input);\n  });\n}\n\nfunction checkTxInputCache(cache, input) {\n  const key = bufferutils_1.reverseBuffer(Buffer.from(input.hash)).toString('hex') + ':' + input.index;\n  if (cache.__TX_IN_CACHE[key]) throw new Error('Duplicate input detected.');\n  cache.__TX_IN_CACHE[key] = 1;\n}\n\nfunction scriptCheckerFactory(payment, paymentScriptName) {\n  return (inputIndex, scriptPubKey, redeemScript, ioType) => {\n    const redeemScriptOutput = payment({\n      redeem: {\n        output: redeemScript\n      }\n    }).output;\n\n    if (!scriptPubKey.equals(redeemScriptOutput)) {\n      throw new Error(`${paymentScriptName} for ${ioType} #${inputIndex} doesn't match the scriptPubKey in the prevout`);\n    }\n  };\n}\n\nconst checkRedeemScript = scriptCheckerFactory(payments.p2sh, 'Redeem script');\nconst checkWitnessScript = scriptCheckerFactory(payments.p2wsh, 'Witness script');\n\nfunction getTxCacheValue(key, name, inputs, c) {\n  if (!inputs.every(isFinalized)) throw new Error(`PSBT must be finalized to calculate ${name}`);\n  if (key === '__FEE_RATE' && c.__FEE_RATE) return c.__FEE_RATE;\n  if (key === '__FEE' && c.__FEE) return c.__FEE;\n  let tx;\n  let mustFinalize = true;\n\n  if (c.__EXTRACTED_TX) {\n    tx = c.__EXTRACTED_TX;\n    mustFinalize = false;\n  } else {\n    tx = c.__TX.clone();\n  }\n\n  inputFinalizeGetAmts(inputs, tx, c, mustFinalize);\n  if (key === '__FEE_RATE') return c.__FEE_RATE;else if (key === '__FEE') return c.__FEE;\n}\n\nfunction getFinalScripts(inputIndex, input, script, isSegwit, isP2SH, isP2WSH) {\n  const scriptType = classifyScript(script);\n  if (!canFinalize(input, script, scriptType)) throw new Error(`Can not finalize input #${inputIndex}`);\n  return prepareFinalScripts(script, scriptType, input.partialSig, isSegwit, isP2SH, isP2WSH);\n}\n\nfunction prepareFinalScripts(script, scriptType, partialSig, isSegwit, isP2SH, isP2WSH) {\n  let finalScriptSig;\n  let finalScriptWitness; // Wow, the payments API is very handy\n\n  const payment = getPayment(script, scriptType, partialSig);\n  const p2wsh = !isP2WSH ? null : payments.p2wsh({\n    redeem: payment\n  });\n  const p2sh = !isP2SH ? null : payments.p2sh({\n    redeem: p2wsh || payment\n  });\n\n  if (isSegwit) {\n    if (p2wsh) {\n      finalScriptWitness = witnessStackToScriptWitness(p2wsh.witness);\n    } else {\n      finalScriptWitness = witnessStackToScriptWitness(payment.witness);\n    }\n\n    if (p2sh) {\n      finalScriptSig = p2sh.input;\n    }\n  } else {\n    if (p2sh) {\n      finalScriptSig = p2sh.input;\n    } else {\n      finalScriptSig = payment.input;\n    }\n  }\n\n  return {\n    finalScriptSig,\n    finalScriptWitness\n  };\n}\n\nfunction getHashAndSighashType(inputs, inputIndex, pubkey, cache, sighashTypes) {\n  const input = utils_1.checkForInput(inputs, inputIndex);\n  const {\n    hash,\n    sighashType,\n    script\n  } = getHashForSig(inputIndex, input, cache, false, sighashTypes);\n  checkScriptForPubkey(pubkey, script, 'sign');\n  return {\n    hash,\n    sighashType\n  };\n}\n\nfunction getHashForSig(inputIndex, input, cache, forValidate, sighashTypes) {\n  const unsignedTx = cache.__TX;\n  const sighashType = input.sighashType || transaction_1.Transaction.SIGHASH_ALL;\n\n  if (sighashTypes && sighashTypes.indexOf(sighashType) < 0) {\n    const str = sighashTypeToString(sighashType);\n    throw new Error(`Sighash type is not allowed. Retry the sign method passing the ` + `sighashTypes array of whitelisted types. Sighash type: ${str}`);\n  }\n\n  let hash;\n  let prevout;\n\n  if (input.nonWitnessUtxo) {\n    const nonWitnessUtxoTx = nonWitnessUtxoTxFromCache(cache, input, inputIndex);\n    const prevoutHash = unsignedTx.ins[inputIndex].hash;\n    const utxoHash = nonWitnessUtxoTx.getHash(); // If a non-witness UTXO is provided, its hash must match the hash specified in the prevout\n\n    if (!prevoutHash.equals(utxoHash)) {\n      throw new Error(`Non-witness UTXO hash for input #${inputIndex} doesn't match the hash specified in the prevout`);\n    }\n\n    const prevoutIndex = unsignedTx.ins[inputIndex].index;\n    prevout = nonWitnessUtxoTx.outs[prevoutIndex];\n  } else if (input.witnessUtxo) {\n    prevout = input.witnessUtxo;\n  } else {\n    throw new Error('Need a Utxo input item for signing');\n  }\n\n  const {\n    meaningfulScript,\n    type\n  } = getMeaningfulScript(prevout.script, inputIndex, 'input', input.redeemScript, input.witnessScript);\n\n  if (['p2sh-p2wsh', 'p2wsh'].indexOf(type) >= 0) {\n    hash = unsignedTx.hashForWitnessV0(inputIndex, meaningfulScript, prevout.value, sighashType);\n  } else if (isP2WPKH(meaningfulScript)) {\n    // P2WPKH uses the P2PKH template for prevoutScript when signing\n    const signingScript = payments.p2pkh({\n      hash: meaningfulScript.slice(2)\n    }).output;\n    hash = unsignedTx.hashForWitnessV0(inputIndex, signingScript, prevout.value, sighashType);\n  } else {\n    // non-segwit\n    if (input.nonWitnessUtxo === undefined && cache.__UNSAFE_SIGN_NONSEGWIT === false) throw new Error(`Input #${inputIndex} has witnessUtxo but non-segwit script: ` + `${meaningfulScript.toString('hex')}`);\n    if (!forValidate && cache.__UNSAFE_SIGN_NONSEGWIT !== false) console.warn('Warning: Signing non-segwit inputs without the full parent transaction ' + 'means there is a chance that a miner could feed you incorrect information ' + 'to trick you into paying large fees. This behavior is the same as the old ' + 'TransactionBuilder class when signing non-segwit scripts. You are not ' + 'able to export this Psbt with toBuffer|toBase64|toHex since it is not ' + 'BIP174 compliant.\\n*********************\\nPROCEED WITH CAUTION!\\n' + '*********************');\n    hash = unsignedTx.hashForSignature(inputIndex, meaningfulScript, sighashType);\n  }\n\n  return {\n    script: meaningfulScript,\n    sighashType,\n    hash\n  };\n}\n\nfunction getPayment(script, scriptType, partialSig) {\n  let payment;\n\n  switch (scriptType) {\n    case 'multisig':\n      const sigs = getSortedSigs(script, partialSig);\n      payment = payments.p2ms({\n        output: script,\n        signatures: sigs\n      });\n      break;\n\n    case 'pubkey':\n      payment = payments.p2pk({\n        output: script,\n        signature: partialSig[0].signature\n      });\n      break;\n\n    case 'pubkeyhash':\n      payment = payments.p2pkh({\n        output: script,\n        pubkey: partialSig[0].pubkey,\n        signature: partialSig[0].signature\n      });\n      break;\n\n    case 'witnesspubkeyhash':\n      payment = payments.p2wpkh({\n        output: script,\n        pubkey: partialSig[0].pubkey,\n        signature: partialSig[0].signature\n      });\n      break;\n  }\n\n  return payment;\n}\n\nfunction getPsigsFromInputFinalScripts(input) {\n  const scriptItems = !input.finalScriptSig ? [] : bscript.decompile(input.finalScriptSig) || [];\n  const witnessItems = !input.finalScriptWitness ? [] : bscript.decompile(input.finalScriptWitness) || [];\n  return scriptItems.concat(witnessItems).filter(item => {\n    return Buffer.isBuffer(item) && bscript.isCanonicalScriptSignature(item);\n  }).map(sig => ({\n    signature: sig\n  }));\n}\n\nfunction getScriptFromInput(inputIndex, input, cache) {\n  const unsignedTx = cache.__TX;\n  const res = {\n    script: null,\n    isSegwit: false,\n    isP2SH: false,\n    isP2WSH: false\n  };\n  res.isP2SH = !!input.redeemScript;\n  res.isP2WSH = !!input.witnessScript;\n\n  if (input.witnessScript) {\n    res.script = input.witnessScript;\n  } else if (input.redeemScript) {\n    res.script = input.redeemScript;\n  } else {\n    if (input.nonWitnessUtxo) {\n      const nonWitnessUtxoTx = nonWitnessUtxoTxFromCache(cache, input, inputIndex);\n      const prevoutIndex = unsignedTx.ins[inputIndex].index;\n      res.script = nonWitnessUtxoTx.outs[prevoutIndex].script;\n    } else if (input.witnessUtxo) {\n      res.script = input.witnessUtxo.script;\n    }\n  }\n\n  if (input.witnessScript || isP2WPKH(res.script)) {\n    res.isSegwit = true;\n  }\n\n  return res;\n}\n\nfunction getSignersFromHD(inputIndex, inputs, hdKeyPair) {\n  const input = utils_1.checkForInput(inputs, inputIndex);\n\n  if (!input.bip32Derivation || input.bip32Derivation.length === 0) {\n    throw new Error('Need bip32Derivation to sign with HD');\n  }\n\n  const myDerivations = input.bip32Derivation.map(bipDv => {\n    if (bipDv.masterFingerprint.equals(hdKeyPair.fingerprint)) {\n      return bipDv;\n    } else {\n      return;\n    }\n  }).filter(v => !!v);\n\n  if (myDerivations.length === 0) {\n    throw new Error('Need one bip32Derivation masterFingerprint to match the HDSigner fingerprint');\n  }\n\n  const signers = myDerivations.map(bipDv => {\n    const node = hdKeyPair.derivePath(bipDv.path);\n\n    if (!bipDv.pubkey.equals(node.publicKey)) {\n      throw new Error('pubkey did not match bip32Derivation');\n    }\n\n    return node;\n  });\n  return signers;\n}\n\nfunction getSortedSigs(script, partialSig) {\n  const p2ms = payments.p2ms({\n    output: script\n  }); // for each pubkey in order of p2ms script\n\n  return p2ms.pubkeys.map(pk => {\n    // filter partialSig array by pubkey being equal\n    return (partialSig.filter(ps => {\n      return ps.pubkey.equals(pk);\n    })[0] || {}).signature; // Any pubkey without a match will return undefined\n    // this last filter removes all the undefined items in the array.\n  }).filter(v => !!v);\n}\n\nfunction scriptWitnessToWitnessStack(buffer) {\n  let offset = 0;\n\n  function readSlice(n) {\n    offset += n;\n    return buffer.slice(offset - n, offset);\n  }\n\n  function readVarInt() {\n    const vi = varuint.decode(buffer, offset);\n    offset += varuint.decode.bytes;\n    return vi;\n  }\n\n  function readVarSlice() {\n    return readSlice(readVarInt());\n  }\n\n  function readVector() {\n    const count = readVarInt();\n    const vector = [];\n\n    for (let i = 0; i < count; i++) vector.push(readVarSlice());\n\n    return vector;\n  }\n\n  return readVector();\n}\n\nfunction sighashTypeToString(sighashType) {\n  let text = sighashType & transaction_1.Transaction.SIGHASH_ANYONECANPAY ? 'SIGHASH_ANYONECANPAY | ' : '';\n  const sigMod = sighashType & 0x1f;\n\n  switch (sigMod) {\n    case transaction_1.Transaction.SIGHASH_ALL:\n      text += 'SIGHASH_ALL';\n      break;\n\n    case transaction_1.Transaction.SIGHASH_SINGLE:\n      text += 'SIGHASH_SINGLE';\n      break;\n\n    case transaction_1.Transaction.SIGHASH_NONE:\n      text += 'SIGHASH_NONE';\n      break;\n  }\n\n  return text;\n}\n\nfunction witnessStackToScriptWitness(witness) {\n  let buffer = Buffer.allocUnsafe(0);\n\n  function writeSlice(slice) {\n    buffer = Buffer.concat([buffer, Buffer.from(slice)]);\n  }\n\n  function writeVarInt(i) {\n    const currentLen = buffer.length;\n    const varintLen = varuint.encodingLength(i);\n    buffer = Buffer.concat([buffer, Buffer.allocUnsafe(varintLen)]);\n    varuint.encode(i, buffer, currentLen);\n  }\n\n  function writeVarSlice(slice) {\n    writeVarInt(slice.length);\n    writeSlice(slice);\n  }\n\n  function writeVector(vector) {\n    writeVarInt(vector.length);\n    vector.forEach(writeVarSlice);\n  }\n\n  writeVector(witness);\n  return buffer;\n}\n\nfunction addNonWitnessTxCache(cache, input, inputIndex) {\n  cache.__NON_WITNESS_UTXO_BUF_CACHE[inputIndex] = input.nonWitnessUtxo;\n  const tx = transaction_1.Transaction.fromBuffer(input.nonWitnessUtxo);\n  cache.__NON_WITNESS_UTXO_TX_CACHE[inputIndex] = tx;\n  const self = cache;\n  const selfIndex = inputIndex;\n  delete input.nonWitnessUtxo;\n  Object.defineProperty(input, 'nonWitnessUtxo', {\n    enumerable: true,\n\n    get() {\n      const buf = self.__NON_WITNESS_UTXO_BUF_CACHE[selfIndex];\n      const txCache = self.__NON_WITNESS_UTXO_TX_CACHE[selfIndex];\n\n      if (buf !== undefined) {\n        return buf;\n      } else {\n        const newBuf = txCache.toBuffer();\n        self.__NON_WITNESS_UTXO_BUF_CACHE[selfIndex] = newBuf;\n        return newBuf;\n      }\n    },\n\n    set(data) {\n      self.__NON_WITNESS_UTXO_BUF_CACHE[selfIndex] = data;\n    }\n\n  });\n}\n\nfunction inputFinalizeGetAmts(inputs, tx, cache, mustFinalize) {\n  let inputAmount = 0;\n  inputs.forEach((input, idx) => {\n    if (mustFinalize && input.finalScriptSig) tx.ins[idx].script = input.finalScriptSig;\n\n    if (mustFinalize && input.finalScriptWitness) {\n      tx.ins[idx].witness = scriptWitnessToWitnessStack(input.finalScriptWitness);\n    }\n\n    if (input.witnessUtxo) {\n      inputAmount += input.witnessUtxo.value;\n    } else if (input.nonWitnessUtxo) {\n      const nwTx = nonWitnessUtxoTxFromCache(cache, input, idx);\n      const vout = tx.ins[idx].index;\n      const out = nwTx.outs[vout];\n      inputAmount += out.value;\n    }\n  });\n  const outputAmount = tx.outs.reduce((total, o) => total + o.value, 0);\n  const fee = inputAmount - outputAmount;\n\n  if (fee < 0) {\n    throw new Error('Outputs are spending more than Inputs');\n  }\n\n  const bytes = tx.virtualSize();\n  cache.__FEE = fee;\n  cache.__EXTRACTED_TX = tx;\n  cache.__FEE_RATE = Math.floor(fee / bytes);\n}\n\nfunction nonWitnessUtxoTxFromCache(cache, input, inputIndex) {\n  const c = cache.__NON_WITNESS_UTXO_TX_CACHE;\n\n  if (!c[inputIndex]) {\n    addNonWitnessTxCache(cache, input, inputIndex);\n  }\n\n  return c[inputIndex];\n}\n\nfunction getScriptFromUtxo(inputIndex, input, cache) {\n  if (input.witnessUtxo !== undefined) {\n    return input.witnessUtxo.script;\n  } else if (input.nonWitnessUtxo !== undefined) {\n    const nonWitnessUtxoTx = nonWitnessUtxoTxFromCache(cache, input, inputIndex);\n    return nonWitnessUtxoTx.outs[cache.__TX.ins[inputIndex].index].script;\n  } else {\n    throw new Error(\"Can't find pubkey in input without Utxo data\");\n  }\n}\n\nfunction pubkeyInInput(pubkey, input, inputIndex, cache) {\n  const script = getScriptFromUtxo(inputIndex, input, cache);\n  const {\n    meaningfulScript\n  } = getMeaningfulScript(script, inputIndex, 'input', input.redeemScript, input.witnessScript);\n  return pubkeyInScript(pubkey, meaningfulScript);\n}\n\nfunction pubkeyInOutput(pubkey, output, outputIndex, cache) {\n  const script = cache.__TX.outs[outputIndex].script;\n  const {\n    meaningfulScript\n  } = getMeaningfulScript(script, outputIndex, 'output', output.redeemScript, output.witnessScript);\n  return pubkeyInScript(pubkey, meaningfulScript);\n}\n\nfunction redeemFromFinalScriptSig(finalScript) {\n  if (!finalScript) return;\n  const decomp = bscript.decompile(finalScript);\n  if (!decomp) return;\n  const lastItem = decomp[decomp.length - 1];\n  if (!Buffer.isBuffer(lastItem) || isPubkeyLike(lastItem) || isSigLike(lastItem)) return;\n  const sDecomp = bscript.decompile(lastItem);\n  if (!sDecomp) return;\n  return lastItem;\n}\n\nfunction redeemFromFinalWitnessScript(finalScript) {\n  if (!finalScript) return;\n  const decomp = scriptWitnessToWitnessStack(finalScript);\n  const lastItem = decomp[decomp.length - 1];\n  if (isPubkeyLike(lastItem)) return;\n  const sDecomp = bscript.decompile(lastItem);\n  if (!sDecomp) return;\n  return lastItem;\n}\n\nfunction isPubkeyLike(buf) {\n  return buf.length === 33 && bscript.isCanonicalPubKey(buf);\n}\n\nfunction isSigLike(buf) {\n  return bscript.isCanonicalScriptSignature(buf);\n}\n\nfunction getMeaningfulScript(script, index, ioType, redeemScript, witnessScript) {\n  const isP2SH = isP2SHScript(script);\n  const isP2SHP2WSH = isP2SH && redeemScript && isP2WSHScript(redeemScript);\n  const isP2WSH = isP2WSHScript(script);\n  if (isP2SH && redeemScript === undefined) throw new Error('scriptPubkey is P2SH but redeemScript missing');\n  if ((isP2WSH || isP2SHP2WSH) && witnessScript === undefined) throw new Error('scriptPubkey or redeemScript is P2WSH but witnessScript missing');\n  let meaningfulScript;\n\n  if (isP2SHP2WSH) {\n    meaningfulScript = witnessScript;\n    checkRedeemScript(index, script, redeemScript, ioType);\n    checkWitnessScript(index, redeemScript, witnessScript, ioType);\n    checkInvalidP2WSH(meaningfulScript);\n  } else if (isP2WSH) {\n    meaningfulScript = witnessScript;\n    checkWitnessScript(index, script, witnessScript, ioType);\n    checkInvalidP2WSH(meaningfulScript);\n  } else if (isP2SH) {\n    meaningfulScript = redeemScript;\n    checkRedeemScript(index, script, redeemScript, ioType);\n  } else {\n    meaningfulScript = script;\n  }\n\n  return {\n    meaningfulScript,\n    type: isP2SHP2WSH ? 'p2sh-p2wsh' : isP2SH ? 'p2sh' : isP2WSH ? 'p2wsh' : 'raw'\n  };\n}\n\nfunction checkInvalidP2WSH(script) {\n  if (isP2WPKH(script) || isP2SHScript(script)) {\n    throw new Error('P2WPKH or P2SH can not be contained within P2WSH');\n  }\n}\n\nfunction pubkeyInScript(pubkey, script) {\n  const pubkeyHash = crypto_1.hash160(pubkey);\n  const decompiled = bscript.decompile(script);\n  if (decompiled === null) throw new Error('Unknown script error');\n  return decompiled.some(element => {\n    if (typeof element === 'number') return false;\n    return element.equals(pubkey) || element.equals(pubkeyHash);\n  });\n}\n\nfunction classifyScript(script) {\n  if (isP2WPKH(script)) return 'witnesspubkeyhash';\n  if (isP2PKH(script)) return 'pubkeyhash';\n  if (isP2MS(script)) return 'multisig';\n  if (isP2PK(script)) return 'pubkey';\n  return 'nonstandard';\n}\n\nfunction range(n) {\n  return [...Array(n).keys()];\n}","map":{"version":3,"names":["Object","defineProperty","exports","value","bip174_1","require","varuint","utils_1","address_1","bufferutils_1","crypto_1","ecpair_1","networks_1","payments","bscript","transaction_1","DEFAULT_OPTS","network","bitcoin","maximumFeeRate","Psbt","constructor","opts","data","PsbtTransaction","assign","__CACHE","__NON_WITNESS_UTXO_TX_CACHE","__NON_WITNESS_UTXO_BUF_CACHE","__TX_IN_CACHE","__TX","globalMap","unsignedTx","tx","__UNSAFE_SIGN_NONSEGWIT","inputs","length","setVersion","dpew","obj","attr","enumerable","writable","fromBase64","buffer","Buffer","from","fromBuffer","fromHex","psbtBase","transactionFromBuffer","psbt","checkTxForDupeIns","inputCount","version","locktime","setLocktime","txInputs","ins","map","input","hash","cloneBuffer","index","sequence","txOutputs","outs","output","address","fromOutputScript","script","_","combine","those","o","clone","res","toBuffer","JSON","parse","stringify","setMaximumFeeRate","satoshiPerByte","check32Bit","checkInputsForPartialSig","c","__EXTRACTED_TX","undefined","setInputSequence","inputIndex","Error","addInputs","inputDatas","forEach","inputData","addInput","arguments","witnessScript","checkInvalidP2WSH","txIn","checkTxInputCache","nonWitnessUtxo","addNonWitnessTxCache","__FEE","__FEE_RATE","addOutputs","outputDatas","outputData","addOutput","toOutputScript","extractTransaction","disableFeeCheck","every","isFinalized","checkFees","inputFinalizeGetAmts","getFeeRate","getTxCacheValue","getFee","finalizeAllInputs","checkForInput","range","idx","finalizeInput","finalScriptsFunc","getFinalScripts","isP2SH","isP2WSH","isSegwit","getScriptFromInput","checkPartialSigSighashes","finalScriptSig","finalScriptWitness","updateInput","clearFinalizedInput","getInputType","getScriptFromUtxo","result","getMeaningfulScript","redeemScript","redeemFromFinalScriptSig","redeemFromFinalWitnessScript","type","mainType","classifyScript","meaningfulScript","inputHasPubkey","pubkey","pubkeyInInput","inputHasHDKey","root","derivationIsMine","bip32DerivationIsMine","bip32Derivation","some","outputHasPubkey","outputIndex","checkForOutput","outputs","pubkeyInOutput","outputHasHDKey","validateSignaturesOfAllInputs","results","validateSignaturesOfInput","reduce","final","partialSig","mySigs","filter","sig","equals","hashCache","scriptCache","sighashCache","pSig","signature","decode","hashType","getHashForSig","sighashType","checkScriptForPubkey","keypair","fromPublicKey","push","verify","signAllInputsHD","hdKeyPair","sighashTypes","Transaction","SIGHASH_ALL","publicKey","fingerprint","i","signInputHD","err","v","signAllInputsHDAsync","Promise","resolve","reject","promises","signInputHDAsync","then","all","signers","getSignersFromHD","signer","signInput","signInputAsync","catch","signAllInputs","keyPair","signAllInputsAsync","entries","getHashAndSighashType","encode","sign","checkCache","toHex","toBase64","updateGlobal","updateData","updateOutput","addUnknownKeyValToGlobal","keyVal","addUnknownKeyValToInput","addUnknownKeyValToOutput","checkTxEmpty","getInputOutputCounts","outputCount","isBuffer","reverseBuffer","canFinalize","scriptType","hasSigs","p2ms","m","pubkeys","cache","neededSigs","sigs","pkey","compressed","find","isPaymentFactory","payment","isP2MS","isP2PK","p2pk","isP2PKH","p2pkh","isP2WPKH","p2wpkh","isP2WSHScript","p2wsh","isP2SHScript","p2sh","d","masterFingerprint","derivePath","path","num","Math","floor","feeRate","vsize","virtualSize","satoshis","toFixed","action","throws","pSigs","getPsigsFromInputFinalScripts","whitelist","isAnyoneCanPay","SIGHASH_ANYONECANPAY","hashMod","SIGHASH_SINGLE","SIGHASH_NONE","indexOf","pubkeyInScript","toString","isEmpty","witness","key","scriptCheckerFactory","paymentScriptName","scriptPubKey","ioType","redeemScriptOutput","redeem","checkRedeemScript","checkWitnessScript","name","mustFinalize","prepareFinalScripts","getPayment","witnessStackToScriptWitness","forValidate","str","sighashTypeToString","prevout","nonWitnessUtxoTx","nonWitnessUtxoTxFromCache","prevoutHash","utxoHash","getHash","prevoutIndex","witnessUtxo","hashForWitnessV0","signingScript","slice","console","warn","hashForSignature","getSortedSigs","signatures","scriptItems","decompile","witnessItems","concat","item","isCanonicalScriptSignature","myDerivations","bipDv","node","pk","ps","scriptWitnessToWitnessStack","offset","readSlice","n","readVarInt","vi","bytes","readVarSlice","readVector","count","vector","text","sigMod","allocUnsafe","writeSlice","writeVarInt","currentLen","varintLen","encodingLength","writeVarSlice","writeVector","self","selfIndex","get","buf","txCache","newBuf","set","inputAmount","nwTx","vout","out","outputAmount","total","fee","finalScript","decomp","lastItem","isPubkeyLike","isSigLike","sDecomp","isCanonicalPubKey","isP2SHP2WSH","pubkeyHash","hash160","decompiled","element","Array","keys"],"sources":["C:/Users/acer/node_modules/bitcoinjs-lib/src/psbt.js"],"sourcesContent":["'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nconst bip174_1 = require('bip174');\nconst varuint = require('bip174/src/lib/converter/varint');\nconst utils_1 = require('bip174/src/lib/utils');\nconst address_1 = require('./address');\nconst bufferutils_1 = require('./bufferutils');\nconst crypto_1 = require('./crypto');\nconst ecpair_1 = require('./ecpair');\nconst networks_1 = require('./networks');\nconst payments = require('./payments');\nconst bscript = require('./script');\nconst transaction_1 = require('./transaction');\n/**\n * These are the default arguments for a Psbt instance.\n */\nconst DEFAULT_OPTS = {\n  /**\n   * A bitcoinjs Network object. This is only used if you pass an `address`\n   * parameter to addOutput. Otherwise it is not needed and can be left default.\n   */\n  network: networks_1.bitcoin,\n  /**\n   * When extractTransaction is called, the fee rate is checked.\n   * THIS IS NOT TO BE RELIED ON.\n   * It is only here as a last ditch effort to prevent sending a 500 BTC fee etc.\n   */\n  maximumFeeRate: 5000,\n};\n/**\n * Psbt class can parse and generate a PSBT binary based off of the BIP174.\n * There are 6 roles that this class fulfills. (Explained in BIP174)\n *\n * Creator: This can be done with `new Psbt()`\n * Updater: This can be done with `psbt.addInput(input)`, `psbt.addInputs(inputs)`,\n *   `psbt.addOutput(output)`, `psbt.addOutputs(outputs)` when you are looking to\n *   add new inputs and outputs to the PSBT, and `psbt.updateGlobal(itemObject)`,\n *   `psbt.updateInput(itemObject)`, `psbt.updateOutput(itemObject)`\n *   addInput requires hash: Buffer | string; and index: number; as attributes\n *   and can also include any attributes that are used in updateInput method.\n *   addOutput requires script: Buffer; and value: number; and likewise can include\n *   data for updateOutput.\n *   For a list of what attributes should be what types. Check the bip174 library.\n *   Also, check the integration tests for some examples of usage.\n * Signer: There are a few methods. signAllInputs and signAllInputsAsync, which will search all input\n *   information for your pubkey or pubkeyhash, and only sign inputs where it finds\n *   your info. Or you can explicitly sign a specific input with signInput and\n *   signInputAsync. For the async methods you can create a SignerAsync object\n *   and use something like a hardware wallet to sign with. (You must implement this)\n * Combiner: psbts can be combined easily with `psbt.combine(psbt2, psbt3, psbt4 ...)`\n *   the psbt calling combine will always have precedence when a conflict occurs.\n *   Combine checks if the internal bitcoin transaction is the same, so be sure that\n *   all sequences, version, locktime, etc. are the same before combining.\n * Input Finalizer: This role is fairly important. Not only does it need to construct\n *   the input scriptSigs and witnesses, but it SHOULD verify the signatures etc.\n *   Before running `psbt.finalizeAllInputs()` please run `psbt.validateSignaturesOfAllInputs()`\n *   Running any finalize method will delete any data in the input(s) that are no longer\n *   needed due to the finalized scripts containing the information.\n * Transaction Extractor: This role will perform some checks before returning a\n *   Transaction object. Such as fee rate not being larger than maximumFeeRate etc.\n */\nclass Psbt {\n  constructor(opts = {}, data = new bip174_1.Psbt(new PsbtTransaction())) {\n    this.data = data;\n    // set defaults\n    this.opts = Object.assign({}, DEFAULT_OPTS, opts);\n    this.__CACHE = {\n      __NON_WITNESS_UTXO_TX_CACHE: [],\n      __NON_WITNESS_UTXO_BUF_CACHE: [],\n      __TX_IN_CACHE: {},\n      __TX: this.data.globalMap.unsignedTx.tx,\n      // Old TransactionBuilder behavior was to not confirm input values\n      // before signing. Even though we highly encourage people to get\n      // the full parent transaction to verify values, the ability to\n      // sign non-segwit inputs without the full transaction was often\n      // requested. So the only way to activate is to use @ts-ignore.\n      // We will disable exporting the Psbt when unsafe sign is active.\n      // because it is not BIP174 compliant.\n      __UNSAFE_SIGN_NONSEGWIT: false,\n    };\n    if (this.data.inputs.length === 0) this.setVersion(2);\n    // Make data hidden when enumerating\n    const dpew = (obj, attr, enumerable, writable) =>\n      Object.defineProperty(obj, attr, {\n        enumerable,\n        writable,\n      });\n    dpew(this, '__CACHE', false, true);\n    dpew(this, 'opts', false, true);\n  }\n  static fromBase64(data, opts = {}) {\n    const buffer = Buffer.from(data, 'base64');\n    return this.fromBuffer(buffer, opts);\n  }\n  static fromHex(data, opts = {}) {\n    const buffer = Buffer.from(data, 'hex');\n    return this.fromBuffer(buffer, opts);\n  }\n  static fromBuffer(buffer, opts = {}) {\n    const psbtBase = bip174_1.Psbt.fromBuffer(buffer, transactionFromBuffer);\n    const psbt = new Psbt(opts, psbtBase);\n    checkTxForDupeIns(psbt.__CACHE.__TX, psbt.__CACHE);\n    return psbt;\n  }\n  get inputCount() {\n    return this.data.inputs.length;\n  }\n  get version() {\n    return this.__CACHE.__TX.version;\n  }\n  set version(version) {\n    this.setVersion(version);\n  }\n  get locktime() {\n    return this.__CACHE.__TX.locktime;\n  }\n  set locktime(locktime) {\n    this.setLocktime(locktime);\n  }\n  get txInputs() {\n    return this.__CACHE.__TX.ins.map(input => ({\n      hash: bufferutils_1.cloneBuffer(input.hash),\n      index: input.index,\n      sequence: input.sequence,\n    }));\n  }\n  get txOutputs() {\n    return this.__CACHE.__TX.outs.map(output => {\n      let address;\n      try {\n        address = address_1.fromOutputScript(output.script, this.opts.network);\n      } catch (_) {}\n      return {\n        script: bufferutils_1.cloneBuffer(output.script),\n        value: output.value,\n        address,\n      };\n    });\n  }\n  combine(...those) {\n    this.data.combine(...those.map(o => o.data));\n    return this;\n  }\n  clone() {\n    // TODO: more efficient cloning\n    const res = Psbt.fromBuffer(this.data.toBuffer());\n    res.opts = JSON.parse(JSON.stringify(this.opts));\n    return res;\n  }\n  setMaximumFeeRate(satoshiPerByte) {\n    check32Bit(satoshiPerByte); // 42.9 BTC per byte IS excessive... so throw\n    this.opts.maximumFeeRate = satoshiPerByte;\n  }\n  setVersion(version) {\n    check32Bit(version);\n    checkInputsForPartialSig(this.data.inputs, 'setVersion');\n    const c = this.__CACHE;\n    c.__TX.version = version;\n    c.__EXTRACTED_TX = undefined;\n    return this;\n  }\n  setLocktime(locktime) {\n    check32Bit(locktime);\n    checkInputsForPartialSig(this.data.inputs, 'setLocktime');\n    const c = this.__CACHE;\n    c.__TX.locktime = locktime;\n    c.__EXTRACTED_TX = undefined;\n    return this;\n  }\n  setInputSequence(inputIndex, sequence) {\n    check32Bit(sequence);\n    checkInputsForPartialSig(this.data.inputs, 'setInputSequence');\n    const c = this.__CACHE;\n    if (c.__TX.ins.length <= inputIndex) {\n      throw new Error('Input index too high');\n    }\n    c.__TX.ins[inputIndex].sequence = sequence;\n    c.__EXTRACTED_TX = undefined;\n    return this;\n  }\n  addInputs(inputDatas) {\n    inputDatas.forEach(inputData => this.addInput(inputData));\n    return this;\n  }\n  addInput(inputData) {\n    if (\n      arguments.length > 1 ||\n      !inputData ||\n      inputData.hash === undefined ||\n      inputData.index === undefined\n    ) {\n      throw new Error(\n        `Invalid arguments for Psbt.addInput. ` +\n          `Requires single object with at least [hash] and [index]`,\n      );\n    }\n    checkInputsForPartialSig(this.data.inputs, 'addInput');\n    if (inputData.witnessScript) checkInvalidP2WSH(inputData.witnessScript);\n    const c = this.__CACHE;\n    this.data.addInput(inputData);\n    const txIn = c.__TX.ins[c.__TX.ins.length - 1];\n    checkTxInputCache(c, txIn);\n    const inputIndex = this.data.inputs.length - 1;\n    const input = this.data.inputs[inputIndex];\n    if (input.nonWitnessUtxo) {\n      addNonWitnessTxCache(this.__CACHE, input, inputIndex);\n    }\n    c.__FEE = undefined;\n    c.__FEE_RATE = undefined;\n    c.__EXTRACTED_TX = undefined;\n    return this;\n  }\n  addOutputs(outputDatas) {\n    outputDatas.forEach(outputData => this.addOutput(outputData));\n    return this;\n  }\n  addOutput(outputData) {\n    if (\n      arguments.length > 1 ||\n      !outputData ||\n      outputData.value === undefined ||\n      (outputData.address === undefined && outputData.script === undefined)\n    ) {\n      throw new Error(\n        `Invalid arguments for Psbt.addOutput. ` +\n          `Requires single object with at least [script or address] and [value]`,\n      );\n    }\n    checkInputsForPartialSig(this.data.inputs, 'addOutput');\n    const { address } = outputData;\n    if (typeof address === 'string') {\n      const { network } = this.opts;\n      const script = address_1.toOutputScript(address, network);\n      outputData = Object.assign(outputData, { script });\n    }\n    const c = this.__CACHE;\n    this.data.addOutput(outputData);\n    c.__FEE = undefined;\n    c.__FEE_RATE = undefined;\n    c.__EXTRACTED_TX = undefined;\n    return this;\n  }\n  extractTransaction(disableFeeCheck) {\n    if (!this.data.inputs.every(isFinalized)) throw new Error('Not finalized');\n    const c = this.__CACHE;\n    if (!disableFeeCheck) {\n      checkFees(this, c, this.opts);\n    }\n    if (c.__EXTRACTED_TX) return c.__EXTRACTED_TX;\n    const tx = c.__TX.clone();\n    inputFinalizeGetAmts(this.data.inputs, tx, c, true);\n    return tx;\n  }\n  getFeeRate() {\n    return getTxCacheValue(\n      '__FEE_RATE',\n      'fee rate',\n      this.data.inputs,\n      this.__CACHE,\n    );\n  }\n  getFee() {\n    return getTxCacheValue('__FEE', 'fee', this.data.inputs, this.__CACHE);\n  }\n  finalizeAllInputs() {\n    utils_1.checkForInput(this.data.inputs, 0); // making sure we have at least one\n    range(this.data.inputs.length).forEach(idx => this.finalizeInput(idx));\n    return this;\n  }\n  finalizeInput(inputIndex, finalScriptsFunc = getFinalScripts) {\n    const input = utils_1.checkForInput(this.data.inputs, inputIndex);\n    const { script, isP2SH, isP2WSH, isSegwit } = getScriptFromInput(\n      inputIndex,\n      input,\n      this.__CACHE,\n    );\n    if (!script) throw new Error(`No script found for input #${inputIndex}`);\n    checkPartialSigSighashes(input);\n    const { finalScriptSig, finalScriptWitness } = finalScriptsFunc(\n      inputIndex,\n      input,\n      script,\n      isSegwit,\n      isP2SH,\n      isP2WSH,\n    );\n    if (finalScriptSig) this.data.updateInput(inputIndex, { finalScriptSig });\n    if (finalScriptWitness)\n      this.data.updateInput(inputIndex, { finalScriptWitness });\n    if (!finalScriptSig && !finalScriptWitness)\n      throw new Error(`Unknown error finalizing input #${inputIndex}`);\n    this.data.clearFinalizedInput(inputIndex);\n    return this;\n  }\n  getInputType(inputIndex) {\n    const input = utils_1.checkForInput(this.data.inputs, inputIndex);\n    const script = getScriptFromUtxo(inputIndex, input, this.__CACHE);\n    const result = getMeaningfulScript(\n      script,\n      inputIndex,\n      'input',\n      input.redeemScript || redeemFromFinalScriptSig(input.finalScriptSig),\n      input.witnessScript ||\n        redeemFromFinalWitnessScript(input.finalScriptWitness),\n    );\n    const type = result.type === 'raw' ? '' : result.type + '-';\n    const mainType = classifyScript(result.meaningfulScript);\n    return type + mainType;\n  }\n  inputHasPubkey(inputIndex, pubkey) {\n    const input = utils_1.checkForInput(this.data.inputs, inputIndex);\n    return pubkeyInInput(pubkey, input, inputIndex, this.__CACHE);\n  }\n  inputHasHDKey(inputIndex, root) {\n    const input = utils_1.checkForInput(this.data.inputs, inputIndex);\n    const derivationIsMine = bip32DerivationIsMine(root);\n    return (\n      !!input.bip32Derivation && input.bip32Derivation.some(derivationIsMine)\n    );\n  }\n  outputHasPubkey(outputIndex, pubkey) {\n    const output = utils_1.checkForOutput(this.data.outputs, outputIndex);\n    return pubkeyInOutput(pubkey, output, outputIndex, this.__CACHE);\n  }\n  outputHasHDKey(outputIndex, root) {\n    const output = utils_1.checkForOutput(this.data.outputs, outputIndex);\n    const derivationIsMine = bip32DerivationIsMine(root);\n    return (\n      !!output.bip32Derivation && output.bip32Derivation.some(derivationIsMine)\n    );\n  }\n  validateSignaturesOfAllInputs() {\n    utils_1.checkForInput(this.data.inputs, 0); // making sure we have at least one\n    const results = range(this.data.inputs.length).map(idx =>\n      this.validateSignaturesOfInput(idx),\n    );\n    return results.reduce((final, res) => res === true && final, true);\n  }\n  validateSignaturesOfInput(inputIndex, pubkey) {\n    const input = this.data.inputs[inputIndex];\n    const partialSig = (input || {}).partialSig;\n    if (!input || !partialSig || partialSig.length < 1)\n      throw new Error('No signatures to validate');\n    const mySigs = pubkey\n      ? partialSig.filter(sig => sig.pubkey.equals(pubkey))\n      : partialSig;\n    if (mySigs.length < 1) throw new Error('No signatures for this pubkey');\n    const results = [];\n    let hashCache;\n    let scriptCache;\n    let sighashCache;\n    for (const pSig of mySigs) {\n      const sig = bscript.signature.decode(pSig.signature);\n      const { hash, script } =\n        sighashCache !== sig.hashType\n          ? getHashForSig(\n              inputIndex,\n              Object.assign({}, input, { sighashType: sig.hashType }),\n              this.__CACHE,\n              true,\n            )\n          : { hash: hashCache, script: scriptCache };\n      sighashCache = sig.hashType;\n      hashCache = hash;\n      scriptCache = script;\n      checkScriptForPubkey(pSig.pubkey, script, 'verify');\n      const keypair = ecpair_1.fromPublicKey(pSig.pubkey);\n      results.push(keypair.verify(hash, sig.signature));\n    }\n    return results.every(res => res === true);\n  }\n  signAllInputsHD(\n    hdKeyPair,\n    sighashTypes = [transaction_1.Transaction.SIGHASH_ALL],\n  ) {\n    if (!hdKeyPair || !hdKeyPair.publicKey || !hdKeyPair.fingerprint) {\n      throw new Error('Need HDSigner to sign input');\n    }\n    const results = [];\n    for (const i of range(this.data.inputs.length)) {\n      try {\n        this.signInputHD(i, hdKeyPair, sighashTypes);\n        results.push(true);\n      } catch (err) {\n        results.push(false);\n      }\n    }\n    if (results.every(v => v === false)) {\n      throw new Error('No inputs were signed');\n    }\n    return this;\n  }\n  signAllInputsHDAsync(\n    hdKeyPair,\n    sighashTypes = [transaction_1.Transaction.SIGHASH_ALL],\n  ) {\n    return new Promise((resolve, reject) => {\n      if (!hdKeyPair || !hdKeyPair.publicKey || !hdKeyPair.fingerprint) {\n        return reject(new Error('Need HDSigner to sign input'));\n      }\n      const results = [];\n      const promises = [];\n      for (const i of range(this.data.inputs.length)) {\n        promises.push(\n          this.signInputHDAsync(i, hdKeyPair, sighashTypes).then(\n            () => {\n              results.push(true);\n            },\n            () => {\n              results.push(false);\n            },\n          ),\n        );\n      }\n      return Promise.all(promises).then(() => {\n        if (results.every(v => v === false)) {\n          return reject(new Error('No inputs were signed'));\n        }\n        resolve();\n      });\n    });\n  }\n  signInputHD(\n    inputIndex,\n    hdKeyPair,\n    sighashTypes = [transaction_1.Transaction.SIGHASH_ALL],\n  ) {\n    if (!hdKeyPair || !hdKeyPair.publicKey || !hdKeyPair.fingerprint) {\n      throw new Error('Need HDSigner to sign input');\n    }\n    const signers = getSignersFromHD(inputIndex, this.data.inputs, hdKeyPair);\n    signers.forEach(signer => this.signInput(inputIndex, signer, sighashTypes));\n    return this;\n  }\n  signInputHDAsync(\n    inputIndex,\n    hdKeyPair,\n    sighashTypes = [transaction_1.Transaction.SIGHASH_ALL],\n  ) {\n    return new Promise((resolve, reject) => {\n      if (!hdKeyPair || !hdKeyPair.publicKey || !hdKeyPair.fingerprint) {\n        return reject(new Error('Need HDSigner to sign input'));\n      }\n      const signers = getSignersFromHD(inputIndex, this.data.inputs, hdKeyPair);\n      const promises = signers.map(signer =>\n        this.signInputAsync(inputIndex, signer, sighashTypes),\n      );\n      return Promise.all(promises)\n        .then(() => {\n          resolve();\n        })\n        .catch(reject);\n    });\n  }\n  signAllInputs(\n    keyPair,\n    sighashTypes = [transaction_1.Transaction.SIGHASH_ALL],\n  ) {\n    if (!keyPair || !keyPair.publicKey)\n      throw new Error('Need Signer to sign input');\n    // TODO: Add a pubkey/pubkeyhash cache to each input\n    // as input information is added, then eventually\n    // optimize this method.\n    const results = [];\n    for (const i of range(this.data.inputs.length)) {\n      try {\n        this.signInput(i, keyPair, sighashTypes);\n        results.push(true);\n      } catch (err) {\n        results.push(false);\n      }\n    }\n    if (results.every(v => v === false)) {\n      throw new Error('No inputs were signed');\n    }\n    return this;\n  }\n  signAllInputsAsync(\n    keyPair,\n    sighashTypes = [transaction_1.Transaction.SIGHASH_ALL],\n  ) {\n    return new Promise((resolve, reject) => {\n      if (!keyPair || !keyPair.publicKey)\n        return reject(new Error('Need Signer to sign input'));\n      // TODO: Add a pubkey/pubkeyhash cache to each input\n      // as input information is added, then eventually\n      // optimize this method.\n      const results = [];\n      const promises = [];\n      for (const [i] of this.data.inputs.entries()) {\n        promises.push(\n          this.signInputAsync(i, keyPair, sighashTypes).then(\n            () => {\n              results.push(true);\n            },\n            () => {\n              results.push(false);\n            },\n          ),\n        );\n      }\n      return Promise.all(promises).then(() => {\n        if (results.every(v => v === false)) {\n          return reject(new Error('No inputs were signed'));\n        }\n        resolve();\n      });\n    });\n  }\n  signInput(\n    inputIndex,\n    keyPair,\n    sighashTypes = [transaction_1.Transaction.SIGHASH_ALL],\n  ) {\n    if (!keyPair || !keyPair.publicKey)\n      throw new Error('Need Signer to sign input');\n    const { hash, sighashType } = getHashAndSighashType(\n      this.data.inputs,\n      inputIndex,\n      keyPair.publicKey,\n      this.__CACHE,\n      sighashTypes,\n    );\n    const partialSig = [\n      {\n        pubkey: keyPair.publicKey,\n        signature: bscript.signature.encode(keyPair.sign(hash), sighashType),\n      },\n    ];\n    this.data.updateInput(inputIndex, { partialSig });\n    return this;\n  }\n  signInputAsync(\n    inputIndex,\n    keyPair,\n    sighashTypes = [transaction_1.Transaction.SIGHASH_ALL],\n  ) {\n    return Promise.resolve().then(() => {\n      if (!keyPair || !keyPair.publicKey)\n        throw new Error('Need Signer to sign input');\n      const { hash, sighashType } = getHashAndSighashType(\n        this.data.inputs,\n        inputIndex,\n        keyPair.publicKey,\n        this.__CACHE,\n        sighashTypes,\n      );\n      return Promise.resolve(keyPair.sign(hash)).then(signature => {\n        const partialSig = [\n          {\n            pubkey: keyPair.publicKey,\n            signature: bscript.signature.encode(signature, sighashType),\n          },\n        ];\n        this.data.updateInput(inputIndex, { partialSig });\n      });\n    });\n  }\n  toBuffer() {\n    checkCache(this.__CACHE);\n    return this.data.toBuffer();\n  }\n  toHex() {\n    checkCache(this.__CACHE);\n    return this.data.toHex();\n  }\n  toBase64() {\n    checkCache(this.__CACHE);\n    return this.data.toBase64();\n  }\n  updateGlobal(updateData) {\n    this.data.updateGlobal(updateData);\n    return this;\n  }\n  updateInput(inputIndex, updateData) {\n    if (updateData.witnessScript) checkInvalidP2WSH(updateData.witnessScript);\n    this.data.updateInput(inputIndex, updateData);\n    if (updateData.nonWitnessUtxo) {\n      addNonWitnessTxCache(\n        this.__CACHE,\n        this.data.inputs[inputIndex],\n        inputIndex,\n      );\n    }\n    return this;\n  }\n  updateOutput(outputIndex, updateData) {\n    this.data.updateOutput(outputIndex, updateData);\n    return this;\n  }\n  addUnknownKeyValToGlobal(keyVal) {\n    this.data.addUnknownKeyValToGlobal(keyVal);\n    return this;\n  }\n  addUnknownKeyValToInput(inputIndex, keyVal) {\n    this.data.addUnknownKeyValToInput(inputIndex, keyVal);\n    return this;\n  }\n  addUnknownKeyValToOutput(outputIndex, keyVal) {\n    this.data.addUnknownKeyValToOutput(outputIndex, keyVal);\n    return this;\n  }\n  clearFinalizedInput(inputIndex) {\n    this.data.clearFinalizedInput(inputIndex);\n    return this;\n  }\n}\nexports.Psbt = Psbt;\n/**\n * This function is needed to pass to the bip174 base class's fromBuffer.\n * It takes the \"transaction buffer\" portion of the psbt buffer and returns a\n * Transaction (From the bip174 library) interface.\n */\nconst transactionFromBuffer = buffer => new PsbtTransaction(buffer);\n/**\n * This class implements the Transaction interface from bip174 library.\n * It contains a bitcoinjs-lib Transaction object.\n */\nclass PsbtTransaction {\n  constructor(buffer = Buffer.from([2, 0, 0, 0, 0, 0, 0, 0, 0, 0])) {\n    this.tx = transaction_1.Transaction.fromBuffer(buffer);\n    checkTxEmpty(this.tx);\n    Object.defineProperty(this, 'tx', {\n      enumerable: false,\n      writable: true,\n    });\n  }\n  getInputOutputCounts() {\n    return {\n      inputCount: this.tx.ins.length,\n      outputCount: this.tx.outs.length,\n    };\n  }\n  addInput(input) {\n    if (\n      input.hash === undefined ||\n      input.index === undefined ||\n      (!Buffer.isBuffer(input.hash) && typeof input.hash !== 'string') ||\n      typeof input.index !== 'number'\n    ) {\n      throw new Error('Error adding input.');\n    }\n    const hash =\n      typeof input.hash === 'string'\n        ? bufferutils_1.reverseBuffer(Buffer.from(input.hash, 'hex'))\n        : input.hash;\n    this.tx.addInput(hash, input.index, input.sequence);\n  }\n  addOutput(output) {\n    if (\n      output.script === undefined ||\n      output.value === undefined ||\n      !Buffer.isBuffer(output.script) ||\n      typeof output.value !== 'number'\n    ) {\n      throw new Error('Error adding output.');\n    }\n    this.tx.addOutput(output.script, output.value);\n  }\n  toBuffer() {\n    return this.tx.toBuffer();\n  }\n}\nfunction canFinalize(input, script, scriptType) {\n  switch (scriptType) {\n    case 'pubkey':\n    case 'pubkeyhash':\n    case 'witnesspubkeyhash':\n      return hasSigs(1, input.partialSig);\n    case 'multisig':\n      const p2ms = payments.p2ms({ output: script });\n      return hasSigs(p2ms.m, input.partialSig, p2ms.pubkeys);\n    default:\n      return false;\n  }\n}\nfunction checkCache(cache) {\n  if (cache.__UNSAFE_SIGN_NONSEGWIT !== false) {\n    throw new Error('Not BIP174 compliant, can not export');\n  }\n}\nfunction hasSigs(neededSigs, partialSig, pubkeys) {\n  if (!partialSig) return false;\n  let sigs;\n  if (pubkeys) {\n    sigs = pubkeys\n      .map(pkey => {\n        const pubkey = ecpair_1.fromPublicKey(pkey, { compressed: true })\n          .publicKey;\n        return partialSig.find(pSig => pSig.pubkey.equals(pubkey));\n      })\n      .filter(v => !!v);\n  } else {\n    sigs = partialSig;\n  }\n  if (sigs.length > neededSigs) throw new Error('Too many signatures');\n  return sigs.length === neededSigs;\n}\nfunction isFinalized(input) {\n  return !!input.finalScriptSig || !!input.finalScriptWitness;\n}\nfunction isPaymentFactory(payment) {\n  return script => {\n    try {\n      payment({ output: script });\n      return true;\n    } catch (err) {\n      return false;\n    }\n  };\n}\nconst isP2MS = isPaymentFactory(payments.p2ms);\nconst isP2PK = isPaymentFactory(payments.p2pk);\nconst isP2PKH = isPaymentFactory(payments.p2pkh);\nconst isP2WPKH = isPaymentFactory(payments.p2wpkh);\nconst isP2WSHScript = isPaymentFactory(payments.p2wsh);\nconst isP2SHScript = isPaymentFactory(payments.p2sh);\nfunction bip32DerivationIsMine(root) {\n  return d => {\n    if (!d.masterFingerprint.equals(root.fingerprint)) return false;\n    if (!root.derivePath(d.path).publicKey.equals(d.pubkey)) return false;\n    return true;\n  };\n}\nfunction check32Bit(num) {\n  if (\n    typeof num !== 'number' ||\n    num !== Math.floor(num) ||\n    num > 0xffffffff ||\n    num < 0\n  ) {\n    throw new Error('Invalid 32 bit integer');\n  }\n}\nfunction checkFees(psbt, cache, opts) {\n  const feeRate = cache.__FEE_RATE || psbt.getFeeRate();\n  const vsize = cache.__EXTRACTED_TX.virtualSize();\n  const satoshis = feeRate * vsize;\n  if (feeRate >= opts.maximumFeeRate) {\n    throw new Error(\n      `Warning: You are paying around ${(satoshis / 1e8).toFixed(8)} in ` +\n        `fees, which is ${feeRate} satoshi per byte for a transaction ` +\n        `with a VSize of ${vsize} bytes (segwit counted as 0.25 byte per ` +\n        `byte). Use setMaximumFeeRate method to raise your threshold, or ` +\n        `pass true to the first arg of extractTransaction.`,\n    );\n  }\n}\nfunction checkInputsForPartialSig(inputs, action) {\n  inputs.forEach(input => {\n    let throws = false;\n    let pSigs = [];\n    if ((input.partialSig || []).length === 0) {\n      if (!input.finalScriptSig && !input.finalScriptWitness) return;\n      pSigs = getPsigsFromInputFinalScripts(input);\n    } else {\n      pSigs = input.partialSig;\n    }\n    pSigs.forEach(pSig => {\n      const { hashType } = bscript.signature.decode(pSig.signature);\n      const whitelist = [];\n      const isAnyoneCanPay =\n        hashType & transaction_1.Transaction.SIGHASH_ANYONECANPAY;\n      if (isAnyoneCanPay) whitelist.push('addInput');\n      const hashMod = hashType & 0x1f;\n      switch (hashMod) {\n        case transaction_1.Transaction.SIGHASH_ALL:\n          break;\n        case transaction_1.Transaction.SIGHASH_SINGLE:\n        case transaction_1.Transaction.SIGHASH_NONE:\n          whitelist.push('addOutput');\n          whitelist.push('setInputSequence');\n          break;\n      }\n      if (whitelist.indexOf(action) === -1) {\n        throws = true;\n      }\n    });\n    if (throws) {\n      throw new Error('Can not modify transaction, signatures exist.');\n    }\n  });\n}\nfunction checkPartialSigSighashes(input) {\n  if (!input.sighashType || !input.partialSig) return;\n  const { partialSig, sighashType } = input;\n  partialSig.forEach(pSig => {\n    const { hashType } = bscript.signature.decode(pSig.signature);\n    if (sighashType !== hashType) {\n      throw new Error('Signature sighash does not match input sighash type');\n    }\n  });\n}\nfunction checkScriptForPubkey(pubkey, script, action) {\n  if (!pubkeyInScript(pubkey, script)) {\n    throw new Error(\n      `Can not ${action} for this input with the key ${pubkey.toString('hex')}`,\n    );\n  }\n}\nfunction checkTxEmpty(tx) {\n  const isEmpty = tx.ins.every(\n    input =>\n      input.script &&\n      input.script.length === 0 &&\n      input.witness &&\n      input.witness.length === 0,\n  );\n  if (!isEmpty) {\n    throw new Error('Format Error: Transaction ScriptSigs are not empty');\n  }\n}\nfunction checkTxForDupeIns(tx, cache) {\n  tx.ins.forEach(input => {\n    checkTxInputCache(cache, input);\n  });\n}\nfunction checkTxInputCache(cache, input) {\n  const key =\n    bufferutils_1.reverseBuffer(Buffer.from(input.hash)).toString('hex') +\n    ':' +\n    input.index;\n  if (cache.__TX_IN_CACHE[key]) throw new Error('Duplicate input detected.');\n  cache.__TX_IN_CACHE[key] = 1;\n}\nfunction scriptCheckerFactory(payment, paymentScriptName) {\n  return (inputIndex, scriptPubKey, redeemScript, ioType) => {\n    const redeemScriptOutput = payment({\n      redeem: { output: redeemScript },\n    }).output;\n    if (!scriptPubKey.equals(redeemScriptOutput)) {\n      throw new Error(\n        `${paymentScriptName} for ${ioType} #${inputIndex} doesn't match the scriptPubKey in the prevout`,\n      );\n    }\n  };\n}\nconst checkRedeemScript = scriptCheckerFactory(payments.p2sh, 'Redeem script');\nconst checkWitnessScript = scriptCheckerFactory(\n  payments.p2wsh,\n  'Witness script',\n);\nfunction getTxCacheValue(key, name, inputs, c) {\n  if (!inputs.every(isFinalized))\n    throw new Error(`PSBT must be finalized to calculate ${name}`);\n  if (key === '__FEE_RATE' && c.__FEE_RATE) return c.__FEE_RATE;\n  if (key === '__FEE' && c.__FEE) return c.__FEE;\n  let tx;\n  let mustFinalize = true;\n  if (c.__EXTRACTED_TX) {\n    tx = c.__EXTRACTED_TX;\n    mustFinalize = false;\n  } else {\n    tx = c.__TX.clone();\n  }\n  inputFinalizeGetAmts(inputs, tx, c, mustFinalize);\n  if (key === '__FEE_RATE') return c.__FEE_RATE;\n  else if (key === '__FEE') return c.__FEE;\n}\nfunction getFinalScripts(inputIndex, input, script, isSegwit, isP2SH, isP2WSH) {\n  const scriptType = classifyScript(script);\n  if (!canFinalize(input, script, scriptType))\n    throw new Error(`Can not finalize input #${inputIndex}`);\n  return prepareFinalScripts(\n    script,\n    scriptType,\n    input.partialSig,\n    isSegwit,\n    isP2SH,\n    isP2WSH,\n  );\n}\nfunction prepareFinalScripts(\n  script,\n  scriptType,\n  partialSig,\n  isSegwit,\n  isP2SH,\n  isP2WSH,\n) {\n  let finalScriptSig;\n  let finalScriptWitness;\n  // Wow, the payments API is very handy\n  const payment = getPayment(script, scriptType, partialSig);\n  const p2wsh = !isP2WSH ? null : payments.p2wsh({ redeem: payment });\n  const p2sh = !isP2SH ? null : payments.p2sh({ redeem: p2wsh || payment });\n  if (isSegwit) {\n    if (p2wsh) {\n      finalScriptWitness = witnessStackToScriptWitness(p2wsh.witness);\n    } else {\n      finalScriptWitness = witnessStackToScriptWitness(payment.witness);\n    }\n    if (p2sh) {\n      finalScriptSig = p2sh.input;\n    }\n  } else {\n    if (p2sh) {\n      finalScriptSig = p2sh.input;\n    } else {\n      finalScriptSig = payment.input;\n    }\n  }\n  return {\n    finalScriptSig,\n    finalScriptWitness,\n  };\n}\nfunction getHashAndSighashType(\n  inputs,\n  inputIndex,\n  pubkey,\n  cache,\n  sighashTypes,\n) {\n  const input = utils_1.checkForInput(inputs, inputIndex);\n  const { hash, sighashType, script } = getHashForSig(\n    inputIndex,\n    input,\n    cache,\n    false,\n    sighashTypes,\n  );\n  checkScriptForPubkey(pubkey, script, 'sign');\n  return {\n    hash,\n    sighashType,\n  };\n}\nfunction getHashForSig(inputIndex, input, cache, forValidate, sighashTypes) {\n  const unsignedTx = cache.__TX;\n  const sighashType =\n    input.sighashType || transaction_1.Transaction.SIGHASH_ALL;\n  if (sighashTypes && sighashTypes.indexOf(sighashType) < 0) {\n    const str = sighashTypeToString(sighashType);\n    throw new Error(\n      `Sighash type is not allowed. Retry the sign method passing the ` +\n        `sighashTypes array of whitelisted types. Sighash type: ${str}`,\n    );\n  }\n  let hash;\n  let prevout;\n  if (input.nonWitnessUtxo) {\n    const nonWitnessUtxoTx = nonWitnessUtxoTxFromCache(\n      cache,\n      input,\n      inputIndex,\n    );\n    const prevoutHash = unsignedTx.ins[inputIndex].hash;\n    const utxoHash = nonWitnessUtxoTx.getHash();\n    // If a non-witness UTXO is provided, its hash must match the hash specified in the prevout\n    if (!prevoutHash.equals(utxoHash)) {\n      throw new Error(\n        `Non-witness UTXO hash for input #${inputIndex} doesn't match the hash specified in the prevout`,\n      );\n    }\n    const prevoutIndex = unsignedTx.ins[inputIndex].index;\n    prevout = nonWitnessUtxoTx.outs[prevoutIndex];\n  } else if (input.witnessUtxo) {\n    prevout = input.witnessUtxo;\n  } else {\n    throw new Error('Need a Utxo input item for signing');\n  }\n  const { meaningfulScript, type } = getMeaningfulScript(\n    prevout.script,\n    inputIndex,\n    'input',\n    input.redeemScript,\n    input.witnessScript,\n  );\n  if (['p2sh-p2wsh', 'p2wsh'].indexOf(type) >= 0) {\n    hash = unsignedTx.hashForWitnessV0(\n      inputIndex,\n      meaningfulScript,\n      prevout.value,\n      sighashType,\n    );\n  } else if (isP2WPKH(meaningfulScript)) {\n    // P2WPKH uses the P2PKH template for prevoutScript when signing\n    const signingScript = payments.p2pkh({ hash: meaningfulScript.slice(2) })\n      .output;\n    hash = unsignedTx.hashForWitnessV0(\n      inputIndex,\n      signingScript,\n      prevout.value,\n      sighashType,\n    );\n  } else {\n    // non-segwit\n    if (\n      input.nonWitnessUtxo === undefined &&\n      cache.__UNSAFE_SIGN_NONSEGWIT === false\n    )\n      throw new Error(\n        `Input #${inputIndex} has witnessUtxo but non-segwit script: ` +\n          `${meaningfulScript.toString('hex')}`,\n      );\n    if (!forValidate && cache.__UNSAFE_SIGN_NONSEGWIT !== false)\n      console.warn(\n        'Warning: Signing non-segwit inputs without the full parent transaction ' +\n          'means there is a chance that a miner could feed you incorrect information ' +\n          'to trick you into paying large fees. This behavior is the same as the old ' +\n          'TransactionBuilder class when signing non-segwit scripts. You are not ' +\n          'able to export this Psbt with toBuffer|toBase64|toHex since it is not ' +\n          'BIP174 compliant.\\n*********************\\nPROCEED WITH CAUTION!\\n' +\n          '*********************',\n      );\n    hash = unsignedTx.hashForSignature(\n      inputIndex,\n      meaningfulScript,\n      sighashType,\n    );\n  }\n  return {\n    script: meaningfulScript,\n    sighashType,\n    hash,\n  };\n}\nfunction getPayment(script, scriptType, partialSig) {\n  let payment;\n  switch (scriptType) {\n    case 'multisig':\n      const sigs = getSortedSigs(script, partialSig);\n      payment = payments.p2ms({\n        output: script,\n        signatures: sigs,\n      });\n      break;\n    case 'pubkey':\n      payment = payments.p2pk({\n        output: script,\n        signature: partialSig[0].signature,\n      });\n      break;\n    case 'pubkeyhash':\n      payment = payments.p2pkh({\n        output: script,\n        pubkey: partialSig[0].pubkey,\n        signature: partialSig[0].signature,\n      });\n      break;\n    case 'witnesspubkeyhash':\n      payment = payments.p2wpkh({\n        output: script,\n        pubkey: partialSig[0].pubkey,\n        signature: partialSig[0].signature,\n      });\n      break;\n  }\n  return payment;\n}\nfunction getPsigsFromInputFinalScripts(input) {\n  const scriptItems = !input.finalScriptSig\n    ? []\n    : bscript.decompile(input.finalScriptSig) || [];\n  const witnessItems = !input.finalScriptWitness\n    ? []\n    : bscript.decompile(input.finalScriptWitness) || [];\n  return scriptItems\n    .concat(witnessItems)\n    .filter(item => {\n      return Buffer.isBuffer(item) && bscript.isCanonicalScriptSignature(item);\n    })\n    .map(sig => ({ signature: sig }));\n}\nfunction getScriptFromInput(inputIndex, input, cache) {\n  const unsignedTx = cache.__TX;\n  const res = {\n    script: null,\n    isSegwit: false,\n    isP2SH: false,\n    isP2WSH: false,\n  };\n  res.isP2SH = !!input.redeemScript;\n  res.isP2WSH = !!input.witnessScript;\n  if (input.witnessScript) {\n    res.script = input.witnessScript;\n  } else if (input.redeemScript) {\n    res.script = input.redeemScript;\n  } else {\n    if (input.nonWitnessUtxo) {\n      const nonWitnessUtxoTx = nonWitnessUtxoTxFromCache(\n        cache,\n        input,\n        inputIndex,\n      );\n      const prevoutIndex = unsignedTx.ins[inputIndex].index;\n      res.script = nonWitnessUtxoTx.outs[prevoutIndex].script;\n    } else if (input.witnessUtxo) {\n      res.script = input.witnessUtxo.script;\n    }\n  }\n  if (input.witnessScript || isP2WPKH(res.script)) {\n    res.isSegwit = true;\n  }\n  return res;\n}\nfunction getSignersFromHD(inputIndex, inputs, hdKeyPair) {\n  const input = utils_1.checkForInput(inputs, inputIndex);\n  if (!input.bip32Derivation || input.bip32Derivation.length === 0) {\n    throw new Error('Need bip32Derivation to sign with HD');\n  }\n  const myDerivations = input.bip32Derivation\n    .map(bipDv => {\n      if (bipDv.masterFingerprint.equals(hdKeyPair.fingerprint)) {\n        return bipDv;\n      } else {\n        return;\n      }\n    })\n    .filter(v => !!v);\n  if (myDerivations.length === 0) {\n    throw new Error(\n      'Need one bip32Derivation masterFingerprint to match the HDSigner fingerprint',\n    );\n  }\n  const signers = myDerivations.map(bipDv => {\n    const node = hdKeyPair.derivePath(bipDv.path);\n    if (!bipDv.pubkey.equals(node.publicKey)) {\n      throw new Error('pubkey did not match bip32Derivation');\n    }\n    return node;\n  });\n  return signers;\n}\nfunction getSortedSigs(script, partialSig) {\n  const p2ms = payments.p2ms({ output: script });\n  // for each pubkey in order of p2ms script\n  return p2ms.pubkeys\n    .map(pk => {\n      // filter partialSig array by pubkey being equal\n      return (\n        partialSig.filter(ps => {\n          return ps.pubkey.equals(pk);\n        })[0] || {}\n      ).signature;\n      // Any pubkey without a match will return undefined\n      // this last filter removes all the undefined items in the array.\n    })\n    .filter(v => !!v);\n}\nfunction scriptWitnessToWitnessStack(buffer) {\n  let offset = 0;\n  function readSlice(n) {\n    offset += n;\n    return buffer.slice(offset - n, offset);\n  }\n  function readVarInt() {\n    const vi = varuint.decode(buffer, offset);\n    offset += varuint.decode.bytes;\n    return vi;\n  }\n  function readVarSlice() {\n    return readSlice(readVarInt());\n  }\n  function readVector() {\n    const count = readVarInt();\n    const vector = [];\n    for (let i = 0; i < count; i++) vector.push(readVarSlice());\n    return vector;\n  }\n  return readVector();\n}\nfunction sighashTypeToString(sighashType) {\n  let text =\n    sighashType & transaction_1.Transaction.SIGHASH_ANYONECANPAY\n      ? 'SIGHASH_ANYONECANPAY | '\n      : '';\n  const sigMod = sighashType & 0x1f;\n  switch (sigMod) {\n    case transaction_1.Transaction.SIGHASH_ALL:\n      text += 'SIGHASH_ALL';\n      break;\n    case transaction_1.Transaction.SIGHASH_SINGLE:\n      text += 'SIGHASH_SINGLE';\n      break;\n    case transaction_1.Transaction.SIGHASH_NONE:\n      text += 'SIGHASH_NONE';\n      break;\n  }\n  return text;\n}\nfunction witnessStackToScriptWitness(witness) {\n  let buffer = Buffer.allocUnsafe(0);\n  function writeSlice(slice) {\n    buffer = Buffer.concat([buffer, Buffer.from(slice)]);\n  }\n  function writeVarInt(i) {\n    const currentLen = buffer.length;\n    const varintLen = varuint.encodingLength(i);\n    buffer = Buffer.concat([buffer, Buffer.allocUnsafe(varintLen)]);\n    varuint.encode(i, buffer, currentLen);\n  }\n  function writeVarSlice(slice) {\n    writeVarInt(slice.length);\n    writeSlice(slice);\n  }\n  function writeVector(vector) {\n    writeVarInt(vector.length);\n    vector.forEach(writeVarSlice);\n  }\n  writeVector(witness);\n  return buffer;\n}\nfunction addNonWitnessTxCache(cache, input, inputIndex) {\n  cache.__NON_WITNESS_UTXO_BUF_CACHE[inputIndex] = input.nonWitnessUtxo;\n  const tx = transaction_1.Transaction.fromBuffer(input.nonWitnessUtxo);\n  cache.__NON_WITNESS_UTXO_TX_CACHE[inputIndex] = tx;\n  const self = cache;\n  const selfIndex = inputIndex;\n  delete input.nonWitnessUtxo;\n  Object.defineProperty(input, 'nonWitnessUtxo', {\n    enumerable: true,\n    get() {\n      const buf = self.__NON_WITNESS_UTXO_BUF_CACHE[selfIndex];\n      const txCache = self.__NON_WITNESS_UTXO_TX_CACHE[selfIndex];\n      if (buf !== undefined) {\n        return buf;\n      } else {\n        const newBuf = txCache.toBuffer();\n        self.__NON_WITNESS_UTXO_BUF_CACHE[selfIndex] = newBuf;\n        return newBuf;\n      }\n    },\n    set(data) {\n      self.__NON_WITNESS_UTXO_BUF_CACHE[selfIndex] = data;\n    },\n  });\n}\nfunction inputFinalizeGetAmts(inputs, tx, cache, mustFinalize) {\n  let inputAmount = 0;\n  inputs.forEach((input, idx) => {\n    if (mustFinalize && input.finalScriptSig)\n      tx.ins[idx].script = input.finalScriptSig;\n    if (mustFinalize && input.finalScriptWitness) {\n      tx.ins[idx].witness = scriptWitnessToWitnessStack(\n        input.finalScriptWitness,\n      );\n    }\n    if (input.witnessUtxo) {\n      inputAmount += input.witnessUtxo.value;\n    } else if (input.nonWitnessUtxo) {\n      const nwTx = nonWitnessUtxoTxFromCache(cache, input, idx);\n      const vout = tx.ins[idx].index;\n      const out = nwTx.outs[vout];\n      inputAmount += out.value;\n    }\n  });\n  const outputAmount = tx.outs.reduce((total, o) => total + o.value, 0);\n  const fee = inputAmount - outputAmount;\n  if (fee < 0) {\n    throw new Error('Outputs are spending more than Inputs');\n  }\n  const bytes = tx.virtualSize();\n  cache.__FEE = fee;\n  cache.__EXTRACTED_TX = tx;\n  cache.__FEE_RATE = Math.floor(fee / bytes);\n}\nfunction nonWitnessUtxoTxFromCache(cache, input, inputIndex) {\n  const c = cache.__NON_WITNESS_UTXO_TX_CACHE;\n  if (!c[inputIndex]) {\n    addNonWitnessTxCache(cache, input, inputIndex);\n  }\n  return c[inputIndex];\n}\nfunction getScriptFromUtxo(inputIndex, input, cache) {\n  if (input.witnessUtxo !== undefined) {\n    return input.witnessUtxo.script;\n  } else if (input.nonWitnessUtxo !== undefined) {\n    const nonWitnessUtxoTx = nonWitnessUtxoTxFromCache(\n      cache,\n      input,\n      inputIndex,\n    );\n    return nonWitnessUtxoTx.outs[cache.__TX.ins[inputIndex].index].script;\n  } else {\n    throw new Error(\"Can't find pubkey in input without Utxo data\");\n  }\n}\nfunction pubkeyInInput(pubkey, input, inputIndex, cache) {\n  const script = getScriptFromUtxo(inputIndex, input, cache);\n  const { meaningfulScript } = getMeaningfulScript(\n    script,\n    inputIndex,\n    'input',\n    input.redeemScript,\n    input.witnessScript,\n  );\n  return pubkeyInScript(pubkey, meaningfulScript);\n}\nfunction pubkeyInOutput(pubkey, output, outputIndex, cache) {\n  const script = cache.__TX.outs[outputIndex].script;\n  const { meaningfulScript } = getMeaningfulScript(\n    script,\n    outputIndex,\n    'output',\n    output.redeemScript,\n    output.witnessScript,\n  );\n  return pubkeyInScript(pubkey, meaningfulScript);\n}\nfunction redeemFromFinalScriptSig(finalScript) {\n  if (!finalScript) return;\n  const decomp = bscript.decompile(finalScript);\n  if (!decomp) return;\n  const lastItem = decomp[decomp.length - 1];\n  if (\n    !Buffer.isBuffer(lastItem) ||\n    isPubkeyLike(lastItem) ||\n    isSigLike(lastItem)\n  )\n    return;\n  const sDecomp = bscript.decompile(lastItem);\n  if (!sDecomp) return;\n  return lastItem;\n}\nfunction redeemFromFinalWitnessScript(finalScript) {\n  if (!finalScript) return;\n  const decomp = scriptWitnessToWitnessStack(finalScript);\n  const lastItem = decomp[decomp.length - 1];\n  if (isPubkeyLike(lastItem)) return;\n  const sDecomp = bscript.decompile(lastItem);\n  if (!sDecomp) return;\n  return lastItem;\n}\nfunction isPubkeyLike(buf) {\n  return buf.length === 33 && bscript.isCanonicalPubKey(buf);\n}\nfunction isSigLike(buf) {\n  return bscript.isCanonicalScriptSignature(buf);\n}\nfunction getMeaningfulScript(\n  script,\n  index,\n  ioType,\n  redeemScript,\n  witnessScript,\n) {\n  const isP2SH = isP2SHScript(script);\n  const isP2SHP2WSH = isP2SH && redeemScript && isP2WSHScript(redeemScript);\n  const isP2WSH = isP2WSHScript(script);\n  if (isP2SH && redeemScript === undefined)\n    throw new Error('scriptPubkey is P2SH but redeemScript missing');\n  if ((isP2WSH || isP2SHP2WSH) && witnessScript === undefined)\n    throw new Error(\n      'scriptPubkey or redeemScript is P2WSH but witnessScript missing',\n    );\n  let meaningfulScript;\n  if (isP2SHP2WSH) {\n    meaningfulScript = witnessScript;\n    checkRedeemScript(index, script, redeemScript, ioType);\n    checkWitnessScript(index, redeemScript, witnessScript, ioType);\n    checkInvalidP2WSH(meaningfulScript);\n  } else if (isP2WSH) {\n    meaningfulScript = witnessScript;\n    checkWitnessScript(index, script, witnessScript, ioType);\n    checkInvalidP2WSH(meaningfulScript);\n  } else if (isP2SH) {\n    meaningfulScript = redeemScript;\n    checkRedeemScript(index, script, redeemScript, ioType);\n  } else {\n    meaningfulScript = script;\n  }\n  return {\n    meaningfulScript,\n    type: isP2SHP2WSH\n      ? 'p2sh-p2wsh'\n      : isP2SH\n      ? 'p2sh'\n      : isP2WSH\n      ? 'p2wsh'\n      : 'raw',\n  };\n}\nfunction checkInvalidP2WSH(script) {\n  if (isP2WPKH(script) || isP2SHScript(script)) {\n    throw new Error('P2WPKH or P2SH can not be contained within P2WSH');\n  }\n}\nfunction pubkeyInScript(pubkey, script) {\n  const pubkeyHash = crypto_1.hash160(pubkey);\n  const decompiled = bscript.decompile(script);\n  if (decompiled === null) throw new Error('Unknown script error');\n  return decompiled.some(element => {\n    if (typeof element === 'number') return false;\n    return element.equals(pubkey) || element.equals(pubkeyHash);\n  });\n}\nfunction classifyScript(script) {\n  if (isP2WPKH(script)) return 'witnesspubkeyhash';\n  if (isP2PKH(script)) return 'pubkeyhash';\n  if (isP2MS(script)) return 'multisig';\n  if (isP2PK(script)) return 'pubkey';\n  return 'nonstandard';\n}\nfunction range(n) {\n  return [...Array(n).keys()];\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}