{"ast":null,"code":"/*!\n * URI.js - Mutating URLs\n * URI Template Support - http://tools.ietf.org/html/rfc6570\n *\n * Version: 1.19.11\n *\n * Author: Rodney Rehm\n * Web: http://medialize.github.io/URI.js/\n *\n * Licensed under\n *   MIT License http://www.opensource.org/licenses/mit-license\n *\n */\n(function (root, factory) {\n  'use strict'; // https://github.com/umdjs/umd/blob/master/returnExports.js\n\n  if (typeof module === 'object' && module.exports) {\n    // Node\n    module.exports = factory(require('./URI'));\n  } else if (typeof define === 'function' && define.amd) {\n    // AMD. Register as an anonymous module.\n    define(['./URI'], factory);\n  } else {\n    // Browser globals (root is window)\n    root.URITemplate = factory(root.URI, root);\n  }\n})(this, function (URI, root) {\n  'use strict'; // FIXME: v2.0.0 renamce non-camelCase properties to uppercase\n\n  /*jshint camelcase: false */\n  // save current URITemplate variable, if any\n\n  var _URITemplate = root && root.URITemplate;\n\n  var hasOwn = Object.prototype.hasOwnProperty;\n\n  function URITemplate(expression) {\n    // serve from cache where possible\n    if (URITemplate._cache[expression]) {\n      return URITemplate._cache[expression];\n    } // Allow instantiation without the 'new' keyword\n\n\n    if (!(this instanceof URITemplate)) {\n      return new URITemplate(expression);\n    }\n\n    this.expression = expression;\n    URITemplate._cache[expression] = this;\n    return this;\n  }\n\n  function Data(data) {\n    this.data = data;\n    this.cache = {};\n  }\n\n  var p = URITemplate.prototype; // list of operators and their defined options\n\n  var operators = {\n    // Simple string expansion\n    '': {\n      prefix: '',\n      separator: ',',\n      named: false,\n      empty_name_separator: false,\n      encode: 'encode'\n    },\n    // Reserved character strings\n    '+': {\n      prefix: '',\n      separator: ',',\n      named: false,\n      empty_name_separator: false,\n      encode: 'encodeReserved'\n    },\n    // Fragment identifiers prefixed by '#'\n    '#': {\n      prefix: '#',\n      separator: ',',\n      named: false,\n      empty_name_separator: false,\n      encode: 'encodeReserved'\n    },\n    // Name labels or extensions prefixed by '.'\n    '.': {\n      prefix: '.',\n      separator: '.',\n      named: false,\n      empty_name_separator: false,\n      encode: 'encode'\n    },\n    // Path segments prefixed by '/'\n    '/': {\n      prefix: '/',\n      separator: '/',\n      named: false,\n      empty_name_separator: false,\n      encode: 'encode'\n    },\n    // Path parameter name or name=value pairs prefixed by ';'\n    ';': {\n      prefix: ';',\n      separator: ';',\n      named: true,\n      empty_name_separator: false,\n      encode: 'encode'\n    },\n    // Query component beginning with '?' and consisting\n    // of name=value pairs separated by '&'; an\n    '?': {\n      prefix: '?',\n      separator: '&',\n      named: true,\n      empty_name_separator: true,\n      encode: 'encode'\n    },\n    // Continuation of query-style &name=value pairs\n    // within a literal query component.\n    '&': {\n      prefix: '&',\n      separator: '&',\n      named: true,\n      empty_name_separator: true,\n      encode: 'encode'\n    } // The operator characters equals (\"=\"), comma (\",\"), exclamation (\"!\"),\n    // at sign (\"@\"), and pipe (\"|\") are reserved for future extensions.\n\n  }; // storage for already parsed templates\n\n  URITemplate._cache = {}; // pattern to identify expressions [operator, variable-list] in template\n\n  URITemplate.EXPRESSION_PATTERN = /\\{([^a-zA-Z0-9%_]?)([^\\}]+)(\\}|$)/g; // pattern to identify variables [name, explode, maxlength] in variable-list\n\n  URITemplate.VARIABLE_PATTERN = /^([^*:.](?:\\.?[^*:.])*)((\\*)|:(\\d+))?$/; // pattern to verify variable name integrity\n\n  URITemplate.VARIABLE_NAME_PATTERN = /[^a-zA-Z0-9%_.]/; // pattern to verify literal integrity\n\n  URITemplate.LITERAL_PATTERN = /[<>{}\"`^| \\\\]/; // expand parsed expression (expression, not template!)\n\n  URITemplate.expand = function (expression, data, opts) {\n    // container for defined options for the given operator\n    var options = operators[expression.operator]; // expansion type (include keys or not)\n\n    var type = options.named ? 'Named' : 'Unnamed'; // list of variables within the expression\n\n    var variables = expression.variables; // result buffer for evaluating the expression\n\n    var buffer = [];\n    var d, variable, i;\n\n    for (i = 0; variable = variables[i]; i++) {\n      // fetch simplified data source\n      d = data.get(variable.name);\n\n      if (d.type === 0 && opts && opts.strict) {\n        throw new Error('Missing expansion value for variable \"' + variable.name + '\"');\n      }\n\n      if (!d.val.length) {\n        if (d.type) {\n          // empty variables (empty string)\n          // still lead to a separator being appended!\n          buffer.push('');\n        } // no data, no action\n\n\n        continue;\n      }\n\n      if (d.type > 1 && variable.maxlength) {\n        // composite variable cannot specify maxlength\n        throw new Error('Invalid expression: Prefix modifier not applicable to variable \"' + variable.name + '\"');\n      } // expand the given variable\n\n\n      buffer.push(URITemplate['expand' + type](d, options, variable.explode, variable.explode && options.separator || ',', variable.maxlength, variable.name));\n    }\n\n    if (buffer.length) {\n      return options.prefix + buffer.join(options.separator);\n    } else {\n      // prefix is not prepended for empty expressions\n      return '';\n    }\n  }; // expand a named variable\n\n\n  URITemplate.expandNamed = function (d, options, explode, separator, length, name) {\n    // variable result buffer\n    var result = ''; // peformance crap\n\n    var encode = options.encode;\n    var empty_name_separator = options.empty_name_separator; // flag noting if values are already encoded\n\n    var _encode = !d[encode].length; // key for named expansion\n\n\n    var _name = d.type === 2 ? '' : URI[encode](name);\n\n    var _value, i, l; // for each found value\n\n\n    for (i = 0, l = d.val.length; i < l; i++) {\n      if (length) {\n        // maxlength must be determined before encoding can happen\n        _value = URI[encode](d.val[i][1].substring(0, length));\n\n        if (d.type === 2) {\n          // apply maxlength to keys of objects as well\n          _name = URI[encode](d.val[i][0].substring(0, length));\n        }\n      } else if (_encode) {\n        // encode value\n        _value = URI[encode](d.val[i][1]);\n\n        if (d.type === 2) {\n          // encode name and cache encoded value\n          _name = URI[encode](d.val[i][0]);\n          d[encode].push([_name, _value]);\n        } else {\n          // cache encoded value\n          d[encode].push([undefined, _value]);\n        }\n      } else {\n        // values are already encoded and can be pulled from cache\n        _value = d[encode][i][1];\n\n        if (d.type === 2) {\n          _name = d[encode][i][0];\n        }\n      }\n\n      if (result) {\n        // unless we're the first value, prepend the separator\n        result += separator;\n      }\n\n      if (!explode) {\n        if (!i) {\n          // first element, so prepend variable name\n          result += URI[encode](name) + (empty_name_separator || _value ? '=' : '');\n        }\n\n        if (d.type === 2) {\n          // without explode-modifier, keys of objects are returned comma-separated\n          result += _name + ',';\n        }\n\n        result += _value;\n      } else {\n        // only add the = if it is either default (?&) or there actually is a value (;)\n        result += _name + (empty_name_separator || _value ? '=' : '') + _value;\n      }\n    }\n\n    return result;\n  }; // expand an unnamed variable\n\n\n  URITemplate.expandUnnamed = function (d, options, explode, separator, length) {\n    // variable result buffer\n    var result = ''; // performance crap\n\n    var encode = options.encode;\n    var empty_name_separator = options.empty_name_separator; // flag noting if values are already encoded\n\n    var _encode = !d[encode].length;\n\n    var _name, _value, i, l; // for each found value\n\n\n    for (i = 0, l = d.val.length; i < l; i++) {\n      if (length) {\n        // maxlength must be determined before encoding can happen\n        _value = URI[encode](d.val[i][1].substring(0, length));\n      } else if (_encode) {\n        // encode and cache value\n        _value = URI[encode](d.val[i][1]);\n        d[encode].push([d.type === 2 ? URI[encode](d.val[i][0]) : undefined, _value]);\n      } else {\n        // value already encoded, pull from cache\n        _value = d[encode][i][1];\n      }\n\n      if (result) {\n        // unless we're the first value, prepend the separator\n        result += separator;\n      }\n\n      if (d.type === 2) {\n        if (length) {\n          // maxlength also applies to keys of objects\n          _name = URI[encode](d.val[i][0].substring(0, length));\n        } else {\n          // at this point the name must already be encoded\n          _name = d[encode][i][0];\n        }\n\n        result += _name;\n\n        if (explode) {\n          // explode-modifier separates name and value by \"=\"\n          result += empty_name_separator || _value ? '=' : '';\n        } else {\n          // no explode-modifier separates name and value by \",\"\n          result += ',';\n        }\n      }\n\n      result += _value;\n    }\n\n    return result;\n  };\n\n  URITemplate.noConflict = function () {\n    if (root.URITemplate === URITemplate) {\n      root.URITemplate = _URITemplate;\n    }\n\n    return URITemplate;\n  }; // expand template through given data map\n\n\n  p.expand = function (data, opts) {\n    var result = '';\n\n    if (!this.parts || !this.parts.length) {\n      // lazilyy parse the template\n      this.parse();\n    }\n\n    if (!(data instanceof Data)) {\n      // make given data available through the\n      // optimized data handling thingie\n      data = new Data(data);\n    }\n\n    for (var i = 0, l = this.parts.length; i < l; i++) {\n      /*jshint laxbreak: true */\n      result += typeof this.parts[i] === 'string' // literal string\n      ? this.parts[i] // expression\n      : URITemplate.expand(this.parts[i], data, opts);\n      /*jshint laxbreak: false */\n    }\n\n    return result;\n  }; // parse template into action tokens\n\n\n  p.parse = function () {\n    // performance crap\n    var expression = this.expression;\n    var ePattern = URITemplate.EXPRESSION_PATTERN;\n    var vPattern = URITemplate.VARIABLE_PATTERN;\n    var nPattern = URITemplate.VARIABLE_NAME_PATTERN;\n    var lPattern = URITemplate.LITERAL_PATTERN; // token result buffer\n\n    var parts = []; // position within source template\n\n    var pos = 0;\n    var variables, eMatch, vMatch;\n\n    var checkLiteral = function (literal) {\n      if (literal.match(lPattern)) {\n        throw new Error('Invalid Literal \"' + literal + '\"');\n      }\n\n      return literal;\n    }; // RegExp is shared accross all templates,\n    // which requires a manual reset\n\n\n    ePattern.lastIndex = 0; // I don't like while(foo = bar()) loops,\n    // to make things simpler I go while(true) and break when required\n\n    while (true) {\n      eMatch = ePattern.exec(expression);\n\n      if (eMatch === null) {\n        // push trailing literal\n        parts.push(checkLiteral(expression.substring(pos)));\n        break;\n      } else {\n        // push leading literal\n        parts.push(checkLiteral(expression.substring(pos, eMatch.index)));\n        pos = eMatch.index + eMatch[0].length;\n      }\n\n      if (!operators[eMatch[1]]) {\n        throw new Error('Unknown Operator \"' + eMatch[1] + '\" in \"' + eMatch[0] + '\"');\n      } else if (!eMatch[3]) {\n        throw new Error('Unclosed Expression \"' + eMatch[0] + '\"');\n      } // parse variable-list\n\n\n      variables = eMatch[2].split(',');\n\n      for (var i = 0, l = variables.length; i < l; i++) {\n        vMatch = variables[i].match(vPattern);\n\n        if (vMatch === null) {\n          throw new Error('Invalid Variable \"' + variables[i] + '\" in \"' + eMatch[0] + '\"');\n        } else if (vMatch[1].match(nPattern)) {\n          throw new Error('Invalid Variable Name \"' + vMatch[1] + '\" in \"' + eMatch[0] + '\"');\n        }\n\n        variables[i] = {\n          name: vMatch[1],\n          explode: !!vMatch[3],\n          maxlength: vMatch[4] && parseInt(vMatch[4], 10)\n        };\n      }\n\n      if (!variables.length) {\n        throw new Error('Expression Missing Variable(s) \"' + eMatch[0] + '\"');\n      }\n\n      parts.push({\n        expression: eMatch[0],\n        operator: eMatch[1],\n        variables: variables\n      });\n    }\n\n    if (!parts.length) {\n      // template doesn't contain any expressions\n      // so it is a simple literal string\n      // this probably should fire a warning or something?\n      parts.push(checkLiteral(expression));\n    }\n\n    this.parts = parts;\n    return this;\n  }; // simplify data structures\n\n\n  Data.prototype.get = function (key) {\n    // performance crap\n    var data = this.data; // cache for processed data-point\n\n    var d = {\n      // type of data 0: undefined/null, 1: string, 2: object, 3: array\n      type: 0,\n      // original values (except undefined/null)\n      val: [],\n      // cache for encoded values (only for non-maxlength expansion)\n      encode: [],\n      encodeReserved: []\n    };\n    var i, l, value;\n\n    if (this.cache[key] !== undefined) {\n      // we've already processed this key\n      return this.cache[key];\n    }\n\n    this.cache[key] = d;\n\n    if (String(Object.prototype.toString.call(data)) === '[object Function]') {\n      // data itself is a callback (global callback)\n      value = data(key);\n    } else if (String(Object.prototype.toString.call(data[key])) === '[object Function]') {\n      // data is a map of callbacks (local callback)\n      value = data[key](key);\n    } else {\n      // data is a map of data\n      value = data[key];\n    } // generalize input into [ [name1, value1], [name2, value2], … ]\n    // so expansion has to deal with a single data structure only\n\n\n    if (value === undefined || value === null) {\n      // undefined and null values are to be ignored completely\n      return d;\n    } else if (String(Object.prototype.toString.call(value)) === '[object Array]') {\n      for (i = 0, l = value.length; i < l; i++) {\n        if (value[i] !== undefined && value[i] !== null) {\n          // arrays don't have names\n          d.val.push([undefined, String(value[i])]);\n        }\n      }\n\n      if (d.val.length) {\n        // only treat non-empty arrays as arrays\n        d.type = 3; // array\n      }\n    } else if (String(Object.prototype.toString.call(value)) === '[object Object]') {\n      for (i in value) {\n        if (hasOwn.call(value, i) && value[i] !== undefined && value[i] !== null) {\n          // objects have keys, remember them for named expansion\n          d.val.push([i, String(value[i])]);\n        }\n      }\n\n      if (d.val.length) {\n        // only treat non-empty objects as objects\n        d.type = 2; // object\n      }\n    } else {\n      d.type = 1; // primitive string (could've been string, number, boolean and objects with a toString())\n      // arrays don't have names\n\n      d.val.push([undefined, String(value)]);\n    }\n\n    return d;\n  }; // hook into URI for fluid access\n\n\n  URI.expand = function (expression, data) {\n    var template = new URITemplate(expression);\n    var expansion = template.expand(data);\n    return new URI(expansion);\n  };\n\n  return URITemplate;\n});","map":{"version":3,"names":["root","factory","module","exports","require","define","amd","URITemplate","URI","_URITemplate","hasOwn","Object","prototype","hasOwnProperty","expression","_cache","Data","data","cache","p","operators","prefix","separator","named","empty_name_separator","encode","EXPRESSION_PATTERN","VARIABLE_PATTERN","VARIABLE_NAME_PATTERN","LITERAL_PATTERN","expand","opts","options","operator","type","variables","buffer","d","variable","i","get","name","strict","Error","val","length","push","maxlength","explode","join","expandNamed","result","_encode","_name","_value","l","substring","undefined","expandUnnamed","noConflict","parts","parse","ePattern","vPattern","nPattern","lPattern","pos","eMatch","vMatch","checkLiteral","literal","match","lastIndex","exec","index","split","parseInt","key","encodeReserved","value","String","toString","call","template","expansion"],"sources":["C:/Users/acer/node_modules/urijs/src/URITemplate.js"],"sourcesContent":["/*!\n * URI.js - Mutating URLs\n * URI Template Support - http://tools.ietf.org/html/rfc6570\n *\n * Version: 1.19.11\n *\n * Author: Rodney Rehm\n * Web: http://medialize.github.io/URI.js/\n *\n * Licensed under\n *   MIT License http://www.opensource.org/licenses/mit-license\n *\n */\n(function (root, factory) {\n  'use strict';\n  // https://github.com/umdjs/umd/blob/master/returnExports.js\n  if (typeof module === 'object' && module.exports) {\n    // Node\n    module.exports = factory(require('./URI'));\n  } else if (typeof define === 'function' && define.amd) {\n    // AMD. Register as an anonymous module.\n    define(['./URI'], factory);\n  } else {\n    // Browser globals (root is window)\n    root.URITemplate = factory(root.URI, root);\n  }\n}(this, function (URI, root) {\n  'use strict';\n  // FIXME: v2.0.0 renamce non-camelCase properties to uppercase\n  /*jshint camelcase: false */\n\n  // save current URITemplate variable, if any\n  var _URITemplate = root && root.URITemplate;\n\n  var hasOwn = Object.prototype.hasOwnProperty;\n  function URITemplate(expression) {\n    // serve from cache where possible\n    if (URITemplate._cache[expression]) {\n      return URITemplate._cache[expression];\n    }\n\n    // Allow instantiation without the 'new' keyword\n    if (!(this instanceof URITemplate)) {\n      return new URITemplate(expression);\n    }\n\n    this.expression = expression;\n    URITemplate._cache[expression] = this;\n    return this;\n  }\n\n  function Data(data) {\n    this.data = data;\n    this.cache = {};\n  }\n\n  var p = URITemplate.prototype;\n  // list of operators and their defined options\n  var operators = {\n    // Simple string expansion\n    '' : {\n      prefix: '',\n      separator: ',',\n      named: false,\n      empty_name_separator: false,\n      encode : 'encode'\n    },\n    // Reserved character strings\n    '+' : {\n      prefix: '',\n      separator: ',',\n      named: false,\n      empty_name_separator: false,\n      encode : 'encodeReserved'\n    },\n    // Fragment identifiers prefixed by '#'\n    '#' : {\n      prefix: '#',\n      separator: ',',\n      named: false,\n      empty_name_separator: false,\n      encode : 'encodeReserved'\n    },\n    // Name labels or extensions prefixed by '.'\n    '.' : {\n      prefix: '.',\n      separator: '.',\n      named: false,\n      empty_name_separator: false,\n      encode : 'encode'\n    },\n    // Path segments prefixed by '/'\n    '/' : {\n      prefix: '/',\n      separator: '/',\n      named: false,\n      empty_name_separator: false,\n      encode : 'encode'\n    },\n    // Path parameter name or name=value pairs prefixed by ';'\n    ';' : {\n      prefix: ';',\n      separator: ';',\n      named: true,\n      empty_name_separator: false,\n      encode : 'encode'\n    },\n    // Query component beginning with '?' and consisting\n    // of name=value pairs separated by '&'; an\n    '?' : {\n      prefix: '?',\n      separator: '&',\n      named: true,\n      empty_name_separator: true,\n      encode : 'encode'\n    },\n    // Continuation of query-style &name=value pairs\n    // within a literal query component.\n    '&' : {\n      prefix: '&',\n      separator: '&',\n      named: true,\n      empty_name_separator: true,\n      encode : 'encode'\n    }\n\n    // The operator characters equals (\"=\"), comma (\",\"), exclamation (\"!\"),\n    // at sign (\"@\"), and pipe (\"|\") are reserved for future extensions.\n  };\n\n  // storage for already parsed templates\n  URITemplate._cache = {};\n  // pattern to identify expressions [operator, variable-list] in template\n  URITemplate.EXPRESSION_PATTERN = /\\{([^a-zA-Z0-9%_]?)([^\\}]+)(\\}|$)/g;\n  // pattern to identify variables [name, explode, maxlength] in variable-list\n  URITemplate.VARIABLE_PATTERN = /^([^*:.](?:\\.?[^*:.])*)((\\*)|:(\\d+))?$/;\n  // pattern to verify variable name integrity\n  URITemplate.VARIABLE_NAME_PATTERN = /[^a-zA-Z0-9%_.]/;\n  // pattern to verify literal integrity\n  URITemplate.LITERAL_PATTERN = /[<>{}\"`^| \\\\]/;\n\n  // expand parsed expression (expression, not template!)\n  URITemplate.expand = function(expression, data, opts) {\n    // container for defined options for the given operator\n    var options = operators[expression.operator];\n    // expansion type (include keys or not)\n    var type = options.named ? 'Named' : 'Unnamed';\n    // list of variables within the expression\n    var variables = expression.variables;\n    // result buffer for evaluating the expression\n    var buffer = [];\n    var d, variable, i;\n\n    for (i = 0; (variable = variables[i]); i++) {\n      // fetch simplified data source\n      d = data.get(variable.name);\n      if (d.type === 0 && opts && opts.strict) {\n          throw new Error('Missing expansion value for variable \"' + variable.name + '\"');\n      }\n      if (!d.val.length) {\n        if (d.type) {\n          // empty variables (empty string)\n          // still lead to a separator being appended!\n          buffer.push('');\n        }\n        // no data, no action\n        continue;\n      }\n\n      if (d.type > 1 && variable.maxlength) {\n        // composite variable cannot specify maxlength\n        throw new Error('Invalid expression: Prefix modifier not applicable to variable \"' + variable.name + '\"');\n      }\n\n      // expand the given variable\n      buffer.push(URITemplate['expand' + type](\n        d,\n        options,\n        variable.explode,\n        variable.explode && options.separator || ',',\n        variable.maxlength,\n        variable.name\n      ));\n    }\n\n    if (buffer.length) {\n      return options.prefix + buffer.join(options.separator);\n    } else {\n      // prefix is not prepended for empty expressions\n      return '';\n    }\n  };\n  // expand a named variable\n  URITemplate.expandNamed = function(d, options, explode, separator, length, name) {\n    // variable result buffer\n    var result = '';\n    // peformance crap\n    var encode = options.encode;\n    var empty_name_separator = options.empty_name_separator;\n    // flag noting if values are already encoded\n    var _encode = !d[encode].length;\n    // key for named expansion\n    var _name = d.type === 2 ? '': URI[encode](name);\n    var _value, i, l;\n\n    // for each found value\n    for (i = 0, l = d.val.length; i < l; i++) {\n      if (length) {\n        // maxlength must be determined before encoding can happen\n        _value = URI[encode](d.val[i][1].substring(0, length));\n        if (d.type === 2) {\n          // apply maxlength to keys of objects as well\n          _name = URI[encode](d.val[i][0].substring(0, length));\n        }\n      } else if (_encode) {\n        // encode value\n        _value = URI[encode](d.val[i][1]);\n        if (d.type === 2) {\n          // encode name and cache encoded value\n          _name = URI[encode](d.val[i][0]);\n          d[encode].push([_name, _value]);\n        } else {\n          // cache encoded value\n          d[encode].push([undefined, _value]);\n        }\n      } else {\n        // values are already encoded and can be pulled from cache\n        _value = d[encode][i][1];\n        if (d.type === 2) {\n          _name = d[encode][i][0];\n        }\n      }\n\n      if (result) {\n        // unless we're the first value, prepend the separator\n        result += separator;\n      }\n\n      if (!explode) {\n        if (!i) {\n          // first element, so prepend variable name\n          result += URI[encode](name) + (empty_name_separator || _value ? '=' : '');\n        }\n\n        if (d.type === 2) {\n          // without explode-modifier, keys of objects are returned comma-separated\n          result += _name + ',';\n        }\n\n        result += _value;\n      } else {\n        // only add the = if it is either default (?&) or there actually is a value (;)\n        result += _name + (empty_name_separator || _value ? '=' : '') + _value;\n      }\n    }\n\n    return result;\n  };\n  // expand an unnamed variable\n  URITemplate.expandUnnamed = function(d, options, explode, separator, length) {\n    // variable result buffer\n    var result = '';\n    // performance crap\n    var encode = options.encode;\n    var empty_name_separator = options.empty_name_separator;\n    // flag noting if values are already encoded\n    var _encode = !d[encode].length;\n    var _name, _value, i, l;\n\n    // for each found value\n    for (i = 0, l = d.val.length; i < l; i++) {\n      if (length) {\n        // maxlength must be determined before encoding can happen\n        _value = URI[encode](d.val[i][1].substring(0, length));\n      } else if (_encode) {\n        // encode and cache value\n        _value = URI[encode](d.val[i][1]);\n        d[encode].push([\n          d.type === 2 ? URI[encode](d.val[i][0]) : undefined,\n          _value\n        ]);\n      } else {\n        // value already encoded, pull from cache\n        _value = d[encode][i][1];\n      }\n\n      if (result) {\n        // unless we're the first value, prepend the separator\n        result += separator;\n      }\n\n      if (d.type === 2) {\n        if (length) {\n          // maxlength also applies to keys of objects\n          _name = URI[encode](d.val[i][0].substring(0, length));\n        } else {\n          // at this point the name must already be encoded\n          _name = d[encode][i][0];\n        }\n\n        result += _name;\n        if (explode) {\n          // explode-modifier separates name and value by \"=\"\n          result += (empty_name_separator || _value ? '=' : '');\n        } else {\n          // no explode-modifier separates name and value by \",\"\n          result += ',';\n        }\n      }\n\n      result += _value;\n    }\n\n    return result;\n  };\n\n  URITemplate.noConflict = function() {\n    if (root.URITemplate === URITemplate) {\n      root.URITemplate = _URITemplate;\n    }\n\n    return URITemplate;\n  };\n\n  // expand template through given data map\n  p.expand = function(data, opts) {\n    var result = '';\n\n    if (!this.parts || !this.parts.length) {\n      // lazilyy parse the template\n      this.parse();\n    }\n\n    if (!(data instanceof Data)) {\n      // make given data available through the\n      // optimized data handling thingie\n      data = new Data(data);\n    }\n\n    for (var i = 0, l = this.parts.length; i < l; i++) {\n      /*jshint laxbreak: true */\n      result += typeof this.parts[i] === 'string'\n        // literal string\n        ? this.parts[i]\n        // expression\n        : URITemplate.expand(this.parts[i], data, opts);\n      /*jshint laxbreak: false */\n    }\n\n    return result;\n  };\n  // parse template into action tokens\n  p.parse = function() {\n    // performance crap\n    var expression = this.expression;\n    var ePattern = URITemplate.EXPRESSION_PATTERN;\n    var vPattern = URITemplate.VARIABLE_PATTERN;\n    var nPattern = URITemplate.VARIABLE_NAME_PATTERN;\n    var lPattern = URITemplate.LITERAL_PATTERN;\n    // token result buffer\n    var parts = [];\n      // position within source template\n    var pos = 0;\n    var variables, eMatch, vMatch;\n\n    var checkLiteral = function(literal) {\n      if (literal.match(lPattern)) {\n        throw new Error('Invalid Literal \"' + literal + '\"');\n      }\n      return literal;\n    };\n\n    // RegExp is shared accross all templates,\n    // which requires a manual reset\n    ePattern.lastIndex = 0;\n    // I don't like while(foo = bar()) loops,\n    // to make things simpler I go while(true) and break when required\n    while (true) {\n      eMatch = ePattern.exec(expression);\n      if (eMatch === null) {\n        // push trailing literal\n        parts.push(checkLiteral(expression.substring(pos)));\n        break;\n      } else {\n        // push leading literal\n        parts.push(checkLiteral(expression.substring(pos, eMatch.index)));\n        pos = eMatch.index + eMatch[0].length;\n      }\n\n      if (!operators[eMatch[1]]) {\n        throw new Error('Unknown Operator \"' + eMatch[1]  + '\" in \"' + eMatch[0] + '\"');\n      } else if (!eMatch[3]) {\n        throw new Error('Unclosed Expression \"' + eMatch[0]  + '\"');\n      }\n\n      // parse variable-list\n      variables = eMatch[2].split(',');\n      for (var i = 0, l = variables.length; i < l; i++) {\n        vMatch = variables[i].match(vPattern);\n        if (vMatch === null) {\n          throw new Error('Invalid Variable \"' + variables[i] + '\" in \"' + eMatch[0] + '\"');\n        } else if (vMatch[1].match(nPattern)) {\n          throw new Error('Invalid Variable Name \"' + vMatch[1] + '\" in \"' + eMatch[0] + '\"');\n        }\n\n        variables[i] = {\n          name: vMatch[1],\n          explode: !!vMatch[3],\n          maxlength: vMatch[4] && parseInt(vMatch[4], 10)\n        };\n      }\n\n      if (!variables.length) {\n        throw new Error('Expression Missing Variable(s) \"' + eMatch[0] + '\"');\n      }\n\n      parts.push({\n        expression: eMatch[0],\n        operator: eMatch[1],\n        variables: variables\n      });\n    }\n\n    if (!parts.length) {\n      // template doesn't contain any expressions\n      // so it is a simple literal string\n      // this probably should fire a warning or something?\n      parts.push(checkLiteral(expression));\n    }\n\n    this.parts = parts;\n    return this;\n  };\n\n  // simplify data structures\n  Data.prototype.get = function(key) {\n    // performance crap\n    var data = this.data;\n    // cache for processed data-point\n    var d = {\n      // type of data 0: undefined/null, 1: string, 2: object, 3: array\n      type: 0,\n      // original values (except undefined/null)\n      val: [],\n      // cache for encoded values (only for non-maxlength expansion)\n      encode: [],\n      encodeReserved: []\n    };\n    var i, l, value;\n\n    if (this.cache[key] !== undefined) {\n      // we've already processed this key\n      return this.cache[key];\n    }\n\n    this.cache[key] = d;\n\n    if (String(Object.prototype.toString.call(data)) === '[object Function]') {\n      // data itself is a callback (global callback)\n      value = data(key);\n    } else if (String(Object.prototype.toString.call(data[key])) === '[object Function]') {\n      // data is a map of callbacks (local callback)\n      value = data[key](key);\n    } else {\n      // data is a map of data\n      value = data[key];\n    }\n\n    // generalize input into [ [name1, value1], [name2, value2], … ]\n    // so expansion has to deal with a single data structure only\n    if (value === undefined || value === null) {\n      // undefined and null values are to be ignored completely\n      return d;\n    } else if (String(Object.prototype.toString.call(value)) === '[object Array]') {\n      for (i = 0, l = value.length; i < l; i++) {\n        if (value[i] !== undefined && value[i] !== null) {\n          // arrays don't have names\n          d.val.push([undefined, String(value[i])]);\n        }\n      }\n\n      if (d.val.length) {\n        // only treat non-empty arrays as arrays\n        d.type = 3; // array\n      }\n    } else if (String(Object.prototype.toString.call(value)) === '[object Object]') {\n      for (i in value) {\n        if (hasOwn.call(value, i) && value[i] !== undefined && value[i] !== null) {\n          // objects have keys, remember them for named expansion\n          d.val.push([i, String(value[i])]);\n        }\n      }\n\n      if (d.val.length) {\n        // only treat non-empty objects as objects\n        d.type = 2; // object\n      }\n    } else {\n      d.type = 1; // primitive string (could've been string, number, boolean and objects with a toString())\n      // arrays don't have names\n      d.val.push([undefined, String(value)]);\n    }\n\n    return d;\n  };\n\n  // hook into URI for fluid access\n  URI.expand = function(expression, data) {\n    var template = new URITemplate(expression);\n    var expansion = template.expand(data);\n\n    return new URI(expansion);\n  };\n\n  return URITemplate;\n}));\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}