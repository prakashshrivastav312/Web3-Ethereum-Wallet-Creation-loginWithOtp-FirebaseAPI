{"ast":null,"code":"'use strict';\n\nvar _ = require('lodash');\n\nvar BigNumber = require('bignumber.js');\n\nvar normalizeNodes = require('./utils').normalizeNodes;\n\nvar dropsToXRP = require('./utils').dropsToXRP;\n\nfunction groupByAddress(balanceChanges) {\n  var grouped = _.groupBy(balanceChanges, function (node) {\n    return node.address;\n  });\n\n  return _.mapValues(grouped, function (group) {\n    return _.map(group, function (node) {\n      return node.balance;\n    });\n  });\n}\n\nfunction parseValue(value) {\n  return new BigNumber(value.value || value);\n}\n\nfunction computeBalanceChange(node) {\n  var value = null;\n\n  if (node.newFields.Balance) {\n    value = parseValue(node.newFields.Balance);\n  } else if (node.previousFields.Balance && node.finalFields.Balance) {\n    value = parseValue(node.finalFields.Balance).minus(parseValue(node.previousFields.Balance));\n  }\n\n  return value === null ? null : value.isZero() ? null : value;\n}\n\nfunction parseFinalBalance(node) {\n  if (node.newFields.Balance) {\n    return parseValue(node.newFields.Balance);\n  } else if (node.finalFields.Balance) {\n    return parseValue(node.finalFields.Balance);\n  }\n\n  return null;\n}\n\nfunction parseXRPQuantity(node, valueParser) {\n  var value = valueParser(node);\n\n  if (value === null) {\n    return null;\n  }\n\n  return {\n    address: node.finalFields.Account || node.newFields.Account,\n    balance: {\n      counterparty: '',\n      currency: 'XRP',\n      value: dropsToXRP(value).toString()\n    }\n  };\n}\n\nfunction flipTrustlinePerspective(quantity) {\n  var negatedBalance = new BigNumber(quantity.balance.value).negated();\n  return {\n    address: quantity.balance.counterparty,\n    balance: {\n      counterparty: quantity.address,\n      currency: quantity.balance.currency,\n      value: negatedBalance.toString()\n    }\n  };\n}\n\nfunction parseTrustlineQuantity(node, valueParser) {\n  var value = valueParser(node);\n\n  if (value === null) {\n    return null;\n  }\n  /*\n   * A trustline can be created with a non-zero starting balance\n   * If an offer is placed to acquire an asset with no existing trustline,\n   * the trustline can be created when the offer is taken.\n   */\n\n\n  var fields = _.isEmpty(node.newFields) ? node.finalFields : node.newFields; // the balance is always from low node's perspective\n\n  var result = {\n    address: fields.LowLimit.issuer,\n    balance: {\n      counterparty: fields.HighLimit.issuer,\n      currency: fields.Balance.currency,\n      value: value.toString()\n    }\n  };\n  return [result, flipTrustlinePerspective(result)];\n}\n\nfunction parseQuantities(metadata, valueParser) {\n  var values = normalizeNodes(metadata).map(function (node) {\n    if (node.entryType === 'AccountRoot') {\n      return [parseXRPQuantity(node, valueParser)];\n    } else if (node.entryType === 'RippleState') {\n      return parseTrustlineQuantity(node, valueParser);\n    }\n\n    return [];\n  });\n  return groupByAddress(_.compact(_.flatten(values)));\n}\n/**\n *  Computes the complete list of every balance that changed in the ledger\n *  as a result of the given transaction.\n *\n *  @param {Object} metadata Transaction metada\n *  @returns {Object} parsed balance changes\n */\n\n\nfunction parseBalanceChanges(metadata) {\n  return parseQuantities(metadata, computeBalanceChange);\n}\n/**\n *  Computes the complete list of every final balance in the ledger\n *  as a result of the given transaction.\n *\n *  @param {Object} metadata Transaction metada\n *  @returns {Object} parsed balances\n */\n\n\nfunction parseFinalBalances(metadata) {\n  return parseQuantities(metadata, parseFinalBalance);\n}\n\nmodule.exports.parseBalanceChanges = parseBalanceChanges;\nmodule.exports.parseFinalBalances = parseFinalBalances;","map":{"version":3,"names":["_","require","BigNumber","normalizeNodes","dropsToXRP","groupByAddress","balanceChanges","grouped","groupBy","node","address","mapValues","group","map","balance","parseValue","value","computeBalanceChange","newFields","Balance","previousFields","finalFields","minus","isZero","parseFinalBalance","parseXRPQuantity","valueParser","Account","counterparty","currency","toString","flipTrustlinePerspective","quantity","negatedBalance","negated","parseTrustlineQuantity","fields","isEmpty","result","LowLimit","issuer","HighLimit","parseQuantities","metadata","values","entryType","compact","flatten","parseBalanceChanges","parseFinalBalances","module","exports"],"sources":["C:/Users/acer/node_modules/ripple-lib-transactionparser/src/balancechanges.js"],"sourcesContent":["'use strict'\n\nvar _ = require('lodash')\nvar BigNumber = require('bignumber.js')\nvar normalizeNodes = require('./utils').normalizeNodes\nvar dropsToXRP = require('./utils').dropsToXRP\n\nfunction groupByAddress(balanceChanges) {\n  var grouped = _.groupBy(balanceChanges, function(node) {\n    return node.address\n  })\n  return _.mapValues(grouped, function(group) {\n    return _.map(group, function(node) {\n      return node.balance\n    })\n  })\n}\n\nfunction parseValue(value) {\n  return new BigNumber(value.value || value)\n}\n\nfunction computeBalanceChange(node) {\n  var value = null\n  if (node.newFields.Balance) {\n    value = parseValue(node.newFields.Balance)\n  } else if (node.previousFields.Balance && node.finalFields.Balance) {\n    value = parseValue(node.finalFields.Balance).minus(\n      parseValue(node.previousFields.Balance))\n  }\n  return value === null ? null : value.isZero() ? null : value\n}\n\nfunction parseFinalBalance(node) {\n  if (node.newFields.Balance) {\n    return parseValue(node.newFields.Balance)\n  } else if (node.finalFields.Balance) {\n    return parseValue(node.finalFields.Balance)\n  }\n  return null\n}\n\n\nfunction parseXRPQuantity(node, valueParser) {\n  var value = valueParser(node)\n\n  if (value === null) {\n    return null\n  }\n\n  return {\n    address: node.finalFields.Account || node.newFields.Account,\n    balance: {\n      counterparty: '',\n      currency: 'XRP',\n      value: dropsToXRP(value).toString()\n    }\n  }\n}\n\nfunction flipTrustlinePerspective(quantity) {\n  var negatedBalance = (new BigNumber(quantity.balance.value)).negated()\n  return {\n    address: quantity.balance.counterparty,\n    balance: {\n      counterparty: quantity.address,\n      currency: quantity.balance.currency,\n      value: negatedBalance.toString()\n    }\n  }\n}\n\nfunction parseTrustlineQuantity(node, valueParser) {\n  var value = valueParser(node)\n\n  if (value === null) {\n    return null\n  }\n\n  /*\n   * A trustline can be created with a non-zero starting balance\n   * If an offer is placed to acquire an asset with no existing trustline,\n   * the trustline can be created when the offer is taken.\n   */\n  var fields = _.isEmpty(node.newFields) ? node.finalFields : node.newFields\n\n  // the balance is always from low node's perspective\n  var result = {\n    address: fields.LowLimit.issuer,\n    balance: {\n      counterparty: fields.HighLimit.issuer,\n      currency: fields.Balance.currency,\n      value: value.toString()\n    }\n  }\n  return [result, flipTrustlinePerspective(result)]\n}\n\nfunction parseQuantities(metadata, valueParser) {\n  var values = normalizeNodes(metadata).map(function(node) {\n    if (node.entryType === 'AccountRoot') {\n      return [parseXRPQuantity(node, valueParser)]\n    } else if (node.entryType === 'RippleState') {\n      return parseTrustlineQuantity(node, valueParser)\n    }\n    return []\n  })\n  return groupByAddress(_.compact(_.flatten(values)))\n}\n\n/**\n *  Computes the complete list of every balance that changed in the ledger\n *  as a result of the given transaction.\n *\n *  @param {Object} metadata Transaction metada\n *  @returns {Object} parsed balance changes\n */\nfunction parseBalanceChanges(metadata) {\n  return parseQuantities(metadata, computeBalanceChange)\n}\n\n\n/**\n *  Computes the complete list of every final balance in the ledger\n *  as a result of the given transaction.\n *\n *  @param {Object} metadata Transaction metada\n *  @returns {Object} parsed balances\n */\nfunction parseFinalBalances(metadata) {\n  return parseQuantities(metadata, parseFinalBalance)\n}\n\nmodule.exports.parseBalanceChanges = parseBalanceChanges\nmodule.exports.parseFinalBalances = parseFinalBalances\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}