{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  Object.defineProperty(o, k2, {\n    enumerable: true,\n    get: function () {\n      return m[k];\n    }\n  });\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Signature = void 0;\n\nconst errors = __importStar(require(\"./errors\"));\n\nconst SIGNATURE_LENGTH = 64;\n/**\n * Signature, as an immutable object.\n */\n\nclass Signature {\n  constructor(value) {\n    this.valueHex = \"\";\n\n    if (!value) {\n      return;\n    }\n\n    if (typeof value === \"string\") {\n      return Signature.fromHex(value);\n    }\n\n    if (value instanceof Buffer) {\n      return Signature.fromBuffer(value);\n    }\n  }\n\n  static empty() {\n    return new Signature();\n  }\n\n  static fromHex(value) {\n    if (value.startsWith(\"0x\")) {\n      value = value.slice(2);\n    }\n\n    if (!Signature.isValidHex(value)) {\n      throw new errors.ErrSignatureCannotCreate(value);\n    }\n\n    return Signature.fromValidHex(value);\n  }\n\n  static isValidHex(value) {\n    return Buffer.from(value, \"hex\").length == SIGNATURE_LENGTH;\n  }\n\n  static fromValidHex(value) {\n    let result = new Signature();\n    result.valueHex = value;\n    return result;\n  }\n\n  static fromBuffer(buffer) {\n    if (buffer.length != SIGNATURE_LENGTH) {\n      throw new errors.ErrSignatureCannotCreate(buffer);\n    }\n\n    return Signature.fromValidHex(buffer.toString(\"hex\"));\n  }\n\n  hex() {\n    this.assertNotEmpty();\n    return this.valueHex;\n  }\n\n  isEmpty() {\n    return !this.valueHex;\n  }\n\n  assertNotEmpty() {\n    if (this.isEmpty()) {\n      throw new errors.ErrSignatureEmpty();\n    }\n  }\n\n}\n\nexports.Signature = Signature;","map":{"version":3,"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;;AAGA,MAAMA,gBAAgB,GAAG,EAAzB;AAEA;;;;AAGA,MAAaC,SAAb,CAAsB;EAGlBC,YAAYC,KAAZ,EAAmC;IAF3B,gBAAmB,EAAnB;;IAGJ,IAAI,CAACA,KAAL,EAAY;MACR;IACH;;IACD,IAAI,OAAOA,KAAP,KAAiB,QAArB,EAA+B;MAC3B,OAAOF,SAAS,CAACG,OAAV,CAAkBD,KAAlB,CAAP;IACH;;IACD,IAAIA,KAAK,YAAYE,MAArB,EAA6B;MACzB,OAAOJ,SAAS,CAACK,UAAV,CAAqBH,KAArB,CAAP;IACH;EACJ;;EAEW,OAALI,KAAK;IACR,OAAO,IAAIN,SAAJ,EAAP;EACH;;EAEa,OAAPG,OAAO,CAACD,KAAD,EAAc;IACxB,IAAIA,KAAK,CAACK,UAAN,CAAiB,IAAjB,CAAJ,EAA4B;MACxBL,KAAK,GAAGA,KAAK,CAACM,KAAN,CAAY,CAAZ,CAAR;IACH;;IACD,IAAI,CAACR,SAAS,CAACS,UAAV,CAAqBP,KAArB,CAAL,EAAkC;MAC9B,MAAM,IAAIQ,MAAM,CAACC,wBAAX,CAAoCT,KAApC,CAAN;IACH;;IAED,OAAOF,SAAS,CAACY,YAAV,CAAuBV,KAAvB,CAAP;EACH;;EAEwB,OAAVO,UAAU,CAACP,KAAD,EAAc;IACnC,OAAOE,MAAM,CAACS,IAAP,CAAYX,KAAZ,EAAmB,KAAnB,EAA0BY,MAA1B,IAAoCf,gBAA3C;EACH;;EAE0B,OAAZa,YAAY,CAACV,KAAD,EAAc;IACrC,IAAIa,MAAM,GAAG,IAAIf,SAAJ,EAAb;IACAe,MAAM,CAACC,QAAP,GAAkBd,KAAlB;IACA,OAAOa,MAAP;EACH;;EAEgB,OAAVV,UAAU,CAACY,MAAD,EAAe;IAC5B,IAAIA,MAAM,CAACH,MAAP,IAAiBf,gBAArB,EAAuC;MACnC,MAAM,IAAIW,MAAM,CAACC,wBAAX,CAAoCM,MAApC,CAAN;IACH;;IAED,OAAOjB,SAAS,CAACY,YAAV,CAAuBK,MAAM,CAACC,QAAP,CAAgB,KAAhB,CAAvB,CAAP;EACH;;EAEDC,GAAG;IACC,KAAKC,cAAL;IAEA,OAAO,KAAKJ,QAAZ;EACH;;EAEDK,OAAO;IACH,OAAO,CAAC,KAAKL,QAAb;EACH;;EAEOI,cAAc;IAClB,IAAI,KAAKC,OAAL,EAAJ,EAAoB;MAChB,MAAM,IAAIX,MAAM,CAACY,iBAAX,EAAN;IACH;EACJ;;AA9DiB;;AAAtBC","names":["SIGNATURE_LENGTH","Signature","constructor","value","fromHex","Buffer","fromBuffer","empty","startsWith","slice","isValidHex","errors","ErrSignatureCannotCreate","fromValidHex","from","length","result","valueHex","buffer","toString","hex","assertNotEmpty","isEmpty","ErrSignatureEmpty","exports"],"sourceRoot":"","sources":["../src/signature.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}