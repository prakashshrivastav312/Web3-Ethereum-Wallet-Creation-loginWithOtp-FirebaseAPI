{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  Object.defineProperty(o, k2, {\n    enumerable: true,\n    get: function () {\n      return m[k];\n    }\n  });\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.AbiRegistry = void 0;\n\nconst fs = __importStar(require(\"fs\"));\n\nconst errors = __importStar(require(\"../../errors\"));\n\nconst axios_1 = __importDefault(require(\"axios\"));\n\nconst utils_1 = require(\"../../utils\");\n\nconst struct_1 = require(\"./struct\");\n\nconst contractInterface_1 = require(\"./contractInterface\");\n\nconst enum_1 = require(\"./enum\");\n\nconst typeMapper_1 = require(\"./typeMapper\");\n\nconst endpoint_1 = require(\"./endpoint\");\n\nclass AbiRegistry {\n  constructor() {\n    this.interfaces = [];\n    this.customTypes = [];\n  }\n  /**\n   * Convenience factory function to load ABIs (from files or URLs).\n   * This function will also remap ABI types to know types (on best-efforts basis).\n   */\n\n\n  static load(json) {\n    return __awaiter(this, void 0, void 0, function* () {\n      let registry = new AbiRegistry();\n\n      for (const file of json.files || []) {\n        yield registry.extendFromFile(file);\n      }\n\n      for (const url of json.urls || []) {\n        yield registry.extendFromUrl(url);\n      }\n\n      registry = registry.remapToKnownTypes();\n      return registry;\n    });\n  }\n  /**\n   * Generally, one should use {@link AbiRegistry.load} instead.\n   */\n\n\n  extendFromFile(file) {\n    return __awaiter(this, void 0, void 0, function* () {\n      let jsonContent = yield fs.promises.readFile(file, {\n        encoding: \"utf8\"\n      });\n      let json = JSON.parse(jsonContent);\n      return this.extend(json);\n    });\n  }\n  /**\n   * Generally, one should use {@link AbiRegistry.load} instead.\n   */\n\n\n  extendFromUrl(url) {\n    return __awaiter(this, void 0, void 0, function* () {\n      let response = yield axios_1.default.get(url);\n      let json = response.data;\n      return this.extend(json);\n    });\n  }\n\n  extend(json) {\n    json.types = json.types || {}; // The \"endpoints\" collection is interpreted by \"ContractInterface\".\n\n    let iface = contractInterface_1.ContractInterface.fromJSON(json);\n    this.interfaces.push(iface);\n\n    for (const customTypeName in json.types) {\n      let itemJson = json.types[customTypeName];\n      let typeDiscriminant = itemJson.type; // Workaround: set the \"name\" field, as required by \"fromJSON()\" below.\n\n      itemJson.name = customTypeName;\n      let customType = this.createCustomType(typeDiscriminant, itemJson);\n      this.customTypes.push(customType);\n    }\n\n    return this;\n  }\n\n  createCustomType(typeDiscriminant, json) {\n    if (typeDiscriminant == \"struct\") {\n      return struct_1.StructType.fromJSON(json);\n    }\n\n    if (typeDiscriminant == \"enum\") {\n      return enum_1.EnumType.fromJSON(json);\n    }\n\n    throw new errors.ErrTypingSystem(`Unknown type discriminant: ${typeDiscriminant}`);\n  }\n\n  getInterface(name) {\n    let result = this.interfaces.find(e => e.name == name);\n    utils_1.guardValueIsSetWithMessage(`interface [${name}] not found`, result);\n    return result;\n  }\n\n  getInterfaces(names) {\n    return names.map(name => this.getInterface(name));\n  }\n\n  getStruct(name) {\n    let result = this.customTypes.find(e => e.getName() == name && e instanceof struct_1.StructType);\n    utils_1.guardValueIsSetWithMessage(`struct [${name}] not found`, result);\n    return result;\n  }\n\n  getStructs(names) {\n    return names.map(name => this.getStruct(name));\n  }\n\n  getEnum(name) {\n    let result = this.customTypes.find(e => e.getName() == name && e instanceof enum_1.EnumType);\n    utils_1.guardValueIsSetWithMessage(`enum [${name}] not found`, result);\n    return result;\n  }\n\n  getEnums(names) {\n    return names.map(name => this.getEnum(name));\n  }\n  /**\n   * Right after loading ABI definitions into a registry (e.g. from a file), the endpoints and the custom types (structs, enums)\n   * use raw types for their I/O parameters (in the case of endpoints), or for their fields (in the case of structs).\n   *\n   * A raw type is merely an instance of {@link Type}, with a given name and type parameters (if it's a generic type).\n   *\n   * Though, for most (development) purposes, we'd like to operate using known, specific types (e.g. {@link List}, {@link U8Type} etc.).\n   * This function increases the specificity of the types used by parameter / field definitions within a registry (on best-efforts basis).\n   * The result is an equivalent, more explicit ABI registry.\n   */\n\n\n  remapToKnownTypes() {\n    let mapper = new typeMapper_1.TypeMapper(this.customTypes);\n    let newCustomTypes = [];\n    let newInterfaces = []; // First, remap custom types (actually, under the hood, this will remap types of struct fields)\n\n    for (const type of this.customTypes) {\n      const mappedTyped = mapper.mapType(type);\n      newCustomTypes.push(mappedTyped);\n      mapper.feedCustomType(mappedTyped);\n    } // Then, remap types of all endpoint parameters.\n    // But we'll use an enhanced mapper, that takes into account the results from the previous step.\n\n\n    mapper = new typeMapper_1.TypeMapper(newCustomTypes);\n\n    for (const iface of this.interfaces) {\n      let newEndpoints = [];\n\n      for (const endpoint of iface.endpoints) {\n        newEndpoints.push(mapEndpoint(endpoint, mapper));\n      }\n\n      let newConstructor = iface.constructorDefinition ? mapEndpoint(iface.constructorDefinition, mapper) : null;\n      newInterfaces.push(new contractInterface_1.ContractInterface(iface.name, newConstructor, newEndpoints));\n    } // Now return the new registry, with all types remapped to known types\n\n\n    let newRegistry = new AbiRegistry();\n    newRegistry.customTypes.push(...newCustomTypes);\n    newRegistry.interfaces.push(...newInterfaces);\n    return newRegistry;\n  }\n\n}\n\nexports.AbiRegistry = AbiRegistry;\n\nfunction mapEndpoint(endpoint, mapper) {\n  let newInput = endpoint.input.map(e => new endpoint_1.EndpointParameterDefinition(e.name, e.description, mapper.mapType(e.type)));\n  let newOutput = endpoint.output.map(e => new endpoint_1.EndpointParameterDefinition(e.name, e.description, mapper.mapType(e.type)));\n  return new endpoint_1.EndpointDefinition(endpoint.name, newInput, newOutput, endpoint.modifiers);\n}","map":{"version":3,"mappings":"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","names":["AbiRegistry","constructor","load","json","registry","file","files","extendFromFile","url","urls","extendFromUrl","remapToKnownTypes","jsonContent","fs","promises","readFile","encoding","JSON","parse","extend","response","axios_1","get","data","types","iface","contractInterface_1","fromJSON","interfaces","push","customTypeName","itemJson","typeDiscriminant","type","name","customType","createCustomType","customTypes","struct_1","enum_1","errors","ErrTypingSystem","getInterface","result","find","e","utils_1","getInterfaces","names","map","getStruct","getName","getStructs","getEnum","getEnums","mapper","typeMapper_1","newCustomTypes","newInterfaces","mappedTyped","mapType","feedCustomType","newEndpoints","endpoint","endpoints","mapEndpoint","newConstructor","constructorDefinition","newRegistry","exports","newInput","input","endpoint_1","description","newOutput","output","modifiers"],"sourceRoot":"","sources":["../../../src/smartcontracts/typesystem/abiRegistry.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}