{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  Object.defineProperty(o, k2, {\n    enumerable: true,\n    get: function () {\n      return m[k];\n    }\n  });\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.StructField = exports.Struct = exports.StructFieldDefinition = exports.StructType = void 0;\n\nconst errors = __importStar(require(\"../../errors\"));\n\nconst typeExpressionParser_1 = require(\"./typeExpressionParser\");\n\nconst types_1 = require(\"./types\");\n\nclass StructType extends types_1.CustomType {\n  constructor(name, fields) {\n    super(name);\n    this.fields = [];\n    this.fields = fields;\n  }\n\n  static fromJSON(json) {\n    let fields = (json.fields || []).map(field => StructFieldDefinition.fromJSON(field));\n    return new StructType(json.name, fields);\n  }\n\n}\n\nexports.StructType = StructType; // TODO: Perhaps rename to FieldDefinition and extract to separate file, fields.ts?\n\nclass StructFieldDefinition {\n  constructor(name, description, type) {\n    this.name = name;\n    this.description = description;\n    this.type = type;\n  }\n\n  static fromJSON(json) {\n    let parsedType = new typeExpressionParser_1.TypeExpressionParser().parse(json.type);\n    return new StructFieldDefinition(json.name, json.description, parsedType);\n  }\n\n}\n\nexports.StructFieldDefinition = StructFieldDefinition; // TODO: implement setField(), convenience method.\n// TODO: Hold fields in a map (by name), and use the order within \"field definitions\" to perform codec operations.\n\nclass Struct extends types_1.TypedValue {\n  /**\n   * Currently, one can only set fields at initialization time. Construction will be improved at a later time.\n   */\n  constructor(type, fields) {\n    super(type);\n    this.fields = [];\n    this.fields = fields;\n    this.checkTyping();\n  }\n\n  checkTyping() {\n    let fields = this.fields;\n    let type = this.getType();\n    let definitions = type.fields;\n\n    if (fields.length != definitions.length) {\n      throw new errors.ErrStructTyping(\"fields length vs. field definitions length\");\n    }\n\n    for (let i = 0; i < fields.length; i++) {\n      let field = fields[i];\n      let definition = definitions[i];\n      let fieldType = field.value.getType();\n      let definitionType = definition.type;\n\n      if (!fieldType.equals(definitionType)) {\n        throw new errors.ErrStructTyping(`check type of field \"${definition.name}; expected: ${definitionType}, actual: ${fieldType}\"`);\n      }\n\n      if (field.name != definition.name) {\n        throw new errors.ErrStructTyping(`check name of field \"${definition.name}\"`);\n      }\n    }\n  }\n\n  getFields() {\n    return this.fields;\n  }\n\n  valueOf() {\n    let result = {};\n\n    for (const field of this.fields) {\n      result[field.name] = field.value.valueOf();\n    }\n\n    return result;\n  }\n\n  equals(other) {\n    if (!this.getType().equals(other.getType())) {\n      return false;\n    }\n\n    let selfFields = this.getFields();\n    let otherFields = other.getFields();\n\n    if (selfFields.length != otherFields.length) {\n      return false;\n    }\n\n    for (let i = 0; i < selfFields.length; i++) {\n      let selfField = selfFields[i];\n      let otherField = otherFields[i];\n\n      if (!selfField.equals(otherField)) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n}\n\nexports.Struct = Struct; // TODO: Perhaps rename to Field and extract to separate file, fields.ts?\n\nclass StructField {\n  constructor(value) {\n    let name = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"\";\n    this.value = value;\n    this.name = name;\n  }\n\n  equals(other) {\n    return this.name == other.name && this.value.equals(other.value);\n  }\n\n}\n\nexports.StructField = StructField;","map":{"version":3,"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;;AACA;;AACA;;AAEA,MAAaA,UAAb,SAAgCC,kBAAhC,CAA0C;EAGtCC,YAAYC,IAAZ,EAA0BC,MAA1B,EAAyD;IACrD,MAAMD,IAAN;IAHK,cAAkC,EAAlC;IAIL,KAAKC,MAAL,GAAcA,MAAd;EACH;;EAEc,OAARC,QAAQ,CAACC,IAAD,EAAsC;IACjD,IAAIF,MAAM,GAAG,CAACE,IAAI,CAACF,MAAL,IAAe,EAAhB,EAAoBG,GAApB,CAAwBC,KAAK,IAAIC,qBAAqB,CAACJ,QAAtB,CAA+BG,KAA/B,CAAjC,CAAb;IACA,OAAO,IAAIR,UAAJ,CAAeM,IAAI,CAACH,IAApB,EAA0BC,MAA1B,CAAP;EACH;;AAXqC;;AAA1CM,gC,CAcA;;AACA,MAAaD,qBAAb,CAAkC;EAK9BP,YAAYC,IAAZ,EAA0BQ,WAA1B,EAA+CC,IAA/C,EAAyD;IACrD,KAAKT,IAAL,GAAYA,IAAZ;IACA,KAAKQ,WAAL,GAAmBA,WAAnB;IACA,KAAKC,IAAL,GAAYA,IAAZ;EACH;;EAEc,OAARP,QAAQ,CAACC,IAAD,EAA0D;IACrE,IAAIO,UAAU,GAAG,IAAIC,2CAAJ,GAA2BC,KAA3B,CAAiCT,IAAI,CAACM,IAAtC,CAAjB;IACA,OAAO,IAAIH,qBAAJ,CAA0BH,IAAI,CAACH,IAA/B,EAAqCG,IAAI,CAACK,WAA1C,EAAuDE,UAAvD,CAAP;EACH;;AAd6B;;AAAlCH,sD,CAiBA;AACA;;AACA,MAAaM,MAAb,SAA4Bf,kBAA5B,CAAsC;EAGlC;;;EAGAC,YAAYU,IAAZ,EAA8BR,MAA9B,EAAmD;IAC/C,MAAMQ,IAAN;IANa,cAAwB,EAAxB;IAOb,KAAKR,MAAL,GAAcA,MAAd;IAEA,KAAKa,WAAL;EACH;;EAEOA,WAAW;IACf,IAAIb,MAAM,GAAG,KAAKA,MAAlB;IACA,IAAIQ,IAAI,GAAe,KAAKM,OAAL,EAAvB;IACA,IAAIC,WAAW,GAAGP,IAAI,CAACR,MAAvB;;IAEA,IAAIA,MAAM,CAACgB,MAAP,IAAiBD,WAAW,CAACC,MAAjC,EAAyC;MACrC,MAAM,IAAIC,MAAM,CAACC,eAAX,CAA2B,4CAA3B,CAAN;IACH;;IAED,KAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGnB,MAAM,CAACgB,MAA3B,EAAmCG,CAAC,EAApC,EAAwC;MACpC,IAAIf,KAAK,GAAGJ,MAAM,CAACmB,CAAD,CAAlB;MACA,IAAIC,UAAU,GAAGL,WAAW,CAACI,CAAD,CAA5B;MACA,IAAIE,SAAS,GAAGjB,KAAK,CAACkB,KAAN,CAAYR,OAAZ,EAAhB;MACA,IAAIS,cAAc,GAAGH,UAAU,CAACZ,IAAhC;;MAEA,IAAI,CAACa,SAAS,CAACG,MAAV,CAAiBD,cAAjB,CAAL,EAAuC;QACnC,MAAM,IAAIN,MAAM,CAACC,eAAX,CAA2B,wBAAwBE,UAAU,CAACrB,IAAI,eAAewB,cAAc,aAAaF,SAAS,GAArH,CAAN;MACH;;MACD,IAAIjB,KAAK,CAACL,IAAN,IAAcqB,UAAU,CAACrB,IAA7B,EAAmC;QAC/B,MAAM,IAAIkB,MAAM,CAACC,eAAX,CAA2B,wBAAwBE,UAAU,CAACrB,IAAI,GAAlE,CAAN;MACH;IACJ;EACJ;;EAED0B,SAAS;IACL,OAAO,KAAKzB,MAAZ;EACH;;EAED0B,OAAO;IACH,IAAIC,MAAM,GAAQ,EAAlB;;IAEA,KAAK,MAAMvB,KAAX,IAAoB,KAAKJ,MAAzB,EAAiC;MAC7B2B,MAAM,CAACvB,KAAK,CAACL,IAAP,CAAN,GAAqBK,KAAK,CAACkB,KAAN,CAAYI,OAAZ,EAArB;IACH;;IAED,OAAOC,MAAP;EACH;;EAEDH,MAAM,CAACI,KAAD,EAAc;IAChB,IAAI,CAAC,KAAKd,OAAL,GAAeU,MAAf,CAAsBI,KAAK,CAACd,OAAN,EAAtB,CAAL,EAA6C;MACzC,OAAO,KAAP;IACH;;IAED,IAAIe,UAAU,GAAG,KAAKJ,SAAL,EAAjB;IACA,IAAIK,WAAW,GAAGF,KAAK,CAACH,SAAN,EAAlB;;IAEA,IAAII,UAAU,CAACb,MAAX,IAAqBc,WAAW,CAACd,MAArC,EAA6C;MACzC,OAAO,KAAP;IACH;;IAED,KAAK,IAAIG,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGU,UAAU,CAACb,MAA/B,EAAuCG,CAAC,EAAxC,EAA4C;MACxC,IAAIY,SAAS,GAAGF,UAAU,CAACV,CAAD,CAA1B;MACA,IAAIa,UAAU,GAAGF,WAAW,CAACX,CAAD,CAA5B;;MAEA,IAAI,CAACY,SAAS,CAACP,MAAV,CAAiBQ,UAAjB,CAAL,EAAmC;QAC/B,OAAO,KAAP;MACH;IACJ;;IAED,OAAO,IAAP;EACH;;AAzEiC;;AAAtC1B,wB,CA6EA;;AACA,MAAa2B,WAAb,CAAwB;EAIpBnC,YAAYwB,KAAZ,EAAgD;IAAA,IAAjBvB,IAAiB,uEAAF,EAAE;IAC5C,KAAKuB,KAAL,GAAaA,KAAb;IACA,KAAKvB,IAAL,GAAYA,IAAZ;EACH;;EAEDyB,MAAM,CAACI,KAAD,EAAmB;IACrB,OAAO,KAAK7B,IAAL,IAAa6B,KAAK,CAAC7B,IAAnB,IAA2B,KAAKuB,KAAL,CAAWE,MAAX,CAAkBI,KAAK,CAACN,KAAxB,CAAlC;EACH;;AAXmB;;AAAxBhB","names":["StructType","types_1","constructor","name","fields","fromJSON","json","map","field","StructFieldDefinition","exports","description","type","parsedType","typeExpressionParser_1","parse","Struct","checkTyping","getType","definitions","length","errors","ErrStructTyping","i","definition","fieldType","value","definitionType","equals","getFields","valueOf","result","other","selfFields","otherFields","selfField","otherField","StructField"],"sourceRoot":"","sources":["../../../src/smartcontracts/typesystem/struct.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}