{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  Object.defineProperty(o, k2, {\n    enumerable: true,\n    get: function () {\n      return m[k];\n    }\n  });\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.common = exports.clamp = exports.isPendingLedgerVersion = exports.hasCompleteLedgerRange = exports.getRecursive = exports.renameCounterpartyToIssuerInOrder = exports.renameCounterpartyToIssuer = exports.compareTransactions = exports.ensureLedgerVersion = exports.getXRPBalance = void 0;\n\nconst _ = __importStar(require(\"lodash\"));\n\nconst assert = __importStar(require(\"assert\"));\n\nconst common = __importStar(require(\"../common\"));\n\nexports.common = common;\n\nfunction clamp(value, min, max) {\n  assert.ok(min <= max, 'Illegal clamp bounds');\n  return Math.min(Math.max(value, min), max);\n}\n\nexports.clamp = clamp;\n\nfunction getXRPBalance(connection, address, ledgerVersion) {\n  const request = {\n    command: 'account_info',\n    account: address,\n    ledger_index: ledgerVersion\n  };\n  return connection.request(request).then(data => common.dropsToXrp(data.account_data.Balance));\n}\n\nexports.getXRPBalance = getXRPBalance;\n\nfunction getRecursiveRecur(getter, marker, limit) {\n  return getter(marker, limit).then(data => {\n    const remaining = limit - data.results.length;\n\n    if (remaining > 0 && data.marker != null) {\n      return getRecursiveRecur(getter, data.marker, remaining).then(results => data.results.concat(results));\n    }\n\n    return data.results.slice(0, limit);\n  });\n}\n\nfunction getRecursive(getter, limit) {\n  return getRecursiveRecur(getter, undefined, limit || Infinity);\n}\n\nexports.getRecursive = getRecursive;\n\nfunction renameCounterpartyToIssuer(obj) {\n  const issuer = obj.counterparty != null ? obj.counterparty : obj.issuer != null ? obj.issuer : undefined;\n  const withIssuer = Object.assign({}, obj, {\n    issuer\n  });\n  delete withIssuer.counterparty;\n  return withIssuer;\n}\n\nexports.renameCounterpartyToIssuer = renameCounterpartyToIssuer;\n\nfunction renameCounterpartyToIssuerInOrder(order) {\n  const taker_gets = renameCounterpartyToIssuer(order.taker_gets);\n  const taker_pays = renameCounterpartyToIssuer(order.taker_pays);\n  const changes = {\n    taker_gets,\n    taker_pays\n  };\n  return Object.assign({}, order, _.omitBy(changes, value => value == null));\n}\n\nexports.renameCounterpartyToIssuerInOrder = renameCounterpartyToIssuerInOrder;\n\nfunction signum(num) {\n  return num === 0 ? 0 : num > 0 ? 1 : -1;\n}\n\nfunction compareTransactions(first, second) {\n  if (!first.outcome || !second.outcome) {\n    return 0;\n  }\n\n  if (first.outcome.ledgerVersion === second.outcome.ledgerVersion) {\n    return signum(first.outcome.indexInLedger - second.outcome.indexInLedger);\n  }\n\n  return first.outcome.ledgerVersion < second.outcome.ledgerVersion ? -1 : 1;\n}\n\nexports.compareTransactions = compareTransactions;\n\nfunction hasCompleteLedgerRange(connection, minLedgerVersion, maxLedgerVersion) {\n  const firstLedgerVersion = 32570;\n  return connection.hasLedgerVersions(minLedgerVersion || firstLedgerVersion, maxLedgerVersion);\n}\n\nexports.hasCompleteLedgerRange = hasCompleteLedgerRange;\n\nfunction isPendingLedgerVersion(connection, maxLedgerVersion) {\n  return connection.getLedgerVersion().then(ledgerVersion => ledgerVersion < (maxLedgerVersion || 0));\n}\n\nexports.isPendingLedgerVersion = isPendingLedgerVersion;\n\nfunction ensureLedgerVersion(options) {\n  if (Boolean(options) && options.ledgerVersion != null && options.ledgerVersion !== null) {\n    return Promise.resolve(options);\n  }\n\n  return this.getLedgerVersion().then(ledgerVersion => Object.assign({}, options, {\n    ledgerVersion\n  }));\n}\n\nexports.ensureLedgerVersion = ensureLedgerVersion;","map":{"version":3,"mappings":"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","names":["exports","clamp","value","min","max","assert","ok","Math","getXRPBalance","connection","address","ledgerVersion","request","command","account","ledger_index","then","data","common","dropsToXrp","account_data","Balance","getRecursiveRecur","getter","marker","limit","remaining","results","length","concat","slice","getRecursive","undefined","Infinity","renameCounterpartyToIssuer","obj","issuer","counterparty","withIssuer","Object","assign","renameCounterpartyToIssuerInOrder","order","taker_gets","taker_pays","changes","_","omitBy","signum","num","compareTransactions","first","second","outcome","indexInLedger","hasCompleteLedgerRange","minLedgerVersion","maxLedgerVersion","firstLedgerVersion","hasLedgerVersions","isPendingLedgerVersion","getLedgerVersion","ensureLedgerVersion","options","Boolean","Promise","resolve"],"sourceRoot":"","sources":["../../../src/ledger/utils.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}