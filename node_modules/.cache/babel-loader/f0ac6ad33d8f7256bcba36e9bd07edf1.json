{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  Object.defineProperty(o, k2, {\n    enumerable: true,\n    get: function () {\n      return m[k];\n    }\n  });\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst _ = __importStar(require(\"lodash\"));\n\nconst hashes_1 = require(\"../common/hashes\");\n\nconst common = __importStar(require(\"../common\"));\n\nfunction convertLedgerHeader(header) {\n  return {\n    account_hash: header.stateHash,\n    close_time: common.iso8601ToRippleTime(header.closeTime),\n    close_time_resolution: header.closeTimeResolution,\n    close_flags: header.closeFlags,\n    hash: header.ledgerHash,\n    ledger_hash: header.ledgerHash,\n    ledger_index: header.ledgerVersion.toString(),\n    parent_hash: header.parentLedgerHash,\n    parent_close_time: common.iso8601ToRippleTime(header.parentCloseTime),\n    total_coins: header.totalDrops,\n    transaction_hash: header.transactionHash\n  };\n}\n\nfunction hashLedgerHeader(ledgerHeader) {\n  const header = convertLedgerHeader(ledgerHeader);\n  return hashes_1.computeLedgerHash(header);\n}\n\nfunction computeTransactionHash(ledger, options) {\n  let transactions;\n\n  if (ledger.rawTransactions) {\n    transactions = JSON.parse(ledger.rawTransactions);\n  } else if (ledger.transactions) {\n    try {\n      transactions = ledger.transactions.map(tx => JSON.parse(tx.rawTransaction));\n    } catch (e) {\n      if (e.toString() === 'SyntaxError: Unexpected' + ' token u in JSON at position 0') {\n        throw new common.errors.ValidationError('ledger' + ' is missing raw transactions');\n      }\n    }\n  } else {\n    if (options.computeTreeHashes) {\n      throw new common.errors.ValidationError('transactions' + ' property is missing from the ledger');\n    }\n\n    return ledger.transactionHash;\n  }\n\n  const txs = transactions.map(tx => {\n    const mergeTx = Object.assign({}, _.omit(tx, 'tx'), tx.tx || {});\n    const renameMeta = Object.assign({}, _.omit(mergeTx, 'meta'), tx.meta ? {\n      metaData: tx.meta\n    } : {});\n    return renameMeta;\n  });\n  const transactionHash = hashes_1.computeTransactionTreeHash(txs);\n\n  if (ledger.transactionHash != null && ledger.transactionHash !== transactionHash) {\n    throw new common.errors.ValidationError('transactionHash in header' + ' does not match computed hash of transactions', {\n      transactionHashInHeader: ledger.transactionHash,\n      computedHashOfTransactions: transactionHash\n    });\n  }\n\n  return transactionHash;\n}\n\nfunction computeStateHash(ledger, options) {\n  if (ledger.rawState == null) {\n    if (options.computeTreeHashes) {\n      throw new common.errors.ValidationError('rawState' + ' property is missing from the ledger');\n    }\n\n    return ledger.stateHash;\n  }\n\n  const state = JSON.parse(ledger.rawState);\n  const stateHash = hashes_1.computeStateTreeHash(state);\n\n  if (ledger.stateHash != null && ledger.stateHash !== stateHash) {\n    throw new common.errors.ValidationError('stateHash in header' + ' does not match computed hash of state');\n  }\n\n  return stateHash;\n}\n\nfunction computeLedgerHeaderHash(ledger) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const subhashes = {\n    transactionHash: computeTransactionHash(ledger, options),\n    stateHash: computeStateHash(ledger, options)\n  };\n  return hashLedgerHeader(Object.assign({}, ledger, subhashes));\n}\n\nexports.default = computeLedgerHeaderHash;","map":{"version":3,"mappings":"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","names":["convertLedgerHeader","header","account_hash","stateHash","close_time","common","iso8601ToRippleTime","closeTime","close_time_resolution","closeTimeResolution","close_flags","closeFlags","hash","ledgerHash","ledger_hash","ledger_index","ledgerVersion","toString","parent_hash","parentLedgerHash","parent_close_time","parentCloseTime","total_coins","totalDrops","transaction_hash","transactionHash","hashLedgerHeader","ledgerHeader","hashes_1","computeTransactionHash","ledger","options","transactions","rawTransactions","JSON","parse","map","tx","rawTransaction","e","errors","ValidationError","computeTreeHashes","txs","mergeTx","Object","assign","_","omit","renameMeta","meta","metaData","transactionHashInHeader","computedHashOfTransactions","computeStateHash","rawState","state","computeLedgerHeaderHash","subhashes","exports"],"sourceRoot":"","sources":["../../../src/offline/ledgerhash.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}