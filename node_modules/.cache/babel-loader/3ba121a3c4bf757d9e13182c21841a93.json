{"ast":null,"code":"'use strict';\n\nvar _ = require('lodash');\n\nvar utils = require('./utils');\n\nvar GlobalBigNumber = require('bignumber.js');\n\nvar BigNumber = GlobalBigNumber.clone({\n  DECIMAL_PLACES: 40\n});\n\nvar parseQuality = require('./quality');\n\nvar lsfSell = 0x00020000; // see \"lsfSell\" flag in rippled source code\n\nfunction removeUndefined(obj) {\n  return _.omitBy(obj, _.isUndefined);\n}\n\nfunction convertOrderChange(order) {\n  var takerGets = order.taker_gets;\n  var takerPays = order.taker_pays;\n  var direction = order.sell ? 'sell' : 'buy';\n  var quantity = direction === 'buy' ? takerPays : takerGets;\n  var totalPrice = direction === 'buy' ? takerGets : takerPays;\n  return removeUndefined({\n    direction: direction,\n    quantity: quantity,\n    totalPrice: totalPrice,\n    sequence: order.sequence,\n    status: order.status,\n    makerExchangeRate: order.quality,\n    expirationTime: order.expiration\n  });\n}\n\nfunction rippleToUnixTimestamp(rpepoch) {\n  return (rpepoch + 0x386D4380) * 1000;\n}\n\nfunction getExpirationTime(node) {\n  var expirationTime = node.finalFields.Expiration || node.newFields.Expiration;\n\n  if (expirationTime === undefined) {\n    return undefined;\n  }\n\n  return new Date(rippleToUnixTimestamp(expirationTime)).toISOString();\n}\n\nfunction getQuality(node) {\n  var takerGets = node.finalFields.TakerGets || node.newFields.TakerGets;\n  var takerPays = node.finalFields.TakerPays || node.newFields.TakerPays;\n  var takerGetsCurrency = takerGets.currency || 'XRP';\n  var takerPaysCurrency = takerPays.currency || 'XRP';\n  var bookDirectory = node.finalFields.BookDirectory || node.newFields.BookDirectory;\n  var qualityHex = bookDirectory.substring(bookDirectory.length - 16);\n  return parseQuality(qualityHex, takerGetsCurrency, takerPaysCurrency);\n}\n\nfunction parseOrderStatus(node) {\n  if (node.diffType === 'CreatedNode') {\n    // \"submitted\" is more conventional, but could be confusing in the\n    // context of Ripple\n    return 'created';\n  }\n\n  if (node.diffType === 'ModifiedNode') {\n    return 'partially-filled';\n  }\n\n  if (node.diffType === 'DeletedNode') {\n    // A filled order has previous fields\n    if (node.previousFields.hasOwnProperty('TakerPays')) {\n      return 'filled';\n    } // A cancelled order has no previous fields\n    // google search for \"cancelled order\" shows 5x more results than\n    // \"canceled order\", even though both spellings are correct\n\n\n    return 'cancelled';\n  }\n\n  return undefined;\n}\n\nfunction calculateDelta(finalAmount, previousAmount) {\n  if (previousAmount) {\n    var finalValue = new BigNumber(finalAmount.value);\n    var previousValue = new BigNumber(previousAmount.value);\n    return finalValue.minus(previousValue).abs().toString();\n  }\n\n  return '0';\n}\n\nfunction parseChangeAmount(node, type) {\n  var status = parseOrderStatus(node);\n\n  if (status === 'cancelled') {\n    // Canceled orders do not have PreviousFields; FinalFields\n    // have positive values\n    return utils.parseCurrencyAmount(node.finalFields[type]);\n  } else if (status === 'created') {\n    return utils.parseCurrencyAmount(node.newFields[type]);\n  }\n\n  var finalAmount = utils.parseCurrencyAmount(node.finalFields[type]);\n  var previousAmount = utils.parseCurrencyAmount(node.previousFields[type]);\n  var value = calculateDelta(finalAmount, previousAmount);\n  return _.assign({}, finalAmount, {\n    value: value\n  });\n}\n\nfunction parseOrderChange(node) {\n  var orderChange = convertOrderChange({\n    taker_pays: parseChangeAmount(node, 'TakerPays'),\n    taker_gets: parseChangeAmount(node, 'TakerGets'),\n    sell: (node.finalFields.Flags & lsfSell) !== 0,\n    sequence: node.finalFields.Sequence || node.newFields.Sequence,\n    status: parseOrderStatus(node),\n    quality: getQuality(node),\n    expiration: getExpirationTime(node)\n  });\n  Object.defineProperty(orderChange, 'account', {\n    value: node.finalFields.Account || node.newFields.Account\n  });\n  return orderChange;\n}\n\nfunction groupByAddress(orderChanges) {\n  return _.groupBy(orderChanges, function (change) {\n    return change.account;\n  });\n}\n/**\n * Computes the complete list of every Offer that changed in the ledger\n * as a result of the given transaction.\n * Returns changes grouped by Ripple account.\n *\n *  @param {Object} metadata - Transaction metadata as return by ripple-lib\n *  @returns {Object} - Orderbook changes grouped by Ripple account\n *\n */\n\n\nexports.parseOrderbookChanges = function parseOrderbookChanges(metadata) {\n  var nodes = utils.normalizeNodes(metadata);\n\n  var orderChanges = _.map(_.filter(nodes, function (node) {\n    return node.entryType === 'Offer';\n  }), parseOrderChange);\n\n  return groupByAddress(orderChanges);\n};","map":{"version":3,"names":["_","require","utils","GlobalBigNumber","BigNumber","clone","DECIMAL_PLACES","parseQuality","lsfSell","removeUndefined","obj","omitBy","isUndefined","convertOrderChange","order","takerGets","taker_gets","takerPays","taker_pays","direction","sell","quantity","totalPrice","sequence","status","makerExchangeRate","quality","expirationTime","expiration","rippleToUnixTimestamp","rpepoch","getExpirationTime","node","finalFields","Expiration","newFields","undefined","Date","toISOString","getQuality","TakerGets","TakerPays","takerGetsCurrency","currency","takerPaysCurrency","bookDirectory","BookDirectory","qualityHex","substring","length","parseOrderStatus","diffType","previousFields","hasOwnProperty","calculateDelta","finalAmount","previousAmount","finalValue","value","previousValue","minus","abs","toString","parseChangeAmount","type","parseCurrencyAmount","assign","parseOrderChange","orderChange","Flags","Sequence","Object","defineProperty","Account","groupByAddress","orderChanges","groupBy","change","account","exports","parseOrderbookChanges","metadata","nodes","normalizeNodes","map","filter","entryType"],"sources":["C:/Users/acer/node_modules/ripple-lib-transactionparser/src/orderbookchanges.js"],"sourcesContent":["'use strict'\nvar _ = require('lodash')\nvar utils = require('./utils')\nvar GlobalBigNumber = require('bignumber.js')\nvar BigNumber = GlobalBigNumber.clone({DECIMAL_PLACES: 40})\nvar parseQuality = require('./quality')\n\nvar lsfSell = 0x00020000 // see \"lsfSell\" flag in rippled source code\n\nfunction removeUndefined(obj) {\n  return _.omitBy(obj, _.isUndefined)\n}\n\nfunction convertOrderChange(order) {\n  var takerGets = order.taker_gets\n  var takerPays = order.taker_pays\n  var direction = order.sell ? 'sell' : 'buy'\n  var quantity = (direction === 'buy') ? takerPays : takerGets\n  var totalPrice = (direction === 'buy') ? takerGets : takerPays\n  return removeUndefined({\n    direction: direction,\n    quantity: quantity,\n    totalPrice: totalPrice,\n    sequence: order.sequence,\n    status: order.status,\n    makerExchangeRate: order.quality,\n    expirationTime: order.expiration\n  })\n}\n\nfunction rippleToUnixTimestamp(rpepoch) {\n  return (rpepoch + 0x386D4380) * 1000\n}\n\nfunction getExpirationTime(node) {\n  var expirationTime = node.finalFields.Expiration || node.newFields.Expiration\n  if (expirationTime === undefined) {\n    return undefined\n  }\n  return (new Date(rippleToUnixTimestamp(expirationTime))).toISOString()\n}\n\nfunction getQuality(node) {\n  var takerGets = node.finalFields.TakerGets || node.newFields.TakerGets\n  var takerPays = node.finalFields.TakerPays || node.newFields.TakerPays\n  var takerGetsCurrency = takerGets.currency || 'XRP'\n  var takerPaysCurrency = takerPays.currency || 'XRP'\n  var bookDirectory = node.finalFields.BookDirectory\n    || node.newFields.BookDirectory\n  var qualityHex = bookDirectory.substring(bookDirectory.length - 16)\n  return parseQuality(qualityHex, takerGetsCurrency, takerPaysCurrency)\n}\n\nfunction parseOrderStatus(node) {\n  if (node.diffType === 'CreatedNode') {\n    // \"submitted\" is more conventional, but could be confusing in the\n    // context of Ripple\n    return 'created'\n  }\n\n  if (node.diffType === 'ModifiedNode') {\n    return 'partially-filled'\n  }\n\n  if (node.diffType === 'DeletedNode') {\n    // A filled order has previous fields\n    if (node.previousFields.hasOwnProperty('TakerPays')) {\n      return 'filled'\n    }\n\n    // A cancelled order has no previous fields\n    // google search for \"cancelled order\" shows 5x more results than\n    // \"canceled order\", even though both spellings are correct\n    return 'cancelled'\n  }\n  return undefined\n}\n\nfunction calculateDelta(finalAmount, previousAmount) {\n  if (previousAmount) {\n    var finalValue = new BigNumber(finalAmount.value)\n    var previousValue = new BigNumber(previousAmount.value)\n    return finalValue.minus(previousValue).abs().toString()\n  }\n  return '0'\n}\n\nfunction parseChangeAmount(node, type) {\n  var status = parseOrderStatus(node)\n\n  if (status === 'cancelled') {\n    // Canceled orders do not have PreviousFields; FinalFields\n    // have positive values\n    return utils.parseCurrencyAmount(node.finalFields[type])\n  } else if (status === 'created') {\n    return utils.parseCurrencyAmount(node.newFields[type])\n  }\n  var finalAmount = utils.parseCurrencyAmount(node.finalFields[type])\n  var previousAmount = utils.parseCurrencyAmount(node.previousFields[type])\n  var value = calculateDelta(finalAmount, previousAmount)\n  return _.assign({}, finalAmount, {value: value})\n}\n\nfunction parseOrderChange(node) {\n  var orderChange = convertOrderChange({\n    taker_pays: parseChangeAmount(node, 'TakerPays'),\n    taker_gets: parseChangeAmount(node, 'TakerGets'),\n    sell: (node.finalFields.Flags & lsfSell) !== 0,\n    sequence: node.finalFields.Sequence || node.newFields.Sequence,\n    status: parseOrderStatus(node),\n    quality: getQuality(node),\n    expiration: getExpirationTime(node)\n  })\n\n  Object.defineProperty(orderChange, 'account', {\n    value: node.finalFields.Account || node.newFields.Account\n  })\n\n  return orderChange\n}\n\nfunction groupByAddress(orderChanges) {\n  return _.groupBy(orderChanges, function(change) {\n    return change.account\n  })\n}\n\n/**\n * Computes the complete list of every Offer that changed in the ledger\n * as a result of the given transaction.\n * Returns changes grouped by Ripple account.\n *\n *  @param {Object} metadata - Transaction metadata as return by ripple-lib\n *  @returns {Object} - Orderbook changes grouped by Ripple account\n *\n */\nexports.parseOrderbookChanges = function parseOrderbookChanges(metadata) {\n  var nodes = utils.normalizeNodes(metadata)\n\n  var orderChanges = _.map(_.filter(nodes, function(node) {\n    return node.entryType === 'Offer'\n  }), parseOrderChange)\n\n  return groupByAddress(orderChanges)\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}