{"ast":null,"code":"var Buffer = require('safe-buffer').Buffer;\n\nvar createHmac = require('create-hmac');\n\nvar BigInteger = require('bigi');\n\nvar typeforce = require('typeforce');\n\nvar types = require('./types');\n\nvar ecurve = require('ecurve');\n\nvar secp256k1 = ecurve.getCurveByName('secp256k1');\nvar ZERO = Buffer.alloc(1, 0);\nvar ONE = Buffer.alloc(1, 1); // https://tools.ietf.org/html/rfc6979#section-3.2\n\nfunction deterministicGenerateK(hash, x, checkSig, algo16) {\n  typeforce(types.tuple(types.Hash256bit, types.Buffer256bit, types.Function), arguments); // Step A, ignored as hash already provided\n  // Step B\n  // Step C\n\n  var k = Buffer.alloc(32, 0);\n  var v = Buffer.alloc(32, 1); // Step D\n\n  k = createHmac('sha256', k).update(v).update(ZERO).update(x).update(hash);\n\n  if (algo16) {\n    typeforce(typeforce.BufferN(16), algo16);\n    k.update(algo16);\n  }\n\n  k = k.digest(); // Step E\n\n  v = createHmac('sha256', k).update(v).digest(); // Step F\n\n  k = createHmac('sha256', k).update(v).update(ONE).update(x).update(hash);\n\n  if (algo16) {\n    typeforce(typeforce.BufferN(16), algo16);\n    k.update(algo16);\n  }\n\n  k = k.digest(); // Step G\n\n  v = createHmac('sha256', k).update(v).digest(); // Step H1/H2a, ignored as tlen === qlen (256 bit)\n  // Step H2b\n\n  v = createHmac('sha256', k).update(v).digest();\n  var T = BigInteger.fromBuffer(v); // Step H3, repeat until T is within the interval [1, n - 1] and is suitable for ECDSA\n\n  while (T.signum() <= 0 || T.compareTo(secp256k1.n) >= 0 || !checkSig(T)) {\n    k = createHmac('sha256', k).update(v).update(ZERO).digest();\n    v = createHmac('sha256', k).update(v).digest(); // Step H1/H2a, again, ignored as tlen === qlen (256 bit)\n    // Step H2b again\n\n    v = createHmac('sha256', k).update(v).digest();\n    T = BigInteger.fromBuffer(v);\n  }\n\n  return T;\n}\n\nmodule.exports = {\n  deterministicGenerateK: deterministicGenerateK\n};","map":{"version":3,"names":["Buffer","require","createHmac","BigInteger","typeforce","types","ecurve","secp256k1","getCurveByName","ZERO","alloc","ONE","deterministicGenerateK","hash","x","checkSig","algo16","tuple","Hash256bit","Buffer256bit","Function","arguments","k","v","update","BufferN","digest","T","fromBuffer","signum","compareTo","n","module","exports"],"sources":["C:/Users/acer/node_modules/@tatumio/bitcoincashjs2-lib/src/rfc6979.js"],"sourcesContent":["var Buffer = require('safe-buffer').Buffer\nvar createHmac = require('create-hmac')\nvar BigInteger = require('bigi')\n\nvar typeforce = require('typeforce')\nvar types = require('./types')\n\nvar ecurve = require('ecurve')\nvar secp256k1 = ecurve.getCurveByName('secp256k1')\n\nvar ZERO = Buffer.alloc(1, 0)\nvar ONE = Buffer.alloc(1, 1)\n\n// https://tools.ietf.org/html/rfc6979#section-3.2\nfunction deterministicGenerateK(hash, x, checkSig, algo16) {\n  typeforce(types.tuple(\n    types.Hash256bit,\n    types.Buffer256bit,\n    types.Function\n  ), arguments)\n\n  // Step A, ignored as hash already provided\n  // Step B\n  // Step C\n  var k = Buffer.alloc(32, 0)\n  var v = Buffer.alloc(32, 1)\n\n  // Step D\n  k = createHmac('sha256', k)\n    .update(v)\n    .update(ZERO)\n    .update(x)\n    .update(hash)\n\n  if(algo16){\n    typeforce(typeforce.BufferN(16), algo16)\n\n    k.update(algo16)\n  }\n\n  k = k.digest()\n\n  // Step E\n  v = createHmac('sha256', k).update(v).digest()\n\n  // Step F\n  k = createHmac('sha256', k)\n    .update(v)\n    .update(ONE)\n    .update(x)\n    .update(hash)\n\n  if(algo16){\n    typeforce(typeforce.BufferN(16), algo16)\n\n    k.update(algo16)\n  }\n  \n  k = k.digest()\n\n  // Step G\n  v = createHmac('sha256', k).update(v).digest()\n\n  // Step H1/H2a, ignored as tlen === qlen (256 bit)\n  // Step H2b\n  v = createHmac('sha256', k).update(v).digest()\n\n  var T = BigInteger.fromBuffer(v)\n\n  // Step H3, repeat until T is within the interval [1, n - 1] and is suitable for ECDSA\n  while (T.signum() <= 0 || T.compareTo(secp256k1.n) >= 0 || !checkSig(T)) {\n    k = createHmac('sha256', k)\n      .update(v)\n      .update(ZERO)\n      .digest()\n\n    v = createHmac('sha256', k).update(v).digest()\n\n    // Step H1/H2a, again, ignored as tlen === qlen (256 bit)\n    // Step H2b again\n    v = createHmac('sha256', k).update(v).digest()\n    T = BigInteger.fromBuffer(v)\n  }\n\n  return T\n}\n\nmodule.exports = {\n  deterministicGenerateK: deterministicGenerateK,\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}