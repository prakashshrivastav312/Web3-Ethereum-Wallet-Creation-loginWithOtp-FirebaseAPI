{"ast":null,"code":"var Buffer = require('safe-buffer').Buffer;\n\nvar bcrypto = require('./crypto');\n\nvar bscript = require('./script');\n\nvar bufferutils = require('./bufferutils');\n\nvar opcodes = require('@tatumio/bitcoincash-ops');\n\nvar typeforce = require('typeforce');\n\nvar types = require('./types');\n\nvar varuint = require('varuint-bitcoin');\n\nfunction varSliceSize(someScript) {\n  var length = someScript.length;\n  return varuint.encodingLength(length) + length;\n}\n\nfunction vectorSize(someVector) {\n  var length = someVector.length;\n  return varuint.encodingLength(length) + someVector.reduce(function (sum, witness) {\n    return sum + varSliceSize(witness);\n  }, 0);\n}\n\nfunction Transaction() {\n  this.version = 2;\n  this.locktime = 0;\n  this.ins = [];\n  this.outs = [];\n}\n\nTransaction.DEFAULT_SEQUENCE = 0xffffffff;\nTransaction.SIGHASH_ALL = 0x01;\nTransaction.SIGHASH_NONE = 0x02;\nTransaction.SIGHASH_SINGLE = 0x03;\nTransaction.SIGHASH_ANYONECANPAY = 0x80;\nTransaction.SIGHASH_BITCOINCASHBIP143 = 0x40;\nTransaction.ADVANCED_TRANSACTION_MARKER = 0x00;\nTransaction.ADVANCED_TRANSACTION_FLAG = 0x01;\nvar EMPTY_SCRIPT = Buffer.allocUnsafe(0);\nvar EMPTY_WITNESS = [];\nvar ZERO = Buffer.from('0000000000000000000000000000000000000000000000000000000000000000', 'hex');\nvar ONE = Buffer.from('0000000000000000000000000000000000000000000000000000000000000001', 'hex');\nvar VALUE_UINT64_MAX = Buffer.from('ffffffffffffffff', 'hex');\nvar BLANK_OUTPUT = {\n  script: EMPTY_SCRIPT,\n  valueBuffer: VALUE_UINT64_MAX\n};\n\nTransaction.fromBuffer = function (buffer, __noStrict) {\n  var offset = 0;\n\n  function readSlice(n) {\n    offset += n;\n    return buffer.slice(offset - n, offset);\n  }\n\n  function readUInt32() {\n    var i = buffer.readUInt32LE(offset);\n    offset += 4;\n    return i;\n  }\n\n  function readInt32() {\n    var i = buffer.readInt32LE(offset);\n    offset += 4;\n    return i;\n  }\n\n  function readUInt64() {\n    var i = bufferutils.readUInt64LE(buffer, offset);\n    offset += 8;\n    return i;\n  }\n\n  function readVarInt() {\n    var vi = varuint.decode(buffer, offset);\n    offset += varuint.decode.bytes;\n    return vi;\n  }\n\n  function readVarSlice() {\n    return readSlice(readVarInt());\n  }\n\n  function readVector() {\n    var count = readVarInt();\n    var vector = [];\n\n    for (var i = 0; i < count; i++) vector.push(readVarSlice());\n\n    return vector;\n  }\n\n  var tx = new Transaction();\n  tx.version = readInt32();\n  var marker = buffer.readUInt8(offset);\n  var flag = buffer.readUInt8(offset + 1);\n  var hasWitnesses = false;\n\n  if (marker === Transaction.ADVANCED_TRANSACTION_MARKER && flag === Transaction.ADVANCED_TRANSACTION_FLAG) {\n    offset += 2;\n    hasWitnesses = true;\n  }\n\n  var vinLen = readVarInt();\n\n  for (var i = 0; i < vinLen; ++i) {\n    tx.ins.push({\n      hash: readSlice(32),\n      index: readUInt32(),\n      script: readVarSlice(),\n      sequence: readUInt32(),\n      witness: EMPTY_WITNESS\n    });\n  }\n\n  var voutLen = readVarInt();\n\n  for (i = 0; i < voutLen; ++i) {\n    tx.outs.push({\n      value: readUInt64(),\n      script: readVarSlice()\n    });\n  }\n\n  if (hasWitnesses) {\n    for (i = 0; i < vinLen; ++i) {\n      tx.ins[i].witness = readVector();\n    } // was this pointless?\n\n\n    if (!tx.hasWitnesses()) throw new Error('Transaction has superfluous witness data');\n  }\n\n  tx.locktime = readUInt32();\n  if (__noStrict) return tx;\n  if (offset !== buffer.length) throw new Error('Transaction has unexpected data');\n  return tx;\n};\n\nTransaction.fromHex = function (hex) {\n  return Transaction.fromBuffer(Buffer.from(hex, 'hex'));\n};\n\nTransaction.isCoinbaseHash = function (buffer) {\n  typeforce(types.Hash256bit, buffer);\n\n  for (var i = 0; i < 32; ++i) {\n    if (buffer[i] !== 0) return false;\n  }\n\n  return true;\n};\n\nTransaction.prototype.isCoinbase = function () {\n  return this.ins.length === 1 && Transaction.isCoinbaseHash(this.ins[0].hash);\n};\n\nTransaction.prototype.addInput = function (hash, index, sequence, scriptSig) {\n  typeforce(types.tuple(types.Hash256bit, types.UInt32, types.maybe(types.UInt32), types.maybe(types.Buffer)), arguments);\n\n  if (types.Null(sequence)) {\n    sequence = Transaction.DEFAULT_SEQUENCE;\n  } // Add the input and return the input's index\n\n\n  return this.ins.push({\n    hash: hash,\n    index: index,\n    script: scriptSig || EMPTY_SCRIPT,\n    sequence: sequence,\n    witness: EMPTY_WITNESS\n  }) - 1;\n};\n\nTransaction.prototype.addOutput = function (scriptPubKey, value) {\n  typeforce(types.tuple(types.Buffer, types.Satoshi), arguments); // Add the output and return the output's index\n\n  return this.outs.push({\n    script: scriptPubKey,\n    value: value\n  }) - 1;\n};\n\nTransaction.prototype.hasWitnesses = function () {\n  return this.ins.some(function (x) {\n    return x.witness.length !== 0;\n  });\n};\n\nTransaction.prototype.weight = function () {\n  var base = this.__byteLength(false);\n\n  var total = this.__byteLength(true);\n\n  return base * 3 + total;\n};\n\nTransaction.prototype.virtualSize = function () {\n  return Math.ceil(this.weight() / 4);\n};\n\nTransaction.prototype.byteLength = function () {\n  return this.__byteLength(true);\n};\n\nTransaction.prototype.__byteLength = function (__allowWitness) {\n  var hasWitnesses = __allowWitness && this.hasWitnesses();\n\n  return (hasWitnesses ? 10 : 8) + varuint.encodingLength(this.ins.length) + varuint.encodingLength(this.outs.length) + this.ins.reduce(function (sum, input) {\n    return sum + 40 + varSliceSize(input.script);\n  }, 0) + this.outs.reduce(function (sum, output) {\n    return sum + 8 + varSliceSize(output.script);\n  }, 0) + (hasWitnesses ? this.ins.reduce(function (sum, input) {\n    return sum + vectorSize(input.witness);\n  }, 0) : 0);\n};\n\nTransaction.prototype.clone = function () {\n  var newTx = new Transaction();\n  newTx.version = this.version;\n  newTx.locktime = this.locktime;\n  newTx.ins = this.ins.map(function (txIn) {\n    return {\n      hash: txIn.hash,\n      index: txIn.index,\n      script: txIn.script,\n      sequence: txIn.sequence,\n      witness: txIn.witness\n    };\n  });\n  newTx.outs = this.outs.map(function (txOut) {\n    return {\n      script: txOut.script,\n      value: txOut.value\n    };\n  });\n  return newTx;\n};\n/**\n * Hash transaction for signing a specific input.\n *\n * Bitcoin uses a different hash for each signed transaction input.\n * This method copies the transaction, makes the necessary changes based on the\n * hashType, and then hashes the result.\n * This hash can then be used to sign the provided transaction input.\n */\n\n\nTransaction.prototype.hashForSignature = function (inIndex, prevOutScript, hashType) {\n  typeforce(types.tuple(types.UInt32, types.Buffer,\n  /* types.UInt8 */\n  types.Number), arguments); // https://github.com/bitcoin/bitcoin/blob/master/src/test/sighash_tests.cpp#L29\n\n  if (inIndex >= this.ins.length) return ONE; // ignore OP_CODESEPARATOR\n\n  var ourScript = bscript.compile(bscript.decompile(prevOutScript).filter(function (x) {\n    return x !== opcodes.OP_CODESEPARATOR;\n  }));\n  var txTmp = this.clone(); // SIGHASH_NONE: ignore all outputs? (wildcard payee)\n\n  if ((hashType & 0x1f) === Transaction.SIGHASH_NONE) {\n    txTmp.outs = []; // ignore sequence numbers (except at inIndex)\n\n    txTmp.ins.forEach(function (input, i) {\n      if (i === inIndex) return;\n      input.sequence = 0;\n    }); // SIGHASH_SINGLE: ignore all outputs, except at the same index?\n  } else if ((hashType & 0x1f) === Transaction.SIGHASH_SINGLE) {\n    // https://github.com/bitcoin/bitcoin/blob/master/src/test/sighash_tests.cpp#L60\n    if (inIndex >= this.outs.length) return ONE; // truncate outputs after\n\n    txTmp.outs.length = inIndex + 1; // \"blank\" outputs before\n\n    for (var i = 0; i < inIndex; i++) {\n      txTmp.outs[i] = BLANK_OUTPUT;\n    } // ignore sequence numbers (except at inIndex)\n\n\n    txTmp.ins.forEach(function (input, y) {\n      if (y === inIndex) return;\n      input.sequence = 0;\n    });\n  } // SIGHASH_ANYONECANPAY: ignore inputs entirely?\n\n\n  if (hashType & Transaction.SIGHASH_ANYONECANPAY) {\n    txTmp.ins = [txTmp.ins[inIndex]];\n    txTmp.ins[0].script = ourScript; // SIGHASH_ALL: only ignore input scripts\n  } else {\n    // \"blank\" others input scripts\n    txTmp.ins.forEach(function (input) {\n      input.script = EMPTY_SCRIPT;\n    });\n    txTmp.ins[inIndex].script = ourScript;\n  } // serialize and hash\n\n\n  var buffer = Buffer.allocUnsafe(txTmp.__byteLength(false) + 4);\n  buffer.writeInt32LE(hashType, buffer.length - 4);\n\n  txTmp.__toBuffer(buffer, 0, false);\n\n  return bcrypto.hash256(buffer);\n};\n\nTransaction.prototype.hashForWitnessV0 = function (inIndex, prevOutScript, value, hashType) {\n  typeforce(types.tuple(types.UInt32, types.Buffer, types.Satoshi, types.UInt32), arguments);\n  var tbuffer, toffset;\n\n  function writeSlice(slice) {\n    toffset += slice.copy(tbuffer, toffset);\n  }\n\n  function writeUInt32(i) {\n    toffset = tbuffer.writeUInt32LE(i, toffset);\n  }\n\n  function writeUInt64(i) {\n    toffset = bufferutils.writeUInt64LE(tbuffer, i, toffset);\n  }\n\n  function writeVarInt(i) {\n    varuint.encode(i, tbuffer, toffset);\n    toffset += varuint.encode.bytes;\n  }\n\n  function writeVarSlice(slice) {\n    writeVarInt(slice.length);\n    writeSlice(slice);\n  }\n\n  var hashOutputs = ZERO;\n  var hashPrevouts = ZERO;\n  var hashSequence = ZERO;\n\n  if (!(hashType & Transaction.SIGHASH_ANYONECANPAY)) {\n    tbuffer = Buffer.allocUnsafe(36 * this.ins.length);\n    toffset = 0;\n    this.ins.forEach(function (txIn) {\n      writeSlice(txIn.hash);\n      writeUInt32(txIn.index);\n    });\n    hashPrevouts = bcrypto.hash256(tbuffer);\n  }\n\n  if (!(hashType & Transaction.SIGHASH_ANYONECANPAY) && (hashType & 0x1f) !== Transaction.SIGHASH_SINGLE && (hashType & 0x1f) !== Transaction.SIGHASH_NONE) {\n    tbuffer = Buffer.allocUnsafe(4 * this.ins.length);\n    toffset = 0;\n    this.ins.forEach(function (txIn) {\n      writeUInt32(txIn.sequence);\n    });\n    hashSequence = bcrypto.hash256(tbuffer);\n  }\n\n  if ((hashType & 0x1f) !== Transaction.SIGHASH_SINGLE && (hashType & 0x1f) !== Transaction.SIGHASH_NONE) {\n    var txOutsSize = this.outs.reduce(function (sum, output) {\n      return sum + 8 + varSliceSize(output.script);\n    }, 0);\n    tbuffer = Buffer.allocUnsafe(txOutsSize);\n    toffset = 0;\n    this.outs.forEach(function (out) {\n      writeUInt64(out.value);\n      writeVarSlice(out.script);\n    });\n    hashOutputs = bcrypto.hash256(tbuffer);\n  } else if ((hashType & 0x1f) === Transaction.SIGHASH_SINGLE && inIndex < this.outs.length) {\n    var output = this.outs[inIndex];\n    tbuffer = Buffer.allocUnsafe(8 + varSliceSize(output.script));\n    toffset = 0;\n    writeUInt64(output.value);\n    writeVarSlice(output.script);\n    hashOutputs = bcrypto.hash256(tbuffer);\n  }\n\n  tbuffer = Buffer.allocUnsafe(156 + varSliceSize(prevOutScript));\n  toffset = 0;\n  var input = this.ins[inIndex];\n  writeUInt32(this.version);\n  writeSlice(hashPrevouts);\n  writeSlice(hashSequence);\n  writeSlice(input.hash);\n  writeUInt32(input.index);\n  writeVarSlice(prevOutScript);\n  writeUInt64(value);\n  writeUInt32(input.sequence);\n  writeSlice(hashOutputs);\n  writeUInt32(this.locktime);\n  writeUInt32(hashType);\n  return bcrypto.hash256(tbuffer);\n};\n/**\n * Hash transaction for signing a specific input for Bitcoin Cash.\n */\n\n\nTransaction.prototype.hashForCashSignature = function (inIndex, prevOutScript, inAmount, hashType) {\n  typeforce(types.tuple(types.UInt32, types.Buffer,\n  /* types.UInt8 */\n  types.Number, types.maybe(types.UInt53)), arguments); // This function works the way it does because Bitcoin Cash\n  // uses BIP143 as their replay protection, AND their algo\n  // includes `forkId | hashType`, AND since their forkId=0,\n  // this is a NOP, and has no difference to segwit. To support\n  // other forks, another parameter is required, and a new parameter\n  // would be required in the hashForWitnessV0 function, or\n  // it could be broken into two..\n  // BIP143 sighash activated in BitcoinCash via 0x40 bit\n\n  if (hashType & Transaction.SIGHASH_BITCOINCASHBIP143) {\n    if (types.Null(inAmount)) {\n      throw new Error('Bitcoin Cash sighash requires value of input to be signed.');\n    }\n\n    return this.hashForWitnessV0(inIndex, prevOutScript, inAmount, hashType);\n  } else {\n    return this.hashForSignature(inIndex, prevOutScript, hashType);\n  }\n};\n\nTransaction.prototype.getHash = function () {\n  return bcrypto.hash256(this.__toBuffer(undefined, undefined, false));\n};\n\nTransaction.prototype.getId = function () {\n  // transaction hash's are displayed in reverse order\n  return this.getHash().reverse().toString('hex');\n};\n\nTransaction.prototype.toBuffer = function (buffer, initialOffset) {\n  return this.__toBuffer(buffer, initialOffset, true);\n};\n\nTransaction.prototype.__toBuffer = function (buffer, initialOffset, __allowWitness) {\n  if (!buffer) buffer = Buffer.allocUnsafe(this.__byteLength(__allowWitness));\n  var offset = initialOffset || 0;\n\n  function writeSlice(slice) {\n    offset += slice.copy(buffer, offset);\n  }\n\n  function writeUInt8(i) {\n    offset = buffer.writeUInt8(i, offset);\n  }\n\n  function writeUInt32(i) {\n    offset = buffer.writeUInt32LE(i, offset);\n  }\n\n  function writeInt32(i) {\n    offset = buffer.writeInt32LE(i, offset);\n  }\n\n  function writeUInt64(i) {\n    offset = bufferutils.writeUInt64LE(buffer, i, offset);\n  }\n\n  function writeVarInt(i) {\n    varuint.encode(i, buffer, offset);\n    offset += varuint.encode.bytes;\n  }\n\n  function writeVarSlice(slice) {\n    writeVarInt(slice.length);\n    writeSlice(slice);\n  }\n\n  function writeVector(vector) {\n    writeVarInt(vector.length);\n    vector.forEach(writeVarSlice);\n  }\n\n  writeInt32(this.version);\n\n  var hasWitnesses = __allowWitness && this.hasWitnesses();\n\n  if (hasWitnesses) {\n    writeUInt8(Transaction.ADVANCED_TRANSACTION_MARKER);\n    writeUInt8(Transaction.ADVANCED_TRANSACTION_FLAG);\n  }\n\n  writeVarInt(this.ins.length);\n  this.ins.forEach(function (txIn) {\n    writeSlice(txIn.hash);\n    writeUInt32(txIn.index);\n    writeVarSlice(txIn.script);\n    writeUInt32(txIn.sequence);\n  });\n  writeVarInt(this.outs.length);\n  this.outs.forEach(function (txOut) {\n    if (!txOut.valueBuffer) {\n      writeUInt64(txOut.value);\n    } else {\n      writeSlice(txOut.valueBuffer);\n    }\n\n    writeVarSlice(txOut.script);\n  });\n\n  if (hasWitnesses) {\n    this.ins.forEach(function (input) {\n      writeVector(input.witness);\n    });\n  }\n\n  writeUInt32(this.locktime); // avoid slicing unless necessary\n\n  if (initialOffset !== undefined) return buffer.slice(initialOffset, offset);\n  return buffer;\n};\n\nTransaction.prototype.toHex = function () {\n  return this.toBuffer().toString('hex');\n};\n\nTransaction.prototype.setInputScript = function (index, scriptSig) {\n  typeforce(types.tuple(types.Number, types.Buffer), arguments);\n  this.ins[index].script = scriptSig;\n};\n\nTransaction.prototype.setWitness = function (index, witness) {\n  typeforce(types.tuple(types.Number, [types.Buffer]), arguments);\n  this.ins[index].witness = witness;\n};\n\nmodule.exports = Transaction;","map":{"version":3,"names":["Buffer","require","bcrypto","bscript","bufferutils","opcodes","typeforce","types","varuint","varSliceSize","someScript","length","encodingLength","vectorSize","someVector","reduce","sum","witness","Transaction","version","locktime","ins","outs","DEFAULT_SEQUENCE","SIGHASH_ALL","SIGHASH_NONE","SIGHASH_SINGLE","SIGHASH_ANYONECANPAY","SIGHASH_BITCOINCASHBIP143","ADVANCED_TRANSACTION_MARKER","ADVANCED_TRANSACTION_FLAG","EMPTY_SCRIPT","allocUnsafe","EMPTY_WITNESS","ZERO","from","ONE","VALUE_UINT64_MAX","BLANK_OUTPUT","script","valueBuffer","fromBuffer","buffer","__noStrict","offset","readSlice","n","slice","readUInt32","i","readUInt32LE","readInt32","readInt32LE","readUInt64","readUInt64LE","readVarInt","vi","decode","bytes","readVarSlice","readVector","count","vector","push","tx","marker","readUInt8","flag","hasWitnesses","vinLen","hash","index","sequence","voutLen","value","Error","fromHex","hex","isCoinbaseHash","Hash256bit","prototype","isCoinbase","addInput","scriptSig","tuple","UInt32","maybe","arguments","Null","addOutput","scriptPubKey","Satoshi","some","x","weight","base","__byteLength","total","virtualSize","Math","ceil","byteLength","__allowWitness","input","output","clone","newTx","map","txIn","txOut","hashForSignature","inIndex","prevOutScript","hashType","Number","ourScript","compile","decompile","filter","OP_CODESEPARATOR","txTmp","forEach","y","writeInt32LE","__toBuffer","hash256","hashForWitnessV0","tbuffer","toffset","writeSlice","copy","writeUInt32","writeUInt32LE","writeUInt64","writeUInt64LE","writeVarInt","encode","writeVarSlice","hashOutputs","hashPrevouts","hashSequence","txOutsSize","out","hashForCashSignature","inAmount","UInt53","getHash","undefined","getId","reverse","toString","toBuffer","initialOffset","writeUInt8","writeInt32","writeVector","toHex","setInputScript","setWitness","module","exports"],"sources":["C:/Users/acer/node_modules/@tatumio/bitcoincashjs2-lib/src/transaction.js"],"sourcesContent":["var Buffer = require('safe-buffer').Buffer\nvar bcrypto = require('./crypto')\nvar bscript = require('./script')\nvar bufferutils = require('./bufferutils')\nvar opcodes = require('@tatumio/bitcoincash-ops')\nvar typeforce = require('typeforce')\nvar types = require('./types')\nvar varuint = require('varuint-bitcoin')\n\nfunction varSliceSize (someScript) {\n  var length = someScript.length\n\n  return varuint.encodingLength(length) + length\n}\n\nfunction vectorSize (someVector) {\n  var length = someVector.length\n\n  return varuint.encodingLength(length) + someVector.reduce(function (sum, witness) {\n    return sum + varSliceSize(witness)\n  }, 0)\n}\n\nfunction Transaction () {\n  this.version = 2\n  this.locktime = 0\n  this.ins = []\n  this.outs = []\n}\n\nTransaction.DEFAULT_SEQUENCE = 0xffffffff\nTransaction.SIGHASH_ALL = 0x01\nTransaction.SIGHASH_NONE = 0x02\nTransaction.SIGHASH_SINGLE = 0x03\nTransaction.SIGHASH_ANYONECANPAY = 0x80\nTransaction.SIGHASH_BITCOINCASHBIP143 = 0x40\nTransaction.ADVANCED_TRANSACTION_MARKER = 0x00\nTransaction.ADVANCED_TRANSACTION_FLAG = 0x01\n\nvar EMPTY_SCRIPT = Buffer.allocUnsafe(0)\nvar EMPTY_WITNESS = []\nvar ZERO = Buffer.from('0000000000000000000000000000000000000000000000000000000000000000', 'hex')\nvar ONE = Buffer.from('0000000000000000000000000000000000000000000000000000000000000001', 'hex')\nvar VALUE_UINT64_MAX = Buffer.from('ffffffffffffffff', 'hex')\nvar BLANK_OUTPUT = {\n  script: EMPTY_SCRIPT,\n  valueBuffer: VALUE_UINT64_MAX\n}\n\nTransaction.fromBuffer = function (buffer, __noStrict) {\n  var offset = 0\n  function readSlice (n) {\n    offset += n\n    return buffer.slice(offset - n, offset)\n  }\n\n  function readUInt32 () {\n    var i = buffer.readUInt32LE(offset)\n    offset += 4\n    return i\n  }\n\n  function readInt32 () {\n    var i = buffer.readInt32LE(offset)\n    offset += 4\n    return i\n  }\n\n  function readUInt64 () {\n    var i = bufferutils.readUInt64LE(buffer, offset)\n    offset += 8\n    return i\n  }\n\n  function readVarInt () {\n    var vi = varuint.decode(buffer, offset)\n    offset += varuint.decode.bytes\n    return vi\n  }\n\n  function readVarSlice () {\n    return readSlice(readVarInt())\n  }\n\n  function readVector () {\n    var count = readVarInt()\n    var vector = []\n    for (var i = 0; i < count; i++) vector.push(readVarSlice())\n    return vector\n  }\n\n  var tx = new Transaction()\n  tx.version = readInt32()\n\n  var marker = buffer.readUInt8(offset)\n  var flag = buffer.readUInt8(offset + 1)\n\n  var hasWitnesses = false\n  if (marker === Transaction.ADVANCED_TRANSACTION_MARKER &&\n      flag === Transaction.ADVANCED_TRANSACTION_FLAG) {\n    offset += 2\n    hasWitnesses = true\n  }\n\n  var vinLen = readVarInt()\n  for (var i = 0; i < vinLen; ++i) {\n    tx.ins.push({\n      hash: readSlice(32),\n      index: readUInt32(),\n      script: readVarSlice(),\n      sequence: readUInt32(),\n      witness: EMPTY_WITNESS\n    })\n  }\n\n  var voutLen = readVarInt()\n  for (i = 0; i < voutLen; ++i) {\n    tx.outs.push({\n      value: readUInt64(),\n      script: readVarSlice()\n    })\n  }\n\n  if (hasWitnesses) {\n    for (i = 0; i < vinLen; ++i) {\n      tx.ins[i].witness = readVector()\n    }\n\n    // was this pointless?\n    if (!tx.hasWitnesses()) throw new Error('Transaction has superfluous witness data')\n  }\n\n  tx.locktime = readUInt32()\n\n  if (__noStrict) return tx\n  if (offset !== buffer.length) throw new Error('Transaction has unexpected data')\n\n  return tx\n}\n\nTransaction.fromHex = function (hex) {\n  return Transaction.fromBuffer(Buffer.from(hex, 'hex'))\n}\n\nTransaction.isCoinbaseHash = function (buffer) {\n  typeforce(types.Hash256bit, buffer)\n  for (var i = 0; i < 32; ++i) {\n    if (buffer[i] !== 0) return false\n  }\n  return true\n}\n\nTransaction.prototype.isCoinbase = function () {\n  return this.ins.length === 1 && Transaction.isCoinbaseHash(this.ins[0].hash)\n}\n\nTransaction.prototype.addInput = function (hash, index, sequence, scriptSig) {\n  typeforce(types.tuple(\n    types.Hash256bit,\n    types.UInt32,\n    types.maybe(types.UInt32),\n    types.maybe(types.Buffer)\n  ), arguments)\n\n  if (types.Null(sequence)) {\n    sequence = Transaction.DEFAULT_SEQUENCE\n  }\n\n  // Add the input and return the input's index\n  return (this.ins.push({\n    hash: hash,\n    index: index,\n    script: scriptSig || EMPTY_SCRIPT,\n    sequence: sequence,\n    witness: EMPTY_WITNESS\n  }) - 1)\n}\n\nTransaction.prototype.addOutput = function (scriptPubKey, value) {\n  typeforce(types.tuple(types.Buffer, types.Satoshi), arguments)\n\n  // Add the output and return the output's index\n  return (this.outs.push({\n    script: scriptPubKey,\n    value: value\n  }) - 1)\n}\n\nTransaction.prototype.hasWitnesses = function () {\n  return this.ins.some(function (x) {\n    return x.witness.length !== 0\n  })\n}\n\nTransaction.prototype.weight = function () {\n  var base = this.__byteLength(false)\n  var total = this.__byteLength(true)\n  return base * 3 + total\n}\n\nTransaction.prototype.virtualSize = function () {\n  return Math.ceil(this.weight() / 4)\n}\n\nTransaction.prototype.byteLength = function () {\n  return this.__byteLength(true)\n}\n\nTransaction.prototype.__byteLength = function (__allowWitness) {\n  var hasWitnesses = __allowWitness && this.hasWitnesses()\n\n  return (\n    (hasWitnesses ? 10 : 8) +\n    varuint.encodingLength(this.ins.length) +\n    varuint.encodingLength(this.outs.length) +\n    this.ins.reduce(function (sum, input) { return sum + 40 + varSliceSize(input.script) }, 0) +\n    this.outs.reduce(function (sum, output) { return sum + 8 + varSliceSize(output.script) }, 0) +\n    (hasWitnesses ? this.ins.reduce(function (sum, input) { return sum + vectorSize(input.witness) }, 0) : 0)\n  )\n}\n\nTransaction.prototype.clone = function () {\n  var newTx = new Transaction()\n  newTx.version = this.version\n  newTx.locktime = this.locktime\n\n  newTx.ins = this.ins.map(function (txIn) {\n    return {\n      hash: txIn.hash,\n      index: txIn.index,\n      script: txIn.script,\n      sequence: txIn.sequence,\n      witness: txIn.witness\n    }\n  })\n\n  newTx.outs = this.outs.map(function (txOut) {\n    return {\n      script: txOut.script,\n      value: txOut.value\n    }\n  })\n\n  return newTx\n}\n\n/**\n * Hash transaction for signing a specific input.\n *\n * Bitcoin uses a different hash for each signed transaction input.\n * This method copies the transaction, makes the necessary changes based on the\n * hashType, and then hashes the result.\n * This hash can then be used to sign the provided transaction input.\n */\nTransaction.prototype.hashForSignature = function (inIndex, prevOutScript, hashType) {\n  typeforce(types.tuple(types.UInt32, types.Buffer, /* types.UInt8 */ types.Number), arguments)\n\n  // https://github.com/bitcoin/bitcoin/blob/master/src/test/sighash_tests.cpp#L29\n  if (inIndex >= this.ins.length) return ONE\n\n  // ignore OP_CODESEPARATOR\n  var ourScript = bscript.compile(bscript.decompile(prevOutScript).filter(function (x) {\n    return x !== opcodes.OP_CODESEPARATOR\n  }))\n\n  var txTmp = this.clone()\n\n  // SIGHASH_NONE: ignore all outputs? (wildcard payee)\n  if ((hashType & 0x1f) === Transaction.SIGHASH_NONE) {\n    txTmp.outs = []\n\n    // ignore sequence numbers (except at inIndex)\n    txTmp.ins.forEach(function (input, i) {\n      if (i === inIndex) return\n\n      input.sequence = 0\n    })\n\n  // SIGHASH_SINGLE: ignore all outputs, except at the same index?\n  } else if ((hashType & 0x1f) === Transaction.SIGHASH_SINGLE) {\n    // https://github.com/bitcoin/bitcoin/blob/master/src/test/sighash_tests.cpp#L60\n    if (inIndex >= this.outs.length) return ONE\n\n    // truncate outputs after\n    txTmp.outs.length = inIndex + 1\n\n    // \"blank\" outputs before\n    for (var i = 0; i < inIndex; i++) {\n      txTmp.outs[i] = BLANK_OUTPUT\n    }\n\n    // ignore sequence numbers (except at inIndex)\n    txTmp.ins.forEach(function (input, y) {\n      if (y === inIndex) return\n\n      input.sequence = 0\n    })\n  }\n\n  // SIGHASH_ANYONECANPAY: ignore inputs entirely?\n  if (hashType & Transaction.SIGHASH_ANYONECANPAY) {\n    txTmp.ins = [txTmp.ins[inIndex]]\n    txTmp.ins[0].script = ourScript\n\n  // SIGHASH_ALL: only ignore input scripts\n  } else {\n    // \"blank\" others input scripts\n    txTmp.ins.forEach(function (input) { input.script = EMPTY_SCRIPT })\n    txTmp.ins[inIndex].script = ourScript\n  }\n\n  // serialize and hash\n  var buffer = Buffer.allocUnsafe(txTmp.__byteLength(false) + 4)\n  buffer.writeInt32LE(hashType, buffer.length - 4)\n  txTmp.__toBuffer(buffer, 0, false)\n\n  return bcrypto.hash256(buffer)\n}\n\nTransaction.prototype.hashForWitnessV0 = function (inIndex, prevOutScript, value, hashType) {\n  typeforce(types.tuple(types.UInt32, types.Buffer, types.Satoshi, types.UInt32), arguments)\n\n  var tbuffer, toffset\n  function writeSlice (slice) { toffset += slice.copy(tbuffer, toffset) }\n  function writeUInt32 (i) { toffset = tbuffer.writeUInt32LE(i, toffset) }\n  function writeUInt64 (i) { toffset = bufferutils.writeUInt64LE(tbuffer, i, toffset) }\n  function writeVarInt (i) {\n    varuint.encode(i, tbuffer, toffset)\n    toffset += varuint.encode.bytes\n  }\n  function writeVarSlice (slice) { writeVarInt(slice.length); writeSlice(slice) }\n\n  var hashOutputs = ZERO\n  var hashPrevouts = ZERO\n  var hashSequence = ZERO\n\n  if (!(hashType & Transaction.SIGHASH_ANYONECANPAY)) {\n    tbuffer = Buffer.allocUnsafe(36 * this.ins.length)\n    toffset = 0\n\n    this.ins.forEach(function (txIn) {\n      writeSlice(txIn.hash)\n      writeUInt32(txIn.index)\n    })\n\n    hashPrevouts = bcrypto.hash256(tbuffer)\n  }\n\n  if (!(hashType & Transaction.SIGHASH_ANYONECANPAY) &&\n       (hashType & 0x1f) !== Transaction.SIGHASH_SINGLE &&\n       (hashType & 0x1f) !== Transaction.SIGHASH_NONE) {\n    tbuffer = Buffer.allocUnsafe(4 * this.ins.length)\n    toffset = 0\n\n    this.ins.forEach(function (txIn) {\n      writeUInt32(txIn.sequence)\n    })\n\n    hashSequence = bcrypto.hash256(tbuffer)\n  }\n\n  if ((hashType & 0x1f) !== Transaction.SIGHASH_SINGLE &&\n      (hashType & 0x1f) !== Transaction.SIGHASH_NONE) {\n    var txOutsSize = this.outs.reduce(function (sum, output) {\n      return sum + 8 + varSliceSize(output.script)\n    }, 0)\n\n    tbuffer = Buffer.allocUnsafe(txOutsSize)\n    toffset = 0\n\n    this.outs.forEach(function (out) {\n      writeUInt64(out.value)\n      writeVarSlice(out.script)\n    })\n\n    hashOutputs = bcrypto.hash256(tbuffer)\n  } else if ((hashType & 0x1f) === Transaction.SIGHASH_SINGLE && inIndex < this.outs.length) {\n    var output = this.outs[inIndex]\n\n    tbuffer = Buffer.allocUnsafe(8 + varSliceSize(output.script))\n    toffset = 0\n    writeUInt64(output.value)\n    writeVarSlice(output.script)\n\n    hashOutputs = bcrypto.hash256(tbuffer)\n  }\n\n  tbuffer = Buffer.allocUnsafe(156 + varSliceSize(prevOutScript))\n  toffset = 0\n\n  var input = this.ins[inIndex]\n  writeUInt32(this.version)\n  writeSlice(hashPrevouts)\n  writeSlice(hashSequence)\n  writeSlice(input.hash)\n  writeUInt32(input.index)\n  writeVarSlice(prevOutScript)\n  writeUInt64(value)\n  writeUInt32(input.sequence)\n  writeSlice(hashOutputs)\n  writeUInt32(this.locktime)\n  writeUInt32(hashType)\n  return bcrypto.hash256(tbuffer)\n}\n\n/**\n * Hash transaction for signing a specific input for Bitcoin Cash.\n */\nTransaction.prototype.hashForCashSignature = function (inIndex, prevOutScript, inAmount, hashType) {\n  typeforce(types.tuple(types.UInt32, types.Buffer, /* types.UInt8 */ types.Number, types.maybe(types.UInt53)), arguments)\n\n  // This function works the way it does because Bitcoin Cash\n  // uses BIP143 as their replay protection, AND their algo\n  // includes `forkId | hashType`, AND since their forkId=0,\n  // this is a NOP, and has no difference to segwit. To support\n  // other forks, another parameter is required, and a new parameter\n  // would be required in the hashForWitnessV0 function, or\n  // it could be broken into two..\n\n  // BIP143 sighash activated in BitcoinCash via 0x40 bit\n  if (hashType & Transaction.SIGHASH_BITCOINCASHBIP143) {\n    if (types.Null(inAmount)) {\n      throw new Error('Bitcoin Cash sighash requires value of input to be signed.')\n    }\n    return this.hashForWitnessV0(inIndex, prevOutScript, inAmount, hashType)\n  } else {\n    return this.hashForSignature(inIndex, prevOutScript, hashType)\n  }\n}\n\nTransaction.prototype.getHash = function () {\n  return bcrypto.hash256(this.__toBuffer(undefined, undefined, false))\n}\n\nTransaction.prototype.getId = function () {\n  // transaction hash's are displayed in reverse order\n  return this.getHash().reverse().toString('hex')\n}\n\nTransaction.prototype.toBuffer = function (buffer, initialOffset) {\n  return this.__toBuffer(buffer, initialOffset, true)\n}\n\nTransaction.prototype.__toBuffer = function (buffer, initialOffset, __allowWitness) {\n  if (!buffer) buffer = Buffer.allocUnsafe(this.__byteLength(__allowWitness))\n\n  var offset = initialOffset || 0\n  function writeSlice (slice) { offset += slice.copy(buffer, offset) }\n  function writeUInt8 (i) { offset = buffer.writeUInt8(i, offset) }\n  function writeUInt32 (i) { offset = buffer.writeUInt32LE(i, offset) }\n  function writeInt32 (i) { offset = buffer.writeInt32LE(i, offset) }\n  function writeUInt64 (i) { offset = bufferutils.writeUInt64LE(buffer, i, offset) }\n  function writeVarInt (i) {\n    varuint.encode(i, buffer, offset)\n    offset += varuint.encode.bytes\n  }\n  function writeVarSlice (slice) { writeVarInt(slice.length); writeSlice(slice) }\n  function writeVector (vector) { writeVarInt(vector.length); vector.forEach(writeVarSlice) }\n\n  writeInt32(this.version)\n\n  var hasWitnesses = __allowWitness && this.hasWitnesses()\n\n  if (hasWitnesses) {\n    writeUInt8(Transaction.ADVANCED_TRANSACTION_MARKER)\n    writeUInt8(Transaction.ADVANCED_TRANSACTION_FLAG)\n  }\n\n  writeVarInt(this.ins.length)\n\n  this.ins.forEach(function (txIn) {\n    writeSlice(txIn.hash)\n    writeUInt32(txIn.index)\n    writeVarSlice(txIn.script)\n    writeUInt32(txIn.sequence)\n  })\n\n  writeVarInt(this.outs.length)\n  this.outs.forEach(function (txOut) {\n    if (!txOut.valueBuffer) {\n      writeUInt64(txOut.value)\n    } else {\n      writeSlice(txOut.valueBuffer)\n    }\n\n    writeVarSlice(txOut.script)\n  })\n\n  if (hasWitnesses) {\n    this.ins.forEach(function (input) {\n      writeVector(input.witness)\n    })\n  }\n\n  writeUInt32(this.locktime)\n\n  // avoid slicing unless necessary\n  if (initialOffset !== undefined) return buffer.slice(initialOffset, offset)\n  return buffer\n}\n\nTransaction.prototype.toHex = function () {\n  return this.toBuffer().toString('hex')\n}\n\nTransaction.prototype.setInputScript = function (index, scriptSig) {\n  typeforce(types.tuple(types.Number, types.Buffer), arguments)\n\n  this.ins[index].script = scriptSig\n}\n\nTransaction.prototype.setWitness = function (index, witness) {\n  typeforce(types.tuple(types.Number, [types.Buffer]), arguments)\n\n  this.ins[index].witness = witness\n}\n\nmodule.exports = Transaction\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}