{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ArgSerializer = exports.ArgumentsSeparator = void 0;\n\nconst codec_1 = require(\"./codec\");\n\nconst composite_1 = require(\"./typesystem/composite\");\n\nconst variadic_1 = require(\"./typesystem/variadic\");\n\nconst algebraic_1 = require(\"./typesystem/algebraic\");\n\nexports.ArgumentsSeparator = \"@\";\n/**\n * For the moment, this is the only codec used.\n */\n\nconst Codec = new codec_1.BinaryCodec();\n\nclass ArgSerializer {\n  /**\n   * Reads typed values from an arguments string (e.g. aa@bb@@cc), given parameter definitions.\n   */\n  stringToValues(joinedString, parameters) {\n    let buffers = this.stringToBuffers(joinedString);\n    let values = this.buffersToValues(buffers, parameters);\n    return values;\n  }\n  /**\n   * Reads raw buffers from an arguments string (e.g. aa@bb@@cc).\n   */\n\n\n  stringToBuffers(joinedString) {\n    // We also keep the zero-length buffers (they could encode missing options, Option<T>).\n    return joinedString.split(exports.ArgumentsSeparator).map(item => Buffer.from(item, \"hex\"));\n  }\n  /**\n   * Decodes a set of buffers into a set of typed values, given parameter definitions.\n   */\n\n\n  buffersToValues(buffers, parameters) {\n    // TODO: Refactor, split (function is quite complex).\n    buffers = buffers || [];\n    let values = [];\n    let bufferIndex = 0;\n    let numBuffers = buffers.length;\n\n    for (let i = 0; i < parameters.length; i++) {\n      let parameter = parameters[i];\n      let type = parameter.type;\n      let value = readValue(type);\n      values.push(value);\n    } // This is a recursive function.\n\n\n    function readValue(type) {\n      // TODO: Use matchers.\n      if (type instanceof algebraic_1.OptionalType) {\n        let typedValue = readValue(type.getFirstTypeParameter());\n        return new algebraic_1.OptionalValue(type, typedValue);\n      } else if (type instanceof variadic_1.VariadicType) {\n        let typedValues = [];\n\n        while (!hasReachedTheEnd()) {\n          typedValues.push(readValue(type.getFirstTypeParameter()));\n        }\n\n        return new variadic_1.VariadicValue(type, typedValues);\n      } else if (type instanceof composite_1.CompositeType) {\n        let typedValues = [];\n\n        for (const typeParameter of type.getTypeParameters()) {\n          typedValues.push(readValue(typeParameter));\n        }\n\n        return new composite_1.CompositeValue(type, typedValues);\n      } else {\n        // Non-composite (singular), non-variadic (fixed) type.\n        // The only branching without a recursive call.\n        let typedValue = decodeNextBuffer(type);\n        return typedValue;\n      }\n    }\n\n    function decodeNextBuffer(type) {\n      if (hasReachedTheEnd()) {\n        return null;\n      }\n\n      let buffer = buffers[bufferIndex++];\n      let decodedValue = Codec.decodeTopLevel(buffer, type);\n      return decodedValue;\n    }\n\n    function hasReachedTheEnd() {\n      return bufferIndex >= numBuffers;\n    }\n\n    return values;\n  }\n  /**\n   * Serializes a set of typed values into an arguments string (e.g. aa@bb@@cc).\n   */\n\n\n  valuesToString(values) {\n    let strings = this.valuesToStrings(values);\n    let joinedString = strings.join(exports.ArgumentsSeparator);\n    return joinedString;\n  }\n  /**\n   * Serializes a set of typed values into a set of strings.\n   */\n\n\n  valuesToStrings(values) {\n    let buffers = this.valuesToBuffers(values);\n    let strings = buffers.map(buffer => buffer.toString(\"hex\"));\n    return strings;\n  }\n  /**\n   * Serializes a set of typed values into a set of strings buffers.\n   * Variadic types and composite types might result into none, one or more buffers.\n   */\n\n\n  valuesToBuffers(values) {\n    // TODO: Refactor, split (function is quite complex).\n    let buffers = [];\n\n    for (const value of values) {\n      handleValue(value);\n    } // This is a recursive function. It appends to the \"buffers\" variable.\n\n\n    function handleValue(value) {\n      // TODO: Use matchers.\n      if (value instanceof algebraic_1.OptionalValue) {\n        if (value.isSet()) {\n          handleValue(value.getTypedValue());\n        }\n      } else if (value instanceof variadic_1.VariadicValue) {\n        for (const item of value.getItems()) {\n          handleValue(item);\n        }\n      } else if (value instanceof composite_1.CompositeValue) {\n        for (const item of value.getItems()) {\n          handleValue(item);\n        }\n      } else {\n        // Non-composite (singular), non-variadic (fixed) type.\n        // The only branching without a recursive call.\n        let buffer = Codec.encodeTopLevel(value);\n        buffers.push(buffer);\n      }\n    }\n\n    return buffers;\n  }\n\n}\n\nexports.ArgSerializer = ArgSerializer;","map":{"version":3,"mappings":"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","names":["exports","Codec","codec_1","ArgSerializer","stringToValues","joinedString","parameters","buffers","stringToBuffers","values","buffersToValues","split","map","item","Buffer","from","bufferIndex","numBuffers","length","i","parameter","type","value","readValue","push","algebraic_1","typedValue","getFirstTypeParameter","variadic_1","typedValues","hasReachedTheEnd","composite_1","typeParameter","getTypeParameters","decodeNextBuffer","buffer","decodedValue","decodeTopLevel","valuesToString","strings","valuesToStrings","join","valuesToBuffers","toString","handleValue","isSet","getTypedValue","getItems","encodeTopLevel"],"sourceRoot":"","sources":["../../src/smartcontracts/argSerializer.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}