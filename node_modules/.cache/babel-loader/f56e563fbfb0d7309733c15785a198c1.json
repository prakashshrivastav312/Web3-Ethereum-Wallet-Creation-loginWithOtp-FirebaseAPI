{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  Object.defineProperty(o, k2, {\n    enumerable: true,\n    get: function () {\n      return m[k];\n    }\n  });\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst _ = __importStar(require(\"lodash\"));\n\nconst utils = __importStar(require(\"./utils\"));\n\nconst validate = utils.common.validate;\nconst paymentFlags = utils.common.txFlags.Payment;\nconst ValidationError = utils.common.errors.ValidationError;\n\nconst common_1 = require(\"../common\");\n\nconst utils_1 = require(\"./utils\");\n\nfunction isMaxAdjustment(source) {\n  return source.maxAmount != null;\n}\n\nfunction isMinAdjustment(destination) {\n  return destination.minAmount != null;\n}\n\nfunction isXRPToXRPPayment(payment) {\n  const {\n    source,\n    destination\n  } = payment;\n  const sourceCurrency = isMaxAdjustment(source) ? source.maxAmount.currency : source.amount.currency;\n  const destinationCurrency = isMinAdjustment(destination) ? destination.minAmount.currency : destination.amount.currency;\n  return (sourceCurrency === 'XRP' || sourceCurrency === 'drops') && (destinationCurrency === 'XRP' || destinationCurrency === 'drops');\n}\n\nfunction isIOUWithoutCounterparty(amount) {\n  return amount && amount.currency !== 'XRP' && amount.currency !== 'drops' && amount.counterparty == null;\n}\n\nfunction applyAnyCounterpartyEncoding(payment) {\n  [payment.source, payment.destination].forEach(adjustment => {\n    ['amount', 'minAmount', 'maxAmount'].forEach(key => {\n      if (isIOUWithoutCounterparty(adjustment[key])) {\n        adjustment[key].counterparty = adjustment.address;\n      }\n    });\n  });\n}\n\nfunction createMaximalAmount(amount) {\n  const maxXRPValue = '100000000000';\n  const maxIOUValue = '999999999999999900000000000000000000000000000000000000000000000000000000000000000000000000000000';\n  let maxValue;\n\n  if (amount.currency === 'XRP') {\n    maxValue = maxXRPValue;\n  } else if (amount.currency === 'drops') {\n    maxValue = common_1.xrpToDrops(maxXRPValue);\n  } else {\n    maxValue = maxIOUValue;\n  }\n\n  return Object.assign({}, amount, {\n    value: maxValue\n  });\n}\n\nfunction validateAndNormalizeAddress(address, expectedTag) {\n  const classicAddress = utils_1.getClassicAccountAndTag(address, expectedTag);\n  classicAddress.tag = classicAddress.tag === false ? undefined : classicAddress.tag;\n  return classicAddress;\n}\n\nfunction createPaymentTransaction(address, paymentArgument) {\n  const payment = _.cloneDeep(paymentArgument);\n\n  applyAnyCounterpartyEncoding(payment);\n  const sourceAddressAndTag = validateAndNormalizeAddress(payment.source.address, payment.source.tag);\n  const addressToVerifyAgainst = validateAndNormalizeAddress(address, undefined);\n\n  if (addressToVerifyAgainst.classicAccount !== sourceAddressAndTag.classicAccount) {\n    throw new ValidationError('address must match payment.source.address');\n  }\n\n  if (addressToVerifyAgainst.tag != null && sourceAddressAndTag.tag != null && addressToVerifyAgainst.tag !== sourceAddressAndTag.tag) {\n    throw new ValidationError('address includes a tag that does not match payment.source.tag');\n  }\n\n  const destinationAddressAndTag = validateAndNormalizeAddress(payment.destination.address, payment.destination.tag);\n\n  if (isMaxAdjustment(payment.source) && isMinAdjustment(payment.destination) || !isMaxAdjustment(payment.source) && !isMinAdjustment(payment.destination)) {\n    throw new ValidationError('payment must specify either (source.maxAmount ' + 'and destination.amount) or (source.amount and destination.minAmount)');\n  }\n\n  const destinationAmount = isMinAdjustment(payment.destination) ? payment.destination.minAmount : payment.destination.amount;\n  const sourceAmount = isMaxAdjustment(payment.source) ? payment.source.maxAmount : payment.source.amount;\n  const amount = isMinAdjustment(payment.destination) && !isXRPToXRPPayment(payment) ? createMaximalAmount(destinationAmount) : destinationAmount;\n  const txJSON = {\n    TransactionType: 'Payment',\n    Account: sourceAddressAndTag.classicAccount,\n    Destination: destinationAddressAndTag.classicAccount,\n    Amount: common_1.toRippledAmount(amount),\n    Flags: 0\n  };\n\n  if (payment.invoiceID != null) {\n    txJSON.InvoiceID = payment.invoiceID;\n  }\n\n  if (sourceAddressAndTag.tag != null) {\n    txJSON.SourceTag = sourceAddressAndTag.tag;\n  }\n\n  if (destinationAddressAndTag.tag != null) {\n    txJSON.DestinationTag = destinationAddressAndTag.tag;\n  }\n\n  if (payment.memos != null) {\n    txJSON.Memos = payment.memos.map(utils.convertMemo);\n  }\n\n  if (payment.noDirectRipple === true) {\n    txJSON.Flags |= paymentFlags.NoRippleDirect;\n  }\n\n  if (payment.limitQuality === true) {\n    txJSON.Flags |= paymentFlags.LimitQuality;\n  }\n\n  if (!isXRPToXRPPayment(payment)) {\n    if (payment.allowPartialPayment || isMinAdjustment(payment.destination)) {\n      txJSON.Flags |= paymentFlags.PartialPayment;\n    }\n\n    txJSON.SendMax = common_1.toRippledAmount(sourceAmount);\n\n    if (isMinAdjustment(payment.destination)) {\n      txJSON.DeliverMin = common_1.toRippledAmount(destinationAmount);\n    }\n\n    if (payment.paths != null) {\n      txJSON.Paths = JSON.parse(payment.paths);\n    }\n  } else if (payment.allowPartialPayment === true) {\n    throw new ValidationError('XRP to XRP payments cannot be partial payments');\n  }\n\n  return txJSON;\n}\n\nfunction preparePayment(address, payment) {\n  let instructions = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n  try {\n    validate.preparePayment({\n      address,\n      payment,\n      instructions\n    });\n    const txJSON = createPaymentTransaction(address, payment);\n    return utils.prepareTransaction(txJSON, this, instructions);\n  } catch (e) {\n    return Promise.reject(e);\n  }\n}\n\nexports.default = preparePayment;","map":{"version":3,"mappings":"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","names":["validate","utils","common","paymentFlags","txFlags","Payment","ValidationError","errors","isMaxAdjustment","source","maxAmount","isMinAdjustment","destination","minAmount","isXRPToXRPPayment","payment","sourceCurrency","currency","amount","destinationCurrency","isIOUWithoutCounterparty","counterparty","applyAnyCounterpartyEncoding","forEach","adjustment","key","address","createMaximalAmount","maxXRPValue","maxIOUValue","maxValue","common_1","Object","assign","value","validateAndNormalizeAddress","expectedTag","classicAddress","utils_1","tag","undefined","createPaymentTransaction","paymentArgument","_","cloneDeep","sourceAddressAndTag","addressToVerifyAgainst","classicAccount","destinationAddressAndTag","destinationAmount","sourceAmount","txJSON","TransactionType","Account","Destination","Amount","Flags","invoiceID","InvoiceID","SourceTag","DestinationTag","memos","Memos","map","convertMemo","noDirectRipple","NoRippleDirect","limitQuality","LimitQuality","allowPartialPayment","PartialPayment","SendMax","DeliverMin","paths","Paths","JSON","parse","preparePayment","instructions","prepareTransaction","e","Promise","reject","exports"],"sourceRoot":"","sources":["../../../src/transaction/payment.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}