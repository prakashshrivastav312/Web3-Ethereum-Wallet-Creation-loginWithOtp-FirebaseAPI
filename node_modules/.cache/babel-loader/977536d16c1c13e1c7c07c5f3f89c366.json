{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.prepareCreateAccountWithFUSDFromPublicKeyTxTemplate = exports.prepareTransferFlowTxTemplate = exports.prepareAddPublicKeyToAccountTxTemplate = exports.transferFlowNftTokenTxTemplate = exports.burnFlowNftTokenTxTemplate = exports.mintFlowMultipleNftTokenTxTemplate = exports.mintFlowNftTokenTxTemplate = exports.tokenByAddressFlowNftTokenScript = exports.metadataFlowNftTokenScript = exports.deployFlowNftTokenTypeWithMinterTxTemplate = void 0;\n\nconst dedent_js_1 = __importDefault(require(\"dedent-js\"));\n\nconst constants_1 = require(\"../../constants\");\n\nconst deployFlowNftTokenTypeWithMinterTxTemplate = testnet => dedent_js_1.default`\nimport TatumMultiNFT from ${testnet ? constants_1.FLOW_TESTNET_ADDRESSES.TatumMultiNFT : constants_1.FLOW_MAINNET_ADDRESSES.TatumMultiNFT}\n\ntransaction(type: String) {\n\n    // local variable for storing the minter reference\n    let minter: &TatumMultiNFT.AdminMinter\n\n    let newMinter: AuthAccount;\n\n    prepare(adminMinter: AuthAccount, newMinter: AuthAccount) {\n\n        // borrow a reference to the NFTMinter resource in storage\n        self.minter = adminMinter.borrow<&TatumMultiNFT.AdminMinter>(from: TatumMultiNFT.AdminMinterStoragePath)\n            ?? panic(\"Could not borrow a reference to the NFT minter\")\n        self.newMinter = newMinter;\n    }\n\n    execute {\n        // add new minter for specific token type\n        self.minter.addMinter(minterAccount: self.newMinter, type: type)\n    }\n}\n`;\n\nexports.deployFlowNftTokenTypeWithMinterTxTemplate = deployFlowNftTokenTypeWithMinterTxTemplate;\n\nconst metadataFlowNftTokenScript = testnet => dedent_js_1.default`\nimport TatumMultiNFT from ${testnet ? constants_1.FLOW_TESTNET_ADDRESSES.TatumMultiNFT : constants_1.FLOW_MAINNET_ADDRESSES.TatumMultiNFT}\n\npub fun main(account: Address, id: UInt64, type: String): String {\n    let collectionRef = getAccount(account)\n        .getCapability(TatumMultiNFT.CollectionPublicPath)\n        .borrow<&{TatumMultiNFT.TatumMultiNftCollectionPublic}>()\n        ?? panic(\"Could not borrow capability from public collection\")\n\n    let ref = collectionRef.borrowTatumNFT(id: id, type: type)\n    if ref != nil {\n      return ref.metadata\n    } else {\n      return panic(\"No such token\");\n    }\n}`;\n\nexports.metadataFlowNftTokenScript = metadataFlowNftTokenScript;\n\nconst tokenByAddressFlowNftTokenScript = testnet => dedent_js_1.default`\nimport TatumMultiNFT from ${testnet ? constants_1.FLOW_TESTNET_ADDRESSES.TatumMultiNFT : constants_1.FLOW_MAINNET_ADDRESSES.TatumMultiNFT}\n\npub fun main(address: Address, type: String): [UInt64] {\n    let collectionRef = getAccount(address)\n        .getCapability(TatumMultiNFT.CollectionPublicPath)\n        .borrow<&{TatumMultiNFT.TatumMultiNftCollectionPublic}>()\n        ?? panic(\"Could not borrow capability from public collection\")\n\n    return collectionRef.getIDsByType(type: type)\n}`;\n\nexports.tokenByAddressFlowNftTokenScript = tokenByAddressFlowNftTokenScript;\n\nconst mintFlowNftTokenTxTemplate = testnet => dedent_js_1.default`\nimport TatumMultiNFT from ${testnet ? constants_1.FLOW_TESTNET_ADDRESSES.TatumMultiNFT : constants_1.FLOW_MAINNET_ADDRESSES.TatumMultiNFT}\n\ntransaction(recipient: Address, url: String, type: String) {\n\n    // local variable for storing the minter reference\n    let minter: &TatumMultiNFT.NFTMinter\n\n    prepare(signer: AuthAccount) {\n\n        // borrow a reference to the NFTMinter resource in storage\n        self.minter = signer.borrow<&TatumMultiNFT.NFTMinter>(from: TatumMultiNFT.MinterStoragePath)\n            ?? panic(\"Could not borrow a reference to the NFT minter\")\n    }\n\n    execute {\n        // get the public account object for the recipient\n        let recipientAccount = getAccount(recipient)\n\n        // borrow the recipient's public NFT collection reference\n        let receiver = recipientAccount\n            .getCapability(TatumMultiNFT.CollectionPublicPath)\n            .borrow<&{TatumMultiNFT.TatumMultiNftCollectionPublic}>()\n            ?? panic(\"Could not get receiver reference to the NFT Collection\")\n\n        // mint the NFT and deposit it to the recipient's collection\n        self.minter.mintNFT(recipient: receiver, type: type, url: url, address: recipient)\n    }\n}`;\n\nexports.mintFlowNftTokenTxTemplate = mintFlowNftTokenTxTemplate;\n\nconst mintFlowMultipleNftTokenTxTemplate = testnet => dedent_js_1.default`\nimport TatumMultiNFT from ${testnet ? constants_1.FLOW_TESTNET_ADDRESSES.TatumMultiNFT : constants_1.FLOW_MAINNET_ADDRESSES.TatumMultiNFT}\n\ntransaction(recipient: [Address], url: [String], type: String) {\n\n    // local variable for storing the minter reference\n    let minter: &TatumMultiNFT.NFTMinter\n\n    prepare(signer: AuthAccount) {\n\n        // borrow a reference to the NFTMinter resource in storage\n        self.minter = signer.borrow<&TatumMultiNFT.NFTMinter>(from: TatumMultiNFT.MinterStoragePath)\n            ?? panic(\"Could not borrow a reference to the NFT minter\")\n    }\n\n    execute {\n        var a = 0;\n        while a < url.length {\n        // get the public account object for the recipient\n        let recipientAccount = getAccount(recipient[a])\n\n        // borrow the recipient's public NFT collection reference\n        let receiver = recipientAccount\n            .getCapability(TatumMultiNFT.CollectionPublicPath)\n            .borrow<&{TatumMultiNFT.TatumMultiNftCollectionPublic}>()\n            ?? panic(\"Could not get receiver reference to the NFT Collection\")\n\n        // mint the NFT and deposit it to the recipient's collection\n            self.minter.mintNFT(recipient: receiver, type: type, url: url[a], address: recipient[a])\n            a = a + 1\n        }\n    }\n}`;\n\nexports.mintFlowMultipleNftTokenTxTemplate = mintFlowMultipleNftTokenTxTemplate;\n\nconst burnFlowNftTokenTxTemplate = testnet => dedent_js_1.default`\nimport TatumMultiNFT from ${testnet ? constants_1.FLOW_TESTNET_ADDRESSES.TatumMultiNFT : constants_1.FLOW_MAINNET_ADDRESSES.TatumMultiNFT}\n\ntransaction(withdrawID: UInt64, type: String) {\n\n    // local variable for storing the minter reference\n    let senderCollection: &{TatumMultiNFT.TatumMultiNftCollectionPublic}\n\n    prepare(signer: AuthAccount) {\n\n        // borrow a reference to the signer's NFT collection\n        self.senderCollection = signer.borrow<&{TatumMultiNFT.TatumMultiNftCollectionPublic}>(from: TatumMultiNFT.CollectionStoragePath)\n            ?? panic(\"Could not borrow a reference to the owner's collection\")\n\n        // check if token has correct type\n        self.senderCollection.borrowTatumNFT(id: withdrawID, type: type)\n    }\n\n    execute {\n        // withdraw the NFT from the owner's collection\n        let nft <- self.senderCollection.withdraw(withdrawID: withdrawID)\n\n        // Destroy the nft\n        destroy nft\n    }\n}`;\n\nexports.burnFlowNftTokenTxTemplate = burnFlowNftTokenTxTemplate;\n\nconst transferFlowNftTokenTxTemplate = testnet => dedent_js_1.default`\nimport TatumMultiNFT from ${testnet ? constants_1.FLOW_TESTNET_ADDRESSES.TatumMultiNFT : constants_1.FLOW_MAINNET_ADDRESSES.TatumMultiNFT}\n\ntransaction(recipient: Address, withdrawID: UInt64) {\n\n    // local variable for storing the minter reference\n    let senderCollection: &{TatumMultiNFT.TatumMultiNftCollectionPublic}\n\n    prepare(signer: AuthAccount) {\n\n        // borrow a reference to the signer's NFT collection\n        self.senderCollection = signer.borrow<&{TatumMultiNFT.TatumMultiNftCollectionPublic}>(from: TatumMultiNFT.CollectionStoragePath)\n            ?? panic(\"Could not borrow a reference to the owner's collection\")\n\n    }\n\n    execute {\n        // get the recipients public account object\n        let recipient = getAccount(recipient)\n\n        // borrow a public reference to the receivers collection\n        let depositRef = recipient.getCapability(TatumMultiNFT.CollectionPublicPath).borrow<&{TatumMultiNFT.TatumMultiNftCollectionPublic}>()!\n\n        // withdraw the NFT from the owner's collection\n        let nft <- self.senderCollection.withdraw(withdrawID: withdrawID)\n\n        // Deposit the NFT in the recipient's collection\n        depositRef.deposit(token: <-nft)\n    }\n}`;\n\nexports.transferFlowNftTokenTxTemplate = transferFlowNftTokenTxTemplate;\n\nconst prepareAddPublicKeyToAccountTxTemplate = () => dedent_js_1.default`transaction(publicKey: String) {\nprepare(signer: AuthAccount) {\nsigner.addPublicKey(publicKey.decodeHex())\n}\n}`;\n\nexports.prepareAddPublicKeyToAccountTxTemplate = prepareAddPublicKeyToAccountTxTemplate;\n\nconst prepareTransferFlowTxTemplate = (testnet, tokenAddress, tokenName, tokenStorage) => dedent_js_1.default`import FungibleToken from ${testnet ? constants_1.FLOW_TESTNET_ADDRESSES.FungibleToken : constants_1.FLOW_MAINNET_ADDRESSES.FungibleToken}\n  import ${tokenName} from ${tokenAddress}\n\ntransaction(amount: UFix64, recipient: Address) {\n  let sentVault: @FungibleToken.Vault\n  prepare(signer: AuthAccount) {\n    let vaultRef = signer.borrow<&${tokenName}.Vault>(from: /storage/${tokenStorage}Vault)\n      ?? panic(\"failed to borrow reference to sender vault\")\n\n    self.sentVault <- vaultRef.withdraw(amount: amount)\n  }\n\n  execute {\n    let receiverRef =  getAccount(recipient)\n      .getCapability(/public/${tokenStorage}Receiver)\n      .borrow<&{FungibleToken.Receiver}>()\n        ?? panic(\"failed to borrow reference to recipient vault\")\n\n    receiverRef.deposit(from: <-self.sentVault)\n  }\n}`;\n\nexports.prepareTransferFlowTxTemplate = prepareTransferFlowTxTemplate;\n\nconst prepareCreateAccountWithFUSDFromPublicKeyTxTemplate = testnet => dedent_js_1.default`import FungibleToken from ${testnet ? constants_1.FLOW_TESTNET_ADDRESSES.FungibleToken : constants_1.FLOW_MAINNET_ADDRESSES.FungibleToken}\n  import FUSD from ${testnet ? constants_1.FLOW_TESTNET_ADDRESSES.FUSD : constants_1.FLOW_MAINNET_ADDRESSES.FUSD}\n  import TatumMultiNFT from ${testnet ? constants_1.FLOW_TESTNET_ADDRESSES.TatumMultiNFT : constants_1.FLOW_MAINNET_ADDRESSES.TatumMultiNFT}\n  transaction(publicKey: String) {\n    let account: AuthAccount\n    prepare(signer: AuthAccount) {\n      self.account = AuthAccount(payer: signer)\n    }\n    execute {\n      self.account.addPublicKey(publicKey.decodeHex())\n      if self.account.borrow<&TatumMultiNFT.Collection>(from: TatumMultiNFT.CollectionStoragePath) == nil {\n\n            // create a new empty collection\n            let collection <- TatumMultiNFT.createEmptyCollection()\n\n            // save it to the account\n            self.account.save(<-collection, to: TatumMultiNFT.CollectionStoragePath)\n\n            // create a public capability for the collection\n            self.account.link<&TatumMultiNFT.Collection>(TatumMultiNFT.CollectionPublicPath, target: TatumMultiNFT.CollectionStoragePath)\n        }\n      // Add FUSD vault\n      self.account.save(<-FUSD.createEmptyVault(), to: /storage/fusdVault)\n      self.account.link<&FUSD.Vault{FungibleToken.Receiver}>(\n          /public/fusdReceiver,\n          target: /storage/fusdVault\n      )\n      self.account.link<&FUSD.Vault{FungibleToken.Balance}>(\n          /public/fusdBalance,\n          target: /storage/fusdVault\n      )\n    }\n  }\n  `;\n\nexports.prepareCreateAccountWithFUSDFromPublicKeyTxTemplate = prepareCreateAccountWithFUSDFromPublicKeyTxTemplate;","map":{"version":3,"mappings":";;;;;;;;;;;;;AAAA;;AACA;;AAEO,MAAMA,0CAA0C,GAAIC,OAAD,IAAsBC,mBAAM;4BAC1DD,OAAO,GAAGE,mCAAuBC,aAA1B,GAA0CD,mCAAuBC,aAAa;;;;;;;;;;;;;;;;;;;;;;CAD1G;;AAAMC,qDAA0CL,0CAA1C;;AAyBN,MAAMM,0BAA0B,GAAIL,OAAD,IAAsBC,mBAAM;4BAC1CD,OAAO,GAAGE,mCAAuBC,aAA1B,GAA0CD,mCAAuBC,aAAa;;;;;;;;;;;;;;EAD1G;;AAAMC,qCAA0BC,0BAA1B;;AAkBN,MAAMC,gCAAgC,GAAIN,OAAD,IAAsBC,mBAAM;4BAChDD,OAAO,GAAGE,mCAAuBC,aAA1B,GAA0CD,mCAAuBC,aAAa;;;;;;;;;EAD1G;;AAAMC,2CAAgCE,gCAAhC;;AAYN,MAAMC,0BAA0B,GAAIP,OAAD,IAAsBC,mBAAM;4BAC1CD,OAAO,GAAGE,mCAAuBC,aAA1B,GAA0CD,mCAAuBC,aAAa;;;;;;;;;;;;;;;;;;;;;;;;;;;EAD1G;;AAAMC,qCAA0BG,0BAA1B;;AA8BN,MAAMC,kCAAkC,GAAIR,OAAD,IAAsBC,mBAAM;4BAClDD,OAAO,GAAGE,mCAAuBC,aAA1B,GAA0CD,mCAAuBC,aAAa;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;EAD1G;;AAAMC,6CAAkCI,kCAAlC;;AAkCN,MAAMC,0BAA0B,GAAIT,OAAD,IAAsBC,mBAAM;4BAC1CD,OAAO,GAAGE,mCAAuBC,aAA1B,GAA0CD,mCAAuBC,aAAa;;;;;;;;;;;;;;;;;;;;;;;;EAD1G;;AAAMC,qCAA0BK,0BAA1B;;AA2BN,MAAMC,8BAA8B,GAAIV,OAAD,IAAsBC,mBAAM;4BAC9CD,OAAO,GAAGE,mCAAuBC,aAA1B,GAA0CD,mCAAuBC,aAAa;;;;;;;;;;;;;;;;;;;;;;;;;;;;EAD1G;;AAAMC,yCAA8BM,8BAA9B;;AA+BN,MAAMC,sCAAsC,GAAG,MAClDV,mBAAM;;;;EADH;;AAAMG,iDAAsCO,sCAAtC;;AAON,MAAMC,6BAA6B,GAAG,CAACZ,OAAD,EAAmBa,YAAnB,EAAyCC,SAAzC,EAA4DC,YAA5D,KACzCd,mBAAM,6BAA6BD,OAAO,GAAGE,mCAAuBc,aAA1B,GAA0Cd,mCAAuBc,aAAa;WACjHF,SAAS,SAASD,YAAY;;;;;oCAKLC,SAAS,0BAA0BC,YAAY;;;;;;;;+BAQpDA,YAAY;;;;;;EAfpC;;AAAMX,wCAA6BQ,6BAA7B;;AAuBN,MAAMK,mDAAmD,GAAIjB,OAAD,IAC/DC,mBAAM,6BAA6BD,OAAO,GAAGE,mCAAuBc,aAA1B,GAA0Cd,mCAAuBc,aAAa;qBACvGhB,OAAO,GAAGE,mCAAuBgB,IAA1B,GAAiChB,mCAAuBgB,IAAI;8BAC1DlB,OAAO,GAAGE,mCAAuBC,aAA1B,GAA0CD,mCAAuBC,aAAa;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;GAH5G;;AAAMC,8DAAmDa,mDAAnD","names":["deployFlowNftTokenTypeWithMinterTxTemplate","testnet","dedent_js_1","constants_1","TatumMultiNFT","exports","metadataFlowNftTokenScript","tokenByAddressFlowNftTokenScript","mintFlowNftTokenTxTemplate","mintFlowMultipleNftTokenTxTemplate","burnFlowNftTokenTxTemplate","transferFlowNftTokenTxTemplate","prepareAddPublicKeyToAccountTxTemplate","prepareTransferFlowTxTemplate","tokenAddress","tokenName","tokenStorage","FungibleToken","prepareCreateAccountWithFUSDFromPublicKeyTxTemplate","FUSD"],"sourceRoot":"","sources":["../../../../src/transaction/flowTransaction/index.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}