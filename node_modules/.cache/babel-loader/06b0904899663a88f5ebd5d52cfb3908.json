{"ast":null,"code":"\"use strict\";\n\nvar __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    if (typeof b !== \"function\" && b !== null) throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.STObject = void 0;\n\nvar enums_1 = require(\"../enums\");\n\nvar serialized_type_1 = require(\"./serialized-type\");\n\nvar ripple_address_codec_1 = require(\"ripple-address-codec\");\n\nvar binary_parser_1 = require(\"../serdes/binary-parser\");\n\nvar binary_serializer_1 = require(\"../serdes/binary-serializer\");\n\nvar buffer_1 = require(\"buffer/\");\n\nvar OBJECT_END_MARKER_BYTE = buffer_1.Buffer.from([0xe1]);\nvar OBJECT_END_MARKER = 'ObjectEndMarker';\nvar ST_OBJECT = 'STObject';\nvar DESTINATION = 'Destination';\nvar ACCOUNT = 'Account';\nvar SOURCE_TAG = 'SourceTag';\nvar DEST_TAG = 'DestinationTag';\n/**\n * Break down an X-Address into an account and a tag\n *\n * @param field Name of field\n * @param xAddress X-Address corresponding to the field\n */\n\nfunction handleXAddress(field, xAddress) {\n  var _a, _b;\n\n  var decoded = (0, ripple_address_codec_1.xAddressToClassicAddress)(xAddress);\n  var tagName;\n  if (field === DESTINATION) tagName = DEST_TAG;else if (field === ACCOUNT) tagName = SOURCE_TAG;else if (decoded.tag !== false) throw new Error(\"\".concat(field, \" cannot have an associated tag\"));\n  return decoded.tag !== false ? (_a = {}, _a[field] = decoded.classicAddress, _a[tagName] = decoded.tag, _a) : (_b = {}, _b[field] = decoded.classicAddress, _b);\n}\n/**\n * Validate that two objects don't both have the same tag fields\n *\n * @param obj1 First object to check for tags\n * @param obj2 Second object to check for tags\n * @throws When both objects have SourceTag or DestinationTag\n */\n\n\nfunction checkForDuplicateTags(obj1, obj2) {\n  if (!(obj1[SOURCE_TAG] === undefined || obj2[SOURCE_TAG] === undefined)) throw new Error('Cannot have Account X-Address and SourceTag');\n  if (!(obj1[DEST_TAG] === undefined || obj2[DEST_TAG] === undefined)) throw new Error('Cannot have Destination X-Address and DestinationTag');\n}\n/**\n * Class for Serializing/Deserializing objects\n */\n\n\nvar STObject =\n/** @class */\nfunction (_super) {\n  __extends(STObject, _super);\n\n  function STObject() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n  /**\n   * Construct a STObject from a BinaryParser\n   *\n   * @param parser BinaryParser to read STObject from\n   * @returns A STObject object\n   */\n\n\n  STObject.fromParser = function (parser) {\n    var list = new binary_serializer_1.BytesList();\n    var bytes = new binary_serializer_1.BinarySerializer(list);\n\n    while (!parser.end()) {\n      var field = parser.readField();\n\n      if (field.name === OBJECT_END_MARKER) {\n        break;\n      }\n\n      var associatedValue = parser.readFieldValue(field);\n      bytes.writeFieldAndValue(field, associatedValue);\n\n      if (field.type.name === ST_OBJECT) {\n        bytes.put(OBJECT_END_MARKER_BYTE);\n      }\n    }\n\n    return new STObject(list.toBytes());\n  };\n  /**\n   * Construct a STObject from a JSON object\n   *\n   * @param value An object to include\n   * @param filter optional, denote which field to include in serialized object\n   * @returns a STObject object\n   */\n\n\n  STObject.from = function (value, filter) {\n    if (value instanceof STObject) {\n      return value;\n    }\n\n    var list = new binary_serializer_1.BytesList();\n    var bytes = new binary_serializer_1.BinarySerializer(list);\n    var isUnlModify = false;\n    var xAddressDecoded = Object.entries(value).reduce(function (acc, _a) {\n      var _b;\n\n      var key = _a[0],\n          val = _a[1];\n      var handled = undefined;\n\n      if (val && (0, ripple_address_codec_1.isValidXAddress)(val.toString())) {\n        handled = handleXAddress(key, val.toString());\n        checkForDuplicateTags(handled, value);\n      }\n\n      return Object.assign(acc, handled !== null && handled !== void 0 ? handled : (_b = {}, _b[key] = val, _b));\n    }, {});\n    var sorted = Object.keys(xAddressDecoded).map(function (f) {\n      return enums_1.Field[f];\n    }).filter(function (f) {\n      return f !== undefined && xAddressDecoded[f.name] !== undefined && f.isSerialized;\n    }).sort(function (a, b) {\n      return a.ordinal - b.ordinal;\n    });\n\n    if (filter !== undefined) {\n      sorted = sorted.filter(filter);\n    }\n\n    sorted.forEach(function (field) {\n      var associatedValue = field.associatedType.from(xAddressDecoded[field.name]);\n\n      if (associatedValue == undefined) {\n        throw new TypeError(\"Unable to interpret \\\"\".concat(field.name, \": \").concat(xAddressDecoded[field.name], \"\\\".\"));\n      }\n\n      if (associatedValue.name === 'UNLModify') {\n        // triggered when the TransactionType field has a value of 'UNLModify'\n        isUnlModify = true;\n      } // true when in the UNLModify pseudotransaction (after the transaction type has been processed) and working with the\n      // Account field\n      // The Account field must not be a part of the UNLModify pseudotransaction encoding, due to a bug in rippled\n\n\n      var isUnlModifyWorkaround = field.name == 'Account' && isUnlModify;\n      bytes.writeFieldAndValue(field, associatedValue, isUnlModifyWorkaround);\n\n      if (field.type.name === ST_OBJECT) {\n        bytes.put(OBJECT_END_MARKER_BYTE);\n      }\n    });\n    return new STObject(list.toBytes());\n  };\n  /**\n   * Get the JSON interpretation of this.bytes\n   *\n   * @returns a JSON object\n   */\n\n\n  STObject.prototype.toJSON = function () {\n    var objectParser = new binary_parser_1.BinaryParser(this.toString());\n    var accumulator = {};\n\n    while (!objectParser.end()) {\n      var field = objectParser.readField();\n\n      if (field.name === OBJECT_END_MARKER) {\n        break;\n      }\n\n      accumulator[field.name] = objectParser.readFieldValue(field).toJSON();\n    }\n\n    return accumulator;\n  };\n\n  return STObject;\n}(serialized_type_1.SerializedType);\n\nexports.STObject = STObject;","map":{"version":3,"mappings":"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","names":["OBJECT_END_MARKER_BYTE","buffer_1","from","OBJECT_END_MARKER","ST_OBJECT","DESTINATION","ACCOUNT","SOURCE_TAG","DEST_TAG","handleXAddress","field","xAddress","decoded","tagName","tag","Error","_a","classicAddress","_b","checkForDuplicateTags","obj1","obj2","undefined","__extends","STObject","parser","list","binary_serializer_1","bytes","end","readField","name","associatedValue","readFieldValue","writeFieldAndValue","type","put","toBytes","value","filter","isUnlModify","xAddressDecoded","Object","entries","reduce","acc","key","val","handled","toString","assign","sorted","keys","map","f","isSerialized","sort","a","b","ordinal","forEach","associatedType","TypeError","concat","isUnlModifyWorkaround","objectParser","binary_parser_1","accumulator","toJSON","serialized_type_1","exports"],"sourceRoot":"","sources":["../../src/types/st-object.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}