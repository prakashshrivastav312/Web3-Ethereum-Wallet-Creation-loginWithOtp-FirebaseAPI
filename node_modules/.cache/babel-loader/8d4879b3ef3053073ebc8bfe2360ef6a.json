{"ast":null,"code":"\"use strict\";\n/**\n * Generate a character map.\n * @param {string} alphabet e.g. \"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567\"\n * @param {object} mappings map overrides from key to value\n * @method\n */\n\nvar charmap = function (alphabet, mappings) {\n  mappings || (mappings = {});\n  alphabet.split(\"\").forEach(function (c, i) {\n    if (!(c in mappings)) mappings[c] = i;\n  });\n  return mappings;\n};\n/**\n * The RFC 4648 base 32 alphabet and character map.\n * @see {@link https://tools.ietf.org/html/rfc4648}\n */\n\n\nvar rfc4648 = {\n  alphabet: \"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567\",\n  charmap: {\n    0: 14,\n    1: 8\n  }\n};\nrfc4648.charmap = charmap(rfc4648.alphabet, rfc4648.charmap);\n/**\n * The Crockford base 32 alphabet and character map.\n * @see {@link http://www.crockford.com/wrmg/base32.html}\n */\n\nvar crockford = {\n  alphabet: \"0123456789ABCDEFGHJKMNPQRSTVWXYZ\",\n  charmap: {\n    O: 0,\n    I: 1,\n    L: 1\n  }\n};\ncrockford.charmap = charmap(crockford.alphabet, crockford.charmap);\n/**\n * base32hex\n * @see {@link https://en.wikipedia.org/wiki/Base32#base32hex}\n */\n\nvar base32hex = {\n  alphabet: \"0123456789ABCDEFGHIJKLMNOPQRSTUV\",\n  charmap: {}\n};\nbase32hex.charmap = charmap(base32hex.alphabet, base32hex.charmap);\n/**\n * Create a new `Decoder` with the given options.\n *\n * @param {object} [options]\n *   @param {string} [type] Supported Base-32 variants are \"rfc4648\" and\n *     \"crockford\".\n *   @param {object} [charmap] Override the character map used in decoding.\n * @constructor\n */\n\nfunction Decoder(options) {\n  this.buf = [];\n  this.shift = 8;\n  this.carry = 0;\n\n  if (options) {\n    switch (options.type) {\n      case \"rfc4648\":\n        this.charmap = exports.rfc4648.charmap;\n        break;\n\n      case \"crockford\":\n        this.charmap = exports.crockford.charmap;\n        break;\n\n      case \"base32hex\":\n        this.charmap = exports.base32hex.charmap;\n        break;\n\n      default:\n        throw new Error(\"invalid type\");\n    }\n\n    if (options.charmap) this.charmap = options.charmap;\n  }\n}\n/**\n * The default character map coresponds to RFC4648.\n */\n\n\nDecoder.prototype.charmap = rfc4648.charmap;\n/**\n * Decode a string, continuing from the previous state.\n *\n * @param {string} str\n * @return {Decoder} this\n */\n\nDecoder.prototype.write = function (str) {\n  var charmap = this.charmap;\n  var buf = this.buf;\n  var shift = this.shift;\n  var carry = this.carry; // decode string\n\n  str.toUpperCase().split(\"\").forEach(function (char) {\n    // ignore padding\n    if (char == \"=\") return; // lookup symbol\n\n    var symbol = charmap[char] & 0xff; // 1: 00000 000\n    // 2:          00 00000 0\n    // 3:                    0000 0000\n    // 4:                             0 00000 00\n    // 5:                                       000 00000\n    // 6:                                                00000 000\n    // 7:                                                         00 00000 0\n\n    shift -= 5;\n\n    if (shift > 0) {\n      carry |= symbol << shift;\n    } else if (shift < 0) {\n      buf.push(carry | symbol >> -shift);\n      shift += 8;\n      carry = symbol << shift & 0xff;\n    } else {\n      buf.push(carry | symbol);\n      shift = 8;\n      carry = 0;\n    }\n  }); // save state\n\n  this.shift = shift;\n  this.carry = carry; // for chaining\n\n  return this;\n};\n/**\n * Finish decoding.\n *\n * @param {string} [str] The final string to decode.\n * @return {Array} Decoded byte array.\n */\n\n\nDecoder.prototype.finalize = function (str) {\n  if (str) {\n    this.write(str);\n  }\n\n  if (this.shift !== 8 && this.carry !== 0) {\n    this.buf.push(this.carry);\n    this.shift = 8;\n    this.carry = 0;\n  }\n\n  return this.buf;\n};\n/**\n * Create a new `Encoder` with the given options.\n *\n * @param {object} [options]\n *   @param {string} [type] Supported Base-32 variants are \"rfc4648\" and\n *     \"crockford\".\n *   @param {object} [alphabet] Override the alphabet used in encoding.\n * @constructor\n */\n\n\nfunction Encoder(options) {\n  this.buf = \"\";\n  this.shift = 3;\n  this.carry = 0;\n\n  if (options) {\n    switch (options.type) {\n      case \"rfc4648\":\n        this.alphabet = exports.rfc4648.alphabet;\n        break;\n\n      case \"crockford\":\n        this.alphabet = exports.crockford.alphabet;\n        break;\n\n      case \"base32hex\":\n        this.alphabet = exports.base32hex.alphabet;\n        break;\n\n      default:\n        throw new Error(\"invalid type\");\n    }\n\n    if (options.alphabet) this.alphabet = options.alphabet;else if (options.lc) this.alphabet = this.alphabet.toLowerCase();\n  }\n}\n/**\n * The default alphabet coresponds to RFC4648.\n */\n\n\nEncoder.prototype.alphabet = rfc4648.alphabet;\n/**\n * Encode a byte array, continuing from the previous state.\n *\n * @param {byte[]} buf The byte array to encode.\n * @return {Encoder} this\n */\n\nEncoder.prototype.write = function (buf) {\n  var shift = this.shift;\n  var carry = this.carry;\n  var symbol;\n  var byte;\n  var i; // encode each byte in buf\n\n  for (i = 0; i < buf.length; i++) {\n    byte = buf[i]; // 1: 00000 000\n    // 2:          00 00000 0\n    // 3:                    0000 0000\n    // 4:                             0 00000 00\n    // 5:                                       000 00000\n    // 6:                                                00000 000\n    // 7:                                                         00 00000 0\n\n    symbol = carry | byte >> shift;\n    this.buf += this.alphabet[symbol & 0x1f];\n\n    if (shift > 5) {\n      shift -= 5;\n      symbol = byte >> shift;\n      this.buf += this.alphabet[symbol & 0x1f];\n    }\n\n    shift = 5 - shift;\n    carry = byte << shift;\n    shift = 8 - shift;\n  } // save state\n\n\n  this.shift = shift;\n  this.carry = carry; // for chaining\n\n  return this;\n};\n/**\n * Finish encoding.\n *\n * @param {byte[]} [buf] The final byte array to encode.\n * @return {string} The encoded byte array.\n */\n\n\nEncoder.prototype.finalize = function (buf) {\n  if (buf) {\n    this.write(buf);\n  }\n\n  if (this.shift !== 3) {\n    this.buf += this.alphabet[this.carry & 0x1f];\n    this.shift = 3;\n    this.carry = 0;\n  }\n\n  return this.buf;\n};\n/**\n * Convenience encoder.\n *\n * @param {byte[]} buf The byte array to encode.\n * @param {object} [options] Options to pass to the encoder.\n * @return {string} The encoded string.\n */\n\n\nexports.encode = function (buf, options) {\n  return new Encoder(options).finalize(buf);\n};\n/**\n * Convenience decoder.\n *\n * @param {string} str The string to decode.\n * @param {object} [options] Options to pass to the decoder.\n * @return {byte[]} The decoded byte array.\n */\n\n\nexports.decode = function (str, options) {\n  return new Decoder(options).finalize(str);\n}; // Exports.\n\n\nexports.Decoder = Decoder;\nexports.Encoder = Encoder;\nexports.charmap = charmap;\nexports.crockford = crockford;\nexports.rfc4648 = rfc4648;\nexports.base32hex = base32hex;","map":{"version":3,"names":["charmap","alphabet","mappings","split","forEach","c","i","rfc4648","crockford","O","I","L","base32hex","Decoder","options","buf","shift","carry","type","exports","Error","prototype","write","str","toUpperCase","char","symbol","push","finalize","Encoder","lc","toLowerCase","byte","length","encode","decode"],"sources":["C:/Users/acer/node_modules/base32.js/base32.js"],"sourcesContent":["\"use strict\";\n\n/**\n * Generate a character map.\n * @param {string} alphabet e.g. \"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567\"\n * @param {object} mappings map overrides from key to value\n * @method\n */\n\nvar charmap = function (alphabet, mappings) {\n  mappings || (mappings = {});\n  alphabet.split(\"\").forEach(function (c, i) {\n    if (!(c in mappings)) mappings[c] = i;\n  });\n  return mappings;\n}\n\n/**\n * The RFC 4648 base 32 alphabet and character map.\n * @see {@link https://tools.ietf.org/html/rfc4648}\n */\n\nvar rfc4648 = {\n  alphabet: \"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567\",\n  charmap: {\n    0: 14,\n    1: 8\n  }\n};\n\nrfc4648.charmap = charmap(rfc4648.alphabet, rfc4648.charmap);\n\n/**\n * The Crockford base 32 alphabet and character map.\n * @see {@link http://www.crockford.com/wrmg/base32.html}\n */\n\nvar crockford = {\n  alphabet: \"0123456789ABCDEFGHJKMNPQRSTVWXYZ\",\n  charmap: {\n    O: 0,\n    I: 1,\n    L: 1\n  }\n};\n\ncrockford.charmap = charmap(crockford.alphabet, crockford.charmap);\n\n/**\n * base32hex\n * @see {@link https://en.wikipedia.org/wiki/Base32#base32hex}\n */\n\nvar base32hex = {\n  alphabet: \"0123456789ABCDEFGHIJKLMNOPQRSTUV\",\n  charmap: {}\n};\n\nbase32hex.charmap = charmap(base32hex.alphabet, base32hex.charmap);\n\n/**\n * Create a new `Decoder` with the given options.\n *\n * @param {object} [options]\n *   @param {string} [type] Supported Base-32 variants are \"rfc4648\" and\n *     \"crockford\".\n *   @param {object} [charmap] Override the character map used in decoding.\n * @constructor\n */\n\nfunction Decoder (options) {\n  this.buf = [];\n  this.shift = 8;\n  this.carry = 0;\n\n  if (options) {\n\n    switch (options.type) {\n      case \"rfc4648\":\n        this.charmap = exports.rfc4648.charmap;\n        break;\n      case \"crockford\":\n        this.charmap = exports.crockford.charmap;\n        break;\n      case \"base32hex\":\n        this.charmap = exports.base32hex.charmap;\n        break;\n      default:\n        throw new Error(\"invalid type\");\n    }\n\n    if (options.charmap) this.charmap = options.charmap;\n  }\n}\n\n/**\n * The default character map coresponds to RFC4648.\n */\n\nDecoder.prototype.charmap = rfc4648.charmap;\n\n/**\n * Decode a string, continuing from the previous state.\n *\n * @param {string} str\n * @return {Decoder} this\n */\n\nDecoder.prototype.write = function (str) {\n  var charmap = this.charmap;\n  var buf = this.buf;\n  var shift = this.shift;\n  var carry = this.carry;\n\n  // decode string\n  str.toUpperCase().split(\"\").forEach(function (char) {\n\n    // ignore padding\n    if (char == \"=\") return;\n\n    // lookup symbol\n    var symbol = charmap[char] & 0xff;\n\n    // 1: 00000 000\n    // 2:          00 00000 0\n    // 3:                    0000 0000\n    // 4:                             0 00000 00\n    // 5:                                       000 00000\n    // 6:                                                00000 000\n    // 7:                                                         00 00000 0\n\n    shift -= 5;\n    if (shift > 0) {\n      carry |= symbol << shift;\n    } else if (shift < 0) {\n      buf.push(carry | (symbol >> -shift));\n      shift += 8;\n      carry = (symbol << shift) & 0xff;\n    } else {\n      buf.push(carry | symbol);\n      shift = 8;\n      carry = 0;\n    }\n  });\n\n  // save state\n  this.shift = shift;\n  this.carry = carry;\n\n  // for chaining\n  return this;\n};\n\n/**\n * Finish decoding.\n *\n * @param {string} [str] The final string to decode.\n * @return {Array} Decoded byte array.\n */\n\nDecoder.prototype.finalize = function (str) {\n  if (str) {\n    this.write(str);\n  }\n  if (this.shift !== 8 && this.carry !== 0) {\n    this.buf.push(this.carry);\n    this.shift = 8;\n    this.carry = 0;\n  }\n  return this.buf;\n};\n\n/**\n * Create a new `Encoder` with the given options.\n *\n * @param {object} [options]\n *   @param {string} [type] Supported Base-32 variants are \"rfc4648\" and\n *     \"crockford\".\n *   @param {object} [alphabet] Override the alphabet used in encoding.\n * @constructor\n */\n\nfunction Encoder (options) {\n  this.buf = \"\";\n  this.shift = 3;\n  this.carry = 0;\n\n  if (options) {\n\n    switch (options.type) {\n      case \"rfc4648\":\n        this.alphabet = exports.rfc4648.alphabet;\n        break;\n      case \"crockford\":\n        this.alphabet = exports.crockford.alphabet;\n        break;\n      case \"base32hex\":\n        this.alphabet = exports.base32hex.alphabet;\n        break;\n      default:\n        throw new Error(\"invalid type\");\n    }\n\n    if (options.alphabet) this.alphabet = options.alphabet;\n    else if (options.lc) this.alphabet = this.alphabet.toLowerCase();\n  }\n}\n\n/**\n * The default alphabet coresponds to RFC4648.\n */\n\nEncoder.prototype.alphabet = rfc4648.alphabet;\n\n/**\n * Encode a byte array, continuing from the previous state.\n *\n * @param {byte[]} buf The byte array to encode.\n * @return {Encoder} this\n */\n\nEncoder.prototype.write = function (buf) {\n  var shift = this.shift;\n  var carry = this.carry;\n  var symbol;\n  var byte;\n  var i;\n\n  // encode each byte in buf\n  for (i = 0; i < buf.length; i++) {\n    byte = buf[i];\n\n    // 1: 00000 000\n    // 2:          00 00000 0\n    // 3:                    0000 0000\n    // 4:                             0 00000 00\n    // 5:                                       000 00000\n    // 6:                                                00000 000\n    // 7:                                                         00 00000 0\n\n    symbol = carry | (byte >> shift);\n    this.buf += this.alphabet[symbol & 0x1f];\n\n    if (shift > 5) {\n      shift -= 5;\n      symbol = byte >> shift;\n      this.buf += this.alphabet[symbol & 0x1f];\n    }\n\n    shift = 5 - shift;\n    carry = byte << shift;\n    shift = 8 - shift;\n  }\n\n  // save state\n  this.shift = shift;\n  this.carry = carry;\n\n  // for chaining\n  return this;\n};\n\n/**\n * Finish encoding.\n *\n * @param {byte[]} [buf] The final byte array to encode.\n * @return {string} The encoded byte array.\n */\n\nEncoder.prototype.finalize = function (buf) {\n  if (buf) {\n    this.write(buf);\n  }\n  if (this.shift !== 3) {\n    this.buf += this.alphabet[this.carry & 0x1f];\n    this.shift = 3;\n    this.carry = 0;\n  }\n  return this.buf;\n};\n\n/**\n * Convenience encoder.\n *\n * @param {byte[]} buf The byte array to encode.\n * @param {object} [options] Options to pass to the encoder.\n * @return {string} The encoded string.\n */\n\nexports.encode = function (buf, options) {\n  return new Encoder(options).finalize(buf);\n};\n\n/**\n * Convenience decoder.\n *\n * @param {string} str The string to decode.\n * @param {object} [options] Options to pass to the decoder.\n * @return {byte[]} The decoded byte array.\n */\n\nexports.decode = function (str, options) {\n  return new Decoder(options).finalize(str);\n};\n\n// Exports.\nexports.Decoder = Decoder;\nexports.Encoder = Encoder;\nexports.charmap = charmap;\nexports.crockford = crockford;\nexports.rfc4648 = rfc4648;\nexports.base32hex = base32hex;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}