{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.sendMarketplaceCancelListing = exports.sendMarketplaceBuyListing = exports.sendMarketplaceCreateListing = exports.sendMarketplaceApproveErc20Spending = exports.sendMarketplaceUpdateFeeRecipient = exports.sendMarketplaceUpdateFee = exports.prepareMarketplaceCancelListing = exports.prepareMarketplaceBuyListing = exports.prepareMarketplaceCreateListing = exports.prepareMarketplaceApproveErc20Spending = exports.prepareMarketplaceUpdateFeeRecipient = exports.prepareMarketplaceUpdateFee = exports.prepareDeployMarketplaceListing = exports.deployMarketplaceListing = exports.getMarketplaceFeeRecipient = exports.getMarketplaceListing = exports.getMarketplaceFee = void 0;\n\nconst bignumber_js_1 = __importDefault(require(\"bignumber.js\"));\n\nconst tatum_1 = require(\"../../connector/tatum\");\n\nconst fungible_1 = require(\"../../fungible\");\n\nconst helpers_1 = require(\"../../helpers\");\n\nconst model_1 = require(\"../../model\");\n\nconst transaction_1 = require(\"../../transaction\");\n\nvar ListingState;\n\n(function (ListingState) {\n  ListingState[\"INITIATED\"] = \"0\";\n  ListingState[\"SOLD\"] = \"1\";\n  ListingState[\"CANCELLED\"] = \"2\";\n})(ListingState || (ListingState = {}));\n/**\n * For more details, see <a href=\"https://tatum.io/apidoc#operation/GetMarketplaceFee\" target=\"_blank\">Tatum API documentation</a>\n */\n\n\nconst getMarketplaceFee = async (chain, contractAddress) => tatum_1.get(`/v3/blockchain/marketplace/listing/${chain}/${contractAddress}/fee`);\n\nexports.getMarketplaceFee = getMarketplaceFee;\n/**\n * For more details, see <a href=\"https://tatum.io/apidoc#operation/GetMarketplaceListing\" target=\"_blank\">Tatum API documentation</a>\n */\n\nconst getMarketplaceListing = async (chain, contractAddress, listingId) => tatum_1.get(`/v3/blockchain/marketplace/listing/${chain}/${contractAddress}/listing/${listingId}`);\n\nexports.getMarketplaceListing = getMarketplaceListing;\n/**\n * For more details, see <a href=\"https://tatum.io/apidoc#operation/GetMarketplaceFeeRecipient\" target=\"_blank\">Tatum API documentation</a>\n */\n\nconst getMarketplaceFeeRecipient = async (chain, contractAddress) => tatum_1.get(`/v3/blockchain/marketplace/listing/${chain}/${contractAddress}/recipient`);\n\nexports.getMarketplaceFeeRecipient = getMarketplaceFeeRecipient;\n/**\n * Deploy new smart contract for NFT marketplace logic. Smart contract enables marketplace operator to create new listing for NFT (ERC-721/1155).\n * Operator can set a fee in percentage, which will be paid on top of the price of the asset.\n * Listing can be offered for native asset - ETH, BSC, etc. - or any ERC20 token - this is configurable during listing creation.\n * Once the listing is created, seller must send the NFT asset to the smart contract.\n * Buyer will buy the asset from the listing using native asset - send assets along the buyAssetFromListing() smart contract call, or via ERC20 token.\n * Buyer of the listing must perform approval for the smart contract to access ERC20 token, before the actual buyAssetFromListing() method is called.\n * Once both assets - from buyer and seller - are in the smart contract, NFT is sent to the buyer, price is sent to the seller\n * and marketplace fee is set to the operator.\n * @param testnet chain to work with\n * @param body request data\n * @param provider optional provider to enter. if not present, Tatum Web3 will be used.\n * @returns {txId: string} Transaction ID of the operation, or signatureID in case of Tatum KMS\n */\n\nconst deployMarketplaceListing = async (testnet, body, provider) => {\n  switch (body.chain) {\n    case model_1.Currency.CELO:\n      return await transaction_1.sendCeloDeployMarketplaceListingSignedTransaction(testnet, body, provider);\n\n    case model_1.Currency.ONE:\n      return await transaction_1.sendOneDeployMarketplaceListingSignedTransaction(testnet, body, provider);\n\n    case model_1.Currency.ETH:\n      return await transaction_1.sendEthDeployMarketplaceListingSignedTransaction(body, provider);\n\n    case model_1.Currency.BSC:\n      return await transaction_1.sendBscDeployMarketplaceListingSignedTransaction(body, provider);\n\n    case model_1.Currency.MATIC:\n      return await transaction_1.sendPolygonDeployMarketplaceListingSignedTransaction(testnet, body, provider);\n\n    case model_1.Currency.KLAY:\n      return await transaction_1.sendKlaytnDeployMarketplaceListingSignedTransaction(testnet, body, provider);\n    // case Currency.TRON:\n    //     return await sendTronDeployMarketplaceListingSignedTransaction(testnet, body as DeployTronMarketplaceListing, provider)\n\n    default:\n      throw new Error('Unsupported chain');\n  }\n};\n\nexports.deployMarketplaceListing = deployMarketplaceListing;\n/**\n * Prepare signed transaction for deploy new smart contract for NFT marketplace logic. Smart contract enables marketplace operator to create new listing for NFT (ERC-721/1155).\n * Operator can set a fee in percentage, which will be paid on top of the price of the asset.\n * Listing can be offered for native asset - ETH, BSC, etc. - or any ERC20 token - this is configurable during listing creation.\n * Once the listing is created, seller must send the NFT asset to the smart contract.\n * Buyer will buy the asset from the listing using native asset - send assets along the buyAssetFromListing() smart contract call, or via ERC20 token.\n * Buyer of the listing must perform approval for the smart contract to access ERC20 token, before the actual buyAssetFromListing() method is called.\n * Once both assets - from buyer and seller - are in the smart contract, NFT is sent to the buyer, price is sent to the seller\n * and marketplace fee is set to the operator.\n * @param testnet chain to work with\n * @param body request data\n * @param provider optional provider to enter. if not present, Tatum Web3 will be used.\n * @returns {txId: string} Transaction ID of the operation, or signatureID in case of Tatum KMS\n */\n\nconst prepareDeployMarketplaceListing = async (testnet, body, provider) => {\n  switch (body.chain) {\n    case model_1.Currency.CELO:\n      return await transaction_1.prepareCeloDeployMarketplaceListingSignedTransaction(testnet, body, provider);\n\n    case model_1.Currency.ONE:\n      return await transaction_1.prepareOneDeployMarketplaceListingSignedTransaction(testnet, body, provider);\n\n    case model_1.Currency.ETH:\n      return await transaction_1.prepareEthDeployMarketplaceListingSignedTransaction(body, provider);\n\n    case model_1.Currency.BSC:\n      return await transaction_1.prepareBscDeployMarketplaceListingSignedTransaction(body, provider);\n\n    case model_1.Currency.MATIC:\n      return await transaction_1.preparePolygonDeployMarketplaceListingSignedTransaction(testnet, body, provider);\n\n    case model_1.Currency.KLAY:\n      return await transaction_1.prepareKlaytnDeployMarketplaceListingSignedTransaction(testnet, body, provider);\n    // case Currency.TRON:\n    //     return await prepareTronDeployMarketplaceListingSignedTransaction(testnet, body as DeployTronMarketplaceListing, provider)\n\n    default:\n      throw new Error('Unsupported chain');\n  }\n};\n\nexports.prepareDeployMarketplaceListing = prepareDeployMarketplaceListing;\n/**\n * Update marketplace fee.\n * @param testnet chain to work with\n * @param body request data\n * @param provider optional provider to enter. if not present, Tatum Web3 will be used.\n * @returns {txId: string} Transaction ID of the operation, or signatureID in case of Tatum KMS\n */\n\nconst prepareMarketplaceUpdateFee = async (testnet, body, provider) => {\n  await tatum_1.validateBody(body, body.chain === model_1.Currency.TRON ? model_1.UpdateTronMarketplaceFee : model_1.UpdateMarketplaceFee);\n  const params = [`0x${new bignumber_js_1.default(body.marketplaceFee).toString(16)}`];\n\n  if (body.chain === model_1.Currency.TRON) {\n    throw new Error('Unsupported chain'); // return await helperPrepareSCCall(testnet, body, UpdateTronMarketplaceFee, 'setMarketplaceFee',\n    //     [\n    //         {type: 'uint256', value: params[0]},\n    //     ], 'setMarketplaceFee(uint256)', provider)\n  } else {\n    return await helpers_1.helperPrepareSCCall(testnet, body, model_1.UpdateMarketplaceFee, 'setMarketplaceFee', params, undefined, provider);\n  }\n};\n\nexports.prepareMarketplaceUpdateFee = prepareMarketplaceUpdateFee;\n/**\n * Update marketplace fee recipient.\n * @param testnet chain to work with\n * @param body request data\n * @param provider optional provider to enter. if not present, Tatum Web3 will be used.\n * @returns {txId: string} Transaction ID of the operation, or signatureID in case of Tatum KMS\n */\n\nconst prepareMarketplaceUpdateFeeRecipient = async (testnet, body, provider) => {\n  await tatum_1.validateBody(body, body.chain === model_1.Currency.TRON ? model_1.UpdateTronMarketplaceFeeRecipient : model_1.UpdateMarketplaceFeeRecipient);\n  const params = [body.feeRecipient];\n\n  if (body.chain === model_1.Currency.TRON) {\n    throw new Error('Unsupported chain'); // return await helperPrepareSCCall(testnet, body, UpdateTronMarketplaceFeeRecipient, 'setMarketplaceFeeRecipient',\n    //     [\n    //         {type: 'address', value: convertAddressToHex(params[0])},\n    //     ], 'setMarketplaceFeeRecipient(address)', provider)\n  } else {\n    return await helpers_1.helperPrepareSCCall(testnet, body, model_1.UpdateMarketplaceFeeRecipient, 'setMarketplaceFeeRecipient', params, undefined, provider);\n  }\n};\n\nexports.prepareMarketplaceUpdateFeeRecipient = prepareMarketplaceUpdateFeeRecipient;\n/**\n * Approve ERC20 spending for marketplace to perform buy with ERC20 token.\n * @param testnet chain to work with\n * @param body request data\n * @param provider optional provider to enter. if not present, Tatum Web3 will be used.\n * @returns {txId: string} Transaction ID of the operation, or signatureID in case of Tatum KMS\n */\n\nconst prepareMarketplaceApproveErc20Spending = async (testnet, body, provider) => {\n  return fungible_1.prepareApproveErc20(testnet, body, provider);\n};\n\nexports.prepareMarketplaceApproveErc20Spending = prepareMarketplaceApproveErc20Spending;\n/**\n * Create new listing on the marketplace.\n * After listing is created, seller must send the asset to the marketplace smart contract.\n * Only listing for existing NFTs can be created - seller must be owner of the NFT asset.\n * @param testnet chain to work with\n * @param body request data\n * @param provider optional provider to enter. if not present, Tatum Web3 will be used.\n * @returns {txId: string} Transaction ID of the operation, or signatureID in case of Tatum KMS\n */\n\nconst prepareMarketplaceCreateListing = async (testnet, body, provider) => {\n  await tatum_1.validateBody(body, body.chain === model_1.Currency.TRON ? model_1.CreateTronMarketplaceListing : model_1.CreateMarketplaceListing);\n  const decimals = body.erc20Address ? await fungible_1.getErc20Decimals(testnet, body.chain, body.erc20Address, provider) : 18;\n  const params = [body.listingId, body.isErc721, body.nftAddress.trim(), `0x${new bignumber_js_1.default(body.tokenId).toString(16)}`, `0x${new bignumber_js_1.default(body.price).multipliedBy(10 ** decimals).toString(16)}`, body.seller.trim(), `0x${new bignumber_js_1.default(body.amount || 0).toString(16)}`, body.erc20Address || '0x0000000000000000000000000000000000000000'];\n\n  if (body.chain === model_1.Currency.TRON) {\n    throw new Error('Unsupported chain'); // if (!body.erc20Address) {\n    //     params[7] = 'T9yD14Nj9j7xAB4dbGeiX9h8unkKHxuWwb';\n    // }\n    // return await helperPrepareSCCall(testnet, body, CreateTronMarketplaceListing, 'createListing',\n    //     [\n    //         {type: 'string', value: params[0]},\n    //         {type: 'bool', value: params[1]},\n    //         {type: 'address', value: convertAddressToHex(params[2] as string)},\n    //         {type: 'uint256', value: params[3]},\n    //         {type: 'uint256', value: params[4]},\n    //         {type: 'address', value: convertAddressToHex(params[5] as string)},\n    //         {type: 'uint256', value: params[6]},\n    //         {type: 'address', value: convertAddressToHex(params[7] as string)},\n    //     ], 'createListing(string,bool,address,uint256,uint256,address,uint256,address)', provider)\n  } else {\n    if (!body.isErc721) {\n      body.amount = undefined;\n    }\n\n    return await helpers_1.helperPrepareSCCall(testnet, body, model_1.CreateMarketplaceListing, 'createListing', params, undefined, provider);\n  }\n};\n\nexports.prepareMarketplaceCreateListing = prepareMarketplaceCreateListing;\n/**\n * Buy listing on the marketplace. Buyer must either send native assets with this operation, or approve ERC20 token spending before.\n * After listing is sold, it's in a pending state to be processed by the marketplace. Noone receives the assets unless the marketplace operator processes that.\n * @param testnet chain to work with\n * @param body request data\n * @param provider optional provider to enter. if not present, Tatum Web3 will be used.\n * @returns {txId: string} Transaction ID of the operation, or signatureID in case of Tatum KMS\n */\n\nconst prepareMarketplaceBuyListing = async (testnet, body, provider) => {\n  await tatum_1.validateBody(body, body.chain === model_1.Currency.TRON ? model_1.InvokeTronMarketplaceListingOperation : model_1.InvokeMarketplaceListingOperation);\n  const params = [body.listingId, body.erc20Address || '0x0000000000000000000000000000000000000000'];\n  let methodName = 'buyAssetFromListing';\n\n  if (body.erc20Address) {\n    body.amount = undefined;\n\n    if (body.buyer) {\n      params.push(body.buyer.trim());\n      methodName = 'buyAssetFromListingForExternalBuyer';\n    }\n  }\n\n  if (body.chain === model_1.Currency.TRON) {\n    throw new Error('Unsupported chain'); // return await helperPrepareSCCall(testnet, body, InvokeTronMarketplaceListingOperation, 'buyAssetFromListing',\n    //     [\n    //         {type: 'string', value: params[0]},\n    //         {type: 'address', value: convertAddressToHex(params[1])},\n    //     ], 'buyAssetFromListing(string,address)', provider);\n  } else {\n    return await helpers_1.helperPrepareSCCall(testnet, body, model_1.InvokeMarketplaceListingOperation, methodName, params, undefined, provider);\n  }\n};\n\nexports.prepareMarketplaceBuyListing = prepareMarketplaceBuyListing;\n/**\n * Cancel listing on the marketplace. Only possible for the seller or the operator. There must be no buyer present for that listing. NFT asset is sent back to the seller.\n * @param testnet chain to work with\n * @param body request data\n * @param provider optional provider to enter. if not present, Tatum Web3 will be used.\n * @returns {txId: string} Transaction ID of the operation, or signatureID in case of Tatum KMS\n */\n\nconst prepareMarketplaceCancelListing = async (testnet, body, provider) => {\n  await tatum_1.validateBody(body, body.chain === model_1.Currency.TRON ? model_1.InvokeTronMarketplaceListingOperation : model_1.InvokeMarketplaceListingOperation);\n  const params = [body.listingId];\n\n  if (body.chain === model_1.Currency.TRON) {\n    throw new Error('Unsupported chain'); // return await helperPrepareSCCall(testnet, body, InvokeTronMarketplaceListingOperation, 'cancelListing',\n    //     [\n    //         {type: 'string', value: params[0]},\n    //     ], 'cancelListing(string)', provider)\n  } else {\n    return await helpers_1.helperPrepareSCCall(testnet, body, model_1.InvokeMarketplaceListingOperation, 'cancelListing', params, undefined, provider);\n  }\n};\n\nexports.prepareMarketplaceCancelListing = prepareMarketplaceCancelListing;\n/**\n * Update marketplace fee.\n * @param testnet chain to work with\n * @param body request data\n * @param provider optional provider to enter. if not present, Tatum Web3 will be used.\n * @returns {txId: string} Transaction ID of the operation, or signatureID in case of Tatum KMS\n */\n\nconst sendMarketplaceUpdateFee = async (testnet, body, provider) => helpers_1.helperBroadcastTx(body.chain, await exports.prepareMarketplaceUpdateFee(testnet, body, provider), body.signatureId);\n\nexports.sendMarketplaceUpdateFee = sendMarketplaceUpdateFee;\n/**\n * Update marketplace fee recipient.\n * @param testnet chain to work with\n * @param body request data\n * @param provider optional provider to enter. if not present, Tatum Web3 will be used.\n * @returns {txId: string} Transaction ID of the operation, or signatureID in case of Tatum KMS\n */\n\nconst sendMarketplaceUpdateFeeRecipient = async (testnet, body, provider) => helpers_1.helperBroadcastTx(body.chain, await exports.prepareMarketplaceUpdateFeeRecipient(testnet, body, provider), body.signatureId);\n\nexports.sendMarketplaceUpdateFeeRecipient = sendMarketplaceUpdateFeeRecipient;\n/**\n * Approve ERC20 spending for marketplace to perform buy with ERC20 token.\n * @param testnet chain to work with\n * @param body request data\n * @param provider optional provider to enter. if not present, Tatum Web3 will be used.\n * @returns {txId: string} Transaction ID of the operation, or signatureID in case of Tatum KMS\n */\n\nconst sendMarketplaceApproveErc20Spending = async (testnet, body, provider) => helpers_1.helperBroadcastTx(body.chain, await exports.prepareMarketplaceApproveErc20Spending(testnet, body, provider), body.signatureId);\n\nexports.sendMarketplaceApproveErc20Spending = sendMarketplaceApproveErc20Spending;\n/**\n * Create new listing on the marketplace.\n * After listing is created, seller must send the asset to the marketplace smart contract.\n * Only listing for existing NFTs can be created - seller must be owner of the NFT asset.\n * @param testnet chain to work with\n * @param body request data\n * @param provider optional provider to enter. if not present, Tatum Web3 will be used.\n * @returns {txId: string} Transaction ID of the operation, or signatureID in case of Tatum KMS\n */\n\nconst sendMarketplaceCreateListing = async (testnet, body, provider) => helpers_1.helperBroadcastTx(body.chain, await exports.prepareMarketplaceCreateListing(testnet, body, provider), body.signatureId);\n\nexports.sendMarketplaceCreateListing = sendMarketplaceCreateListing;\n/**\n * Buy listing on the marketplace. Buyer must either send native assets with this operation, or approve ERC20 token spending before.\n * After listing is sold, it's in a pending state to be processed by the marketplace. Noone receives the assets unless the marketplace operator processes that.\n * @param testnet chain to work with\n * @param body request data\n * @param provider optional provider to enter. if not present, Tatum Web3 will be used.\n * @returns {txId: string} Transaction ID of the operation, or signatureID in case of Tatum KMS\n */\n\nconst sendMarketplaceBuyListing = async (testnet, body, provider) => helpers_1.helperBroadcastTx(body.chain, await exports.prepareMarketplaceBuyListing(testnet, body, provider), body.signatureId);\n\nexports.sendMarketplaceBuyListing = sendMarketplaceBuyListing;\n/**\n * Cancel listing on the marketplace. Only possible for the seller or the operator. There must be no buyer present for that listing. NFT asset is sent back to the seller.\n * @param testnet chain to work with\n * @param body request data\n * @param provider optional provider to enter. if not present, Tatum Web3 will be used.\n * @returns {txId: string} Transaction ID of the operation, or signatureID in case of Tatum KMS\n */\n\nconst sendMarketplaceCancelListing = async (testnet, body, provider) => helpers_1.helperBroadcastTx(body.chain, await exports.prepareMarketplaceCancelListing(testnet, body, provider), body.signatureId);\n\nexports.sendMarketplaceCancelListing = sendMarketplaceCancelListing;","map":{"version":3,"mappings":"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","names":["ListingState","getMarketplaceFee","chain","contractAddress","tatum_1","exports","getMarketplaceListing","listingId","getMarketplaceFeeRecipient","deployMarketplaceListing","testnet","body","provider","model_1","CELO","transaction_1","ONE","ETH","BSC","MATIC","KLAY","Error","prepareDeployMarketplaceListing","prepareMarketplaceUpdateFee","TRON","params","bignumber_js_1","marketplaceFee","toString","helpers_1","undefined","prepareMarketplaceUpdateFeeRecipient","feeRecipient","prepareMarketplaceApproveErc20Spending","fungible_1","prepareMarketplaceCreateListing","decimals","erc20Address","isErc721","nftAddress","trim","tokenId","price","multipliedBy","seller","amount","prepareMarketplaceBuyListing","methodName","buyer","push","prepareMarketplaceCancelListing","sendMarketplaceUpdateFee","signatureId","sendMarketplaceUpdateFeeRecipient","sendMarketplaceApproveErc20Spending","sendMarketplaceCreateListing","sendMarketplaceBuyListing","sendMarketplaceCancelListing"],"sourceRoot":"","sources":["../../../../src/nft/marketplace/listing.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}