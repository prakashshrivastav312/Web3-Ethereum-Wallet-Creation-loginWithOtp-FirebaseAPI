{"ast":null,"code":"'use strict';\n\nvar assert = require('assert');\n\nvar _ = require('lodash');\n\nvar $ = require('./util/preconditions');\n\nvar BN = require('./crypto/bn');\n\nvar Base58 = require('./encoding/base58');\n\nvar Base58Check = require('./encoding/base58check');\n\nvar Hash = require('./crypto/hash');\n\nvar Network = require('./networks');\n\nvar Point = require('./crypto/point');\n\nvar PrivateKey = require('./privatekey');\n\nvar Random = require('./crypto/random');\n\nvar errors = require('./errors');\n\nvar hdErrors = errors.HDPrivateKey;\n\nvar BufferUtil = require('./util/buffer');\n\nvar JSUtil = require('./util/js');\n\nvar MINIMUM_ENTROPY_BITS = 128;\nvar BITS_TO_BYTES = 1 / 8;\nvar MAXIMUM_ENTROPY_BITS = 512;\n/**\n * Represents an instance of an hierarchically derived private key.\n *\n * More info on https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki\n *\n * @constructor\n * @param {string|Buffer|Object} arg\n */\n\nfunction HDPrivateKey(arg) {\n  /* jshint maxcomplexity: 10 */\n  if (arg instanceof HDPrivateKey) {\n    return arg;\n  }\n\n  if (!(this instanceof HDPrivateKey)) {\n    return new HDPrivateKey(arg);\n  }\n\n  if (!arg) {\n    return this._generateRandomly();\n  }\n\n  if (Network.get(arg)) {\n    return this._generateRandomly(arg);\n  } else if (_.isString(arg) || BufferUtil.isBuffer(arg)) {\n    if (HDPrivateKey.isValidSerialized(arg)) {\n      this._buildFromSerialized(arg);\n    } else if (JSUtil.isValidJSON(arg)) {\n      this._buildFromJSON(arg);\n    } else if (BufferUtil.isBuffer(arg) && HDPrivateKey.isValidSerialized(arg.toString())) {\n      this._buildFromSerialized(arg.toString());\n    } else {\n      throw HDPrivateKey.getSerializedError(arg);\n    }\n  } else if (_.isObject(arg)) {\n    this._buildFromObject(arg);\n  } else {\n    throw new hdErrors.UnrecognizedArgument(arg);\n  }\n}\n/**\n * Verifies that a given path is valid.\n *\n * @param {string|number} arg\n * @param {boolean?} hardened\n * @return {boolean}\n */\n\n\nHDPrivateKey.isValidPath = function (arg, hardened) {\n  if (_.isString(arg)) {\n    var indexes = HDPrivateKey._getDerivationIndexes(arg);\n\n    return indexes !== null && _.every(indexes, HDPrivateKey.isValidPath);\n  }\n\n  if (_.isNumber(arg)) {\n    if (arg < HDPrivateKey.Hardened && hardened === true) {\n      arg += HDPrivateKey.Hardened;\n    }\n\n    return arg >= 0 && arg < HDPrivateKey.MaxIndex;\n  }\n\n  return false;\n};\n/**\n * Internal function that splits a string path into a derivation index array.\n * It will return null if the string path is malformed.\n * It does not validate if indexes are in bounds.\n *\n * @param {string} path\n * @return {Array}\n */\n\n\nHDPrivateKey._getDerivationIndexes = function (path) {\n  var steps = path.split('/'); // Special cases:\n\n  if (_.includes(HDPrivateKey.RootElementAlias, path)) {\n    return [];\n  }\n\n  if (!_.includes(HDPrivateKey.RootElementAlias, steps[0])) {\n    return null;\n  }\n\n  var indexes = steps.slice(1).map(function (step) {\n    var isHardened = step.slice(-1) === '\\'';\n\n    if (isHardened) {\n      step = step.slice(0, -1);\n    }\n\n    if (!step || step[0] === '-') {\n      return NaN;\n    }\n\n    var index = +step; // cast to number\n\n    if (isHardened) {\n      index += HDPrivateKey.Hardened;\n    }\n\n    return index;\n  });\n  return _.some(indexes, isNaN) ? null : indexes;\n};\n/**\n * WARNING: This method will not be officially supported until v1.0.0.\n *\n *\n * Get a derived child based on a string or number.\n *\n * If the first argument is a string, it's parsed as the full path of\n * derivation. Valid values for this argument include \"m\" (which returns the\n * same private key), \"m/0/1/40/2'/1000\", where the ' quote means a hardened\n * derivation.\n *\n * If the first argument is a number, the child with that index will be\n * derived. If the second argument is truthy, the hardened version will be\n * derived. See the example usage for clarification.\n *\n * WARNING: The `nonCompliant` option should NOT be used, except for older implementation\n * that used a derivation strategy that used a non-zero padded private key.\n *\n * @example\n * ```javascript\n * var parent = new HDPrivateKey('xprv...');\n * var child_0_1_2h = parent.deriveChild(0).deriveChild(1).deriveChild(2, true);\n * var copy_of_child_0_1_2h = parent.deriveChild(\"m/0/1/2'\");\n * assert(child_0_1_2h.xprivkey === copy_of_child_0_1_2h);\n * ```\n *\n * @param {string|number} arg\n * @param {boolean?} hardened\n */\n\n\nHDPrivateKey.prototype.deriveChild = function (arg, hardened) {\n  if (_.isNumber(arg)) {\n    return this._deriveWithNumber(arg, hardened);\n  } else if (_.isString(arg)) {\n    return this._deriveFromString(arg);\n  } else {\n    throw new hdErrors.InvalidDerivationArgument(arg);\n  }\n};\n/**\n * WARNING: This method will not be officially supported until v1.0.0\n *\n *\n * WARNING: If this is a new implementation you should NOT use this method, you should be using\n * `derive` instead.\n *\n * This method is explicitly for use and compatibility with an implementation that\n * was not compliant with BIP32 regarding the derivation algorithm. The private key\n * must be 32 bytes hashing, and this implementation will use the non-zero padded\n * serialization of a private key, such that it's still possible to derive the privateKey\n * to recover those funds.\n *\n * @param {string|number} arg\n * @param {boolean?} hardened\n */\n\n\nHDPrivateKey.prototype.deriveNonCompliantChild = function (arg, hardened) {\n  if (_.isNumber(arg)) {\n    return this._deriveWithNumber(arg, hardened, true);\n  } else if (_.isString(arg)) {\n    return this._deriveFromString(arg, true);\n  } else {\n    throw new hdErrors.InvalidDerivationArgument(arg);\n  }\n};\n\nHDPrivateKey.prototype._deriveWithNumber = function (index, hardened, nonCompliant) {\n  /* jshint maxstatements: 20 */\n\n  /* jshint maxcomplexity: 10 */\n  if (!HDPrivateKey.isValidPath(index, hardened)) {\n    throw new hdErrors.InvalidPath(index);\n  }\n\n  hardened = index >= HDPrivateKey.Hardened ? true : hardened;\n\n  if (index < HDPrivateKey.Hardened && hardened === true) {\n    index += HDPrivateKey.Hardened;\n  }\n\n  var indexBuffer = BufferUtil.integerAsBuffer(index);\n  var data;\n\n  if (hardened && nonCompliant) {\n    // The private key serialization in this case will not be exactly 32 bytes and can be\n    // any value less, and the value is not zero-padded.\n    var nonZeroPadded = this.privateKey.bn.toBuffer();\n    data = BufferUtil.concat([Buffer.from([0]), nonZeroPadded, indexBuffer]);\n  } else if (hardened) {\n    // This will use a 32 byte zero padded serialization of the private key\n    var privateKeyBuffer = this.privateKey.bn.toBuffer({\n      size: 32\n    });\n    assert(privateKeyBuffer.length === 32, 'length of private key buffer is expected to be 32 bytes');\n    data = BufferUtil.concat([Buffer.from([0]), privateKeyBuffer, indexBuffer]);\n  } else {\n    data = BufferUtil.concat([this.publicKey.toBuffer(), indexBuffer]);\n  }\n\n  var hash = Hash.sha512hmac(data, this._buffers.chainCode);\n  var leftPart = BN.fromBuffer(hash.slice(0, 32), {\n    size: 32\n  });\n  var chainCode = hash.slice(32, 64);\n  var privateKey = leftPart.add(this.privateKey.toBigNumber()).umod(Point.getN()).toBuffer({\n    size: 32\n  });\n\n  if (!PrivateKey.isValid(privateKey)) {\n    // Index at this point is already hardened, we can pass null as the hardened arg\n    return this._deriveWithNumber(index + 1, null, nonCompliant);\n  }\n\n  var derived = new HDPrivateKey({\n    network: this.network,\n    depth: this.depth + 1,\n    parentFingerPrint: this.fingerPrint,\n    childIndex: index,\n    chainCode: chainCode,\n    privateKey: privateKey\n  });\n  return derived;\n};\n\nHDPrivateKey.prototype._deriveFromString = function (path, nonCompliant) {\n  if (!HDPrivateKey.isValidPath(path)) {\n    throw new hdErrors.InvalidPath(path);\n  }\n\n  var indexes = HDPrivateKey._getDerivationIndexes(path);\n\n  var derived = indexes.reduce(function (prev, index) {\n    return prev._deriveWithNumber(index, null, nonCompliant);\n  }, this);\n  return derived;\n};\n/**\n * Verifies that a given serialized private key in base58 with checksum format\n * is valid.\n *\n * @param {string|Buffer} data - the serialized private key\n * @param {string|Network=} network - optional, if present, checks that the\n *     network provided matches the network serialized.\n * @return {boolean}\n */\n\n\nHDPrivateKey.isValidSerialized = function (data, network) {\n  return !HDPrivateKey.getSerializedError(data, network);\n};\n/**\n * Checks what's the error that causes the validation of a serialized private key\n * in base58 with checksum to fail.\n *\n * @param {string|Buffer} data - the serialized private key\n * @param {string|Network=} network - optional, if present, checks that the\n *     network provided matches the network serialized.\n * @return {errors.InvalidArgument|null}\n */\n\n\nHDPrivateKey.getSerializedError = function (data, network) {\n  /* jshint maxcomplexity: 10 */\n  if (!(_.isString(data) || BufferUtil.isBuffer(data))) {\n    return new hdErrors.UnrecognizedArgument('Expected string or buffer');\n  }\n\n  if (!Base58.validCharacters(data)) {\n    return new errors.InvalidB58Char('(unknown)', data);\n  }\n\n  try {\n    data = Base58Check.decode(data);\n  } catch (e) {\n    return new errors.InvalidB58Checksum(data);\n  }\n\n  if (data.length !== HDPrivateKey.DataLength) {\n    return new hdErrors.InvalidLength(data);\n  }\n\n  if (!_.isUndefined(network)) {\n    var error = HDPrivateKey._validateNetwork(data, network);\n\n    if (error) {\n      return error;\n    }\n  }\n\n  return null;\n};\n\nHDPrivateKey._validateNetwork = function (data, networkArg) {\n  var network = Network.get(networkArg);\n\n  if (!network) {\n    return new errors.InvalidNetworkArgument(networkArg);\n  }\n\n  var version = data.slice(0, 4);\n\n  if (BufferUtil.integerFromBuffer(version) !== network.xprivkey) {\n    return new errors.InvalidNetwork(version);\n  }\n\n  return null;\n};\n\nHDPrivateKey.fromString = function (arg) {\n  $.checkArgument(_.isString(arg), 'No valid string was provided');\n  return new HDPrivateKey(arg);\n};\n\nHDPrivateKey.fromObject = function (arg) {\n  $.checkArgument(_.isObject(arg), 'No valid argument was provided');\n  return new HDPrivateKey(arg);\n};\n\nHDPrivateKey.prototype._buildFromJSON = function (arg) {\n  return this._buildFromObject(JSON.parse(arg));\n};\n\nHDPrivateKey.prototype._buildFromObject = function (arg) {\n  /* jshint maxcomplexity: 12 */\n  // TODO: Type validation\n  var buffers = {\n    version: arg.network ? BufferUtil.integerAsBuffer(Network.get(arg.network).xprivkey) : arg.version,\n    depth: _.isNumber(arg.depth) ? BufferUtil.integerAsSingleByteBuffer(arg.depth) : arg.depth,\n    parentFingerPrint: _.isNumber(arg.parentFingerPrint) ? BufferUtil.integerAsBuffer(arg.parentFingerPrint) : arg.parentFingerPrint,\n    childIndex: _.isNumber(arg.childIndex) ? BufferUtil.integerAsBuffer(arg.childIndex) : arg.childIndex,\n    chainCode: _.isString(arg.chainCode) ? Buffer.from(arg.chainCode, 'hex') : arg.chainCode,\n    privateKey: _.isString(arg.privateKey) && JSUtil.isHexa(arg.privateKey) ? Buffer.from(arg.privateKey, 'hex') : arg.privateKey,\n    checksum: arg.checksum ? arg.checksum.length ? arg.checksum : BufferUtil.integerAsBuffer(arg.checksum) : undefined\n  };\n  return this._buildFromBuffers(buffers);\n};\n\nHDPrivateKey.prototype._buildFromSerialized = function (arg) {\n  var decoded = Base58Check.decode(arg);\n  var buffers = {\n    version: decoded.slice(HDPrivateKey.VersionStart, HDPrivateKey.VersionEnd),\n    depth: decoded.slice(HDPrivateKey.DepthStart, HDPrivateKey.DepthEnd),\n    parentFingerPrint: decoded.slice(HDPrivateKey.ParentFingerPrintStart, HDPrivateKey.ParentFingerPrintEnd),\n    childIndex: decoded.slice(HDPrivateKey.ChildIndexStart, HDPrivateKey.ChildIndexEnd),\n    chainCode: decoded.slice(HDPrivateKey.ChainCodeStart, HDPrivateKey.ChainCodeEnd),\n    privateKey: decoded.slice(HDPrivateKey.PrivateKeyStart, HDPrivateKey.PrivateKeyEnd),\n    checksum: decoded.slice(HDPrivateKey.ChecksumStart, HDPrivateKey.ChecksumEnd),\n    xprivkey: arg\n  };\n  return this._buildFromBuffers(buffers);\n};\n\nHDPrivateKey.prototype._generateRandomly = function (network) {\n  return HDPrivateKey.fromSeed(Random.getRandomBuffer(64), network);\n};\n/**\n * Generate a private key from a seed, as described in BIP32\n *\n * @param {string|Buffer} hexa\n * @param {*} network\n * @return HDPrivateKey\n */\n\n\nHDPrivateKey.fromSeed = function (hexa, network) {\n  /* jshint maxcomplexity: 8 */\n  if (JSUtil.isHexaString(hexa)) {\n    hexa = Buffer.from(hexa, 'hex');\n  }\n\n  if (!Buffer.isBuffer(hexa)) {\n    throw new hdErrors.InvalidEntropyArgument(hexa);\n  }\n\n  if (hexa.length < MINIMUM_ENTROPY_BITS * BITS_TO_BYTES) {\n    throw new hdErrors.InvalidEntropyArgument.NotEnoughEntropy(hexa);\n  }\n\n  if (hexa.length > MAXIMUM_ENTROPY_BITS * BITS_TO_BYTES) {\n    throw new hdErrors.InvalidEntropyArgument.TooMuchEntropy(hexa);\n  }\n\n  var hash = Hash.sha512hmac(hexa, Buffer.from('Bitcoin seed'));\n  return new HDPrivateKey({\n    network: Network.get(network) || Network.defaultNetwork,\n    depth: 0,\n    parentFingerPrint: 0,\n    childIndex: 0,\n    privateKey: hash.slice(0, 32),\n    chainCode: hash.slice(32, 64)\n  });\n};\n\nHDPrivateKey.prototype._calcHDPublicKey = function () {\n  if (!this._hdPublicKey) {\n    var HDPublicKey = require('./hdpublickey');\n\n    this._hdPublicKey = new HDPublicKey(this);\n  }\n};\n/**\n * Receives a object with buffers in all the properties and populates the\n * internal structure\n *\n * @param {Object} arg\n * @param {Buffer} arg.version\n * @param {Buffer} arg.depth\n * @param {Buffer} arg.parentFingerPrint\n * @param {Buffer} arg.childIndex\n * @param {Buffer} arg.chainCode\n * @param {Buffer} arg.privateKey\n * @param {Buffer} arg.checksum\n * @param {string=} arg.xprivkey - if set, don't recalculate the base58\n *      representation\n * @return {HDPrivateKey} this\n */\n\n\nHDPrivateKey.prototype._buildFromBuffers = function (arg) {\n  /* jshint maxcomplexity: 8 */\n\n  /* jshint maxstatements: 20 */\n  HDPrivateKey._validateBufferArguments(arg);\n\n  JSUtil.defineImmutable(this, {\n    _buffers: arg\n  });\n  var sequence = [arg.version, arg.depth, arg.parentFingerPrint, arg.childIndex, arg.chainCode, BufferUtil.emptyBuffer(1), arg.privateKey];\n  var concat = Buffer.concat(sequence);\n\n  if (!arg.checksum || !arg.checksum.length) {\n    arg.checksum = Base58Check.checksum(concat);\n  } else {\n    if (arg.checksum.toString() !== Base58Check.checksum(concat).toString()) {\n      throw new errors.InvalidB58Checksum(concat);\n    }\n  }\n\n  var network = Network.get(BufferUtil.integerFromBuffer(arg.version));\n  var xprivkey;\n  xprivkey = Base58Check.encode(Buffer.concat(sequence));\n  arg.xprivkey = Buffer.from(xprivkey);\n  var privateKey = new PrivateKey(BN.fromBuffer(arg.privateKey), network);\n  var publicKey = privateKey.toPublicKey();\n  var size = HDPrivateKey.ParentFingerPrintSize;\n  var fingerPrint = Hash.sha256ripemd160(publicKey.toBuffer()).slice(0, size);\n  JSUtil.defineImmutable(this, {\n    xprivkey: xprivkey,\n    network: network,\n    depth: BufferUtil.integerFromSingleByteBuffer(arg.depth),\n    privateKey: privateKey,\n    publicKey: publicKey,\n    fingerPrint: fingerPrint\n  });\n  this._hdPublicKey = null;\n  Object.defineProperty(this, 'hdPublicKey', {\n    configurable: false,\n    enumerable: true,\n    get: function () {\n      this._calcHDPublicKey();\n\n      return this._hdPublicKey;\n    }\n  });\n  Object.defineProperty(this, 'xpubkey', {\n    configurable: false,\n    enumerable: true,\n    get: function () {\n      this._calcHDPublicKey();\n\n      return this._hdPublicKey.xpubkey;\n    }\n  });\n  return this;\n};\n\nHDPrivateKey._validateBufferArguments = function (arg) {\n  var checkBuffer = function (name, size) {\n    var buff = arg[name];\n    assert(BufferUtil.isBuffer(buff), name + ' argument is not a buffer');\n    assert(buff.length === size, name + ' has not the expected size: found ' + buff.length + ', expected ' + size);\n  };\n\n  checkBuffer('version', HDPrivateKey.VersionSize);\n  checkBuffer('depth', HDPrivateKey.DepthSize);\n  checkBuffer('parentFingerPrint', HDPrivateKey.ParentFingerPrintSize);\n  checkBuffer('childIndex', HDPrivateKey.ChildIndexSize);\n  checkBuffer('chainCode', HDPrivateKey.ChainCodeSize);\n  checkBuffer('privateKey', HDPrivateKey.PrivateKeySize);\n\n  if (arg.checksum && arg.checksum.length) {\n    checkBuffer('checksum', HDPrivateKey.CheckSumSize);\n  }\n};\n/**\n * Returns the string representation of this private key (a string starting\n * with \"xprv...\"\n *\n * @return string\n */\n\n\nHDPrivateKey.prototype.toString = function () {\n  return this.xprivkey;\n};\n/**\n * Returns the console representation of this extended private key.\n * @return string\n */\n\n\nHDPrivateKey.prototype.inspect = function () {\n  return '<HDPrivateKey: ' + this.xprivkey + '>';\n};\n/**\n * Returns a plain object with a representation of this private key.\n *\n * Fields include:<ul>\n * <li> network: either 'livenet' or 'testnet'\n * <li> depth: a number ranging from 0 to 255\n * <li> fingerPrint: a number ranging from 0 to 2^32-1, taken from the hash of the\n * <li>     associated public key\n * <li> parentFingerPrint: a number ranging from 0 to 2^32-1, taken from the hash\n * <li>     of this parent's associated public key or zero.\n * <li> childIndex: the index from which this child was derived (or zero)\n * <li> chainCode: an hexa string representing a number used in the derivation\n * <li> privateKey: the private key associated, in hexa representation\n * <li> xprivkey: the representation of this extended private key in checksum\n * <li>     base58 format\n * <li> checksum: the base58 checksum of xprivkey\n * </ul>\n *  @return {Object}\n */\n\n\nHDPrivateKey.prototype.toObject = HDPrivateKey.prototype.toJSON = function toObject() {\n  return {\n    network: Network.get(BufferUtil.integerFromBuffer(this._buffers.version), 'xprivkey').name,\n    depth: BufferUtil.integerFromSingleByteBuffer(this._buffers.depth),\n    fingerPrint: BufferUtil.integerFromBuffer(this.fingerPrint),\n    parentFingerPrint: BufferUtil.integerFromBuffer(this._buffers.parentFingerPrint),\n    childIndex: BufferUtil.integerFromBuffer(this._buffers.childIndex),\n    chainCode: BufferUtil.bufferToHex(this._buffers.chainCode),\n    privateKey: this.privateKey.toBuffer().toString('hex'),\n    checksum: BufferUtil.integerFromBuffer(this._buffers.checksum),\n    xprivkey: this.xprivkey\n  };\n};\n/**\n * Build a HDPrivateKey from a buffer\n *\n * @param {Buffer} arg\n * @return {HDPrivateKey}\n */\n\n\nHDPrivateKey.fromBuffer = function (arg) {\n  return new HDPrivateKey(arg.toString());\n};\n/**\n * Returns a buffer representation of the HDPrivateKey\n *\n * @return {string}\n */\n\n\nHDPrivateKey.prototype.toBuffer = function () {\n  return BufferUtil.copy(this._buffers.xprivkey);\n};\n\nHDPrivateKey.DefaultDepth = 0;\nHDPrivateKey.DefaultFingerprint = 0;\nHDPrivateKey.DefaultChildIndex = 0;\nHDPrivateKey.Hardened = 0x80000000;\nHDPrivateKey.MaxIndex = 2 * HDPrivateKey.Hardened;\nHDPrivateKey.RootElementAlias = ['m', 'M', 'm\\'', 'M\\''];\nHDPrivateKey.VersionSize = 4;\nHDPrivateKey.DepthSize = 1;\nHDPrivateKey.ParentFingerPrintSize = 4;\nHDPrivateKey.ChildIndexSize = 4;\nHDPrivateKey.ChainCodeSize = 32;\nHDPrivateKey.PrivateKeySize = 32;\nHDPrivateKey.CheckSumSize = 4;\nHDPrivateKey.DataLength = 78;\nHDPrivateKey.SerializedByteSize = 82;\nHDPrivateKey.VersionStart = 0;\nHDPrivateKey.VersionEnd = HDPrivateKey.VersionStart + HDPrivateKey.VersionSize;\nHDPrivateKey.DepthStart = HDPrivateKey.VersionEnd;\nHDPrivateKey.DepthEnd = HDPrivateKey.DepthStart + HDPrivateKey.DepthSize;\nHDPrivateKey.ParentFingerPrintStart = HDPrivateKey.DepthEnd;\nHDPrivateKey.ParentFingerPrintEnd = HDPrivateKey.ParentFingerPrintStart + HDPrivateKey.ParentFingerPrintSize;\nHDPrivateKey.ChildIndexStart = HDPrivateKey.ParentFingerPrintEnd;\nHDPrivateKey.ChildIndexEnd = HDPrivateKey.ChildIndexStart + HDPrivateKey.ChildIndexSize;\nHDPrivateKey.ChainCodeStart = HDPrivateKey.ChildIndexEnd;\nHDPrivateKey.ChainCodeEnd = HDPrivateKey.ChainCodeStart + HDPrivateKey.ChainCodeSize;\nHDPrivateKey.PrivateKeyStart = HDPrivateKey.ChainCodeEnd + 1;\nHDPrivateKey.PrivateKeyEnd = HDPrivateKey.PrivateKeyStart + HDPrivateKey.PrivateKeySize;\nHDPrivateKey.ChecksumStart = HDPrivateKey.PrivateKeyEnd;\nHDPrivateKey.ChecksumEnd = HDPrivateKey.ChecksumStart + HDPrivateKey.CheckSumSize;\nassert(HDPrivateKey.ChecksumEnd === HDPrivateKey.SerializedByteSize);\nmodule.exports = HDPrivateKey;","map":{"version":3,"names":["assert","require","_","$","BN","Base58","Base58Check","Hash","Network","Point","PrivateKey","Random","errors","hdErrors","HDPrivateKey","BufferUtil","JSUtil","MINIMUM_ENTROPY_BITS","BITS_TO_BYTES","MAXIMUM_ENTROPY_BITS","arg","_generateRandomly","get","isString","isBuffer","isValidSerialized","_buildFromSerialized","isValidJSON","_buildFromJSON","toString","getSerializedError","isObject","_buildFromObject","UnrecognizedArgument","isValidPath","hardened","indexes","_getDerivationIndexes","every","isNumber","Hardened","MaxIndex","path","steps","split","includes","RootElementAlias","slice","map","step","isHardened","NaN","index","some","isNaN","prototype","deriveChild","_deriveWithNumber","_deriveFromString","InvalidDerivationArgument","deriveNonCompliantChild","nonCompliant","InvalidPath","indexBuffer","integerAsBuffer","data","nonZeroPadded","privateKey","bn","toBuffer","concat","Buffer","from","privateKeyBuffer","size","length","publicKey","hash","sha512hmac","_buffers","chainCode","leftPart","fromBuffer","add","toBigNumber","umod","getN","isValid","derived","network","depth","parentFingerPrint","fingerPrint","childIndex","reduce","prev","validCharacters","InvalidB58Char","decode","e","InvalidB58Checksum","DataLength","InvalidLength","isUndefined","error","_validateNetwork","networkArg","InvalidNetworkArgument","version","integerFromBuffer","xprivkey","InvalidNetwork","fromString","checkArgument","fromObject","JSON","parse","buffers","integerAsSingleByteBuffer","isHexa","checksum","undefined","_buildFromBuffers","decoded","VersionStart","VersionEnd","DepthStart","DepthEnd","ParentFingerPrintStart","ParentFingerPrintEnd","ChildIndexStart","ChildIndexEnd","ChainCodeStart","ChainCodeEnd","PrivateKeyStart","PrivateKeyEnd","ChecksumStart","ChecksumEnd","fromSeed","getRandomBuffer","hexa","isHexaString","InvalidEntropyArgument","NotEnoughEntropy","TooMuchEntropy","defaultNetwork","_calcHDPublicKey","_hdPublicKey","HDPublicKey","_validateBufferArguments","defineImmutable","sequence","emptyBuffer","encode","toPublicKey","ParentFingerPrintSize","sha256ripemd160","integerFromSingleByteBuffer","Object","defineProperty","configurable","enumerable","xpubkey","checkBuffer","name","buff","VersionSize","DepthSize","ChildIndexSize","ChainCodeSize","PrivateKeySize","CheckSumSize","inspect","toObject","toJSON","bufferToHex","copy","DefaultDepth","DefaultFingerprint","DefaultChildIndex","SerializedByteSize","module","exports"],"sources":["C:/Users/acer/node_modules/bitcore-lib-ltc/lib/hdprivatekey.js"],"sourcesContent":["'use strict';\n\n\nvar assert = require('assert');\nvar _ = require('lodash');\nvar $ = require('./util/preconditions');\n\nvar BN = require('./crypto/bn');\nvar Base58 = require('./encoding/base58');\nvar Base58Check = require('./encoding/base58check');\nvar Hash = require('./crypto/hash');\nvar Network = require('./networks');\nvar Point = require('./crypto/point');\nvar PrivateKey = require('./privatekey');\nvar Random = require('./crypto/random');\n\nvar errors = require('./errors');\nvar hdErrors = errors.HDPrivateKey;\nvar BufferUtil = require('./util/buffer');\nvar JSUtil = require('./util/js');\n\nvar MINIMUM_ENTROPY_BITS = 128;\nvar BITS_TO_BYTES = 1 / 8;\nvar MAXIMUM_ENTROPY_BITS = 512;\n\n\n/**\n * Represents an instance of an hierarchically derived private key.\n *\n * More info on https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki\n *\n * @constructor\n * @param {string|Buffer|Object} arg\n */\nfunction HDPrivateKey(arg) {\n  /* jshint maxcomplexity: 10 */\n  if (arg instanceof HDPrivateKey) {\n    return arg;\n  }\n  if (!(this instanceof HDPrivateKey)) {\n    return new HDPrivateKey(arg);\n  }\n  if (!arg) {\n    return this._generateRandomly();\n  }\n\n  if (Network.get(arg)) {\n    return this._generateRandomly(arg);\n  } else if (_.isString(arg) || BufferUtil.isBuffer(arg)) {\n    if (HDPrivateKey.isValidSerialized(arg)) {\n      this._buildFromSerialized(arg);\n    } else if (JSUtil.isValidJSON(arg)) {\n      this._buildFromJSON(arg);\n    } else if (BufferUtil.isBuffer(arg) && HDPrivateKey.isValidSerialized(arg.toString())) {\n      this._buildFromSerialized(arg.toString());\n    } else {\n      throw HDPrivateKey.getSerializedError(arg);\n    }\n  } else if (_.isObject(arg)) {\n    this._buildFromObject(arg);\n  } else {\n    throw new hdErrors.UnrecognizedArgument(arg);\n  }\n}\n\n/**\n * Verifies that a given path is valid.\n *\n * @param {string|number} arg\n * @param {boolean?} hardened\n * @return {boolean}\n */\nHDPrivateKey.isValidPath = function(arg, hardened) {\n  if (_.isString(arg)) {\n    var indexes = HDPrivateKey._getDerivationIndexes(arg);\n    return indexes !== null && _.every(indexes, HDPrivateKey.isValidPath);\n  }\n\n  if (_.isNumber(arg)) {\n    if (arg < HDPrivateKey.Hardened && hardened === true) {\n      arg += HDPrivateKey.Hardened;\n    }\n    return arg >= 0 && arg < HDPrivateKey.MaxIndex;\n  }\n\n  return false;\n};\n\n/**\n * Internal function that splits a string path into a derivation index array.\n * It will return null if the string path is malformed.\n * It does not validate if indexes are in bounds.\n *\n * @param {string} path\n * @return {Array}\n */\nHDPrivateKey._getDerivationIndexes = function(path) {\n  var steps = path.split('/');\n\n  // Special cases:\n  if (_.includes(HDPrivateKey.RootElementAlias, path)) {\n    return [];\n  }\n\n  if (!_.includes(HDPrivateKey.RootElementAlias, steps[0])) {\n    return null;\n  }\n\n  var indexes = steps.slice(1).map(function(step) {\n    var isHardened = step.slice(-1) === '\\'';\n    if (isHardened) {\n      step = step.slice(0, -1);\n    }\n    if (!step || step[0] === '-') {\n      return NaN;\n    }\n    var index = +step; // cast to number\n    if (isHardened) {\n      index += HDPrivateKey.Hardened;\n    }\n\n    return index;\n  });\n\n  return _.some(indexes, isNaN) ? null : indexes;\n};\n\n/**\n * WARNING: This method will not be officially supported until v1.0.0.\n *\n *\n * Get a derived child based on a string or number.\n *\n * If the first argument is a string, it's parsed as the full path of\n * derivation. Valid values for this argument include \"m\" (which returns the\n * same private key), \"m/0/1/40/2'/1000\", where the ' quote means a hardened\n * derivation.\n *\n * If the first argument is a number, the child with that index will be\n * derived. If the second argument is truthy, the hardened version will be\n * derived. See the example usage for clarification.\n *\n * WARNING: The `nonCompliant` option should NOT be used, except for older implementation\n * that used a derivation strategy that used a non-zero padded private key.\n *\n * @example\n * ```javascript\n * var parent = new HDPrivateKey('xprv...');\n * var child_0_1_2h = parent.deriveChild(0).deriveChild(1).deriveChild(2, true);\n * var copy_of_child_0_1_2h = parent.deriveChild(\"m/0/1/2'\");\n * assert(child_0_1_2h.xprivkey === copy_of_child_0_1_2h);\n * ```\n *\n * @param {string|number} arg\n * @param {boolean?} hardened\n */\nHDPrivateKey.prototype.deriveChild = function(arg, hardened) {\n  if (_.isNumber(arg)) {\n    return this._deriveWithNumber(arg, hardened);\n  } else if (_.isString(arg)) {\n    return this._deriveFromString(arg);\n  } else {\n    throw new hdErrors.InvalidDerivationArgument(arg);\n  }\n};\n\n/**\n * WARNING: This method will not be officially supported until v1.0.0\n *\n *\n * WARNING: If this is a new implementation you should NOT use this method, you should be using\n * `derive` instead.\n *\n * This method is explicitly for use and compatibility with an implementation that\n * was not compliant with BIP32 regarding the derivation algorithm. The private key\n * must be 32 bytes hashing, and this implementation will use the non-zero padded\n * serialization of a private key, such that it's still possible to derive the privateKey\n * to recover those funds.\n *\n * @param {string|number} arg\n * @param {boolean?} hardened\n */\nHDPrivateKey.prototype.deriveNonCompliantChild = function(arg, hardened) {\n  if (_.isNumber(arg)) {\n    return this._deriveWithNumber(arg, hardened, true);\n  } else if (_.isString(arg)) {\n    return this._deriveFromString(arg, true);\n  } else {\n    throw new hdErrors.InvalidDerivationArgument(arg);\n  }\n};\n\nHDPrivateKey.prototype._deriveWithNumber = function(index, hardened, nonCompliant) {\n  /* jshint maxstatements: 20 */\n  /* jshint maxcomplexity: 10 */\n  if (!HDPrivateKey.isValidPath(index, hardened)) {\n    throw new hdErrors.InvalidPath(index);\n  }\n\n  hardened = index >= HDPrivateKey.Hardened ? true : hardened;\n  if (index < HDPrivateKey.Hardened && hardened === true) {\n    index += HDPrivateKey.Hardened;\n  }\n\n  var indexBuffer = BufferUtil.integerAsBuffer(index);\n  var data;\n  if (hardened && nonCompliant) {\n    // The private key serialization in this case will not be exactly 32 bytes and can be\n    // any value less, and the value is not zero-padded.\n    var nonZeroPadded = this.privateKey.bn.toBuffer();\n    data = BufferUtil.concat([Buffer.from([0]), nonZeroPadded, indexBuffer]);\n  } else if (hardened) {\n    // This will use a 32 byte zero padded serialization of the private key\n    var privateKeyBuffer = this.privateKey.bn.toBuffer({size: 32});\n    assert(privateKeyBuffer.length === 32, 'length of private key buffer is expected to be 32 bytes');\n    data = BufferUtil.concat([Buffer.from([0]), privateKeyBuffer, indexBuffer]);\n  } else {\n    data = BufferUtil.concat([this.publicKey.toBuffer(), indexBuffer]);\n  }\n  var hash = Hash.sha512hmac(data, this._buffers.chainCode);\n  var leftPart = BN.fromBuffer(hash.slice(0, 32), {\n    size: 32\n  });\n  var chainCode = hash.slice(32, 64);\n\n  var privateKey = leftPart.add(this.privateKey.toBigNumber()).umod(Point.getN()).toBuffer({\n    size: 32\n  });\n\n  if (!PrivateKey.isValid(privateKey)) {\n    // Index at this point is already hardened, we can pass null as the hardened arg\n    return this._deriveWithNumber(index + 1, null, nonCompliant);\n  }\n\n  var derived = new HDPrivateKey({\n    network: this.network,\n    depth: this.depth + 1,\n    parentFingerPrint: this.fingerPrint,\n    childIndex: index,\n    chainCode: chainCode,\n    privateKey: privateKey\n  });\n\n  return derived;\n};\n\nHDPrivateKey.prototype._deriveFromString = function(path, nonCompliant) {\n  if (!HDPrivateKey.isValidPath(path)) {\n    throw new hdErrors.InvalidPath(path);\n  }\n\n  var indexes = HDPrivateKey._getDerivationIndexes(path);\n  var derived = indexes.reduce(function(prev, index) {\n    return prev._deriveWithNumber(index, null, nonCompliant);\n  }, this);\n\n  return derived;\n};\n\n/**\n * Verifies that a given serialized private key in base58 with checksum format\n * is valid.\n *\n * @param {string|Buffer} data - the serialized private key\n * @param {string|Network=} network - optional, if present, checks that the\n *     network provided matches the network serialized.\n * @return {boolean}\n */\nHDPrivateKey.isValidSerialized = function(data, network) {\n  return !HDPrivateKey.getSerializedError(data, network);\n};\n\n/**\n * Checks what's the error that causes the validation of a serialized private key\n * in base58 with checksum to fail.\n *\n * @param {string|Buffer} data - the serialized private key\n * @param {string|Network=} network - optional, if present, checks that the\n *     network provided matches the network serialized.\n * @return {errors.InvalidArgument|null}\n */\nHDPrivateKey.getSerializedError = function(data, network) {\n  /* jshint maxcomplexity: 10 */\n  if (!(_.isString(data) || BufferUtil.isBuffer(data))) {\n    return new hdErrors.UnrecognizedArgument('Expected string or buffer');\n  }\n  if (!Base58.validCharacters(data)) {\n    return new errors.InvalidB58Char('(unknown)', data);\n  }\n  try {\n    data = Base58Check.decode(data);\n  } catch (e) {\n    return new errors.InvalidB58Checksum(data);\n  }\n  if (data.length !== HDPrivateKey.DataLength) {\n    return new hdErrors.InvalidLength(data);\n  }\n  if (!_.isUndefined(network)) {\n    var error = HDPrivateKey._validateNetwork(data, network);\n    if (error) {\n      return error;\n    }\n  }\n  return null;\n};\n\nHDPrivateKey._validateNetwork = function(data, networkArg) {\n  var network = Network.get(networkArg);\n  if (!network) {\n    return new errors.InvalidNetworkArgument(networkArg);\n  }\n  var version = data.slice(0, 4);\n  if (BufferUtil.integerFromBuffer(version) !== network.xprivkey) {\n    return new errors.InvalidNetwork(version);\n  }\n  return null;\n};\n\nHDPrivateKey.fromString = function(arg) {\n  $.checkArgument(_.isString(arg), 'No valid string was provided');\n  return new HDPrivateKey(arg);\n};\n\nHDPrivateKey.fromObject = function(arg) {\n  $.checkArgument(_.isObject(arg), 'No valid argument was provided');\n  return new HDPrivateKey(arg);\n};\n\nHDPrivateKey.prototype._buildFromJSON = function(arg) {\n  return this._buildFromObject(JSON.parse(arg));\n};\n\nHDPrivateKey.prototype._buildFromObject = function(arg) {\n  /* jshint maxcomplexity: 12 */\n  // TODO: Type validation\n  var buffers = {\n    version: arg.network ? BufferUtil.integerAsBuffer(Network.get(arg.network).xprivkey) : arg.version,\n    depth: _.isNumber(arg.depth) ? BufferUtil.integerAsSingleByteBuffer(arg.depth) : arg.depth,\n    parentFingerPrint: _.isNumber(arg.parentFingerPrint) ? BufferUtil.integerAsBuffer(arg.parentFingerPrint) : arg.parentFingerPrint,\n    childIndex: _.isNumber(arg.childIndex) ? BufferUtil.integerAsBuffer(arg.childIndex) : arg.childIndex,\n    chainCode: _.isString(arg.chainCode) ? Buffer.from(arg.chainCode,'hex') : arg.chainCode,\n    privateKey: (_.isString(arg.privateKey) && JSUtil.isHexa(arg.privateKey)) ? Buffer.from(arg.privateKey,'hex') : arg.privateKey,\n    checksum: arg.checksum ? (arg.checksum.length ? arg.checksum : BufferUtil.integerAsBuffer(arg.checksum)) : undefined\n  };\n  return this._buildFromBuffers(buffers);\n};\n\nHDPrivateKey.prototype._buildFromSerialized = function(arg) {\n  var decoded = Base58Check.decode(arg);\n  var buffers = {\n    version: decoded.slice(HDPrivateKey.VersionStart, HDPrivateKey.VersionEnd),\n    depth: decoded.slice(HDPrivateKey.DepthStart, HDPrivateKey.DepthEnd),\n    parentFingerPrint: decoded.slice(HDPrivateKey.ParentFingerPrintStart,\n      HDPrivateKey.ParentFingerPrintEnd),\n    childIndex: decoded.slice(HDPrivateKey.ChildIndexStart, HDPrivateKey.ChildIndexEnd),\n    chainCode: decoded.slice(HDPrivateKey.ChainCodeStart, HDPrivateKey.ChainCodeEnd),\n    privateKey: decoded.slice(HDPrivateKey.PrivateKeyStart, HDPrivateKey.PrivateKeyEnd),\n    checksum: decoded.slice(HDPrivateKey.ChecksumStart, HDPrivateKey.ChecksumEnd),\n    xprivkey: arg\n  };\n  return this._buildFromBuffers(buffers);\n};\n\nHDPrivateKey.prototype._generateRandomly = function(network) {\n  return HDPrivateKey.fromSeed(Random.getRandomBuffer(64), network);\n};\n\n/**\n * Generate a private key from a seed, as described in BIP32\n *\n * @param {string|Buffer} hexa\n * @param {*} network\n * @return HDPrivateKey\n */\nHDPrivateKey.fromSeed = function(hexa, network) {\n  /* jshint maxcomplexity: 8 */\n  if (JSUtil.isHexaString(hexa)) {\n    hexa = Buffer.from(hexa, 'hex');\n  }\n  if (!Buffer.isBuffer(hexa)) {\n    throw new hdErrors.InvalidEntropyArgument(hexa);\n  }\n  if (hexa.length < MINIMUM_ENTROPY_BITS * BITS_TO_BYTES) {\n    throw new hdErrors.InvalidEntropyArgument.NotEnoughEntropy(hexa);\n  }\n  if (hexa.length > MAXIMUM_ENTROPY_BITS * BITS_TO_BYTES) {\n    throw new hdErrors.InvalidEntropyArgument.TooMuchEntropy(hexa);\n  }\n  var hash = Hash.sha512hmac(hexa, Buffer.from('Bitcoin seed'));\n\n  return new HDPrivateKey({\n    network: Network.get(network) || Network.defaultNetwork,\n    depth: 0,\n    parentFingerPrint: 0,\n    childIndex: 0,\n    privateKey: hash.slice(0, 32),\n    chainCode: hash.slice(32, 64)\n  });\n};\n\n\n\nHDPrivateKey.prototype._calcHDPublicKey = function() {\n  if (!this._hdPublicKey) {\n    var HDPublicKey = require('./hdpublickey');\n    this._hdPublicKey = new HDPublicKey(this);\n  }\n};\n\n/**\n * Receives a object with buffers in all the properties and populates the\n * internal structure\n *\n * @param {Object} arg\n * @param {Buffer} arg.version\n * @param {Buffer} arg.depth\n * @param {Buffer} arg.parentFingerPrint\n * @param {Buffer} arg.childIndex\n * @param {Buffer} arg.chainCode\n * @param {Buffer} arg.privateKey\n * @param {Buffer} arg.checksum\n * @param {string=} arg.xprivkey - if set, don't recalculate the base58\n *      representation\n * @return {HDPrivateKey} this\n */\nHDPrivateKey.prototype._buildFromBuffers = function(arg) {\n  /* jshint maxcomplexity: 8 */\n  /* jshint maxstatements: 20 */\n\n  HDPrivateKey._validateBufferArguments(arg);\n\n  JSUtil.defineImmutable(this, {\n    _buffers: arg\n  });\n\n  var sequence = [\n    arg.version, arg.depth, arg.parentFingerPrint, arg.childIndex, arg.chainCode,\n    BufferUtil.emptyBuffer(1), arg.privateKey\n  ];\n  var concat = Buffer.concat(sequence);\n  if (!arg.checksum || !arg.checksum.length) {\n    arg.checksum = Base58Check.checksum(concat);\n  } else {\n    if (arg.checksum.toString() !== Base58Check.checksum(concat).toString()) {\n      throw new errors.InvalidB58Checksum(concat);\n    }\n  }\n\n  var network = Network.get(BufferUtil.integerFromBuffer(arg.version));\n  var xprivkey;\n  xprivkey = Base58Check.encode(Buffer.concat(sequence));\n  arg.xprivkey = Buffer.from(xprivkey);\n\n  var privateKey = new PrivateKey(BN.fromBuffer(arg.privateKey), network);\n  var publicKey = privateKey.toPublicKey();\n  var size = HDPrivateKey.ParentFingerPrintSize;\n  var fingerPrint = Hash.sha256ripemd160(publicKey.toBuffer()).slice(0, size);\n\n  JSUtil.defineImmutable(this, {\n    xprivkey: xprivkey,\n    network: network,\n    depth: BufferUtil.integerFromSingleByteBuffer(arg.depth),\n    privateKey: privateKey,\n    publicKey: publicKey,\n    fingerPrint: fingerPrint\n  });\n\n  this._hdPublicKey = null;\n\n  Object.defineProperty(this, 'hdPublicKey', {\n    configurable: false,\n    enumerable: true,\n    get: function() {\n      this._calcHDPublicKey();\n      return this._hdPublicKey;\n    }\n  });\n  Object.defineProperty(this, 'xpubkey', {\n    configurable: false,\n    enumerable: true,\n    get: function() {\n      this._calcHDPublicKey();\n      return this._hdPublicKey.xpubkey;\n    }\n  });\n  return this;\n};\n\nHDPrivateKey._validateBufferArguments = function(arg) {\n  var checkBuffer = function(name, size) {\n    var buff = arg[name];\n    assert(BufferUtil.isBuffer(buff), name + ' argument is not a buffer');\n    assert(\n      buff.length === size,\n      name + ' has not the expected size: found ' + buff.length + ', expected ' + size\n    );\n  };\n  checkBuffer('version', HDPrivateKey.VersionSize);\n  checkBuffer('depth', HDPrivateKey.DepthSize);\n  checkBuffer('parentFingerPrint', HDPrivateKey.ParentFingerPrintSize);\n  checkBuffer('childIndex', HDPrivateKey.ChildIndexSize);\n  checkBuffer('chainCode', HDPrivateKey.ChainCodeSize);\n  checkBuffer('privateKey', HDPrivateKey.PrivateKeySize);\n  if (arg.checksum && arg.checksum.length) {\n    checkBuffer('checksum', HDPrivateKey.CheckSumSize);\n  }\n};\n\n/**\n * Returns the string representation of this private key (a string starting\n * with \"xprv...\"\n *\n * @return string\n */\nHDPrivateKey.prototype.toString = function() {\n  return this.xprivkey;\n};\n\n/**\n * Returns the console representation of this extended private key.\n * @return string\n */\nHDPrivateKey.prototype.inspect = function() {\n  return '<HDPrivateKey: ' + this.xprivkey + '>';\n};\n\n/**\n * Returns a plain object with a representation of this private key.\n *\n * Fields include:<ul>\n * <li> network: either 'livenet' or 'testnet'\n * <li> depth: a number ranging from 0 to 255\n * <li> fingerPrint: a number ranging from 0 to 2^32-1, taken from the hash of the\n * <li>     associated public key\n * <li> parentFingerPrint: a number ranging from 0 to 2^32-1, taken from the hash\n * <li>     of this parent's associated public key or zero.\n * <li> childIndex: the index from which this child was derived (or zero)\n * <li> chainCode: an hexa string representing a number used in the derivation\n * <li> privateKey: the private key associated, in hexa representation\n * <li> xprivkey: the representation of this extended private key in checksum\n * <li>     base58 format\n * <li> checksum: the base58 checksum of xprivkey\n * </ul>\n *  @return {Object}\n */\nHDPrivateKey.prototype.toObject = HDPrivateKey.prototype.toJSON = function toObject() {\n  return {\n    network: Network.get(BufferUtil.integerFromBuffer(this._buffers.version), 'xprivkey').name,\n    depth: BufferUtil.integerFromSingleByteBuffer(this._buffers.depth),\n    fingerPrint: BufferUtil.integerFromBuffer(this.fingerPrint),\n    parentFingerPrint: BufferUtil.integerFromBuffer(this._buffers.parentFingerPrint),\n    childIndex: BufferUtil.integerFromBuffer(this._buffers.childIndex),\n    chainCode: BufferUtil.bufferToHex(this._buffers.chainCode),\n    privateKey: this.privateKey.toBuffer().toString('hex'),\n    checksum: BufferUtil.integerFromBuffer(this._buffers.checksum),\n    xprivkey: this.xprivkey\n  };\n};\n\n/**\n * Build a HDPrivateKey from a buffer\n *\n * @param {Buffer} arg\n * @return {HDPrivateKey}\n */\nHDPrivateKey.fromBuffer = function(arg) {\n  return new HDPrivateKey(arg.toString());\n};\n\n/**\n * Returns a buffer representation of the HDPrivateKey\n *\n * @return {string}\n */\nHDPrivateKey.prototype.toBuffer = function() {\n  return BufferUtil.copy(this._buffers.xprivkey);\n};\n\nHDPrivateKey.DefaultDepth = 0;\nHDPrivateKey.DefaultFingerprint = 0;\nHDPrivateKey.DefaultChildIndex = 0;\nHDPrivateKey.Hardened = 0x80000000;\nHDPrivateKey.MaxIndex = 2 * HDPrivateKey.Hardened;\n\nHDPrivateKey.RootElementAlias = ['m', 'M', 'm\\'', 'M\\''];\n\nHDPrivateKey.VersionSize = 4;\nHDPrivateKey.DepthSize = 1;\nHDPrivateKey.ParentFingerPrintSize = 4;\nHDPrivateKey.ChildIndexSize = 4;\nHDPrivateKey.ChainCodeSize = 32;\nHDPrivateKey.PrivateKeySize = 32;\nHDPrivateKey.CheckSumSize = 4;\n\nHDPrivateKey.DataLength = 78;\nHDPrivateKey.SerializedByteSize = 82;\n\nHDPrivateKey.VersionStart = 0;\nHDPrivateKey.VersionEnd = HDPrivateKey.VersionStart + HDPrivateKey.VersionSize;\nHDPrivateKey.DepthStart = HDPrivateKey.VersionEnd;\nHDPrivateKey.DepthEnd = HDPrivateKey.DepthStart + HDPrivateKey.DepthSize;\nHDPrivateKey.ParentFingerPrintStart = HDPrivateKey.DepthEnd;\nHDPrivateKey.ParentFingerPrintEnd = HDPrivateKey.ParentFingerPrintStart + HDPrivateKey.ParentFingerPrintSize;\nHDPrivateKey.ChildIndexStart = HDPrivateKey.ParentFingerPrintEnd;\nHDPrivateKey.ChildIndexEnd = HDPrivateKey.ChildIndexStart + HDPrivateKey.ChildIndexSize;\nHDPrivateKey.ChainCodeStart = HDPrivateKey.ChildIndexEnd;\nHDPrivateKey.ChainCodeEnd = HDPrivateKey.ChainCodeStart + HDPrivateKey.ChainCodeSize;\nHDPrivateKey.PrivateKeyStart = HDPrivateKey.ChainCodeEnd + 1;\nHDPrivateKey.PrivateKeyEnd = HDPrivateKey.PrivateKeyStart + HDPrivateKey.PrivateKeySize;\nHDPrivateKey.ChecksumStart = HDPrivateKey.PrivateKeyEnd;\nHDPrivateKey.ChecksumEnd = HDPrivateKey.ChecksumStart + HDPrivateKey.CheckSumSize;\n\nassert(HDPrivateKey.ChecksumEnd === HDPrivateKey.SerializedByteSize);\n\nmodule.exports = HDPrivateKey;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}