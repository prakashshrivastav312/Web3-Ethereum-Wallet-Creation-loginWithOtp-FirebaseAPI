{"ast":null,"code":"'use strict';\n\nvar _ = require('lodash');\n\nvar $ = require('./util/preconditions');\n\nvar errors = require('./errors');\n\nvar Base58Check = require('./encoding/base58check');\n\nvar Bech32 = require('./encoding/bech32');\n\nvar Networks = require('./networks');\n\nvar Hash = require('./crypto/hash');\n\nvar JSUtil = require('./util/js');\n\nvar PublicKey = require('./publickey');\n/**\n * Instantiate an address from an address String or Buffer, a public key or script hash Buffer,\n * or an instance of {@link PublicKey} or {@link Script}.\n *\n * This is an immutable class, and if the first parameter provided to this constructor is an\n * `Address` instance, the same argument will be returned.\n *\n * An address has two key properties: `network` and `type`. The type is one of\n * `Address.PayToPublicKeyHash` (value is the `'pubkeyhash'` string),\n * `Address.PayToScriptHash` (the string `'scripthash'`),\n * `Address.PayToWitnessPublicKeyHash` (the string `'witnesspubkeyhash'`),\n * or `Address.PayToWitnessScriptHash` (the string `'witnessscripthash'`).\n * The network is an instance of {@link Network}.\n * You can quickly check whether an address is of a given kind by using the methods\n * `isPayToPublicKeyHash`, `isPayToScriptHash`, `isPayToWitnessPublicKeyHash`,\n * and `isPayToWitnessScriptHash`.\n *\n * @example\n * ```javascript\n * // validate that an input field is valid\n * var error = Address.getValidationError(input, 'testnet');\n * if (!error) {\n *   var address = Address(input, 'testnet');\n * } else {\n *   // invalid network or checksum (typo?)\n *   var message = error.messsage;\n * }\n *\n * // get an address from a public key\n * var address = Address(publicKey, 'testnet').toString();\n * ```\n *\n * @param {*} data - The encoded data in various formats\n * @param {Network|String|number=} network - The network: 'livenet' or 'testnet'\n * @param {string=} type - The type of address: 'scripthash', 'pubkeyhash', witnessscripthash or 'witnesspubkeyhash'\n * @param {string=} multisigType - The type of multisig: 'scripthash' or 'witnessscripthash'\n * @returns {Address} A new valid and frozen instance of an Address\n * @constructor\n */\n\n\nfunction Address(data, network, type, multisigType) {\n  /* jshint maxcomplexity: 12 */\n\n  /* jshint maxstatements: 20 */\n  if (!(this instanceof Address)) {\n    return new Address(data, network, type);\n  }\n\n  if (_.isArray(data) && _.isNumber(network)) {\n    return Address.createMultisig(data, network, type, false, multisigType);\n  }\n\n  if (data instanceof Address) {\n    // Immutable instance\n    return data;\n  }\n\n  $.checkArgument(data, 'First argument is required, please include address data.', 'guide/address.html');\n\n  if (network && !Networks.get(network)) {\n    throw new TypeError('Second argument must be \"livenet\" or \"testnet\".');\n  }\n\n  if (type && type !== Address.PayToPublicKeyHash && type !== Address.PayToScriptHash && type !== Address.PayToWitnessPublicKeyHash && type !== Address.PayToWitnessScriptHash) {\n    throw new TypeError('Third argument must be \"pubkeyhash\", \"scripthash\", \"witnesspubkeyhash\", or \"witnessscripthash\".');\n  }\n\n  var info = this._classifyArguments(data, network, type); // set defaults if not set\n\n\n  info.network = info.network || Networks.get(network) || Networks.defaultNetwork;\n  info.type = info.type || type || Address.PayToPublicKeyHash;\n  JSUtil.defineImmutable(this, {\n    hashBuffer: info.hashBuffer,\n    network: info.network,\n    type: info.type\n  });\n  return this;\n}\n/**\n * Internal function used to split different kinds of arguments of the constructor\n * @param {*} data - The encoded data in various formats\n * @param {Network|String|number=} network - The network: 'livenet' or 'testnet'\n * @param {string=} type - The type of address: 'script' or 'pubkey'\n * @returns {Object} An \"info\" object with \"type\", \"network\", and \"hashBuffer\"\n */\n\n\nAddress.prototype._classifyArguments = function (data, network, type) {\n  /* jshint maxcomplexity: 10 */\n  // transform and validate input data\n  if ((data instanceof Buffer || data instanceof Uint8Array) && (data.length === 20 || data.length === 32)) {\n    return Address._transformHash(data, network, type);\n  } else if ((data instanceof Buffer || data instanceof Uint8Array) && data.length >= 21) {\n    return Address._transformBuffer(data, network, type);\n  } else if (data instanceof PublicKey) {\n    return Address._transformPublicKey(data, network, type);\n  } else if (data instanceof Script) {\n    return Address._transformScript(data, network);\n  } else if (typeof data === 'string') {\n    return Address._transformString(data, network, type);\n  } else if (_.isObject(data)) {\n    return Address._transformObject(data);\n  } else {\n    throw new TypeError('First argument is an unrecognized data format.');\n  }\n};\n/** @static */\n\n\nAddress.PayToPublicKeyHash = 'pubkeyhash';\n/** @static */\n\nAddress.PayToScriptHash = 'scripthash';\n/** @static */\n\nAddress.PayToWitnessPublicKeyHash = 'witnesspubkeyhash';\n/** @static */\n\nAddress.PayToWitnessScriptHash = 'witnessscripthash';\n/**\n * @param {Buffer} hash - An instance of a hash Buffer\n * @param {string} type - either 'pubkeyhash', 'scripthash', 'witnesspubkeyhash', or 'witnessscripthash'\n * @param {Network=} network - the name of the network associated\n * @returns {Object} An object with keys: hashBuffer\n * @private\n */\n\nAddress._transformHash = function (hash, network, type) {\n  var info = {};\n\n  if (!(hash instanceof Buffer) && !(hash instanceof Uint8Array)) {\n    throw new TypeError('Address supplied is not a buffer.');\n  }\n\n  if (hash.length !== 20 && hash.length !== 32) {\n    throw new TypeError('Address hashbuffers must be either 20 or 32 bytes.');\n  }\n\n  info.hashBuffer = hash;\n  info.network = Networks.get(network) || Networks.defaultNetwork;\n  info.type = type;\n  return info;\n};\n/**\n * Deserializes an address serialized through `Address#toObject()`\n * @param {Object} data\n * @param {string} data.hash - the hash that this address encodes\n * @param {string} data.type - either 'pubkeyhash', 'scripthash', 'witnesspubkeyhash', or 'witnessscripthash'\n * @param {Network=} data.network - the name of the network associated\n * @return {Address}\n */\n\n\nAddress._transformObject = function (data) {\n  $.checkArgument(data.hash || data.hashBuffer, 'Must provide a `hash` or `hashBuffer` property');\n  $.checkArgument(data.type, 'Must provide a `type` property');\n  return {\n    hashBuffer: data.hash ? Buffer.from(data.hash, 'hex') : data.hashBuffer,\n    network: Networks.get(data.network) || Networks.defaultNetwork,\n    type: data.type\n  };\n};\n/**\n * Internal function to discover the network and type based on the first data byte\n *\n * @param {Buffer} buffer - An instance of a hex encoded address Buffer\n * @returns {Object} An object with keys: network and type\n * @private\n */\n\n\nAddress._classifyFromVersion = function (buffer) {\n  var version = {};\n\n  if (buffer.length > 21) {\n    var info = Bech32.decode(buffer.toString('utf8'));\n\n    if (info.version !== 0) {\n      throw new TypeError('Only witness v0 addresses are supported.');\n    }\n\n    if (info.data.length === 20) {\n      version.type = Address.PayToWitnessPublicKeyHash;\n    } else if (info.data.length === 32) {\n      version.type = Address.PayToWitnessScriptHash;\n    } else {\n      throw new TypeError('Witness data must be either 20 or 32 bytes.');\n    }\n\n    version.network = Networks.get(info.prefix, 'bech32prefix');\n  } else {\n    var pubkeyhashNetwork = Networks.get(buffer[0], 'pubkeyhash');\n    var scripthashNetwork = Networks.get(buffer[0], 'scripthash');\n\n    if (pubkeyhashNetwork) {\n      version.network = pubkeyhashNetwork;\n      version.type = Address.PayToPublicKeyHash;\n    } else if (scripthashNetwork) {\n      version.network = scripthashNetwork;\n      version.type = Address.PayToScriptHash;\n    }\n  }\n\n  return version;\n};\n/**\n * Internal function to transform a bitcoin address buffer\n *\n * @param {Buffer} buffer - An instance of a hex encoded address Buffer\n * @param {string=} network - The network: 'livenet' or 'testnet'\n * @param {string=} type - The type: 'pubkeyhash', 'scripthash', 'witnesspubkeyhash', or 'witnessscripthash'\n * @returns {Object} An object with keys: hashBuffer, network and type\n * @private\n */\n\n\nAddress._transformBuffer = function (buffer, network, type) {\n  /* jshint maxcomplexity: 9 */\n  var info = {};\n\n  if (!(buffer instanceof Buffer) && !(buffer instanceof Uint8Array)) {\n    throw new TypeError('Address supplied is not a buffer.');\n  }\n\n  if (buffer.length < 21) {\n    throw new TypeError('Address buffer is incorrect length.');\n  }\n\n  var networkObj = Networks.get(network);\n\n  var bufferVersion = Address._classifyFromVersion(buffer);\n\n  if (network && !networkObj) {\n    throw new TypeError('Unknown network');\n  }\n\n  if (!bufferVersion.network || networkObj && networkObj.xpubkey !== bufferVersion.network.xpubkey) {\n    throw new TypeError('Address has mismatched network type.');\n  }\n\n  if (!bufferVersion.type || type && type !== bufferVersion.type) {\n    throw new TypeError('Address has mismatched type.');\n  }\n\n  if (buffer.length > 21) {\n    info.hashBuffer = Bech32.decode(buffer.toString('utf8')).data;\n  } else {\n    info.hashBuffer = buffer.slice(1);\n  }\n\n  info.network = bufferVersion.network;\n  info.type = bufferVersion.type;\n  return info;\n};\n/**\n * Internal function to transform a {@link PublicKey}\n *\n * @param {PublicKey} pubkey - An instance of PublicKey\n * @param {string} type - Either 'pubkeyhash', 'witnesspubkeyhash', or 'scripthash'\n * @returns {Object} An object with keys: hashBuffer, type\n * @private\n */\n\n\nAddress._transformPublicKey = function (pubkey, network, type) {\n  var info = {};\n\n  if (!(pubkey instanceof PublicKey)) {\n    throw new TypeError('Address must be an instance of PublicKey.');\n  }\n\n  if (type && type !== Address.PayToScriptHash && type !== Address.PayToWitnessPublicKeyHash && type !== Address.PayToPublicKeyHash) {\n    throw new TypeError('Type must be either pubkeyhash, witnesspubkeyhash, or scripthash to transform public key.');\n  }\n\n  if (!pubkey.compressed && (type === Address.PayToScriptHash || type === Address.PayToWitnessPublicKeyHash)) {\n    throw new TypeError('Witness addresses must use compressed public keys.');\n  }\n\n  if (type === Address.PayToScriptHash) {\n    info.hashBuffer = Hash.sha256ripemd160(Script.buildWitnessV0Out(pubkey).toBuffer());\n  } else {\n    info.hashBuffer = Hash.sha256ripemd160(pubkey.toBuffer());\n  }\n\n  info.type = type || Address.PayToPublicKeyHash;\n  return info;\n};\n/**\n * Internal function to transform a {@link Script} into a `info` object.\n *\n * @param {Script} script - An instance of Script\n * @returns {Object} An object with keys: hashBuffer, type\n * @private\n */\n\n\nAddress._transformScript = function (script, network) {\n  $.checkArgument(script instanceof Script, 'script must be a Script instance');\n  var info = script.getAddressInfo(network);\n\n  if (!info) {\n    throw new errors.Script.CantDeriveAddress(script);\n  }\n\n  return info;\n};\n/**\n * Creates a P2SH address from a set of public keys and a threshold.\n *\n * The addresses will be sorted lexicographically, as that is the trend in bitcoin.\n * To create an address from unsorted public keys, use the {@link Script#buildMultisigOut}\n * interface.\n *\n * @param {Array} publicKeys - a set of public keys to create an address\n * @param {number} threshold - the number of signatures needed to release the funds\n * @param {String|Network} network - either a Network instance, 'livenet', or 'testnet'\n * @param {boolean=} nestedWitness - if the address uses a nested p2sh witness\n * @param {string} type - Either 'scripthash' or 'witnessscripthash'. If nestedWitness is set, then this is ignored\n * @return {Address}\n */\n\n\nAddress.createMultisig = function (publicKeys, threshold, network, nestedWitness, type) {\n  network = network || publicKeys[0].network || Networks.defaultNetwork;\n\n  if (type && type !== Address.PayToScriptHash && type !== Address.PayToWitnessScriptHash) {\n    throw new TypeError('Type must be either scripthash or witnessscripthash to create multisig.');\n  }\n\n  if (nestedWitness || type === Address.PayToWitnessScriptHash) {\n    publicKeys = _.map(publicKeys, PublicKey);\n\n    for (var i = 0; i < publicKeys.length; i++) {\n      if (!publicKeys[i].compressed) {\n        throw new TypeError('Witness addresses must use compressed public keys.');\n      }\n    }\n  }\n\n  var redeemScript = Script.buildMultisigOut(publicKeys, threshold);\n\n  if (nestedWitness) {\n    return Address.payingTo(Script.buildWitnessMultisigOutFromScript(redeemScript), network);\n  }\n\n  return Address.payingTo(redeemScript, network, type);\n};\n/**\n * Internal function to transform a bitcoin address string\n *\n * @param {string} data\n * @param {String|Network=} network - either a Network instance, 'livenet', or 'testnet'\n * @param {string=} type - The type: 'pubkeyhash', 'scripthash', 'witnesspubkeyhash', or 'witnessscripthash'\n * @returns {Object} An object with keys: hashBuffer, network and type\n * @private\n */\n\n\nAddress._transformString = function (data, network, type) {\n  if (typeof data !== 'string') {\n    throw new TypeError('data parameter supplied is not a string.');\n  }\n\n  if (data.length > 100) {\n    throw new TypeError('address string is too long');\n  }\n\n  if (network && !Networks.get(network)) {\n    throw new TypeError('Unknown network');\n  }\n\n  data = data.trim();\n\n  try {\n    var info = Address._transformBuffer(Buffer.from(data, 'utf8'), network, type);\n\n    return info;\n  } catch (e) {\n    if (type === Address.PayToWitnessPublicKeyHash || type === Address.PayToWitnessScriptHash) {\n      throw e;\n    }\n  }\n\n  var addressBuffer = Base58Check.decode(data);\n\n  var info = Address._transformBuffer(addressBuffer, network, type);\n\n  return info;\n};\n/**\n * Instantiate an address from a PublicKey instance\n *\n * @param {PublicKey} data\n * @param {String|Network} network - either a Network instance, 'livenet', or 'testnet'\n * @param {string} type - Either 'pubkeyhash', 'witnesspubkeyhash', or 'scripthash'\n * @returns {Address} A new valid and frozen instance of an Address\n */\n\n\nAddress.fromPublicKey = function (data, network, type) {\n  var info = Address._transformPublicKey(data, network, type);\n\n  network = network || Networks.defaultNetwork;\n  return new Address(info.hashBuffer, network, info.type);\n};\n/**\n * Instantiate an address from a ripemd160 public key hash\n *\n * @param {Buffer} hash - An instance of buffer of the hash\n * @param {String|Network} network - either a Network instance, 'livenet', or 'testnet'\n * @returns {Address} A new valid and frozen instance of an Address\n */\n\n\nAddress.fromPublicKeyHash = function (hash, network) {\n  var info = Address._transformHash(hash);\n\n  return new Address(info.hashBuffer, network, Address.PayToPublicKeyHash);\n};\n/**\n * Instantiate an address from a ripemd160 script hash\n *\n * @param {Buffer} hash - An instance of buffer of the hash\n * @param {String|Network} network - either a Network instance, 'livenet', or 'testnet'\n * @param {string} type - Either 'scripthash' or 'witnessscripthash'\n * @returns {Address} A new valid and frozen instance of an Address\n */\n\n\nAddress.fromScriptHash = function (hash, network, type) {\n  $.checkArgument(hash, 'hash parameter is required');\n\n  var info = Address._transformHash(hash);\n\n  if (type === Address.PayToWitnessScriptHash && hash.length !== 32) {\n    throw new TypeError('Address hashbuffer must be exactly 32 bytes for v0 witness script hash.');\n  }\n\n  var type = type || Address.PayToScriptHash;\n  return new Address(info.hashBuffer, network, type);\n};\n/**\n * Builds a p2sh address paying to script. This will hash the script and\n * use that to create the address.\n * If you want to extract an address associated with a script instead,\n * see {{Address#fromScript}}\n *\n * @param {Script} script - An instance of Script\n * @param {String|Network} network - either a Network instance, 'livenet', or 'testnet'\n * @param {string} type - Either 'scripthash' or 'witnessscripthash'\n * @returns {Address} A new valid and frozen instance of an Address\n */\n\n\nAddress.payingTo = function (script, network, type) {\n  $.checkArgument(script, 'script is required');\n  $.checkArgument(script instanceof Script, 'script must be instance of Script');\n  var hash;\n\n  if (type === Address.PayToWitnessScriptHash) {\n    hash = Hash.sha256(script.toBuffer());\n  } else {\n    hash = Hash.sha256ripemd160(script.toBuffer());\n  }\n\n  var type = type || Address.PayToScriptHash;\n  return Address.fromScriptHash(hash, network, type);\n};\n/**\n * Extract address from a Script. The script must be of one\n * of the following types: p2pkh input, p2pkh output, p2sh input\n * or p2sh output.\n * This will analyze the script and extract address information from it.\n * If you want to transform any script to a p2sh Address paying\n * to that script's hash instead, use {{Address#payingTo}}\n *\n * @param {Script} script - An instance of Script\n * @param {String|Network} network - either a Network instance, 'livenet', or 'testnet'\n * @returns {Address} A new valid and frozen instance of an Address\n */\n\n\nAddress.fromScript = function (script, network) {\n  $.checkArgument(script instanceof Script, 'script must be a Script instance');\n\n  var info = Address._transformScript(script, network);\n\n  return new Address(info.hashBuffer, network, info.type);\n};\n/**\n * Instantiate an address from a buffer of the address\n *\n * @param {Buffer} buffer - An instance of buffer of the address\n * @param {String|Network=} network - either a Network instance, 'livenet', or 'testnet'\n * @param {string=} type - The type of address: 'script' or 'pubkey'\n * @returns {Address} A new valid and frozen instance of an Address\n */\n\n\nAddress.fromBuffer = function (buffer, network, type) {\n  var info = Address._transformBuffer(buffer, network, type);\n\n  return new Address(info.hashBuffer, info.network, info.type);\n};\n/**\n * Instantiate an address from an address string\n *\n * @param {string} str - An string of the bitcoin address\n * @param {String|Network=} network - either a Network instance, 'livenet', or 'testnet'\n * @param {string=} type - The type of address: 'script' or 'pubkey'\n * @returns {Address} A new valid and frozen instance of an Address\n */\n\n\nAddress.fromString = function (str, network, type) {\n  var info = Address._transformString(str, network, type);\n\n  return new Address(info.hashBuffer, info.network, info.type);\n};\n/**\n * Instantiate an address from an Object\n *\n * @param {string} json - An JSON string or Object with keys: hash, network and type\n * @returns {Address} A new valid instance of an Address\n */\n\n\nAddress.fromObject = function fromObject(obj) {\n  $.checkState(JSUtil.isHexa(obj.hash), 'Unexpected hash property, \"' + obj.hash + '\", expected to be hex.');\n  var hashBuffer = Buffer.from(obj.hash, 'hex');\n  return new Address(hashBuffer, obj.network, obj.type);\n};\n/**\n * Will return a validation error if exists\n *\n * @example\n * ```javascript\n * // a network mismatch error\n * var error = Address.getValidationError('15vkcKf7gB23wLAnZLmbVuMiiVDc1Nm4a2', 'testnet');\n * ```\n *\n * @param {string} data - The encoded data\n * @param {String|Network} network - either a Network instance, 'livenet', or 'testnet'\n * @param {string} type - The type of address: 'script' or 'pubkey'\n * @returns {null|Error} The corresponding error message\n */\n\n\nAddress.getValidationError = function (data, network, type) {\n  var error;\n\n  try {\n    /* jshint nonew: false */\n    new Address(data, network, type);\n  } catch (e) {\n    error = e;\n  }\n\n  return error;\n};\n/**\n * Will return a boolean if an address is valid\n *\n * @example\n * ```javascript\n * assert(Address.isValid('15vkcKf7gB23wLAnZLmbVuMiiVDc1Nm4a2', 'livenet'));\n * ```\n *\n * @param {string} data - The encoded data\n * @param {String|Network} network - either a Network instance, 'livenet', or 'testnet'\n * @param {string} type - The type of address: 'script' or 'pubkey'\n * @returns {boolean} The corresponding error message\n */\n\n\nAddress.isValid = function (data, network, type) {\n  return !Address.getValidationError(data, network, type);\n};\n/**\n * Returns true if an address is of pay to public key hash type\n * @return boolean\n */\n\n\nAddress.prototype.isPayToPublicKeyHash = function () {\n  return this.type === Address.PayToPublicKeyHash;\n};\n/**\n * Returns true if an address is of pay to script hash type\n * @return boolean\n */\n\n\nAddress.prototype.isPayToScriptHash = function () {\n  return this.type === Address.PayToScriptHash;\n};\n/**\n * Returns true if an address is of pay to witness public key hash type\n * @return boolean\n */\n\n\nAddress.prototype.isPayToWitnessPublicKeyHash = function () {\n  return this.type === Address.PayToWitnessPublicKeyHash;\n};\n/**\n * Returns true if an address is of pay to witness script hash type\n * @return boolean\n */\n\n\nAddress.prototype.isPayToWitnessScriptHash = function () {\n  return this.type === Address.PayToWitnessScriptHash;\n};\n/**\n * Will return a buffer representation of the address\n *\n * @returns {Buffer} Bitcoin address buffer\n */\n\n\nAddress.prototype.toBuffer = function () {\n  if (this.isPayToWitnessPublicKeyHash() || this.isPayToWitnessScriptHash()) {\n    return Buffer.from(this.toString(), 'utf8');\n  }\n\n  var version = Buffer.from([this.network[this.type]]);\n  return Buffer.concat([version, this.hashBuffer]);\n};\n/**\n * @returns {Object} A plain object with the address information\n */\n\n\nAddress.prototype.toObject = Address.prototype.toJSON = function toObject() {\n  return {\n    hash: this.hashBuffer.toString('hex'),\n    type: this.type,\n    network: this.network.toString()\n  };\n};\n/**\n * Will return a the string representation of the address\n *\n * @returns {string} Bitcoin address\n */\n\n\nAddress.prototype.toString = function () {\n  if (this.isPayToWitnessPublicKeyHash() || this.isPayToWitnessScriptHash()) {\n    var prefix = this.network.bech32prefix;\n    var version = 0; // Only supporting segwit v0 for now\n\n    return Bech32.encode(prefix, version, this.hashBuffer);\n  }\n\n  return Base58Check.encode(this.toBuffer());\n};\n/**\n * Will return a string formatted for the console\n *\n * @returns {string} Bitcoin address\n */\n\n\nAddress.prototype.inspect = function () {\n  return '<Address: ' + this.toString() + ', type: ' + this.type + ', network: ' + this.network + '>';\n};\n\nmodule.exports = Address;\n\nvar Script = require('./script');","map":{"version":3,"names":["_","require","$","errors","Base58Check","Bech32","Networks","Hash","JSUtil","PublicKey","Address","data","network","type","multisigType","isArray","isNumber","createMultisig","checkArgument","get","TypeError","PayToPublicKeyHash","PayToScriptHash","PayToWitnessPublicKeyHash","PayToWitnessScriptHash","info","_classifyArguments","defaultNetwork","defineImmutable","hashBuffer","prototype","Buffer","Uint8Array","length","_transformHash","_transformBuffer","_transformPublicKey","Script","_transformScript","_transformString","isObject","_transformObject","hash","from","_classifyFromVersion","buffer","version","decode","toString","prefix","pubkeyhashNetwork","scripthashNetwork","networkObj","bufferVersion","xpubkey","slice","pubkey","compressed","sha256ripemd160","buildWitnessV0Out","toBuffer","script","getAddressInfo","CantDeriveAddress","publicKeys","threshold","nestedWitness","map","i","redeemScript","buildMultisigOut","payingTo","buildWitnessMultisigOutFromScript","trim","e","addressBuffer","fromPublicKey","fromPublicKeyHash","fromScriptHash","sha256","fromScript","fromBuffer","fromString","str","fromObject","obj","checkState","isHexa","getValidationError","error","isValid","isPayToPublicKeyHash","isPayToScriptHash","isPayToWitnessPublicKeyHash","isPayToWitnessScriptHash","concat","toObject","toJSON","bech32prefix","encode","inspect","module","exports"],"sources":["C:/Users/acer/node_modules/bitcore-lib/lib/address.js"],"sourcesContent":["'use strict';\n\nvar _ = require('lodash');\nvar $ = require('./util/preconditions');\nvar errors = require('./errors');\nvar Base58Check = require('./encoding/base58check');\nvar Bech32 = require('./encoding/bech32');\nvar Networks = require('./networks');\nvar Hash = require('./crypto/hash');\nvar JSUtil = require('./util/js');\nvar PublicKey = require('./publickey');\n\n/**\n * Instantiate an address from an address String or Buffer, a public key or script hash Buffer,\n * or an instance of {@link PublicKey} or {@link Script}.\n *\n * This is an immutable class, and if the first parameter provided to this constructor is an\n * `Address` instance, the same argument will be returned.\n *\n * An address has two key properties: `network` and `type`. The type is one of\n * `Address.PayToPublicKeyHash` (value is the `'pubkeyhash'` string),\n * `Address.PayToScriptHash` (the string `'scripthash'`),\n * `Address.PayToWitnessPublicKeyHash` (the string `'witnesspubkeyhash'`),\n * or `Address.PayToWitnessScriptHash` (the string `'witnessscripthash'`).\n * The network is an instance of {@link Network}.\n * You can quickly check whether an address is of a given kind by using the methods\n * `isPayToPublicKeyHash`, `isPayToScriptHash`, `isPayToWitnessPublicKeyHash`,\n * and `isPayToWitnessScriptHash`.\n *\n * @example\n * ```javascript\n * // validate that an input field is valid\n * var error = Address.getValidationError(input, 'testnet');\n * if (!error) {\n *   var address = Address(input, 'testnet');\n * } else {\n *   // invalid network or checksum (typo?)\n *   var message = error.messsage;\n * }\n *\n * // get an address from a public key\n * var address = Address(publicKey, 'testnet').toString();\n * ```\n *\n * @param {*} data - The encoded data in various formats\n * @param {Network|String|number=} network - The network: 'livenet' or 'testnet'\n * @param {string=} type - The type of address: 'scripthash', 'pubkeyhash', witnessscripthash or 'witnesspubkeyhash'\n * @param {string=} multisigType - The type of multisig: 'scripthash' or 'witnessscripthash'\n * @returns {Address} A new valid and frozen instance of an Address\n * @constructor\n */\nfunction Address(data, network, type, multisigType) {\n  /* jshint maxcomplexity: 12 */\n  /* jshint maxstatements: 20 */\n\n  if (!(this instanceof Address)) {\n    return new Address(data, network, type);\n  }\n\n  if (_.isArray(data) && _.isNumber(network)) {\n    return Address.createMultisig(data, network, type, false, multisigType);\n  }\n\n  if (data instanceof Address) {\n    // Immutable instance\n    return data;\n  }\n\n  $.checkArgument(data, 'First argument is required, please include address data.', 'guide/address.html');\n\n  if (network && !Networks.get(network)) {\n    throw new TypeError('Second argument must be \"livenet\" or \"testnet\".');\n  }\n\n  if (type && (\n    type !== Address.PayToPublicKeyHash\n    && type !== Address.PayToScriptHash\n    && type !== Address.PayToWitnessPublicKeyHash\n    && type !== Address.PayToWitnessScriptHash)) {\n    throw new TypeError('Third argument must be \"pubkeyhash\", \"scripthash\", \"witnesspubkeyhash\", or \"witnessscripthash\".');\n  }\n\n  var info = this._classifyArguments(data, network, type);\n\n  // set defaults if not set\n  info.network = info.network || Networks.get(network) || Networks.defaultNetwork;\n  info.type = info.type || type || Address.PayToPublicKeyHash;\n\n  JSUtil.defineImmutable(this, {\n    hashBuffer: info.hashBuffer,\n    network: info.network,\n    type: info.type\n  });\n\n  return this;\n}\n\n/**\n * Internal function used to split different kinds of arguments of the constructor\n * @param {*} data - The encoded data in various formats\n * @param {Network|String|number=} network - The network: 'livenet' or 'testnet'\n * @param {string=} type - The type of address: 'script' or 'pubkey'\n * @returns {Object} An \"info\" object with \"type\", \"network\", and \"hashBuffer\"\n */\nAddress.prototype._classifyArguments = function(data, network, type) {\n  /* jshint maxcomplexity: 10 */\n  // transform and validate input data\n  if ((data instanceof Buffer || data instanceof Uint8Array) && (data.length === 20 || data.length === 32)) {\n    return Address._transformHash(data, network, type);\n  } else if ((data instanceof Buffer || data instanceof Uint8Array) && data.length >= 21) {\n    return Address._transformBuffer(data, network, type);\n  } else if (data instanceof PublicKey) {\n    return Address._transformPublicKey(data, network, type);\n  } else if (data instanceof Script) {\n    return Address._transformScript(data, network);\n  } else if (typeof(data) === 'string') {\n    return Address._transformString(data, network, type);\n  } else if (_.isObject(data)) {\n    return Address._transformObject(data);\n  } else {\n    throw new TypeError('First argument is an unrecognized data format.');\n  }\n};\n\n/** @static */\nAddress.PayToPublicKeyHash = 'pubkeyhash';\n/** @static */\nAddress.PayToScriptHash = 'scripthash';\n/** @static */\nAddress.PayToWitnessPublicKeyHash = 'witnesspubkeyhash';\n/** @static */\nAddress.PayToWitnessScriptHash = 'witnessscripthash';\n\n/**\n * @param {Buffer} hash - An instance of a hash Buffer\n * @param {string} type - either 'pubkeyhash', 'scripthash', 'witnesspubkeyhash', or 'witnessscripthash'\n * @param {Network=} network - the name of the network associated\n * @returns {Object} An object with keys: hashBuffer\n * @private\n */\nAddress._transformHash = function(hash, network, type) {\n  var info = {};\n  if (!(hash instanceof Buffer) && !(hash instanceof Uint8Array)) {\n    throw new TypeError('Address supplied is not a buffer.');\n  }\n  if (hash.length !== 20 && hash.length !== 32) {\n    throw new TypeError('Address hashbuffers must be either 20 or 32 bytes.');\n  }\n  info.hashBuffer = hash;\n  info.network = Networks.get(network) || Networks.defaultNetwork;\n  info.type = type;\n  return info;\n};\n\n/**\n * Deserializes an address serialized through `Address#toObject()`\n * @param {Object} data\n * @param {string} data.hash - the hash that this address encodes\n * @param {string} data.type - either 'pubkeyhash', 'scripthash', 'witnesspubkeyhash', or 'witnessscripthash'\n * @param {Network=} data.network - the name of the network associated\n * @return {Address}\n */\nAddress._transformObject = function(data) {\n  $.checkArgument(data.hash || data.hashBuffer, 'Must provide a `hash` or `hashBuffer` property');\n  $.checkArgument(data.type, 'Must provide a `type` property');\n  return {\n    hashBuffer: data.hash ? Buffer.from(data.hash, 'hex') : data.hashBuffer,\n    network: Networks.get(data.network) || Networks.defaultNetwork,\n    type: data.type\n  };\n};\n\n/**\n * Internal function to discover the network and type based on the first data byte\n *\n * @param {Buffer} buffer - An instance of a hex encoded address Buffer\n * @returns {Object} An object with keys: network and type\n * @private\n */\nAddress._classifyFromVersion = function(buffer) {\n  var version = {};\n\n  if (buffer.length > 21) {\n    var info = Bech32.decode(buffer.toString('utf8'));\n    if (info.version !== 0) {\n      throw new TypeError('Only witness v0 addresses are supported.');\n    }\n    if (info.data.length === 20) {\n      version.type = Address.PayToWitnessPublicKeyHash;\n    } else if (info.data.length === 32) {\n      version.type = Address.PayToWitnessScriptHash;\n    } else {\n      throw new TypeError('Witness data must be either 20 or 32 bytes.')\n    }\n    version.network = Networks.get(info.prefix, 'bech32prefix');\n  } else {\n\n    var pubkeyhashNetwork = Networks.get(buffer[0], 'pubkeyhash');\n    var scripthashNetwork = Networks.get(buffer[0], 'scripthash');\n\n    if (pubkeyhashNetwork) {\n      version.network = pubkeyhashNetwork;\n      version.type = Address.PayToPublicKeyHash;\n    } else if (scripthashNetwork) {\n      version.network = scripthashNetwork;\n      version.type = Address.PayToScriptHash;\n    }\n  }\n\n  return version;\n};\n\n/**\n * Internal function to transform a bitcoin address buffer\n *\n * @param {Buffer} buffer - An instance of a hex encoded address Buffer\n * @param {string=} network - The network: 'livenet' or 'testnet'\n * @param {string=} type - The type: 'pubkeyhash', 'scripthash', 'witnesspubkeyhash', or 'witnessscripthash'\n * @returns {Object} An object with keys: hashBuffer, network and type\n * @private\n */\nAddress._transformBuffer = function(buffer, network, type) {\n  /* jshint maxcomplexity: 9 */\n  var info = {};\n  if (!(buffer instanceof Buffer) && !(buffer instanceof Uint8Array)) {\n    throw new TypeError('Address supplied is not a buffer.');\n  }\n\n  if (buffer.length < 21) {\n    throw new TypeError('Address buffer is incorrect length.');\n  }\n\n  var networkObj = Networks.get(network);\n  var bufferVersion = Address._classifyFromVersion(buffer);\n\n  if (network && !networkObj) {\n    throw new TypeError('Unknown network');\n  }\n\n  if (!bufferVersion.network || (networkObj && networkObj.xpubkey !== bufferVersion.network.xpubkey)) {\n    throw new TypeError('Address has mismatched network type.');\n  }\n\n  if (!bufferVersion.type || (type && type !== bufferVersion.type)) {\n    throw new TypeError('Address has mismatched type.');\n  }\n\n  if (buffer.length > 21) {\n    info.hashBuffer = Bech32.decode(buffer.toString('utf8')).data;\n  } else {\n    info.hashBuffer = buffer.slice(1);\n  }\n  info.network = bufferVersion.network;\n  info.type = bufferVersion.type;\n  return info;\n};\n\n/**\n * Internal function to transform a {@link PublicKey}\n *\n * @param {PublicKey} pubkey - An instance of PublicKey\n * @param {string} type - Either 'pubkeyhash', 'witnesspubkeyhash', or 'scripthash'\n * @returns {Object} An object with keys: hashBuffer, type\n * @private\n */\nAddress._transformPublicKey = function(pubkey, network, type) {\n  var info = {};\n  if (!(pubkey instanceof PublicKey)) {\n    throw new TypeError('Address must be an instance of PublicKey.');\n  }\n  if (type && type !== Address.PayToScriptHash && type !== Address.PayToWitnessPublicKeyHash && type !== Address.PayToPublicKeyHash) {\n    throw new TypeError('Type must be either pubkeyhash, witnesspubkeyhash, or scripthash to transform public key.');\n  }\n  if (!pubkey.compressed && (type === Address.PayToScriptHash || type === Address.PayToWitnessPublicKeyHash)) {\n    throw new TypeError('Witness addresses must use compressed public keys.');\n  }\n  if (type === Address.PayToScriptHash) {\n    info.hashBuffer = Hash.sha256ripemd160(Script.buildWitnessV0Out(pubkey).toBuffer());\n  } else {\n    info.hashBuffer = Hash.sha256ripemd160(pubkey.toBuffer());\n  }\n  info.type = type || Address.PayToPublicKeyHash;\n  return info;\n};\n\n/**\n * Internal function to transform a {@link Script} into a `info` object.\n *\n * @param {Script} script - An instance of Script\n * @returns {Object} An object with keys: hashBuffer, type\n * @private\n */\nAddress._transformScript = function(script, network) {\n  $.checkArgument(script instanceof Script, 'script must be a Script instance');\n  var info = script.getAddressInfo(network);\n  if (!info) {\n    throw new errors.Script.CantDeriveAddress(script);\n  }\n  return info;\n};\n\n/**\n * Creates a P2SH address from a set of public keys and a threshold.\n *\n * The addresses will be sorted lexicographically, as that is the trend in bitcoin.\n * To create an address from unsorted public keys, use the {@link Script#buildMultisigOut}\n * interface.\n *\n * @param {Array} publicKeys - a set of public keys to create an address\n * @param {number} threshold - the number of signatures needed to release the funds\n * @param {String|Network} network - either a Network instance, 'livenet', or 'testnet'\n * @param {boolean=} nestedWitness - if the address uses a nested p2sh witness\n * @param {string} type - Either 'scripthash' or 'witnessscripthash'. If nestedWitness is set, then this is ignored\n * @return {Address}\n */\nAddress.createMultisig = function(publicKeys, threshold, network, nestedWitness, type) {\n  network = network || publicKeys[0].network || Networks.defaultNetwork;\n  if (type && type !== Address.PayToScriptHash && type !== Address.PayToWitnessScriptHash) {\n    throw new TypeError('Type must be either scripthash or witnessscripthash to create multisig.');\n  }\n  if (nestedWitness || type === Address.PayToWitnessScriptHash) {\n    publicKeys = _.map(publicKeys, PublicKey);\n    for (var i = 0; i < publicKeys.length; i++) {\n      if (!publicKeys[i].compressed) {\n        throw new TypeError('Witness addresses must use compressed public keys.');\n      }\n    }\n  }\n  var redeemScript = Script.buildMultisigOut(publicKeys, threshold);\n  if (nestedWitness) {\n    return Address.payingTo(Script.buildWitnessMultisigOutFromScript(redeemScript), network);\n  }\n  return Address.payingTo(redeemScript, network, type);\n};\n\n/**\n * Internal function to transform a bitcoin address string\n *\n * @param {string} data\n * @param {String|Network=} network - either a Network instance, 'livenet', or 'testnet'\n * @param {string=} type - The type: 'pubkeyhash', 'scripthash', 'witnesspubkeyhash', or 'witnessscripthash'\n * @returns {Object} An object with keys: hashBuffer, network and type\n * @private\n */\nAddress._transformString = function(data, network, type) {\n  if (typeof(data) !== 'string') {\n    throw new TypeError('data parameter supplied is not a string.');\n  }\n\n  if(data.length > 100) {\n    throw new TypeError('address string is too long');\n  }\n\n  if (network && !Networks.get(network)) {\n    throw new TypeError('Unknown network');\n  }\n\n  data = data.trim();\n\n  try {\n    var info = Address._transformBuffer(Buffer.from(data, 'utf8'), network, type);\n    return info;\n  } catch (e) {\n    if (type === Address.PayToWitnessPublicKeyHash || type === Address.PayToWitnessScriptHash) {\n      throw e;\n    }\n  }\n\n  var addressBuffer = Base58Check.decode(data);\n  var info = Address._transformBuffer(addressBuffer, network, type);\n  return info;\n};\n\n/**\n * Instantiate an address from a PublicKey instance\n *\n * @param {PublicKey} data\n * @param {String|Network} network - either a Network instance, 'livenet', or 'testnet'\n * @param {string} type - Either 'pubkeyhash', 'witnesspubkeyhash', or 'scripthash'\n * @returns {Address} A new valid and frozen instance of an Address\n */\nAddress.fromPublicKey = function(data, network, type) {\n  var info = Address._transformPublicKey(data, network, type);\n  network = network || Networks.defaultNetwork;\n  return new Address(info.hashBuffer, network, info.type);\n};\n\n/**\n * Instantiate an address from a ripemd160 public key hash\n *\n * @param {Buffer} hash - An instance of buffer of the hash\n * @param {String|Network} network - either a Network instance, 'livenet', or 'testnet'\n * @returns {Address} A new valid and frozen instance of an Address\n */\nAddress.fromPublicKeyHash = function(hash, network) {\n  var info = Address._transformHash(hash);\n  return new Address(info.hashBuffer, network, Address.PayToPublicKeyHash);\n};\n\n/**\n * Instantiate an address from a ripemd160 script hash\n *\n * @param {Buffer} hash - An instance of buffer of the hash\n * @param {String|Network} network - either a Network instance, 'livenet', or 'testnet'\n * @param {string} type - Either 'scripthash' or 'witnessscripthash'\n * @returns {Address} A new valid and frozen instance of an Address\n */\nAddress.fromScriptHash = function(hash, network, type) {\n  $.checkArgument(hash, 'hash parameter is required');\n  var info = Address._transformHash(hash);\n  if (type === Address.PayToWitnessScriptHash && hash.length !== 32) {\n      throw new TypeError('Address hashbuffer must be exactly 32 bytes for v0 witness script hash.');\n  }\n  var type = type || Address.PayToScriptHash;\n  return new Address(info.hashBuffer, network, type);\n};\n\n/**\n * Builds a p2sh address paying to script. This will hash the script and\n * use that to create the address.\n * If you want to extract an address associated with a script instead,\n * see {{Address#fromScript}}\n *\n * @param {Script} script - An instance of Script\n * @param {String|Network} network - either a Network instance, 'livenet', or 'testnet'\n * @param {string} type - Either 'scripthash' or 'witnessscripthash'\n * @returns {Address} A new valid and frozen instance of an Address\n */\nAddress.payingTo = function(script, network, type) {\n  $.checkArgument(script, 'script is required');\n  $.checkArgument(script instanceof Script, 'script must be instance of Script');\n  var hash;\n  if (type === Address.PayToWitnessScriptHash) {\n    hash = Hash.sha256(script.toBuffer());\n  } else {\n    hash = Hash.sha256ripemd160(script.toBuffer());\n  }\n  var type = type || Address.PayToScriptHash;\n  return Address.fromScriptHash(hash, network, type);\n};\n\n/**\n * Extract address from a Script. The script must be of one\n * of the following types: p2pkh input, p2pkh output, p2sh input\n * or p2sh output.\n * This will analyze the script and extract address information from it.\n * If you want to transform any script to a p2sh Address paying\n * to that script's hash instead, use {{Address#payingTo}}\n *\n * @param {Script} script - An instance of Script\n * @param {String|Network} network - either a Network instance, 'livenet', or 'testnet'\n * @returns {Address} A new valid and frozen instance of an Address\n */\nAddress.fromScript = function(script, network) {\n  $.checkArgument(script instanceof Script, 'script must be a Script instance');\n  var info = Address._transformScript(script, network);\n  return new Address(info.hashBuffer, network, info.type);\n};\n\n/**\n * Instantiate an address from a buffer of the address\n *\n * @param {Buffer} buffer - An instance of buffer of the address\n * @param {String|Network=} network - either a Network instance, 'livenet', or 'testnet'\n * @param {string=} type - The type of address: 'script' or 'pubkey'\n * @returns {Address} A new valid and frozen instance of an Address\n */\nAddress.fromBuffer = function(buffer, network, type) {\n  var info = Address._transformBuffer(buffer, network, type);\n  return new Address(info.hashBuffer, info.network, info.type);\n};\n\n/**\n * Instantiate an address from an address string\n *\n * @param {string} str - An string of the bitcoin address\n * @param {String|Network=} network - either a Network instance, 'livenet', or 'testnet'\n * @param {string=} type - The type of address: 'script' or 'pubkey'\n * @returns {Address} A new valid and frozen instance of an Address\n */\nAddress.fromString = function(str, network, type) {\n  var info = Address._transformString(str, network, type);\n  return new Address(info.hashBuffer, info.network, info.type);\n};\n\n/**\n * Instantiate an address from an Object\n *\n * @param {string} json - An JSON string or Object with keys: hash, network and type\n * @returns {Address} A new valid instance of an Address\n */\nAddress.fromObject = function fromObject(obj) {\n  $.checkState(\n    JSUtil.isHexa(obj.hash),\n    'Unexpected hash property, \"' + obj.hash + '\", expected to be hex.'\n  );\n  var hashBuffer = Buffer.from(obj.hash, 'hex');\n  return new Address(hashBuffer, obj.network, obj.type);\n};\n\n/**\n * Will return a validation error if exists\n *\n * @example\n * ```javascript\n * // a network mismatch error\n * var error = Address.getValidationError('15vkcKf7gB23wLAnZLmbVuMiiVDc1Nm4a2', 'testnet');\n * ```\n *\n * @param {string} data - The encoded data\n * @param {String|Network} network - either a Network instance, 'livenet', or 'testnet'\n * @param {string} type - The type of address: 'script' or 'pubkey'\n * @returns {null|Error} The corresponding error message\n */\nAddress.getValidationError = function(data, network, type) {\n  var error;\n  try {\n    /* jshint nonew: false */\n    new Address(data, network, type);\n  } catch (e) {\n    error = e;\n  }\n  return error;\n};\n\n/**\n * Will return a boolean if an address is valid\n *\n * @example\n * ```javascript\n * assert(Address.isValid('15vkcKf7gB23wLAnZLmbVuMiiVDc1Nm4a2', 'livenet'));\n * ```\n *\n * @param {string} data - The encoded data\n * @param {String|Network} network - either a Network instance, 'livenet', or 'testnet'\n * @param {string} type - The type of address: 'script' or 'pubkey'\n * @returns {boolean} The corresponding error message\n */\nAddress.isValid = function(data, network, type) {\n  return !Address.getValidationError(data, network, type);\n};\n\n/**\n * Returns true if an address is of pay to public key hash type\n * @return boolean\n */\nAddress.prototype.isPayToPublicKeyHash = function() {\n  return this.type === Address.PayToPublicKeyHash;\n};\n\n/**\n * Returns true if an address is of pay to script hash type\n * @return boolean\n */\nAddress.prototype.isPayToScriptHash = function() {\n  return this.type === Address.PayToScriptHash;\n};\n\n/**\n * Returns true if an address is of pay to witness public key hash type\n * @return boolean\n */\nAddress.prototype.isPayToWitnessPublicKeyHash = function() {\n  return this.type === Address.PayToWitnessPublicKeyHash;\n};\n\n/**\n * Returns true if an address is of pay to witness script hash type\n * @return boolean\n */\nAddress.prototype.isPayToWitnessScriptHash = function() {\n  return this.type === Address.PayToWitnessScriptHash;\n};\n\n/**\n * Will return a buffer representation of the address\n *\n * @returns {Buffer} Bitcoin address buffer\n */\nAddress.prototype.toBuffer = function() {\n  if (this.isPayToWitnessPublicKeyHash() || this.isPayToWitnessScriptHash()) {\n    return Buffer.from(this.toString(), 'utf8')\n  }\n  var version = Buffer.from([this.network[this.type]]);\n  return Buffer.concat([version, this.hashBuffer]);\n};\n\n/**\n * @returns {Object} A plain object with the address information\n */\nAddress.prototype.toObject = Address.prototype.toJSON = function toObject() {\n  return {\n    hash: this.hashBuffer.toString('hex'),\n    type: this.type,\n    network: this.network.toString()\n  };\n};\n\n/**\n * Will return a the string representation of the address\n *\n * @returns {string} Bitcoin address\n */\nAddress.prototype.toString = function() {\n  if (this.isPayToWitnessPublicKeyHash() || this.isPayToWitnessScriptHash()) {\n    var prefix = this.network.bech32prefix;\n    var version = 0; // Only supporting segwit v0 for now\n    return Bech32.encode(prefix, version, this.hashBuffer);\n  }\n  return Base58Check.encode(this.toBuffer());\n};\n\n/**\n * Will return a string formatted for the console\n *\n * @returns {string} Bitcoin address\n */\nAddress.prototype.inspect = function() {\n  return '<Address: ' + this.toString() + ', type: ' + this.type + ', network: ' + this.network + '>';\n};\n\nmodule.exports = Address;\n\nvar Script = require('./script');\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}