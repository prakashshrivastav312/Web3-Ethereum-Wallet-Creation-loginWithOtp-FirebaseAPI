{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.BinaryParser = void 0;\n\nvar assert = require(\"assert\");\n\nvar enums_1 = require(\"../enums\");\n\nvar buffer_1 = require(\"buffer/\");\n/**\n * BinaryParser is used to compute fields and values from a HexString\n */\n\n\nvar BinaryParser =\n/** @class */\nfunction () {\n  /**\n   * Initialize bytes to a hex string\n   *\n   * @param hexBytes a hex string\n   */\n  function BinaryParser(hexBytes) {\n    this.bytes = buffer_1.Buffer.from(hexBytes, 'hex');\n  }\n  /**\n   * Peek the first byte of the BinaryParser\n   *\n   * @returns The first byte of the BinaryParser\n   */\n\n\n  BinaryParser.prototype.peek = function () {\n    assert.ok(this.bytes.byteLength !== 0);\n    return this.bytes[0];\n  };\n  /**\n   * Consume the first n bytes of the BinaryParser\n   *\n   * @param n the number of bytes to skip\n   */\n\n\n  BinaryParser.prototype.skip = function (n) {\n    assert.ok(n <= this.bytes.byteLength);\n    this.bytes = this.bytes.slice(n);\n  };\n  /**\n   * read the first n bytes from the BinaryParser\n   *\n   * @param n The number of bytes to read\n   * @return The bytes\n   */\n\n\n  BinaryParser.prototype.read = function (n) {\n    assert.ok(n <= this.bytes.byteLength);\n    var slice = this.bytes.slice(0, n);\n    this.skip(n);\n    return slice;\n  };\n  /**\n   * Read an integer of given size\n   *\n   * @param n The number of bytes to read\n   * @return The number represented by those bytes\n   */\n\n\n  BinaryParser.prototype.readUIntN = function (n) {\n    assert.ok(0 < n && n <= 4, 'invalid n');\n    return this.read(n).reduce(function (a, b) {\n      return a << 8 | b;\n    }) >>> 0;\n  };\n\n  BinaryParser.prototype.readUInt8 = function () {\n    return this.readUIntN(1);\n  };\n\n  BinaryParser.prototype.readUInt16 = function () {\n    return this.readUIntN(2);\n  };\n\n  BinaryParser.prototype.readUInt32 = function () {\n    return this.readUIntN(4);\n  };\n\n  BinaryParser.prototype.size = function () {\n    return this.bytes.byteLength;\n  };\n\n  BinaryParser.prototype.end = function (customEnd) {\n    var length = this.bytes.byteLength;\n    return length === 0 || customEnd !== undefined && length <= customEnd;\n  };\n  /**\n   * Reads variable length encoded bytes\n   *\n   * @return The variable length bytes\n   */\n\n\n  BinaryParser.prototype.readVariableLength = function () {\n    return this.read(this.readVariableLengthLength());\n  };\n  /**\n   * Reads the length of the variable length encoded bytes\n   *\n   * @return The length of the variable length encoded bytes\n   */\n\n\n  BinaryParser.prototype.readVariableLengthLength = function () {\n    var b1 = this.readUInt8();\n\n    if (b1 <= 192) {\n      return b1;\n    } else if (b1 <= 240) {\n      var b2 = this.readUInt8();\n      return 193 + (b1 - 193) * 256 + b2;\n    } else if (b1 <= 254) {\n      var b2 = this.readUInt8();\n      var b3 = this.readUInt8();\n      return 12481 + (b1 - 241) * 65536 + b2 * 256 + b3;\n    }\n\n    throw new Error('Invalid variable length indicator');\n  };\n  /**\n   * Reads the field ordinal from the BinaryParser\n   *\n   * @return Field ordinal\n   */\n\n\n  BinaryParser.prototype.readFieldOrdinal = function () {\n    var type = this.readUInt8();\n    var nth = type & 15;\n    type >>= 4;\n\n    if (type === 0) {\n      type = this.readUInt8();\n\n      if (type === 0 || type < 16) {\n        throw new Error('Cannot read FieldOrdinal, type_code out of range');\n      }\n    }\n\n    if (nth === 0) {\n      nth = this.readUInt8();\n\n      if (nth === 0 || nth < 16) {\n        throw new Error('Cannot read FieldOrdinal, field_code out of range');\n      }\n    }\n\n    return type << 16 | nth;\n  };\n  /**\n   * Read the field from the BinaryParser\n   *\n   * @return The field represented by the bytes at the head of the BinaryParser\n   */\n\n\n  BinaryParser.prototype.readField = function () {\n    return enums_1.Field.fromString(this.readFieldOrdinal().toString());\n  };\n  /**\n   * Read a given type from the BinaryParser\n   *\n   * @param type The type that you want to read from the BinaryParser\n   * @return The instance of that type read from the BinaryParser\n   */\n\n\n  BinaryParser.prototype.readType = function (type) {\n    return type.fromParser(this);\n  };\n  /**\n   * Get the type associated with a given field\n   *\n   * @param field The field that you wan to get the type of\n   * @return The type associated with the given field\n   */\n\n\n  BinaryParser.prototype.typeForField = function (field) {\n    return field.associatedType;\n  };\n  /**\n   * Read value of the type specified by field from the BinaryParser\n   *\n   * @param field The field that you want to get the associated value for\n   * @return The value associated with the given field\n   */\n\n\n  BinaryParser.prototype.readFieldValue = function (field) {\n    var type = this.typeForField(field);\n\n    if (!type) {\n      throw new Error(\"unsupported: (\".concat(field.name, \", \").concat(field.type.name, \")\"));\n    }\n\n    var sizeHint = field.isVariableLengthEncoded ? this.readVariableLengthLength() : undefined;\n    var value = type.fromParser(this, sizeHint);\n\n    if (value === undefined) {\n      throw new Error(\"fromParser for (\".concat(field.name, \", \").concat(field.type.name, \") -> undefined \"));\n    }\n\n    return value;\n  };\n  /**\n   * Get the next field and value from the BinaryParser\n   *\n   * @return The field and value\n   */\n\n\n  BinaryParser.prototype.readFieldAndValue = function () {\n    var field = this.readField();\n    return [field, this.readFieldValue(field)];\n  };\n\n  return BinaryParser;\n}();\n\nexports.BinaryParser = BinaryParser;","map":{"version":3,"mappings":"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","names":["hexBytes","bytes","buffer_1","from","BinaryParser","assert","ok","byteLength","n","slice","skip","read","reduce","a","b","readUIntN","customEnd","length","undefined","readVariableLengthLength","b1","readUInt8","b2","b3","Error","type","nth","enums_1","fromString","readFieldOrdinal","toString","fromParser","field","associatedType","typeForField","name","concat","sizeHint","isVariableLengthEncoded","value","readField","readFieldValue","exports"],"sourceRoot":"","sources":["../../src/serdes/binary-parser.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}