{"ast":null,"code":"'use strict';\n\nconst CID = require('cids');\n\nconst Client = require('../../lib/core');\n\nconst Service = require('./service');\n\nconst toUrlSearchParams = require('../../lib/to-url-search-params');\n/**\n * @typedef {import('../..').HttpOptions} HttpOptions\n * @typedef {import('../../lib/core').ClientOptions} ClientOptions\n * @typedef {import('ipfs-core-types/src/basic').AbortOptions} AbortOptions\n * @typedef {import('ipfs-core-types/src/pin/remote').API} API\n * @typedef {import('ipfs-core-types/src/pin/remote').Pin} Pin\n * @typedef {import('ipfs-core-types/src/pin/remote').AddOptions} AddOptions\n * @typedef {import('ipfs-core-types/src/pin/remote').Query} Query\n * @typedef {import('ipfs-core-types/src/pin/remote').Status} Status\n *\n * @implements {API}\n */\n\n\nclass Remote {\n  /**\n   * @param {ClientOptions} options\n   */\n  constructor(options) {\n    /** @private */\n    this.client = new Client(options);\n    /** @readonly */\n\n    this.service = new Service(options);\n  }\n  /**\n   * Stores an IPFS object(s) from a given path to a remote pinning service.\n   *\n   * @param {CID} cid\n   * @param {AddOptions & AbortOptions & HttpOptions} options\n   * @returns {Promise<Pin>}\n   */\n\n\n  add(cid, options) {\n    return Remote.add(this.client, cid, options);\n  }\n  /**\n   * @param {Client} client\n   * @param {CID} cid\n   * @param {AddOptions & AbortOptions & HttpOptions} options\n   */\n\n\n  static async add(client, cid, _ref) {\n    let {\n      timeout,\n      signal,\n      headers,\n      ...options\n    } = _ref;\n    const response = await client.post('pin/remote/add', {\n      timeout,\n      signal,\n      headers,\n      searchParams: encodeAddParams({\n        cid,\n        ...options\n      })\n    });\n    return Remote.decodePin(await response.json());\n  }\n  /**\n   * @param {Object} json\n   * @param {string} json.Name\n   * @param {string} json.Cid\n   * @param {Status} json.Status\n   * @returns {Pin}\n   */\n\n\n  static decodePin(_ref2) {\n    let {\n      Name: name,\n      Status: status,\n      Cid: cid\n    } = _ref2;\n    return {\n      cid: new CID(cid),\n      name,\n      status\n    };\n  }\n  /**\n   * Returns a list of matching pins on the remote pinning service.\n   *\n   * @param {Query & AbortOptions & HttpOptions} query\n   */\n\n\n  ls(query) {\n    return Remote.ls(this.client, query);\n  }\n  /**\n   *\n   * @param {Client} client\n   * @param {Query & AbortOptions & HttpOptions} options\n   * @returns {AsyncIterable<Pin>}\n   */\n\n\n  static async *ls(client, _ref3) {\n    let {\n      timeout,\n      signal,\n      headers,\n      ...query\n    } = _ref3;\n    const response = await client.post('pin/remote/ls', {\n      signal,\n      timeout,\n      headers,\n      searchParams: encodeQuery(query)\n    });\n\n    for await (const pin of response.ndjson()) {\n      yield Remote.decodePin(pin);\n    }\n  }\n  /**\n   * Removes a single pin object matching query allowing it to be garbage\n   * collected (if needed). Will error if multiple pins mtach provided\n   * query. To remove all matches use `rmAll` instead.\n   *\n   * @param {Query & AbortOptions & HttpOptions} query\n   */\n\n\n  rm(query) {\n    return Remote.rm(this.client, { ...query,\n      all: false\n    });\n  }\n  /**\n   * Removes all pin object that match given query allowing them to be garbage\n   * collected if needed.\n   *\n   * @param {Query & AbortOptions & HttpOptions} query\n   */\n\n\n  rmAll(query) {\n    return Remote.rm(this.client, { ...query,\n      all: true\n    });\n  }\n  /**\n   *\n   * @param {Client} client\n   * @param {{all: boolean} & Query & AbortOptions & HttpOptions} options\n   */\n\n\n  static async rm(client, _ref4) {\n    let {\n      timeout,\n      signal,\n      headers,\n      ...query\n    } = _ref4;\n    await client.post('pin/remote/rm', {\n      timeout,\n      signal,\n      headers,\n      searchParams: encodeQuery(query)\n    });\n  }\n\n}\n/**\n * @param {any} service\n * @returns {string}\n */\n\n\nconst encodeService = service => {\n  if (typeof service === 'string' && service !== '') {\n    return service;\n  } else {\n    throw new TypeError('service name must be passed');\n  }\n};\n/**\n * @param {any} cid\n * @returns {string}\n */\n\n\nconst encodeCID = cid => {\n  if (CID.isCID(cid)) {\n    return cid.toString();\n  } else {\n    throw new TypeError(`CID instance expected instead of ${cid}`);\n  }\n};\n/**\n * @param {Query & { all?: boolean }} query\n * @returns {URLSearchParams}\n */\n\n\nconst encodeQuery = _ref5 => {\n  let {\n    service,\n    cid,\n    name,\n    status,\n    all\n  } = _ref5;\n  const query = toUrlSearchParams({\n    service: encodeService(service),\n    name,\n    force: all ? true : undefined\n  });\n\n  if (cid) {\n    for (const value of cid) {\n      query.append('cid', encodeCID(value));\n    }\n  }\n\n  if (status) {\n    for (const value of status) {\n      query.append('status', value);\n    }\n  }\n\n  return query;\n};\n/**\n * @param {AddOptions & {cid:CID}} options\n * @returns {URLSearchParams}\n */\n\n\nconst encodeAddParams = _ref6 => {\n  let {\n    cid,\n    service,\n    background,\n    name,\n    origins\n  } = _ref6;\n  const params = toUrlSearchParams({\n    arg: encodeCID(cid),\n    service: encodeService(service),\n    name,\n    background: background ? true : undefined\n  });\n\n  if (origins) {\n    for (const origin of origins) {\n      params.append('origin', origin.toString());\n    }\n  }\n\n  return params;\n};\n\nmodule.exports = Remote;","map":{"version":3,"names":["CID","require","Client","Service","toUrlSearchParams","Remote","constructor","options","client","service","add","cid","timeout","signal","headers","response","post","searchParams","encodeAddParams","decodePin","json","Name","name","Status","status","Cid","ls","query","encodeQuery","pin","ndjson","rm","all","rmAll","encodeService","TypeError","encodeCID","isCID","toString","force","undefined","value","append","background","origins","params","arg","origin","module","exports"],"sources":["C:/Users/acer/node_modules/ipfs-http-client/src/pin/remote/index.js"],"sourcesContent":["'use strict'\n\nconst CID = require('cids')\nconst Client = require('../../lib/core')\nconst Service = require('./service')\nconst toUrlSearchParams = require('../../lib/to-url-search-params')\n\n/**\n * @typedef {import('../..').HttpOptions} HttpOptions\n * @typedef {import('../../lib/core').ClientOptions} ClientOptions\n * @typedef {import('ipfs-core-types/src/basic').AbortOptions} AbortOptions\n * @typedef {import('ipfs-core-types/src/pin/remote').API} API\n * @typedef {import('ipfs-core-types/src/pin/remote').Pin} Pin\n * @typedef {import('ipfs-core-types/src/pin/remote').AddOptions} AddOptions\n * @typedef {import('ipfs-core-types/src/pin/remote').Query} Query\n * @typedef {import('ipfs-core-types/src/pin/remote').Status} Status\n *\n * @implements {API}\n */\nclass Remote {\n  /**\n   * @param {ClientOptions} options\n   */\n  constructor (options) {\n    /** @private */\n    this.client = new Client(options)\n    /** @readonly */\n    this.service = new Service(options)\n  }\n\n  /**\n   * Stores an IPFS object(s) from a given path to a remote pinning service.\n   *\n   * @param {CID} cid\n   * @param {AddOptions & AbortOptions & HttpOptions} options\n   * @returns {Promise<Pin>}\n   */\n  add (cid, options) {\n    return Remote.add(this.client, cid, options)\n  }\n\n  /**\n   * @param {Client} client\n   * @param {CID} cid\n   * @param {AddOptions & AbortOptions & HttpOptions} options\n   */\n  static async add (client, cid, { timeout, signal, headers, ...options }) {\n    const response = await client.post('pin/remote/add', {\n      timeout,\n      signal,\n      headers,\n      searchParams: encodeAddParams({ cid, ...options })\n    })\n\n    return Remote.decodePin(await response.json())\n  }\n\n  /**\n   * @param {Object} json\n   * @param {string} json.Name\n   * @param {string} json.Cid\n   * @param {Status} json.Status\n   * @returns {Pin}\n   */\n  static decodePin ({ Name: name, Status: status, Cid: cid }) {\n    return {\n      cid: new CID(cid),\n      name,\n      status\n    }\n  }\n\n  /**\n   * Returns a list of matching pins on the remote pinning service.\n   *\n   * @param {Query & AbortOptions & HttpOptions} query\n   */\n  ls (query) {\n    return Remote.ls(this.client, query)\n  }\n\n  /**\n   *\n   * @param {Client} client\n   * @param {Query & AbortOptions & HttpOptions} options\n   * @returns {AsyncIterable<Pin>}\n   */\n  static async * ls (client, { timeout, signal, headers, ...query }) {\n    const response = await client.post('pin/remote/ls', {\n      signal,\n      timeout,\n      headers,\n      searchParams: encodeQuery(query)\n    })\n\n    for await (const pin of response.ndjson()) {\n      yield Remote.decodePin(pin)\n    }\n  }\n\n  /**\n   * Removes a single pin object matching query allowing it to be garbage\n   * collected (if needed). Will error if multiple pins mtach provided\n   * query. To remove all matches use `rmAll` instead.\n   *\n   * @param {Query & AbortOptions & HttpOptions} query\n   */\n  rm (query) {\n    return Remote.rm(this.client, { ...query, all: false })\n  }\n\n  /**\n   * Removes all pin object that match given query allowing them to be garbage\n   * collected if needed.\n   *\n   * @param {Query & AbortOptions & HttpOptions} query\n   */\n  rmAll (query) {\n    return Remote.rm(this.client, { ...query, all: true })\n  }\n\n  /**\n   *\n   * @param {Client} client\n   * @param {{all: boolean} & Query & AbortOptions & HttpOptions} options\n   */\n  static async rm (client, { timeout, signal, headers, ...query }) {\n    await client.post('pin/remote/rm', {\n      timeout,\n      signal,\n      headers,\n      searchParams: encodeQuery(query)\n    })\n  }\n}\n\n/**\n * @param {any} service\n * @returns {string}\n */\nconst encodeService = (service) => {\n  if (typeof service === 'string' && service !== '') {\n    return service\n  } else {\n    throw new TypeError('service name must be passed')\n  }\n}\n\n/**\n * @param {any} cid\n * @returns {string}\n */\nconst encodeCID = (cid) => {\n  if (CID.isCID(cid)) {\n    return cid.toString()\n  } else {\n    throw new TypeError(`CID instance expected instead of ${cid}`)\n  }\n}\n\n/**\n * @param {Query & { all?: boolean }} query\n * @returns {URLSearchParams}\n */\nconst encodeQuery = ({ service, cid, name, status, all }) => {\n  const query = toUrlSearchParams({\n    service: encodeService(service),\n    name,\n    force: all ? true : undefined\n  })\n\n  if (cid) {\n    for (const value of cid) {\n      query.append('cid', encodeCID(value))\n    }\n  }\n\n  if (status) {\n    for (const value of status) {\n      query.append('status', value)\n    }\n  }\n\n  return query\n}\n\n/**\n * @param {AddOptions & {cid:CID}} options\n * @returns {URLSearchParams}\n */\nconst encodeAddParams = ({ cid, service, background, name, origins }) => {\n  const params = toUrlSearchParams({\n    arg: encodeCID(cid),\n    service: encodeService(service),\n    name,\n    background: background ? true : undefined\n  })\n\n  if (origins) {\n    for (const origin of origins) {\n      params.append('origin', origin.toString())\n    }\n  }\n\n  return params\n}\n\nmodule.exports = Remote\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}