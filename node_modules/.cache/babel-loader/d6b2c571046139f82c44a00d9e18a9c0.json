{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar ClassTransformer_1 = require(\"./ClassTransformer\");\n\nvar storage_1 = require(\"./storage\");\n\nvar TypeMetadata_1 = require(\"./metadata/TypeMetadata\");\n\nvar ExposeMetadata_1 = require(\"./metadata/ExposeMetadata\");\n\nvar ExcludeMetadata_1 = require(\"./metadata/ExcludeMetadata\");\n\nvar TransformMetadata_1 = require(\"./metadata/TransformMetadata\");\n/**\n * Defines a custom logic for value transformation.\n */\n\n\nfunction Transform(transformFn, options) {\n  return function (target, key) {\n    var metadata = new TransformMetadata_1.TransformMetadata(target.constructor, key, transformFn, options);\n    storage_1.defaultMetadataStorage.addTransformMetadata(metadata);\n  };\n}\n\nexports.Transform = Transform;\n/**\n * Specifies a type of the property.\n * The given TypeFunction can return a constructor. A discriminator can be given in the options.\n */\n\nfunction Type(typeFunction, options) {\n  return function (target, key) {\n    var type = Reflect.getMetadata(\"design:type\", target, key);\n    var metadata = new TypeMetadata_1.TypeMetadata(target.constructor, key, type, typeFunction, options);\n    storage_1.defaultMetadataStorage.addTypeMetadata(metadata);\n  };\n}\n\nexports.Type = Type;\n/**\n * Marks property as included in the process of transformation. By default it includes the property for both\n * constructorToPlain and plainToConstructor transformations, however you can specify on which of transformation types\n * you want to skip this property.\n */\n\nfunction Expose(options) {\n  return function (object, propertyName) {\n    var metadata = new ExposeMetadata_1.ExposeMetadata(object instanceof Function ? object : object.constructor, propertyName, options || {});\n    storage_1.defaultMetadataStorage.addExposeMetadata(metadata);\n  };\n}\n\nexports.Expose = Expose;\n/**\n * Marks property as excluded from the process of transformation. By default it excludes the property for both\n * constructorToPlain and plainToConstructor transformations, however you can specify on which of transformation types\n * you want to skip this property.\n */\n\nfunction Exclude(options) {\n  return function (object, propertyName) {\n    var metadata = new ExcludeMetadata_1.ExcludeMetadata(object instanceof Function ? object : object.constructor, propertyName, options || {});\n    storage_1.defaultMetadataStorage.addExcludeMetadata(metadata);\n  };\n}\n\nexports.Exclude = Exclude;\n/**\n * Transform the object from class to plain object and return only with the exposed properties.\n */\n\nfunction TransformClassToPlain(params) {\n  return function (target, propertyKey, descriptor) {\n    var classTransformer = new ClassTransformer_1.ClassTransformer();\n    var originalMethod = descriptor.value;\n\n    descriptor.value = function () {\n      var args = [];\n\n      for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n      }\n\n      var result = originalMethod.apply(this, args);\n      var isPromise = !!result && (typeof result === \"object\" || typeof result === \"function\") && typeof result.then === \"function\";\n      return isPromise ? result.then(function (data) {\n        return classTransformer.classToPlain(data, params);\n      }) : classTransformer.classToPlain(result, params);\n    };\n  };\n}\n\nexports.TransformClassToPlain = TransformClassToPlain;\n/**\n * Return the class instance only with the exposed properties.\n */\n\nfunction TransformClassToClass(params) {\n  return function (target, propertyKey, descriptor) {\n    var classTransformer = new ClassTransformer_1.ClassTransformer();\n    var originalMethod = descriptor.value;\n\n    descriptor.value = function () {\n      var args = [];\n\n      for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n      }\n\n      var result = originalMethod.apply(this, args);\n      var isPromise = !!result && (typeof result === \"object\" || typeof result === \"function\") && typeof result.then === \"function\";\n      return isPromise ? result.then(function (data) {\n        return classTransformer.classToClass(data, params);\n      }) : classTransformer.classToClass(result, params);\n    };\n  };\n}\n\nexports.TransformClassToClass = TransformClassToClass;\n/**\n * Return the class instance only with the exposed properties.\n */\n\nfunction TransformPlainToClass(classType, params) {\n  return function (target, propertyKey, descriptor) {\n    var classTransformer = new ClassTransformer_1.ClassTransformer();\n    var originalMethod = descriptor.value;\n\n    descriptor.value = function () {\n      var args = [];\n\n      for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n      }\n\n      var result = originalMethod.apply(this, args);\n      var isPromise = !!result && (typeof result === \"object\" || typeof result === \"function\") && typeof result.then === \"function\";\n      return isPromise ? result.then(function (data) {\n        return classTransformer.plainToClass(classType, data, params);\n      }) : classTransformer.plainToClass(classType, result, params);\n    };\n  };\n}\n\nexports.TransformPlainToClass = TransformPlainToClass;","map":{"version":3,"mappings":"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","names":["transformFn","options","target","key","metadata","TransformMetadata_1","constructor","storage_1","addTransformMetadata","exports","typeFunction","type","Reflect","getMetadata","TypeMetadata_1","addTypeMetadata","object","propertyName","ExposeMetadata_1","Function","addExposeMetadata","ExcludeMetadata_1","addExcludeMetadata","params","propertyKey","descriptor","classTransformer","ClassTransformer_1","originalMethod","value","args","result","apply","isPromise","then","data","classToPlain","classToClass","classType","plainToClass"],"sourceRoot":".","sources":["../../src/decorators.ts"],"sourcesContent":["import {ClassTransformer} from \"./ClassTransformer\";\nimport {defaultMetadataStorage} from \"./storage\";\nimport {TypeMetadata} from \"./metadata/TypeMetadata\";\nimport {ExposeMetadata} from \"./metadata/ExposeMetadata\";\nimport {ExposeOptions, ExcludeOptions, TypeHelpOptions, TransformOptions, Discriminator, TypeOptions} from \"./metadata/ExposeExcludeOptions\";\nimport {ExcludeMetadata} from \"./metadata/ExcludeMetadata\";\nimport {TransformMetadata} from \"./metadata/TransformMetadata\";\nimport {ClassTransformOptions} from \"./ClassTransformOptions\";\nimport {TransformationType} from \"./TransformOperationExecutor\";\n\n/**\n * Defines a custom logic for value transformation.\n */\nexport function Transform(transformFn: (value: any, obj: any, transformationType: TransformationType) => any, options?: TransformOptions) {\n    return function(target: any, key: string) {\n        const metadata = new TransformMetadata(target.constructor, key, transformFn, options);\n        defaultMetadataStorage.addTransformMetadata(metadata);\n    };\n}\n\n/**\n * Specifies a type of the property.\n * The given TypeFunction can return a constructor. A discriminator can be given in the options.\n */\nexport function Type(typeFunction?: (type?: TypeHelpOptions) => Function, options?: TypeOptions) {\n    return function(target: any, key: string) {\n        const type = (Reflect as any).getMetadata(\"design:type\", target, key);\n        const metadata = new TypeMetadata(target.constructor, key, type, typeFunction, options);\n        defaultMetadataStorage.addTypeMetadata(metadata);\n    };\n}\n\n/**\n * Marks property as included in the process of transformation. By default it includes the property for both\n * constructorToPlain and plainToConstructor transformations, however you can specify on which of transformation types\n * you want to skip this property.\n */\nexport function Expose(options?: ExposeOptions) {\n    return function(object: Object|Function, propertyName?: string) {\n        const metadata = new ExposeMetadata(object instanceof Function ? object : object.constructor, propertyName, options || {});\n        defaultMetadataStorage.addExposeMetadata(metadata);\n    };\n}\n\n/**\n * Marks property as excluded from the process of transformation. By default it excludes the property for both\n * constructorToPlain and plainToConstructor transformations, however you can specify on which of transformation types\n * you want to skip this property.\n */\nexport function Exclude(options?: ExcludeOptions) {\n    return function(object: Object|Function, propertyName?: string) {\n        const metadata = new ExcludeMetadata(object instanceof Function ? object : object.constructor, propertyName, options || {});\n        defaultMetadataStorage.addExcludeMetadata(metadata);\n    };\n}\n\n/**\n * Transform the object from class to plain object and return only with the exposed properties.\n */\nexport function TransformClassToPlain(params?: ClassTransformOptions): Function {\n\n    return function (target: Function, propertyKey: string, descriptor: PropertyDescriptor) {\n        const classTransformer: ClassTransformer = new ClassTransformer();\n        const originalMethod = descriptor.value;\n\n        descriptor.value = function(...args: any[]) {\n            const result: any = originalMethod.apply(this, args);\n            const isPromise = !!result && (typeof result === \"object\" || typeof result === \"function\") && typeof result.then === \"function\";\n\n            return isPromise ? result.then((data: any) => classTransformer.classToPlain(data, params)) : classTransformer.classToPlain(result, params);\n        };\n    };\n}\n\n/**\n * Return the class instance only with the exposed properties.\n */\nexport function TransformClassToClass(params?: ClassTransformOptions): Function {\n\n    return function (target: Function, propertyKey: string, descriptor: PropertyDescriptor) {\n        const classTransformer: ClassTransformer = new ClassTransformer();\n        const originalMethod = descriptor.value;\n\n        descriptor.value = function(...args: any[]) {\n            const result: any = originalMethod.apply(this, args);\n            const isPromise = !!result && (typeof result === \"object\" || typeof result === \"function\") && typeof result.then === \"function\";\n\n            return isPromise ? result.then((data: any) => classTransformer.classToClass(data, params)) : classTransformer.classToClass(result, params);\n        };\n    };\n}\n\n/**\n * Return the class instance only with the exposed properties.\n */\nexport function TransformPlainToClass(classType: any, params?: ClassTransformOptions): Function {\n\n    return function (target: Function, propertyKey: string, descriptor: PropertyDescriptor) {\n        const classTransformer: ClassTransformer = new ClassTransformer();\n        const originalMethod = descriptor.value;\n\n        descriptor.value = function(...args: any[]) {\n            const result: any = originalMethod.apply(this, args);\n            const isPromise = !!result && (typeof result === \"object\" || typeof result === \"function\") && typeof result.then === \"function\";\n\n            return isPromise ? result.then((data: any) => classTransformer.plainToClass(classType, data, params)) : classTransformer.plainToClass(classType, result, params);\n        };\n    };\n}\n"]},"metadata":{},"sourceType":"script"}