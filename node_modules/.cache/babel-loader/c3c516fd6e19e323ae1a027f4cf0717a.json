{"ast":null,"code":"'use strict';\n/* jshint maxparams:5 */\n\nvar Signature = require('../crypto/signature');\n\nvar Script = require('../script');\n\nvar Output = require('./output');\n\nvar BufferReader = require('../encoding/bufferreader');\n\nvar BufferWriter = require('../encoding/bufferwriter');\n\nvar BN = require('../crypto/bn');\n\nvar Hash = require('../crypto/hash');\n\nvar ECDSA = require('../crypto/ecdsa');\n\nvar $ = require('../util/preconditions');\n\nvar _ = require('lodash');\n/**\n * Returns a buffer of length 32 bytes with the hash that needs to be signed\n * for witness programs as defined by:\n * https://github.com/bitcoin/bips/blob/master/bip-0143.mediawiki\n *\n * @name Signing.sighash\n * @param {Transaction} transaction the transaction to sign\n * @param {number} sighashType the type of the hash\n * @param {number} inputNumber the input index for the signature\n * @param {Buffer} scriptCode\n * @param {Buffer} satoshisBuffer\n */\n\n\nvar sighash = function sighash(transaction, sighashType, inputNumber, scriptCode, satoshisBuffer) {\n  /* jshint maxstatements: 50 */\n  var hashPrevouts = Buffer.alloc(32);\n  var hashSequence = Buffer.alloc(32);\n  var hashOutputs = Buffer.alloc(32);\n\n  if (!(sighashType & Signature.SIGHASH_ANYONECANPAY)) {\n    var buffers = [];\n\n    for (var n = 0; n < transaction.inputs.length; n++) {\n      var input = transaction.inputs[n];\n      var prevTxIdBuffer = new BufferReader(input.prevTxId).readReverse();\n      buffers.push(prevTxIdBuffer);\n      var outputIndexBuffer = Buffer.alloc(4);\n      outputIndexBuffer.writeUInt32LE(input.outputIndex, 0);\n      buffers.push(outputIndexBuffer);\n    }\n\n    hashPrevouts = Hash.sha256sha256(Buffer.concat(buffers));\n  }\n\n  if (!(sighashType & Signature.SIGHASH_ANYONECANPAY) && (sighashType & 0x1f) !== Signature.SIGHASH_SINGLE && (sighashType & 0x1f) !== Signature.SIGHASH_NONE) {\n    var sequenceBuffers = [];\n\n    for (var m = 0; m < transaction.inputs.length; m++) {\n      var sequenceBuffer = Buffer.alloc(4);\n      sequenceBuffer.writeUInt32LE(transaction.inputs[m].sequenceNumber, 0);\n      sequenceBuffers.push(sequenceBuffer);\n    }\n\n    hashSequence = Hash.sha256sha256(Buffer.concat(sequenceBuffers));\n  }\n\n  var outputWriter = new BufferWriter();\n\n  if ((sighashType & 0x1f) !== Signature.SIGHASH_SINGLE && (sighashType & 0x1f) !== Signature.SIGHASH_NONE) {\n    for (var p = 0; p < transaction.outputs.length; p++) {\n      transaction.outputs[p].toBufferWriter(outputWriter);\n    }\n\n    hashOutputs = Hash.sha256sha256(outputWriter.toBuffer());\n  } else if ((sighashType & 0x1f) === Signature.SIGHASH_SINGLE && inputNumber < transaction.outputs.length) {\n    transaction.outputs[inputNumber].toBufferWriter(outputWriter);\n    hashOutputs = Hash.sha256sha256(outputWriter.toBuffer());\n  } // Version\n\n\n  var writer = new BufferWriter();\n  writer.writeUInt32LE(transaction.version); // Input prevouts/nSequence (none/all, depending on flags)\n\n  writer.write(hashPrevouts);\n  writer.write(hashSequence); // The input being signed (replacing the scriptSig with scriptCode + amount)\n  // The prevout may already be contained in hashPrevout, and the nSequence\n  // may already be contain in hashSequence.\n\n  var outpointId = new BufferReader(transaction.inputs[inputNumber].prevTxId).readReverse();\n  writer.write(outpointId);\n  writer.writeUInt32LE(transaction.inputs[inputNumber].outputIndex);\n  writer.write(scriptCode);\n  writer.write(satoshisBuffer);\n  writer.writeUInt32LE(transaction.inputs[inputNumber].sequenceNumber); // Outputs (none/one/all, depending on flags)\n\n  writer.write(hashOutputs); // Locktime\n\n  writer.writeUInt32LE(transaction.nLockTime); // Sighash type\n\n  writer.writeInt32LE(sighashType);\n  return Hash.sha256sha256(writer.toBuffer());\n};\n/**\n * Create a signature\n *\n * @name Signing.sign\n * @param {Transaction} transaction\n * @param {PrivateKey} privateKey\n * @param {number} sighash\n * @param {number} inputIndex\n * @param {Script} subscript\n * @param {String} signingMethod - method used to sign - 'ecdsa' or 'schnorr'\n * @return {Signature}\n */\n\n\nfunction sign(transaction, privateKey, sighashType, inputIndex, scriptCode, satoshisBuffer, signingMethod) {\n  signingMethod = signingMethod || 'ecdsa';\n  var sig;\n\n  if (signingMethod === 'ecdsa') {\n    let hashbuf = sighash(transaction, sighashType, inputIndex, scriptCode, satoshisBuffer);\n    sig = ECDSA.sign(hashbuf, privateKey).set({\n      nhashtype: sighashType\n    });\n    return sig;\n  }\n\n  throw new Error(\"signingMethod not supported \", signingMethod);\n}\n/**\n * Verify a signature\n *\n * @name Signing.verify\n * @param {Transaction} transaction\n * @param {Signature} signature\n * @param {PublicKey} publicKey\n * @param {number} inputIndex\n * @param {Script} subscript\n * @param {String} signingMethod - method used to sign - 'ecdsa' or 'schnorr' (future signing method)\n * @return {boolean}\n */\n\n\nfunction verify(transaction, signature, publicKey, inputIndex, scriptCode, satoshisBuffer, signingMethod) {\n  $.checkArgument(!_.isUndefined(transaction));\n  $.checkArgument(!_.isUndefined(signature) && !_.isUndefined(signature.nhashtype));\n  signingMethod = signingMethod || 'ecdsa';\n\n  if (signingMethod === 'ecdsa') {\n    let hashbuf = sighash(transaction, signature.nhashtype, inputIndex, scriptCode, satoshisBuffer);\n    return ECDSA.verify(hashbuf, signature, publicKey);\n  }\n\n  throw new Error(\"signingMethod not supported \", signingMethod);\n}\n/**\n * @namespace Signing\n */\n\n\nmodule.exports = {\n  sighash: sighash,\n  sign: sign,\n  verify: verify\n};","map":{"version":3,"names":["Signature","require","Script","Output","BufferReader","BufferWriter","BN","Hash","ECDSA","$","_","sighash","transaction","sighashType","inputNumber","scriptCode","satoshisBuffer","hashPrevouts","Buffer","alloc","hashSequence","hashOutputs","SIGHASH_ANYONECANPAY","buffers","n","inputs","length","input","prevTxIdBuffer","prevTxId","readReverse","push","outputIndexBuffer","writeUInt32LE","outputIndex","sha256sha256","concat","SIGHASH_SINGLE","SIGHASH_NONE","sequenceBuffers","m","sequenceBuffer","sequenceNumber","outputWriter","p","outputs","toBufferWriter","toBuffer","writer","version","write","outpointId","nLockTime","writeInt32LE","sign","privateKey","inputIndex","signingMethod","sig","hashbuf","set","nhashtype","Error","verify","signature","publicKey","checkArgument","isUndefined","module","exports"],"sources":["C:/Users/acer/node_modules/bitcore-lib-doge/lib/transaction/sighashwitness.js"],"sourcesContent":["'use strict';\n\n/* jshint maxparams:5 */\n\nvar Signature = require('../crypto/signature');\nvar Script = require('../script');\nvar Output = require('./output');\nvar BufferReader = require('../encoding/bufferreader');\nvar BufferWriter = require('../encoding/bufferwriter');\nvar BN = require('../crypto/bn');\nvar Hash = require('../crypto/hash');\nvar ECDSA = require('../crypto/ecdsa');\nvar $ = require('../util/preconditions');\nvar _ = require('lodash');\n\n/**\n * Returns a buffer of length 32 bytes with the hash that needs to be signed\n * for witness programs as defined by:\n * https://github.com/bitcoin/bips/blob/master/bip-0143.mediawiki\n *\n * @name Signing.sighash\n * @param {Transaction} transaction the transaction to sign\n * @param {number} sighashType the type of the hash\n * @param {number} inputNumber the input index for the signature\n * @param {Buffer} scriptCode\n * @param {Buffer} satoshisBuffer\n */\nvar sighash = function sighash(transaction, sighashType, inputNumber, scriptCode, satoshisBuffer) {\n  /* jshint maxstatements: 50 */\n\n  var hashPrevouts = Buffer.alloc(32);\n  var hashSequence = Buffer.alloc(32);\n  var hashOutputs = Buffer.alloc(32);\n\n  if (!(sighashType & Signature.SIGHASH_ANYONECANPAY)) {\n    var buffers = [];\n    for (var n = 0; n < transaction.inputs.length; n++) {\n      var input = transaction.inputs[n];\n      var prevTxIdBuffer = new BufferReader(input.prevTxId).readReverse();\n      buffers.push(prevTxIdBuffer);\n      var outputIndexBuffer = Buffer.alloc(4);\n      outputIndexBuffer.writeUInt32LE(input.outputIndex, 0);\n      buffers.push(outputIndexBuffer);\n    }\n    hashPrevouts = Hash.sha256sha256(Buffer.concat(buffers));\n  }\n\n  if (!(sighashType & Signature.SIGHASH_ANYONECANPAY) &&\n      (sighashType & 0x1f) !== Signature.SIGHASH_SINGLE && (sighashType & 0x1f) !== Signature.SIGHASH_NONE) {\n\n    var sequenceBuffers = [];\n    for (var m = 0; m < transaction.inputs.length; m++) {\n      var sequenceBuffer = Buffer.alloc(4);\n      sequenceBuffer.writeUInt32LE(transaction.inputs[m].sequenceNumber, 0);\n      sequenceBuffers.push(sequenceBuffer);\n    }\n    hashSequence = Hash.sha256sha256(Buffer.concat(sequenceBuffers));\n  }\n\n  var outputWriter = new BufferWriter();\n  if ((sighashType & 0x1f) !== Signature.SIGHASH_SINGLE && (sighashType & 0x1f) !== Signature.SIGHASH_NONE) {\n    for (var p = 0; p < transaction.outputs.length; p++) {\n      transaction.outputs[p].toBufferWriter(outputWriter);\n    }\n    hashOutputs = Hash.sha256sha256(outputWriter.toBuffer());\n  } else if ((sighashType & 0x1f) === Signature.SIGHASH_SINGLE && inputNumber < transaction.outputs.length) {\n    transaction.outputs[inputNumber].toBufferWriter(outputWriter);\n    hashOutputs = Hash.sha256sha256(outputWriter.toBuffer());\n  }\n\n  // Version\n  var writer = new BufferWriter();\n  writer.writeUInt32LE(transaction.version);\n\n  // Input prevouts/nSequence (none/all, depending on flags)\n  writer.write(hashPrevouts);\n  writer.write(hashSequence);\n\n  // The input being signed (replacing the scriptSig with scriptCode + amount)\n  // The prevout may already be contained in hashPrevout, and the nSequence\n  // may already be contain in hashSequence.\n  var outpointId = new BufferReader(transaction.inputs[inputNumber].prevTxId).readReverse();\n  writer.write(outpointId);\n  writer.writeUInt32LE(transaction.inputs[inputNumber].outputIndex);\n\n  writer.write(scriptCode);\n\n  writer.write(satoshisBuffer);\n\n  writer.writeUInt32LE(transaction.inputs[inputNumber].sequenceNumber);\n\n  // Outputs (none/one/all, depending on flags)\n  writer.write(hashOutputs);\n\n  // Locktime\n  writer.writeUInt32LE(transaction.nLockTime);\n\n  // Sighash type\n  writer.writeInt32LE(sighashType);\n\n  return Hash.sha256sha256(writer.toBuffer());\n\n};\n\n/**\n * Create a signature\n *\n * @name Signing.sign\n * @param {Transaction} transaction\n * @param {PrivateKey} privateKey\n * @param {number} sighash\n * @param {number} inputIndex\n * @param {Script} subscript\n * @param {String} signingMethod - method used to sign - 'ecdsa' or 'schnorr'\n * @return {Signature}\n */\nfunction sign(transaction, privateKey, sighashType, inputIndex, scriptCode, satoshisBuffer, signingMethod) {\n  signingMethod = signingMethod || 'ecdsa';\n  var sig;\n\n  if (signingMethod === 'ecdsa') {\n    let hashbuf = sighash(transaction, sighashType, inputIndex, scriptCode, satoshisBuffer);\n    sig = ECDSA.sign(hashbuf, privateKey).set({\n      nhashtype: sighashType\n    });\n    return sig;\n  }\n  throw new Error(\"signingMethod not supported \", signingMethod);\n}\n\n/**\n * Verify a signature\n *\n * @name Signing.verify\n * @param {Transaction} transaction\n * @param {Signature} signature\n * @param {PublicKey} publicKey\n * @param {number} inputIndex\n * @param {Script} subscript\n * @param {String} signingMethod - method used to sign - 'ecdsa' or 'schnorr' (future signing method)\n * @return {boolean}\n */\nfunction verify(transaction, signature, publicKey, inputIndex, scriptCode, satoshisBuffer, signingMethod) {\n  $.checkArgument(!_.isUndefined(transaction));\n  $.checkArgument(!_.isUndefined(signature) && !_.isUndefined(signature.nhashtype));\n  signingMethod = signingMethod || 'ecdsa';\n\n  if (signingMethod === 'ecdsa') {\n    let hashbuf = sighash(transaction, signature.nhashtype, inputIndex, scriptCode, satoshisBuffer);\n    return ECDSA.verify(hashbuf, signature, publicKey);\n  }\n  throw new Error(\"signingMethod not supported \", signingMethod);\n}\n\n/**\n * @namespace Signing\n */\nmodule.exports = {\n  sighash: sighash,\n  sign: sign,\n  verify: verify\n};"],"mappings":"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"},"metadata":{},"sourceType":"script"}