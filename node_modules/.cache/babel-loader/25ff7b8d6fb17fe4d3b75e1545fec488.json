{"ast":null,"code":"'use strict';\n\nvar _ = require('lodash');\n\nvar $ = require('./util/preconditions');\n\nvar BN = require('./crypto/bn');\n\nvar Base58 = require('./encoding/base58');\n\nvar Base58Check = require('./encoding/base58check');\n\nvar Hash = require('./crypto/hash');\n\nvar HDPrivateKey = require('./hdprivatekey');\n\nvar Network = require('./networks');\n\nvar Point = require('./crypto/point');\n\nvar PublicKey = require('./publickey');\n\nvar bitcoreErrors = require('./errors');\n\nvar errors = bitcoreErrors;\nvar hdErrors = bitcoreErrors.HDPublicKey;\n\nvar assert = require('assert');\n\nvar JSUtil = require('./util/js');\n\nvar BufferUtil = require('./util/buffer');\n/**\n * The representation of an hierarchically derived public key.\n *\n * See https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki\n *\n * @constructor\n * @param {Object|string|Buffer} arg\n */\n\n\nfunction HDPublicKey(arg) {\n  /* jshint maxcomplexity: 12 */\n\n  /* jshint maxstatements: 20 */\n  if (arg instanceof HDPublicKey) {\n    return arg;\n  }\n\n  if (!(this instanceof HDPublicKey)) {\n    return new HDPublicKey(arg);\n  }\n\n  if (arg) {\n    if (_.isString(arg) || BufferUtil.isBuffer(arg)) {\n      var error = HDPublicKey.getSerializedError(arg);\n\n      if (!error) {\n        return this._buildFromSerialized(arg);\n      } else if (BufferUtil.isBuffer(arg) && !HDPublicKey.getSerializedError(arg.toString())) {\n        return this._buildFromSerialized(arg.toString());\n      } else {\n        if (error instanceof hdErrors.ArgumentIsPrivateExtended) {\n          return new HDPrivateKey(arg).hdPublicKey;\n        }\n\n        throw error;\n      }\n    } else {\n      if (_.isObject(arg)) {\n        if (arg instanceof HDPrivateKey) {\n          return this._buildFromPrivate(arg);\n        } else {\n          return this._buildFromObject(arg);\n        }\n      } else {\n        throw new hdErrors.UnrecognizedArgument(arg);\n      }\n    }\n  } else {\n    throw new hdErrors.MustSupplyArgument();\n  }\n}\n/**\n * Verifies that a given path is valid.\n *\n * @param {string|number} arg\n * @return {boolean}\n */\n\n\nHDPublicKey.isValidPath = function (arg) {\n  if (_.isString(arg)) {\n    var indexes = HDPrivateKey._getDerivationIndexes(arg);\n\n    return indexes !== null && _.every(indexes, HDPublicKey.isValidPath);\n  }\n\n  if (_.isNumber(arg)) {\n    return arg >= 0 && arg < HDPublicKey.Hardened;\n  }\n\n  return false;\n};\n/**\n * WARNING: This method is deprecated. Use deriveChild instead.\n *\n *\n * Get a derivated child based on a string or number.\n *\n * If the first argument is a string, it's parsed as the full path of\n * derivation. Valid values for this argument include \"m\" (which returns the\n * same public key), \"m/0/1/40/2/1000\".\n *\n * Note that hardened keys can't be derived from a public extended key.\n *\n * If the first argument is a number, the child with that index will be\n * derived. See the example usage for clarification.\n *\n * @example\n * ```javascript\n * var parent = new HDPublicKey('xpub...');\n * var child_0_1_2 = parent.derive(0).derive(1).derive(2);\n * var copy_of_child_0_1_2 = parent.derive(\"m/0/1/2\");\n * assert(child_0_1_2.xprivkey === copy_of_child_0_1_2);\n * ```\n *\n * @param {string|number} arg\n */\n\n\nHDPublicKey.prototype.derive = function (arg, hardened) {\n  return this.deriveChild(arg, hardened);\n};\n/**\n * WARNING: This method will not be officially supported until v1.0.0.\n *\n *\n * Get a derivated child based on a string or number.\n *\n * If the first argument is a string, it's parsed as the full path of\n * derivation. Valid values for this argument include \"m\" (which returns the\n * same public key), \"m/0/1/40/2/1000\".\n *\n * Note that hardened keys can't be derived from a public extended key.\n *\n * If the first argument is a number, the child with that index will be\n * derived. See the example usage for clarification.\n *\n * @example\n * ```javascript\n * var parent = new HDPublicKey('xpub...');\n * var child_0_1_2 = parent.deriveChild(0).deriveChild(1).deriveChild(2);\n * var copy_of_child_0_1_2 = parent.deriveChild(\"m/0/1/2\");\n * assert(child_0_1_2.xprivkey === copy_of_child_0_1_2);\n * ```\n *\n * @param {string|number} arg\n */\n\n\nHDPublicKey.prototype.deriveChild = function (arg, hardened) {\n  if (_.isNumber(arg)) {\n    return this._deriveWithNumber(arg, hardened);\n  } else if (_.isString(arg)) {\n    return this._deriveFromString(arg);\n  } else {\n    throw new hdErrors.InvalidDerivationArgument(arg);\n  }\n};\n\nHDPublicKey.prototype._deriveWithNumber = function (index, hardened) {\n  if (index >= HDPublicKey.Hardened || hardened) {\n    throw new hdErrors.InvalidIndexCantDeriveHardened();\n  }\n\n  if (index < 0) {\n    throw new hdErrors.InvalidPath(index);\n  }\n\n  var indexBuffer = BufferUtil.integerAsBuffer(index);\n  var data = BufferUtil.concat([this.publicKey.toBuffer(), indexBuffer]);\n  var hash = Hash.sha512hmac(data, this._buffers.chainCode);\n  var leftPart = BN.fromBuffer(hash.slice(0, 32), {\n    size: 32\n  });\n  var chainCode = hash.slice(32, 64);\n  var publicKey;\n\n  try {\n    publicKey = PublicKey.fromPoint(Point.getG().mul(leftPart).add(this.publicKey.point));\n  } catch (e) {\n    return this._deriveWithNumber(index + 1);\n  }\n\n  var derived = new HDPublicKey({\n    network: this.network,\n    depth: this.depth + 1,\n    parentFingerPrint: this.fingerPrint,\n    childIndex: index,\n    chainCode: chainCode,\n    publicKey: publicKey\n  });\n  return derived;\n};\n\nHDPublicKey.prototype._deriveFromString = function (path) {\n  /* jshint maxcomplexity: 8 */\n  if (_.includes(path, \"'\")) {\n    throw new hdErrors.InvalidIndexCantDeriveHardened();\n  } else if (!HDPublicKey.isValidPath(path)) {\n    throw new hdErrors.InvalidPath(path);\n  }\n\n  var indexes = HDPrivateKey._getDerivationIndexes(path);\n\n  var derived = indexes.reduce(function (prev, index) {\n    return prev._deriveWithNumber(index);\n  }, this);\n  return derived;\n};\n/**\n * Verifies that a given serialized public key in base58 with checksum format\n * is valid.\n *\n * @param {string|Buffer} data - the serialized public key\n * @param {string|Network=} network - optional, if present, checks that the\n *     network provided matches the network serialized.\n * @return {boolean}\n */\n\n\nHDPublicKey.isValidSerialized = function (data, network) {\n  return _.isNull(HDPublicKey.getSerializedError(data, network));\n};\n/**\n * Checks what's the error that causes the validation of a serialized public key\n * in base58 with checksum to fail.\n *\n * @param {string|Buffer} data - the serialized public key\n * @param {string|Network=} network - optional, if present, checks that the\n *     network provided matches the network serialized.\n * @return {errors|null}\n */\n\n\nHDPublicKey.getSerializedError = function (data, network) {\n  /* jshint maxcomplexity: 10 */\n\n  /* jshint maxstatements: 20 */\n  if (!(_.isString(data) || BufferUtil.isBuffer(data))) {\n    return new hdErrors.UnrecognizedArgument('expected buffer or string');\n  }\n\n  if (!Base58.validCharacters(data)) {\n    return new errors.InvalidB58Char('(unknown)', data);\n  }\n\n  try {\n    data = Base58Check.decode(data);\n  } catch (e) {\n    return new errors.InvalidB58Checksum(data);\n  }\n\n  if (data.length !== HDPublicKey.DataSize) {\n    return new hdErrors.InvalidLength(data);\n  }\n\n  if (!_.isUndefined(network)) {\n    var error = HDPublicKey._validateNetwork(data, network);\n\n    if (error) {\n      return error;\n    }\n  }\n\n  var version = BufferUtil.integerFromBuffer(data.slice(0, 4));\n\n  if (version === Network.livenet.xprivkey || version === Network.testnet.xprivkey) {\n    return new hdErrors.ArgumentIsPrivateExtended();\n  }\n\n  return null;\n};\n\nHDPublicKey._validateNetwork = function (data, networkArg) {\n  var network = Network.get(networkArg);\n\n  if (!network) {\n    return new errors.InvalidNetworkArgument(networkArg);\n  }\n\n  var version = data.slice(HDPublicKey.VersionStart, HDPublicKey.VersionEnd);\n\n  if (BufferUtil.integerFromBuffer(version) !== network.xpubkey) {\n    return new errors.InvalidNetwork(version);\n  }\n\n  return null;\n};\n\nHDPublicKey.prototype._buildFromPrivate = function (arg) {\n  var args = _.clone(arg._buffers);\n\n  var point = Point.getG().mul(BN.fromBuffer(args.privateKey));\n  args.publicKey = Point.pointToCompressed(point);\n  args.version = BufferUtil.integerAsBuffer(Network.get(BufferUtil.integerFromBuffer(args.version)).xpubkey);\n  args.privateKey = undefined;\n  args.checksum = undefined;\n  args.xprivkey = undefined;\n  return this._buildFromBuffers(args);\n};\n\nHDPublicKey.prototype._buildFromObject = function (arg) {\n  /* jshint maxcomplexity: 10 */\n  // TODO: Type validation\n  var buffers = {\n    version: arg.network ? BufferUtil.integerAsBuffer(Network.get(arg.network).xpubkey) : arg.version,\n    depth: _.isNumber(arg.depth) ? BufferUtil.integerAsSingleByteBuffer(arg.depth) : arg.depth,\n    parentFingerPrint: _.isNumber(arg.parentFingerPrint) ? BufferUtil.integerAsBuffer(arg.parentFingerPrint) : arg.parentFingerPrint,\n    childIndex: _.isNumber(arg.childIndex) ? BufferUtil.integerAsBuffer(arg.childIndex) : arg.childIndex,\n    chainCode: _.isString(arg.chainCode) ? Buffer.from(arg.chainCode, 'hex') : arg.chainCode,\n    publicKey: _.isString(arg.publicKey) ? Buffer.from(arg.publicKey, 'hex') : BufferUtil.isBuffer(arg.publicKey) ? arg.publicKey : arg.publicKey.toBuffer(),\n    checksum: _.isNumber(arg.checksum) ? BufferUtil.integerAsBuffer(arg.checksum) : arg.checksum\n  };\n  return this._buildFromBuffers(buffers);\n};\n\nHDPublicKey.prototype._buildFromSerialized = function (arg) {\n  var decoded = Base58Check.decode(arg);\n  var buffers = {\n    version: decoded.slice(HDPublicKey.VersionStart, HDPublicKey.VersionEnd),\n    depth: decoded.slice(HDPublicKey.DepthStart, HDPublicKey.DepthEnd),\n    parentFingerPrint: decoded.slice(HDPublicKey.ParentFingerPrintStart, HDPublicKey.ParentFingerPrintEnd),\n    childIndex: decoded.slice(HDPublicKey.ChildIndexStart, HDPublicKey.ChildIndexEnd),\n    chainCode: decoded.slice(HDPublicKey.ChainCodeStart, HDPublicKey.ChainCodeEnd),\n    publicKey: decoded.slice(HDPublicKey.PublicKeyStart, HDPublicKey.PublicKeyEnd),\n    checksum: decoded.slice(HDPublicKey.ChecksumStart, HDPublicKey.ChecksumEnd),\n    xpubkey: arg\n  };\n  return this._buildFromBuffers(buffers);\n};\n/**\n * Receives a object with buffers in all the properties and populates the\n * internal structure\n *\n * @param {Object} arg\n * @param {buffer.Buffer} arg.version\n * @param {buffer.Buffer} arg.depth\n * @param {buffer.Buffer} arg.parentFingerPrint\n * @param {buffer.Buffer} arg.childIndex\n * @param {buffer.Buffer} arg.chainCode\n * @param {buffer.Buffer} arg.publicKey\n * @param {buffer.Buffer} arg.checksum\n * @param {string=} arg.xpubkey - if set, don't recalculate the base58\n *      representation\n * @return {HDPublicKey} this\n */\n\n\nHDPublicKey.prototype._buildFromBuffers = function (arg) {\n  /* jshint maxcomplexity: 8 */\n\n  /* jshint maxstatements: 20 */\n  HDPublicKey._validateBufferArguments(arg);\n\n  JSUtil.defineImmutable(this, {\n    _buffers: arg\n  });\n  var sequence = [arg.version, arg.depth, arg.parentFingerPrint, arg.childIndex, arg.chainCode, arg.publicKey];\n  var concat = BufferUtil.concat(sequence);\n  var checksum = Base58Check.checksum(concat);\n\n  if (!arg.checksum || !arg.checksum.length) {\n    arg.checksum = checksum;\n  } else {\n    if (arg.checksum.toString('hex') !== checksum.toString('hex')) {\n      throw new errors.InvalidB58Checksum(concat, checksum);\n    }\n  }\n\n  var network = Network.get(BufferUtil.integerFromBuffer(arg.version));\n  var xpubkey;\n  xpubkey = Base58Check.encode(BufferUtil.concat(sequence));\n  arg.xpubkey = Buffer.from(xpubkey);\n  var publicKey = new PublicKey(arg.publicKey, {\n    network: network\n  });\n  var size = HDPublicKey.ParentFingerPrintSize;\n  var fingerPrint = Hash.sha256ripemd160(publicKey.toBuffer()).slice(0, size);\n  JSUtil.defineImmutable(this, {\n    xpubkey: xpubkey,\n    network: network,\n    depth: BufferUtil.integerFromSingleByteBuffer(arg.depth),\n    publicKey: publicKey,\n    fingerPrint: fingerPrint\n  });\n  return this;\n};\n\nHDPublicKey._validateBufferArguments = function (arg) {\n  var checkBuffer = function (name, size) {\n    var buff = arg[name];\n    assert(BufferUtil.isBuffer(buff), name + ' argument is not a buffer, it\\'s ' + typeof buff);\n    assert(buff.length === size, name + ' has not the expected size: found ' + buff.length + ', expected ' + size);\n  };\n\n  checkBuffer('version', HDPublicKey.VersionSize);\n  checkBuffer('depth', HDPublicKey.DepthSize);\n  checkBuffer('parentFingerPrint', HDPublicKey.ParentFingerPrintSize);\n  checkBuffer('childIndex', HDPublicKey.ChildIndexSize);\n  checkBuffer('chainCode', HDPublicKey.ChainCodeSize);\n  checkBuffer('publicKey', HDPublicKey.PublicKeySize);\n\n  if (arg.checksum && arg.checksum.length) {\n    checkBuffer('checksum', HDPublicKey.CheckSumSize);\n  }\n};\n\nHDPublicKey.fromString = function (arg) {\n  $.checkArgument(_.isString(arg), 'No valid string was provided');\n  return new HDPublicKey(arg);\n};\n\nHDPublicKey.fromObject = function (arg) {\n  $.checkArgument(_.isObject(arg), 'No valid argument was provided');\n  return new HDPublicKey(arg);\n};\n/**\n * Returns the base58 checked representation of the public key\n * @return {string} a string starting with \"xpub...\" in livenet\n */\n\n\nHDPublicKey.prototype.toString = function () {\n  return this.xpubkey;\n};\n/**\n * Returns the console representation of this extended public key.\n * @return string\n */\n\n\nHDPublicKey.prototype.inspect = function () {\n  return '<HDPublicKey: ' + this.xpubkey + '>';\n};\n/**\n * Returns a plain JavaScript object with information to reconstruct a key.\n *\n * Fields are: <ul>\n *  <li> network: 'livenet' or 'testnet'\n *  <li> depth: a number from 0 to 255, the depth to the master extended key\n *  <li> fingerPrint: a number of 32 bits taken from the hash of the public key\n *  <li> fingerPrint: a number of 32 bits taken from the hash of this key's\n *  <li>     parent's public key\n *  <li> childIndex: index with which this key was derived\n *  <li> chainCode: string in hexa encoding used for derivation\n *  <li> publicKey: string, hexa encoded, in compressed key format\n *  <li> checksum: BufferUtil.integerFromBuffer(this._buffers.checksum),\n *  <li> xpubkey: the string with the base58 representation of this extended key\n *  <li> checksum: the base58 checksum of xpubkey\n * </ul>\n */\n\n\nHDPublicKey.prototype.toObject = HDPublicKey.prototype.toJSON = function toObject() {\n  return {\n    network: Network.get(BufferUtil.integerFromBuffer(this._buffers.version)).name,\n    depth: BufferUtil.integerFromSingleByteBuffer(this._buffers.depth),\n    fingerPrint: BufferUtil.integerFromBuffer(this.fingerPrint),\n    parentFingerPrint: BufferUtil.integerFromBuffer(this._buffers.parentFingerPrint),\n    childIndex: BufferUtil.integerFromBuffer(this._buffers.childIndex),\n    chainCode: BufferUtil.bufferToHex(this._buffers.chainCode),\n    publicKey: this.publicKey.toString(),\n    checksum: BufferUtil.integerFromBuffer(this._buffers.checksum),\n    xpubkey: this.xpubkey\n  };\n};\n/**\n * Create a HDPublicKey from a buffer argument\n *\n * @param {Buffer} arg\n * @return {HDPublicKey}\n */\n\n\nHDPublicKey.fromBuffer = function (arg) {\n  return new HDPublicKey(arg);\n};\n/**\n * Return a buffer representation of the xpubkey\n *\n * @return {Buffer}\n */\n\n\nHDPublicKey.prototype.toBuffer = function () {\n  return BufferUtil.copy(this._buffers.xpubkey);\n};\n\nHDPublicKey.Hardened = 0x80000000;\nHDPublicKey.RootElementAlias = ['m', 'M'];\nHDPublicKey.VersionSize = 4;\nHDPublicKey.DepthSize = 1;\nHDPublicKey.ParentFingerPrintSize = 4;\nHDPublicKey.ChildIndexSize = 4;\nHDPublicKey.ChainCodeSize = 32;\nHDPublicKey.PublicKeySize = 33;\nHDPublicKey.CheckSumSize = 4;\nHDPublicKey.DataSize = 78;\nHDPublicKey.SerializedByteSize = 82;\nHDPublicKey.VersionStart = 0;\nHDPublicKey.VersionEnd = HDPublicKey.VersionStart + HDPublicKey.VersionSize;\nHDPublicKey.DepthStart = HDPublicKey.VersionEnd;\nHDPublicKey.DepthEnd = HDPublicKey.DepthStart + HDPublicKey.DepthSize;\nHDPublicKey.ParentFingerPrintStart = HDPublicKey.DepthEnd;\nHDPublicKey.ParentFingerPrintEnd = HDPublicKey.ParentFingerPrintStart + HDPublicKey.ParentFingerPrintSize;\nHDPublicKey.ChildIndexStart = HDPublicKey.ParentFingerPrintEnd;\nHDPublicKey.ChildIndexEnd = HDPublicKey.ChildIndexStart + HDPublicKey.ChildIndexSize;\nHDPublicKey.ChainCodeStart = HDPublicKey.ChildIndexEnd;\nHDPublicKey.ChainCodeEnd = HDPublicKey.ChainCodeStart + HDPublicKey.ChainCodeSize;\nHDPublicKey.PublicKeyStart = HDPublicKey.ChainCodeEnd;\nHDPublicKey.PublicKeyEnd = HDPublicKey.PublicKeyStart + HDPublicKey.PublicKeySize;\nHDPublicKey.ChecksumStart = HDPublicKey.PublicKeyEnd;\nHDPublicKey.ChecksumEnd = HDPublicKey.ChecksumStart + HDPublicKey.CheckSumSize;\nassert(HDPublicKey.PublicKeyEnd === HDPublicKey.DataSize);\nassert(HDPublicKey.ChecksumEnd === HDPublicKey.SerializedByteSize);\nmodule.exports = HDPublicKey;","map":{"version":3,"names":["_","require","$","BN","Base58","Base58Check","Hash","HDPrivateKey","Network","Point","PublicKey","bitcoreErrors","errors","hdErrors","HDPublicKey","assert","JSUtil","BufferUtil","arg","isString","isBuffer","error","getSerializedError","_buildFromSerialized","toString","ArgumentIsPrivateExtended","hdPublicKey","isObject","_buildFromPrivate","_buildFromObject","UnrecognizedArgument","MustSupplyArgument","isValidPath","indexes","_getDerivationIndexes","every","isNumber","Hardened","prototype","derive","hardened","deriveChild","_deriveWithNumber","_deriveFromString","InvalidDerivationArgument","index","InvalidIndexCantDeriveHardened","InvalidPath","indexBuffer","integerAsBuffer","data","concat","publicKey","toBuffer","hash","sha512hmac","_buffers","chainCode","leftPart","fromBuffer","slice","size","fromPoint","getG","mul","add","point","e","derived","network","depth","parentFingerPrint","fingerPrint","childIndex","path","includes","reduce","prev","isValidSerialized","isNull","validCharacters","InvalidB58Char","decode","InvalidB58Checksum","length","DataSize","InvalidLength","isUndefined","_validateNetwork","version","integerFromBuffer","livenet","xprivkey","testnet","networkArg","get","InvalidNetworkArgument","VersionStart","VersionEnd","xpubkey","InvalidNetwork","args","clone","privateKey","pointToCompressed","undefined","checksum","_buildFromBuffers","buffers","integerAsSingleByteBuffer","Buffer","from","decoded","DepthStart","DepthEnd","ParentFingerPrintStart","ParentFingerPrintEnd","ChildIndexStart","ChildIndexEnd","ChainCodeStart","ChainCodeEnd","PublicKeyStart","PublicKeyEnd","ChecksumStart","ChecksumEnd","_validateBufferArguments","defineImmutable","sequence","encode","ParentFingerPrintSize","sha256ripemd160","integerFromSingleByteBuffer","checkBuffer","name","buff","VersionSize","DepthSize","ChildIndexSize","ChainCodeSize","PublicKeySize","CheckSumSize","fromString","checkArgument","fromObject","inspect","toObject","toJSON","bufferToHex","copy","RootElementAlias","SerializedByteSize","module","exports"],"sources":["C:/Users/acer/node_modules/bitcore-lib/lib/hdpublickey.js"],"sourcesContent":["'use strict';\n\nvar _ = require('lodash');\nvar $ = require('./util/preconditions');\n\nvar BN = require('./crypto/bn');\nvar Base58 = require('./encoding/base58');\nvar Base58Check = require('./encoding/base58check');\nvar Hash = require('./crypto/hash');\nvar HDPrivateKey = require('./hdprivatekey');\nvar Network = require('./networks');\nvar Point = require('./crypto/point');\nvar PublicKey = require('./publickey');\n\nvar bitcoreErrors = require('./errors');\nvar errors = bitcoreErrors;\nvar hdErrors = bitcoreErrors.HDPublicKey;\nvar assert = require('assert');\n\nvar JSUtil = require('./util/js');\nvar BufferUtil = require('./util/buffer');\n\n/**\n * The representation of an hierarchically derived public key.\n *\n * See https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki\n *\n * @constructor\n * @param {Object|string|Buffer} arg\n */\nfunction HDPublicKey(arg) {\n  /* jshint maxcomplexity: 12 */\n  /* jshint maxstatements: 20 */\n  if (arg instanceof HDPublicKey) {\n    return arg;\n  }\n  if (!(this instanceof HDPublicKey)) {\n    return new HDPublicKey(arg);\n  }\n  if (arg) {\n    if (_.isString(arg) || BufferUtil.isBuffer(arg)) {\n      var error = HDPublicKey.getSerializedError(arg);\n      if (!error) {\n        return this._buildFromSerialized(arg);\n      } else if (BufferUtil.isBuffer(arg) && !HDPublicKey.getSerializedError(arg.toString())) {\n        return this._buildFromSerialized(arg.toString());\n      } else {\n        if (error instanceof hdErrors.ArgumentIsPrivateExtended) {\n          return new HDPrivateKey(arg).hdPublicKey;\n        }\n        throw error;\n      }\n    } else {\n      if (_.isObject(arg)) {\n        if (arg instanceof HDPrivateKey) {\n          return this._buildFromPrivate(arg);\n        } else {\n          return this._buildFromObject(arg);\n        }\n      } else {\n        throw new hdErrors.UnrecognizedArgument(arg);\n      }\n    }\n  } else {\n    throw new hdErrors.MustSupplyArgument();\n  }\n}\n\n/**\n * Verifies that a given path is valid.\n *\n * @param {string|number} arg\n * @return {boolean}\n */\nHDPublicKey.isValidPath = function(arg) {\n  if (_.isString(arg)) {\n    var indexes = HDPrivateKey._getDerivationIndexes(arg);\n    return indexes !== null && _.every(indexes, HDPublicKey.isValidPath);\n  }\n\n  if (_.isNumber(arg)) {\n    return arg >= 0 && arg < HDPublicKey.Hardened;\n  }\n\n  return false;\n};\n\n/**\n * WARNING: This method is deprecated. Use deriveChild instead.\n *\n *\n * Get a derivated child based on a string or number.\n *\n * If the first argument is a string, it's parsed as the full path of\n * derivation. Valid values for this argument include \"m\" (which returns the\n * same public key), \"m/0/1/40/2/1000\".\n *\n * Note that hardened keys can't be derived from a public extended key.\n *\n * If the first argument is a number, the child with that index will be\n * derived. See the example usage for clarification.\n *\n * @example\n * ```javascript\n * var parent = new HDPublicKey('xpub...');\n * var child_0_1_2 = parent.derive(0).derive(1).derive(2);\n * var copy_of_child_0_1_2 = parent.derive(\"m/0/1/2\");\n * assert(child_0_1_2.xprivkey === copy_of_child_0_1_2);\n * ```\n *\n * @param {string|number} arg\n */\nHDPublicKey.prototype.derive = function(arg, hardened) {\n  return this.deriveChild(arg, hardened);\n};\n\n/**\n * WARNING: This method will not be officially supported until v1.0.0.\n *\n *\n * Get a derivated child based on a string or number.\n *\n * If the first argument is a string, it's parsed as the full path of\n * derivation. Valid values for this argument include \"m\" (which returns the\n * same public key), \"m/0/1/40/2/1000\".\n *\n * Note that hardened keys can't be derived from a public extended key.\n *\n * If the first argument is a number, the child with that index will be\n * derived. See the example usage for clarification.\n *\n * @example\n * ```javascript\n * var parent = new HDPublicKey('xpub...');\n * var child_0_1_2 = parent.deriveChild(0).deriveChild(1).deriveChild(2);\n * var copy_of_child_0_1_2 = parent.deriveChild(\"m/0/1/2\");\n * assert(child_0_1_2.xprivkey === copy_of_child_0_1_2);\n * ```\n *\n * @param {string|number} arg\n */\nHDPublicKey.prototype.deriveChild = function(arg, hardened) {\n  if (_.isNumber(arg)) {\n    return this._deriveWithNumber(arg, hardened);\n  } else if (_.isString(arg)) {\n    return this._deriveFromString(arg);\n  } else {\n    throw new hdErrors.InvalidDerivationArgument(arg);\n  }\n};\n\nHDPublicKey.prototype._deriveWithNumber = function(index, hardened) {\n  if (index >= HDPublicKey.Hardened || hardened) {\n    throw new hdErrors.InvalidIndexCantDeriveHardened();\n  }\n  if (index < 0) {\n    throw new hdErrors.InvalidPath(index);\n  }\n\n  var indexBuffer = BufferUtil.integerAsBuffer(index);\n  var data = BufferUtil.concat([this.publicKey.toBuffer(), indexBuffer]);\n  var hash = Hash.sha512hmac(data, this._buffers.chainCode);\n  var leftPart = BN.fromBuffer(hash.slice(0, 32), {size: 32});\n  var chainCode = hash.slice(32, 64);\n\n  var publicKey;\n  try {\n    publicKey = PublicKey.fromPoint(Point.getG().mul(leftPart).add(this.publicKey.point));\n  } catch (e) {\n    return this._deriveWithNumber(index + 1);\n  }\n\n  var derived = new HDPublicKey({\n    network: this.network,\n    depth: this.depth + 1,\n    parentFingerPrint: this.fingerPrint,\n    childIndex: index,\n    chainCode: chainCode,\n    publicKey: publicKey\n  });\n\n  return derived;\n};\n\nHDPublicKey.prototype._deriveFromString = function(path) {\n  /* jshint maxcomplexity: 8 */\n  if (_.includes(path, \"'\")) {\n    throw new hdErrors.InvalidIndexCantDeriveHardened();\n  } else if (!HDPublicKey.isValidPath(path)) {\n    throw new hdErrors.InvalidPath(path);\n  }\n\n  var indexes = HDPrivateKey._getDerivationIndexes(path);\n  var derived = indexes.reduce(function(prev, index) {\n    return prev._deriveWithNumber(index);\n  }, this);\n\n  return derived;\n};\n\n/**\n * Verifies that a given serialized public key in base58 with checksum format\n * is valid.\n *\n * @param {string|Buffer} data - the serialized public key\n * @param {string|Network=} network - optional, if present, checks that the\n *     network provided matches the network serialized.\n * @return {boolean}\n */\nHDPublicKey.isValidSerialized = function(data, network) {\n  return _.isNull(HDPublicKey.getSerializedError(data, network));\n};\n\n/**\n * Checks what's the error that causes the validation of a serialized public key\n * in base58 with checksum to fail.\n *\n * @param {string|Buffer} data - the serialized public key\n * @param {string|Network=} network - optional, if present, checks that the\n *     network provided matches the network serialized.\n * @return {errors|null}\n */\nHDPublicKey.getSerializedError = function(data, network) {\n  /* jshint maxcomplexity: 10 */\n  /* jshint maxstatements: 20 */\n  if (!(_.isString(data) || BufferUtil.isBuffer(data))) {\n    return new hdErrors.UnrecognizedArgument('expected buffer or string');\n  }\n  if (!Base58.validCharacters(data)) {\n    return new errors.InvalidB58Char('(unknown)', data);\n  }\n  try {\n    data = Base58Check.decode(data);\n  } catch (e) {\n    return new errors.InvalidB58Checksum(data);\n  }\n  if (data.length !== HDPublicKey.DataSize) {\n    return new hdErrors.InvalidLength(data);\n  }\n  if (!_.isUndefined(network)) {\n    var error = HDPublicKey._validateNetwork(data, network);\n    if (error) {\n      return error;\n    }\n  }\n  var version = BufferUtil.integerFromBuffer(data.slice(0, 4));\n  if (version === Network.livenet.xprivkey || version === Network.testnet.xprivkey ) {\n    return new hdErrors.ArgumentIsPrivateExtended();\n  }\n  return null;\n};\n\nHDPublicKey._validateNetwork = function(data, networkArg) {\n  var network = Network.get(networkArg);\n  if (!network) {\n    return new errors.InvalidNetworkArgument(networkArg);\n  }\n  var version = data.slice(HDPublicKey.VersionStart, HDPublicKey.VersionEnd);\n  if (BufferUtil.integerFromBuffer(version) !== network.xpubkey) {\n    return new errors.InvalidNetwork(version);\n  }\n  return null;\n};\n\nHDPublicKey.prototype._buildFromPrivate = function (arg) {\n  var args = _.clone(arg._buffers);\n  var point = Point.getG().mul(BN.fromBuffer(args.privateKey));\n  args.publicKey = Point.pointToCompressed(point);\n  args.version = BufferUtil.integerAsBuffer(Network.get(BufferUtil.integerFromBuffer(args.version)).xpubkey);\n  args.privateKey = undefined;\n  args.checksum = undefined;\n  args.xprivkey = undefined;\n  return this._buildFromBuffers(args);\n};\n\nHDPublicKey.prototype._buildFromObject = function(arg) {\n  /* jshint maxcomplexity: 10 */\n  // TODO: Type validation\n  var buffers = {\n    version: arg.network ? BufferUtil.integerAsBuffer(Network.get(arg.network).xpubkey) : arg.version,\n    depth: _.isNumber(arg.depth) ? BufferUtil.integerAsSingleByteBuffer(arg.depth) : arg.depth,\n    parentFingerPrint: _.isNumber(arg.parentFingerPrint) ? BufferUtil.integerAsBuffer(arg.parentFingerPrint) : arg.parentFingerPrint,\n    childIndex: _.isNumber(arg.childIndex) ? BufferUtil.integerAsBuffer(arg.childIndex) : arg.childIndex,\n    chainCode: _.isString(arg.chainCode) ? Buffer.from(arg.chainCode,'hex') : arg.chainCode,\n    publicKey: _.isString(arg.publicKey) ? Buffer.from(arg.publicKey,'hex') :\n      BufferUtil.isBuffer(arg.publicKey) ? arg.publicKey : arg.publicKey.toBuffer(),\n    checksum: _.isNumber(arg.checksum) ? BufferUtil.integerAsBuffer(arg.checksum) : arg.checksum\n  };\n  return this._buildFromBuffers(buffers);\n};\n\nHDPublicKey.prototype._buildFromSerialized = function(arg) {\n  var decoded = Base58Check.decode(arg);\n  var buffers = {\n    version: decoded.slice(HDPublicKey.VersionStart, HDPublicKey.VersionEnd),\n    depth: decoded.slice(HDPublicKey.DepthStart, HDPublicKey.DepthEnd),\n    parentFingerPrint: decoded.slice(HDPublicKey.ParentFingerPrintStart,\n                                     HDPublicKey.ParentFingerPrintEnd),\n    childIndex: decoded.slice(HDPublicKey.ChildIndexStart, HDPublicKey.ChildIndexEnd),\n    chainCode: decoded.slice(HDPublicKey.ChainCodeStart, HDPublicKey.ChainCodeEnd),\n    publicKey: decoded.slice(HDPublicKey.PublicKeyStart, HDPublicKey.PublicKeyEnd),\n    checksum: decoded.slice(HDPublicKey.ChecksumStart, HDPublicKey.ChecksumEnd),\n    xpubkey: arg\n  };\n  return this._buildFromBuffers(buffers);\n};\n\n/**\n * Receives a object with buffers in all the properties and populates the\n * internal structure\n *\n * @param {Object} arg\n * @param {buffer.Buffer} arg.version\n * @param {buffer.Buffer} arg.depth\n * @param {buffer.Buffer} arg.parentFingerPrint\n * @param {buffer.Buffer} arg.childIndex\n * @param {buffer.Buffer} arg.chainCode\n * @param {buffer.Buffer} arg.publicKey\n * @param {buffer.Buffer} arg.checksum\n * @param {string=} arg.xpubkey - if set, don't recalculate the base58\n *      representation\n * @return {HDPublicKey} this\n */\nHDPublicKey.prototype._buildFromBuffers = function(arg) {\n  /* jshint maxcomplexity: 8 */\n  /* jshint maxstatements: 20 */\n\n  HDPublicKey._validateBufferArguments(arg);\n\n  JSUtil.defineImmutable(this, {\n    _buffers: arg\n  });\n\n  var sequence = [\n    arg.version, arg.depth, arg.parentFingerPrint, arg.childIndex, arg.chainCode,\n    arg.publicKey\n  ];\n  var concat = BufferUtil.concat(sequence);\n  var checksum = Base58Check.checksum(concat);\n  if (!arg.checksum || !arg.checksum.length) {\n    arg.checksum = checksum;\n  } else {\n    if (arg.checksum.toString('hex') !== checksum.toString('hex')) {\n      throw new errors.InvalidB58Checksum(concat, checksum);\n    }\n  }\n  var network = Network.get(BufferUtil.integerFromBuffer(arg.version));\n\n  var xpubkey;\n  xpubkey = Base58Check.encode(BufferUtil.concat(sequence));\n  arg.xpubkey = Buffer.from(xpubkey);\n\n  var publicKey = new PublicKey(arg.publicKey, {network: network});\n  var size = HDPublicKey.ParentFingerPrintSize;\n  var fingerPrint = Hash.sha256ripemd160(publicKey.toBuffer()).slice(0, size);\n\n  JSUtil.defineImmutable(this, {\n    xpubkey: xpubkey,\n    network: network,\n    depth: BufferUtil.integerFromSingleByteBuffer(arg.depth),\n    publicKey: publicKey,\n    fingerPrint: fingerPrint\n  });\n\n  return this;\n};\n\nHDPublicKey._validateBufferArguments = function(arg) {\n  var checkBuffer = function(name, size) {\n    var buff = arg[name];\n    assert(BufferUtil.isBuffer(buff), name + ' argument is not a buffer, it\\'s ' + typeof buff);\n    assert(\n      buff.length === size,\n      name + ' has not the expected size: found ' + buff.length + ', expected ' + size\n    );\n  };\n  checkBuffer('version', HDPublicKey.VersionSize);\n  checkBuffer('depth', HDPublicKey.DepthSize);\n  checkBuffer('parentFingerPrint', HDPublicKey.ParentFingerPrintSize);\n  checkBuffer('childIndex', HDPublicKey.ChildIndexSize);\n  checkBuffer('chainCode', HDPublicKey.ChainCodeSize);\n  checkBuffer('publicKey', HDPublicKey.PublicKeySize);\n  if (arg.checksum && arg.checksum.length) {\n    checkBuffer('checksum', HDPublicKey.CheckSumSize);\n  }\n};\n\nHDPublicKey.fromString = function(arg) {\n  $.checkArgument(_.isString(arg), 'No valid string was provided');\n  return new HDPublicKey(arg);\n};\n\nHDPublicKey.fromObject = function(arg) {\n  $.checkArgument(_.isObject(arg), 'No valid argument was provided');\n  return new HDPublicKey(arg);\n};\n\n/**\n * Returns the base58 checked representation of the public key\n * @return {string} a string starting with \"xpub...\" in livenet\n */\nHDPublicKey.prototype.toString = function() {\n  return this.xpubkey;\n};\n\n/**\n * Returns the console representation of this extended public key.\n * @return string\n */\nHDPublicKey.prototype.inspect = function() {\n  return '<HDPublicKey: ' + this.xpubkey + '>';\n};\n\n/**\n * Returns a plain JavaScript object with information to reconstruct a key.\n *\n * Fields are: <ul>\n *  <li> network: 'livenet' or 'testnet'\n *  <li> depth: a number from 0 to 255, the depth to the master extended key\n *  <li> fingerPrint: a number of 32 bits taken from the hash of the public key\n *  <li> fingerPrint: a number of 32 bits taken from the hash of this key's\n *  <li>     parent's public key\n *  <li> childIndex: index with which this key was derived\n *  <li> chainCode: string in hexa encoding used for derivation\n *  <li> publicKey: string, hexa encoded, in compressed key format\n *  <li> checksum: BufferUtil.integerFromBuffer(this._buffers.checksum),\n *  <li> xpubkey: the string with the base58 representation of this extended key\n *  <li> checksum: the base58 checksum of xpubkey\n * </ul>\n */\nHDPublicKey.prototype.toObject = HDPublicKey.prototype.toJSON = function toObject() {\n  return {\n    network: Network.get(BufferUtil.integerFromBuffer(this._buffers.version)).name,\n    depth: BufferUtil.integerFromSingleByteBuffer(this._buffers.depth),\n    fingerPrint: BufferUtil.integerFromBuffer(this.fingerPrint),\n    parentFingerPrint: BufferUtil.integerFromBuffer(this._buffers.parentFingerPrint),\n    childIndex: BufferUtil.integerFromBuffer(this._buffers.childIndex),\n    chainCode: BufferUtil.bufferToHex(this._buffers.chainCode),\n    publicKey: this.publicKey.toString(),\n    checksum: BufferUtil.integerFromBuffer(this._buffers.checksum),\n    xpubkey: this.xpubkey\n  };\n};\n\n/**\n * Create a HDPublicKey from a buffer argument\n *\n * @param {Buffer} arg\n * @return {HDPublicKey}\n */\nHDPublicKey.fromBuffer = function(arg) {\n  return new HDPublicKey(arg);\n};\n\n/**\n * Return a buffer representation of the xpubkey\n *\n * @return {Buffer}\n */\nHDPublicKey.prototype.toBuffer = function() {\n  return BufferUtil.copy(this._buffers.xpubkey);\n};\n\nHDPublicKey.Hardened = 0x80000000;\nHDPublicKey.RootElementAlias = ['m', 'M'];\n\nHDPublicKey.VersionSize = 4;\nHDPublicKey.DepthSize = 1;\nHDPublicKey.ParentFingerPrintSize = 4;\nHDPublicKey.ChildIndexSize = 4;\nHDPublicKey.ChainCodeSize = 32;\nHDPublicKey.PublicKeySize = 33;\nHDPublicKey.CheckSumSize = 4;\n\nHDPublicKey.DataSize = 78;\nHDPublicKey.SerializedByteSize = 82;\n\nHDPublicKey.VersionStart           = 0;\nHDPublicKey.VersionEnd             = HDPublicKey.VersionStart + HDPublicKey.VersionSize;\nHDPublicKey.DepthStart             = HDPublicKey.VersionEnd;\nHDPublicKey.DepthEnd               = HDPublicKey.DepthStart + HDPublicKey.DepthSize;\nHDPublicKey.ParentFingerPrintStart = HDPublicKey.DepthEnd;\nHDPublicKey.ParentFingerPrintEnd   = HDPublicKey.ParentFingerPrintStart + HDPublicKey.ParentFingerPrintSize;\nHDPublicKey.ChildIndexStart        = HDPublicKey.ParentFingerPrintEnd;\nHDPublicKey.ChildIndexEnd          = HDPublicKey.ChildIndexStart + HDPublicKey.ChildIndexSize;\nHDPublicKey.ChainCodeStart         = HDPublicKey.ChildIndexEnd;\nHDPublicKey.ChainCodeEnd           = HDPublicKey.ChainCodeStart + HDPublicKey.ChainCodeSize;\nHDPublicKey.PublicKeyStart         = HDPublicKey.ChainCodeEnd;\nHDPublicKey.PublicKeyEnd           = HDPublicKey.PublicKeyStart + HDPublicKey.PublicKeySize;\nHDPublicKey.ChecksumStart          = HDPublicKey.PublicKeyEnd;\nHDPublicKey.ChecksumEnd            = HDPublicKey.ChecksumStart + HDPublicKey.CheckSumSize;\n\nassert(HDPublicKey.PublicKeyEnd === HDPublicKey.DataSize);\nassert(HDPublicKey.ChecksumEnd === HDPublicKey.SerializedByteSize);\n\nmodule.exports = HDPublicKey;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}