{"ast":null,"code":"'use strict';\n\nvar defined = require('./utils').defined;\n\nvar varint = require('varint');\n\nfunction compileEncode(m, resolve, enc, oneofs, encodingLength) {\n  const oneofsKeys = Object.keys(oneofs);\n  const encLength = enc.length;\n  const ints = {};\n\n  for (let i = 0; i < encLength; i++) {\n    ints[i] = {\n      p: varint.encode(m.fields[i].tag << 3 | 2),\n      h: varint.encode(m.fields[i].tag << 3 | enc[i].type)\n    };\n    const field = m.fields[i];\n    m.fields[i].packed = field.repeated && field.options && field.options.packed && field.options.packed !== 'false';\n  }\n\n  function encodeField(buf, view, offset, h, e, packed, innerVal) {\n    let j = 0;\n\n    if (!packed) {\n      for (j = 0; j < h.length; j++) {\n        buf[offset++] = h[j];\n      }\n    }\n\n    if (e.message) {\n      varint.encode(e.encodingLength(innerVal), buf, offset);\n      offset += varint.encode.bytes;\n    }\n\n    e.encode(innerVal, buf, view, offset);\n    return offset + e.encode.bytes;\n  }\n\n  return function encode(obj, buf, view) {\n    let offset = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n\n    if (buf == null) {\n      buf = new Uint8Array(encodingLength(obj));\n    }\n\n    if (view == null) {\n      view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);\n    }\n\n    const oldOffset = offset;\n    const objKeys = Object.keys(obj);\n    let i = 0; // oneof checks\n\n    let match = false;\n\n    for (i = 0; i < oneofsKeys.length; i++) {\n      const name = oneofsKeys[i];\n      const prop = oneofs[i];\n\n      if (objKeys.indexOf(prop) > -1) {\n        if (match) {\n          throw new Error('only one of the properties defined in oneof ' + name + ' can be set');\n        }\n\n        match = true;\n      }\n    }\n\n    for (i = 0; i < encLength; i++) {\n      const e = enc[i];\n      const field = m.fields[i]; // was f\n\n      let val = obj[field.name];\n      let j = 0;\n\n      if (!defined(val)) {\n        if (field.required) {\n          throw new Error(field.name + ' is required');\n        }\n\n        continue;\n      }\n\n      const p = ints[i].p;\n      const h = ints[i].h;\n      const packed = field.packed;\n\n      if (field.map) {\n        const tmp = Object.keys(val);\n\n        for (j = 0; j < tmp.length; j++) {\n          tmp[j] = {\n            key: tmp[j],\n            value: val[tmp[j]]\n          };\n        }\n\n        val = tmp;\n      }\n\n      if (packed) {\n        let packedLen = 0;\n\n        for (j = 0; j < val.length; j++) {\n          if (!Object.prototype.hasOwnProperty.call(val, j)) {\n            continue;\n          }\n\n          packedLen += e.encodingLength(val[j]);\n        }\n\n        if (packedLen) {\n          for (j = 0; j < h.length; j++) {\n            buf[offset++] = p[j];\n          }\n\n          varint.encode(packedLen, buf, offset);\n          offset += varint.encode.bytes;\n        }\n      }\n\n      if (field.repeated) {\n        let innerVal;\n\n        for (j = 0; j < val.length; j++) {\n          innerVal = val[j];\n\n          if (!defined(innerVal)) {\n            continue;\n          }\n\n          offset = encodeField(buf, view, offset, h, e, packed, innerVal);\n        }\n      } else {\n        offset = encodeField(buf, view, offset, h, e, packed, val);\n      }\n    }\n\n    encode.bytes = offset - oldOffset;\n    return buf;\n  };\n}\n\nmodule.exports = compileEncode;","map":{"version":3,"names":["defined","require","varint","compileEncode","m","resolve","enc","oneofs","encodingLength","oneofsKeys","Object","keys","encLength","length","ints","i","p","encode","fields","tag","h","type","field","packed","repeated","options","encodeField","buf","view","offset","e","innerVal","j","message","bytes","obj","Uint8Array","DataView","buffer","byteOffset","byteLength","oldOffset","objKeys","match","name","prop","indexOf","Error","val","required","map","tmp","key","value","packedLen","prototype","hasOwnProperty","call","module","exports"],"sources":["C:/Users/acer/node_modules/protons/src/compile/encode.js"],"sourcesContent":["'use strict'\n\nvar defined = require('./utils').defined\nvar varint = require('varint')\n\nfunction compileEncode (m, resolve, enc, oneofs, encodingLength) {\n  const oneofsKeys = Object.keys(oneofs)\n  const encLength = enc.length\n  const ints = {}\n  for (let i = 0; i < encLength; i++) {\n    ints[i] = {\n      p: varint.encode(m.fields[i].tag << 3 | 2),\n      h: varint.encode(m.fields[i].tag << 3 | enc[i].type)\n    }\n\n    const field = m.fields[i]\n    m.fields[i].packed = field.repeated && field.options && field.options.packed && field.options.packed !== 'false'\n  }\n\n  function encodeField (buf, view, offset, h, e, packed, innerVal) {\n    let j = 0\n    if (!packed) {\n      for (j = 0; j < h.length; j++) {\n        buf[offset++] = h[j]\n      }\n    }\n\n    if (e.message) {\n      varint.encode(e.encodingLength(innerVal), buf, offset)\n      offset += varint.encode.bytes\n    }\n\n    e.encode(innerVal, buf, view, offset)\n\n    return offset + e.encode.bytes\n  }\n\n  return function encode (obj, buf, view, offset = 0) {\n    if (buf == null) {\n      buf = new Uint8Array(encodingLength(obj))\n    }\n\n    if (view == null) {\n      view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength)\n    }\n\n    const oldOffset = offset\n    const objKeys = Object.keys(obj)\n    let i = 0\n\n    // oneof checks\n\n    let match = false\n    for (i = 0; i < oneofsKeys.length; i++) {\n      const name = oneofsKeys[i]\n      const prop = oneofs[i]\n      if (objKeys.indexOf(prop) > -1) {\n        if (match) {\n          throw new Error('only one of the properties defined in oneof ' + name + ' can be set')\n        }\n\n        match = true\n      }\n    }\n\n    for (i = 0; i < encLength; i++) {\n      const e = enc[i]\n      const field = m.fields[i] // was f\n      let val = obj[field.name]\n      let j = 0\n\n      if (!defined(val)) {\n        if (field.required) {\n          throw new Error(field.name + ' is required')\n        }\n        continue\n      }\n      const p = ints[i].p\n      const h = ints[i].h\n\n      const packed = field.packed\n\n      if (field.map) {\n        const tmp = Object.keys(val)\n        for (j = 0; j < tmp.length; j++) {\n          tmp[j] = {\n            key: tmp[j],\n            value: val[tmp[j]]\n          }\n        }\n        val = tmp\n      }\n\n      if (packed) {\n        let packedLen = 0\n        for (j = 0; j < val.length; j++) {\n          if (!Object.prototype.hasOwnProperty.call(val, j)) {\n            continue\n          }\n\n          packedLen += e.encodingLength(val[j])\n        }\n\n        if (packedLen) {\n          for (j = 0; j < h.length; j++) {\n            buf[offset++] = p[j]\n          }\n          varint.encode(packedLen, buf, offset)\n          offset += varint.encode.bytes\n        }\n      }\n\n      if (field.repeated) {\n        let innerVal\n        for (j = 0; j < val.length; j++) {\n          innerVal = val[j]\n          if (!defined(innerVal)) {\n            continue\n          }\n\n          offset = encodeField(buf, view, offset, h, e, packed, innerVal)\n        }\n      } else {\n        offset = encodeField(buf, view, offset, h, e, packed, val)\n      }\n    }\n\n    encode.bytes = offset - oldOffset\n    return buf\n  }\n}\n\nmodule.exports = compileEncode\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}