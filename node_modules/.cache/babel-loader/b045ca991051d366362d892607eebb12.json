{"ast":null,"code":"import { randomBytes } from 'crypto';\nimport { ec as EC } from 'elliptic';\nconst curve = new EC('secp256k1');\nconst N = Buffer.from('fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141', 'hex');\nconst ZERO = Buffer.alloc(32, 0);\n\nfunction isValidPrivateKey(key) {\n  return Buffer.isBuffer(key) && key.length === 32 && !key.equals(ZERO) && key.compare(N) < 0;\n}\n\nfunction isValidMessageHash(hash) {\n  return Buffer.isBuffer(hash) && hash.length === 32;\n}\n/** secp256k1 methods set */\n\n\nexport var secp256k1;\n\n(function (secp256k1) {\n  /**\n   * generate private key\n   * @param rng the optional random number generator, which exactly generates 32 random bytes\n   */\n  function generatePrivateKey(rng) {\n    rng = rng || (() => randomBytes(32));\n\n    for (;;) {\n      const privKey = rng();\n\n      if (isValidPrivateKey(privKey)) {\n        return privKey;\n      }\n    }\n  }\n\n  secp256k1.generatePrivateKey = generatePrivateKey;\n  /**\n   * derive public key(uncompressed) from private key\n   * @param privKey the private key\n   */\n\n  function derivePublicKey(privKey) {\n    if (!isValidPrivateKey(privKey)) {\n      throw new Error('invalid private key');\n    }\n\n    const keyPair = curve.keyFromPrivate(privKey);\n    return Buffer.from(keyPair.getPublic().encode('array', false));\n  }\n\n  secp256k1.derivePublicKey = derivePublicKey;\n  /**\n   * sign a message using elliptic curve algorithm on the curve secp256k1\n   * @param msgHash hash of message\n   * @param privKey serialized private key\n   */\n\n  function sign(msgHash, privKey) {\n    if (!isValidMessageHash(msgHash)) {\n      throw new Error('invalid message hash');\n    }\n\n    if (!isValidPrivateKey(privKey)) {\n      throw new Error('invalid private key');\n    }\n\n    const keyPair = curve.keyFromPrivate(privKey);\n    const sig = keyPair.sign(msgHash, {\n      canonical: true\n    });\n    const r = Buffer.from(sig.r.toArray('be', 32));\n    const s = Buffer.from(sig.s.toArray('be', 32));\n    return Buffer.concat([r, s, Buffer.from([sig.recoveryParam])]);\n  }\n\n  secp256k1.sign = sign;\n  /**\n   * recovery signature to public key\n   * @param msgHash hash of message\n   * @param sig signature\n   */\n\n  function recover(msgHash, sig) {\n    if (!isValidMessageHash(msgHash)) {\n      throw new Error('invalid message hash');\n    }\n\n    if (!Buffer.isBuffer(sig) || sig.length !== 65) {\n      throw new Error('invalid signature');\n    }\n\n    const recovery = sig[64];\n\n    if (recovery !== 0 && recovery !== 1) {\n      throw new Error('invalid signature recovery');\n    }\n\n    const r = sig.slice(0, 32);\n    const s = sig.slice(32, 64);\n    return Buffer.from(curve.recoverPubKey(msgHash, {\n      r,\n      s\n    }, recovery).encode('array', false));\n  }\n\n  secp256k1.recover = recover;\n})(secp256k1 || (secp256k1 = {}));","map":{"version":3,"mappings":"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","names":["randomBytes","ec","EC","curve","N","Buffer","from","ZERO","alloc","isValidPrivateKey","key","isBuffer","length","equals","compare","isValidMessageHash","hash","secp256k1","generatePrivateKey","rng","privKey","derivePublicKey","Error","keyPair","keyFromPrivate","getPublic","encode","sign","msgHash","sig","canonical","r","toArray","s","concat","recoveryParam","recover","recovery","slice","recoverPubKey"],"sourceRoot":"","sources":["../../src/cry/secp256k1.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"module"}