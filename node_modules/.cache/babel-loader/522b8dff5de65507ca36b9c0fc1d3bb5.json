{"ast":null,"code":"'use strict';\n\nconst cbor = require('borc');\n\nconst multicodec = require('multicodec');\n\nconst multihashing = require('multihashing-async');\n\nconst CID = require('cids');\n\nconst isCircular = require('is-circular');\n\nconst uint8ArrayConcat = require('uint8arrays/concat');\n\nconst uint8ArrayFromString = require('uint8arrays/from-string'); // https://github.com/ipfs/go-ipfs/issues/3570#issuecomment-273931692\n\n\nconst CID_CBOR_TAG = 42;\n\nfunction tagCID(cid) {\n  if (typeof cid === 'string') {\n    cid = new CID(cid).bytes;\n  } else if (CID.isCID(cid)) {\n    cid = cid.bytes;\n  }\n\n  return new cbor.Tagged(CID_CBOR_TAG, uint8ArrayConcat([uint8ArrayFromString('00', 'base16'), // thanks jdag\n  cid], 1 + cid.length));\n}\n\nfunction replaceCIDbyTAG(dagNode) {\n  let circular;\n\n  try {\n    circular = isCircular(dagNode);\n  } catch (e) {\n    circular = false;\n  }\n\n  if (circular) {\n    throw new Error('The object passed has circular references');\n  }\n\n  function transform(obj) {\n    if (!obj || obj instanceof Uint8Array || typeof obj === 'string') {\n      return obj;\n    }\n\n    if (Array.isArray(obj)) {\n      return obj.map(transform);\n    }\n\n    if (CID.isCID(obj)) {\n      return tagCID(obj);\n    }\n\n    const keys = Object.keys(obj);\n\n    if (keys.length > 0) {\n      // Recursive transform\n      const out = {};\n      keys.forEach(key => {\n        if (typeof obj[key] === 'object') {\n          out[key] = transform(obj[key]);\n        } else {\n          out[key] = obj[key];\n        }\n      });\n      return out;\n    } else {\n      return obj;\n    }\n  }\n\n  return transform(dagNode);\n}\n\nconst codec = multicodec.DAG_CBOR;\nconst defaultHashAlg = multicodec.SHA2_256;\nconst defaultTags = {\n  [CID_CBOR_TAG]: val => {\n    // remove that 0\n    val = val.slice(1);\n    return new CID(val);\n  }\n};\nconst defaultSize = 64 * 1024; // current decoder heap size, 64 Kb\n\nlet currentSize = defaultSize;\nconst defaultMaxSize = 64 * 1024 * 1024; // max heap size when auto-growing, 64 Mb\n\nlet maxSize = defaultMaxSize;\nlet decoder = null;\n/**\n * Configure the underlying CBOR decoder.\n *\n * @param {Object} [options] - The options the decoder takes. The decoder will reset to the defaul values if no options are given.\n * @param {number} [options.size=65536] - The current heap size used in CBOR parsing, this may grow automatically as larger blocks are encountered up to `maxSize`\n * @param {number} [options.maxSize=67108864] - The maximum size the CBOR parsing heap is allowed to grow to before `dagCBOR.util.deserialize()` returns an error\n * @param {Object} [options.tags] - An object whose keys are CBOR tag numbers and values are transform functions that accept a `value` and return a decoded representation of that `value`\n */\n\nfunction configureDecoder(options) {\n  let tags = defaultTags;\n\n  if (options) {\n    if (typeof options.size === 'number') {\n      currentSize = options.size;\n    }\n\n    if (typeof options.maxSize === 'number') {\n      maxSize = options.maxSize;\n    }\n\n    if (options.tags) {\n      tags = Object.assign({}, defaultTags, options && options.tags);\n    }\n  } else {\n    // no options, reset to defaults\n    currentSize = defaultSize;\n    maxSize = defaultMaxSize;\n  }\n\n  const decoderOptions = {\n    tags,\n    size: currentSize\n  };\n  decoder = new cbor.Decoder(decoderOptions); // borc edits opts.size in-place so we can capture _actual_ size\n\n  currentSize = decoderOptions.size;\n}\n\nconfigureDecoder(); // Setup default cbor.Decoder\n\n/**\n * Serialize internal representation into a binary CBOR block.\n *\n * @param {Object} node - Internal representation of a CBOR block\n * @returns {Uint8Array} - The encoded binary representation\n */\n\nfunction serialize(node) {\n  const nodeTagged = replaceCIDbyTAG(node);\n  const serialized = cbor.encode(nodeTagged);\n  return serialized;\n}\n/**\n * Deserialize CBOR block into the internal representation.\n *\n * @param {Uint8Array} data - Binary representation of a CBOR block\n * @returns {Object} - An object that conforms to the IPLD Data Model\n */\n\n\nfunction deserialize(data) {\n  if (data.length > currentSize && data.length <= maxSize) {\n    configureDecoder({\n      size: data.length\n    });\n  }\n\n  if (data.length > currentSize) {\n    throw new Error('Data is too large to deserialize with current decoder');\n  } // borc will decode back-to-back objects into an implicit top-level array, we\n  // strictly want to only see a single explicit top-level object\n\n\n  const all = decoder.decodeAll(data);\n\n  if (all.length !== 1) {\n    throw new Error('Extraneous CBOR data found beyond initial top-level object');\n  }\n\n  return all[0];\n}\n/**\n * Calculate the CID of the binary blob.\n *\n * @param {Object} binaryBlob - Encoded IPLD Node\n * @param {Object} [userOptions] - Options to create the CID\n * @param {number} [userOptions.cidVersion=1] - CID version number\n * @param {string} [userOptions.hashAlg] - Defaults to the defaultHashAlg of the format\n * @returns {Promise.<CID>}\n */\n\n\nasync function cid(binaryBlob, userOptions) {\n  const defaultOptions = {\n    cidVersion: 1,\n    hashAlg: defaultHashAlg\n  };\n  const options = Object.assign(defaultOptions, userOptions);\n  const multihash = await multihashing(binaryBlob, options.hashAlg);\n  const codecName = multicodec.getNameFromCode(codec);\n  const cid = new CID(options.cidVersion, codecName, multihash);\n  return cid;\n}\n\nmodule.exports = {\n  codec,\n  defaultHashAlg,\n  configureDecoder,\n  serialize,\n  deserialize,\n  cid\n};","map":{"version":3,"names":["cbor","require","multicodec","multihashing","CID","isCircular","uint8ArrayConcat","uint8ArrayFromString","CID_CBOR_TAG","tagCID","cid","bytes","isCID","Tagged","length","replaceCIDbyTAG","dagNode","circular","e","Error","transform","obj","Uint8Array","Array","isArray","map","keys","Object","out","forEach","key","codec","DAG_CBOR","defaultHashAlg","SHA2_256","defaultTags","val","slice","defaultSize","currentSize","defaultMaxSize","maxSize","decoder","configureDecoder","options","tags","size","assign","decoderOptions","Decoder","serialize","node","nodeTagged","serialized","encode","deserialize","data","all","decodeAll","binaryBlob","userOptions","defaultOptions","cidVersion","hashAlg","multihash","codecName","getNameFromCode","module","exports"],"sources":["C:/Users/acer/node_modules/ipld-dag-cbor/src/util.js"],"sourcesContent":["'use strict'\n\nconst cbor = require('borc')\nconst multicodec = require('multicodec')\nconst multihashing = require('multihashing-async')\nconst CID = require('cids')\nconst isCircular = require('is-circular')\nconst uint8ArrayConcat = require('uint8arrays/concat')\nconst uint8ArrayFromString = require('uint8arrays/from-string')\n\n// https://github.com/ipfs/go-ipfs/issues/3570#issuecomment-273931692\nconst CID_CBOR_TAG = 42\n\nfunction tagCID (cid) {\n  if (typeof cid === 'string') {\n    cid = new CID(cid).bytes\n  } else if (CID.isCID(cid)) {\n    cid = cid.bytes\n  }\n\n  return new cbor.Tagged(CID_CBOR_TAG, uint8ArrayConcat([\n    uint8ArrayFromString('00', 'base16'), // thanks jdag\n    cid\n  ], 1 + cid.length))\n}\n\nfunction replaceCIDbyTAG (dagNode) {\n  let circular\n  try {\n    circular = isCircular(dagNode)\n  } catch (e) {\n    circular = false\n  }\n  if (circular) {\n    throw new Error('The object passed has circular references')\n  }\n\n  function transform (obj) {\n    if (!obj || obj instanceof Uint8Array || typeof obj === 'string') {\n      return obj\n    }\n\n    if (Array.isArray(obj)) {\n      return obj.map(transform)\n    }\n\n    if (CID.isCID(obj)) {\n      return tagCID(obj)\n    }\n\n    const keys = Object.keys(obj)\n\n    if (keys.length > 0) {\n      // Recursive transform\n      const out = {}\n      keys.forEach((key) => {\n        if (typeof obj[key] === 'object') {\n          out[key] = transform(obj[key])\n        } else {\n          out[key] = obj[key]\n        }\n      })\n      return out\n    } else {\n      return obj\n    }\n  }\n\n  return transform(dagNode)\n}\n\nconst codec = multicodec.DAG_CBOR\nconst defaultHashAlg = multicodec.SHA2_256\n\nconst defaultTags = {\n  [CID_CBOR_TAG]: (val) => {\n    // remove that 0\n    val = val.slice(1)\n    return new CID(val)\n  }\n}\nconst defaultSize = 64 * 1024 // current decoder heap size, 64 Kb\nlet currentSize = defaultSize\nconst defaultMaxSize = 64 * 1024 * 1024 // max heap size when auto-growing, 64 Mb\nlet maxSize = defaultMaxSize\nlet decoder = null\n\n/**\n * Configure the underlying CBOR decoder.\n *\n * @param {Object} [options] - The options the decoder takes. The decoder will reset to the defaul values if no options are given.\n * @param {number} [options.size=65536] - The current heap size used in CBOR parsing, this may grow automatically as larger blocks are encountered up to `maxSize`\n * @param {number} [options.maxSize=67108864] - The maximum size the CBOR parsing heap is allowed to grow to before `dagCBOR.util.deserialize()` returns an error\n * @param {Object} [options.tags] - An object whose keys are CBOR tag numbers and values are transform functions that accept a `value` and return a decoded representation of that `value`\n */\nfunction configureDecoder (options) {\n  let tags = defaultTags\n\n  if (options) {\n    if (typeof options.size === 'number') {\n      currentSize = options.size\n    }\n    if (typeof options.maxSize === 'number') {\n      maxSize = options.maxSize\n    }\n    if (options.tags) {\n      tags = Object.assign({}, defaultTags, options && options.tags)\n    }\n  } else {\n    // no options, reset to defaults\n    currentSize = defaultSize\n    maxSize = defaultMaxSize\n  }\n\n  const decoderOptions = {\n    tags,\n    size: currentSize\n  }\n\n  decoder = new cbor.Decoder(decoderOptions)\n  // borc edits opts.size in-place so we can capture _actual_ size\n  currentSize = decoderOptions.size\n}\n\nconfigureDecoder() // Setup default cbor.Decoder\n\n/**\n * Serialize internal representation into a binary CBOR block.\n *\n * @param {Object} node - Internal representation of a CBOR block\n * @returns {Uint8Array} - The encoded binary representation\n */\nfunction serialize (node) {\n  const nodeTagged = replaceCIDbyTAG(node)\n  const serialized = cbor.encode(nodeTagged)\n\n  return serialized\n}\n\n/**\n * Deserialize CBOR block into the internal representation.\n *\n * @param {Uint8Array} data - Binary representation of a CBOR block\n * @returns {Object} - An object that conforms to the IPLD Data Model\n */\nfunction deserialize (data) {\n  if (data.length > currentSize && data.length <= maxSize) {\n    configureDecoder({ size: data.length })\n  }\n\n  if (data.length > currentSize) {\n    throw new Error('Data is too large to deserialize with current decoder')\n  }\n\n  // borc will decode back-to-back objects into an implicit top-level array, we\n  // strictly want to only see a single explicit top-level object\n  const all = decoder.decodeAll(data)\n  if (all.length !== 1) {\n    throw new Error('Extraneous CBOR data found beyond initial top-level object')\n  }\n\n  return all[0]\n}\n\n/**\n * Calculate the CID of the binary blob.\n *\n * @param {Object} binaryBlob - Encoded IPLD Node\n * @param {Object} [userOptions] - Options to create the CID\n * @param {number} [userOptions.cidVersion=1] - CID version number\n * @param {string} [userOptions.hashAlg] - Defaults to the defaultHashAlg of the format\n * @returns {Promise.<CID>}\n */\nasync function cid (binaryBlob, userOptions) {\n  const defaultOptions = { cidVersion: 1, hashAlg: defaultHashAlg }\n  const options = Object.assign(defaultOptions, userOptions)\n\n  const multihash = await multihashing(binaryBlob, options.hashAlg)\n  const codecName = multicodec.getNameFromCode(codec)\n  const cid = new CID(options.cidVersion, codecName, multihash)\n\n  return cid\n}\n\nmodule.exports = {\n  codec,\n  defaultHashAlg,\n  configureDecoder,\n  serialize,\n  deserialize,\n  cid\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}