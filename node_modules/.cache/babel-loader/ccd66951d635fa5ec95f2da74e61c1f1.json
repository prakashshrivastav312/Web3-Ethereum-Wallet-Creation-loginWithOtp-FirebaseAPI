{"ast":null,"code":"var typeforce = require('typeforce');\n\nvar types = require('./types');\n\nvar BigInteger = require('bigi');\n\nvar ECSignature = require('./ecsignature');\n\nvar crypto = require('./crypto');\n\nvar ecurve = require('ecurve');\n\nvar secp256k1 = ecurve.getCurveByName('secp256k1');\n\nvar deterministicGenerateK = require('./rfc6979').deterministicGenerateK;\n\nvar USE_RFC6979 = true;\n\nfunction sign(h, x) {\n  typeforce(types.tuple(types.BufferN(32), types.BigInt), arguments);\n  var n = secp256k1.n;\n  var G = secp256k1.G;\n\n  if (x.compareTo(BigInteger.ZERO) <= 0 || x.compareTo(n) >= 0) {\n    throw new Error('Private key x not in range');\n  }\n\n  var P = G.multiply(x);\n  var r, s;\n\n  function signWithK(k) {\n    var R = G.multiply(k); // sign chosen so that the Y coordinate of R has Jacobi symbol 1\n\n    if (jacobi(R.affineY, secp256k1.p) != 1) {\n      k = n.subtract(k); // R doesn't need to be updated here\n      // as we only need the x coordinate\n      // which wouldn't change with negative k\n    }\n\n    r = R.affineX.mod(n);\n    var BP = toCompressedPoint(P);\n    var Br = r.toBuffer(32);\n    var eh = crypto.sha256(Buffer.concat([Br, BP, h]));\n    var e = BigInteger.fromBuffer(eh).mod(n);\n    s = k.add(e.multiply(x)).mod(n);\n    return true;\n  }\n\n  if (USE_RFC6979) {\n    deterministicGenerateK(h, x.toBuffer(32), signWithK, Buffer.from('Schnorr+SHA256  ', 'ascii'));\n  } else {\n    // Wuille's nonce generation:\n    // https://github.com/sipa/bips/blob/bip-schnorr/bip-schnorr/reference.py#L63\n    var kh = crypto.sha256(Buffer.concat([x.toBuffer(32), h]));\n    var k = BigInteger.fromBuffer(kh).mod(n);\n    signWithK(k);\n  }\n\n  return new ECSignature(r, s);\n} // https://github.com/bitcoincashorg/bitcoincash.org/blob/master/spec/2019-05-15-schnorr.md#signature-verification-algorithm\n\n\nfunction verify(h, signature, P) {\n  typeforce(types.tuple(types.BufferN(32), types.ECSignature, types.ECPoint), arguments);\n  var n = secp256k1.n;\n  var G = secp256k1.G;\n  var r = signature.r;\n  var s = signature.s; // 1. Fail if point P is not actually on the curve, or if it is the point at infinity.\n\n  if (!secp256k1.isOnCurve(P)) return false;\n  if (secp256k1.isInfinity(P)) return false; // 2. Fail if r >= p, where p is the field size used in secp256k1.\n\n  if (r.compareTo(secp256k1.p) >= 0) return false; // 3. Fail if s >= n, where n is the order of the secp256k1 curve.\n\n  if (s.compareTo(n) >= 0) return false; // 4. Let BP be the 33-byte encoding of P as a compressed point.\n\n  var BP = toCompressedPoint(P); // 5. Let Br be the 32-byte encoding of r as an unsigned big-endian 256-bit integer.\n\n  var Br = r.toBuffer(32); // 6. Compute integer e = H(Br | BP | h) mod n.\n\n  var h = crypto.sha256(Buffer.concat([Br, BP, h]));\n  var e = BigInteger.fromBuffer(h).mod(n); // 7. Compute elliptic curve point R' = sG + (-e)P, where G is the secp256k1 generator point.\n\n  var R = G.multiply(s).add(P.multiply(n.subtract(e))); // 8. Fail if R' is the point at infinity.\n\n  if (secp256k1.isInfinity(R)) return false; // 9. Fail if the X coordinate of R' is not equal to r.\n\n  if (R.affineX.compareTo(r) != 0) return false; // 10. Fail if the Jacobi symbol of the Y coordinate of R' is not 1.\n\n  if (jacobi(R.affineY, secp256k1.p) != 1) return false; // 11. Otherwise, the signature is valid\n\n  return true;\n}\n\nfunction jacobi(a, p) {\n  return a.modPow(p.subtract(BigInteger.ONE).divide(BigInteger.valueOf(2)), p).intValue();\n}\n\nfunction toCompressedPoint(P) {\n  typeforce(types.tuple(types.ECPoint), arguments);\n  return Buffer.concat([Buffer.from([P.affineY.isEven() ? 0x02 : 0x03]), P.affineX.toBuffer(32)]);\n}\n\nfunction fromCompressedPoint(buffer) {\n  typeforce(types.tuple(types.BufferN(33)), arguments);\n  if (buffer.length !== 33) throw new Error('Invalid length of buffer');\n  if (buffer[0] !== 0x2 && buffer[0] !== 0x3) throw new Error('Invalid signum byte');\n  var isOdd = buffer[0] === 0x3;\n  var x = BigInteger.fromBuffer(buffer.slice(1, 33));\n  return secp256k1.pointFromX(isOdd, x);\n}\n\nmodule.exports = {\n  deterministicGenerateK: deterministicGenerateK,\n  sign: sign,\n  verify: verify,\n  jacobi: jacobi,\n  toCompressedPoint: toCompressedPoint,\n  fromCompressedPoint: fromCompressedPoint,\n  // TODO: remove\n  __curve: secp256k1,\n  // If disabled, Wuille's nonce generation instead of RFC6979 will be used\n  // https://github.com/sipa/bips/blob/bip-schnorr/bip-schnorr/reference.py#L63\n  __useRFC6979: function (use) {\n    if (typeof use !== 'boolean') {\n      throw new Error(\"'use' must be a boolean\");\n    }\n\n    USE_RFC6979 = use;\n  }\n};","map":{"version":3,"names":["typeforce","require","types","BigInteger","ECSignature","crypto","ecurve","secp256k1","getCurveByName","deterministicGenerateK","USE_RFC6979","sign","h","x","tuple","BufferN","BigInt","arguments","n","G","compareTo","ZERO","Error","P","multiply","r","s","signWithK","k","R","jacobi","affineY","p","subtract","affineX","mod","BP","toCompressedPoint","Br","toBuffer","eh","sha256","Buffer","concat","e","fromBuffer","add","from","kh","verify","signature","ECPoint","isOnCurve","isInfinity","a","modPow","ONE","divide","valueOf","intValue","isEven","fromCompressedPoint","buffer","length","isOdd","slice","pointFromX","module","exports","__curve","__useRFC6979","use"],"sources":["C:/Users/acer/node_modules/@tatumio/bitcoincashjs2-lib/src/schnorr.js"],"sourcesContent":["var typeforce = require('typeforce')\nvar types = require('./types')\n\nvar BigInteger = require('bigi')\nvar ECSignature = require('./ecsignature')\nvar crypto = require('./crypto')\n\nvar ecurve = require('ecurve')\nvar secp256k1 = ecurve.getCurveByName('secp256k1')\n\nvar deterministicGenerateK = require('./rfc6979').deterministicGenerateK\n\nvar USE_RFC6979 = true\nfunction sign(h, x) {\n  typeforce(types.tuple(\n    types.BufferN(32),\n    types.BigInt\n  ), arguments)\n\n  var n = secp256k1.n\n  var G = secp256k1.G\n\n  if(x.compareTo(BigInteger.ZERO) <= 0 || x.compareTo(n) >= 0){\n    throw new Error('Private key x not in range')\n  }\n\n  var P = G.multiply(x);\n\n  var r, s\n  function signWithK(k){\n    var R = G.multiply(k)\n\n    // sign chosen so that the Y coordinate of R has Jacobi symbol 1\n    if(jacobi(R.affineY, secp256k1.p) != 1){\n      k = n.subtract(k)\n      // R doesn't need to be updated here\n      // as we only need the x coordinate\n      // which wouldn't change with negative k\n    }\n\n    r = R.affineX.mod(n)\n\n    var BP = toCompressedPoint(P)\n    var Br = r.toBuffer(32)\n\n    var eh = crypto.sha256(Buffer.concat([Br, BP, h]))\n    var e = BigInteger.fromBuffer(eh).mod(n)\n\n    s = k.add(e.multiply(x)).mod(n)\n\n    return true\n  }\n\n  if(USE_RFC6979){\n    deterministicGenerateK(h, x.toBuffer(32), signWithK, Buffer.from('Schnorr+SHA256  ', 'ascii'))\n  } else {\n    // Wuille's nonce generation:\n    // https://github.com/sipa/bips/blob/bip-schnorr/bip-schnorr/reference.py#L63\n    var kh = crypto.sha256(Buffer.concat([x.toBuffer(32), h]))\n    var k = BigInteger.fromBuffer(kh).mod(n)\n    signWithK(k)\n  }\n\n  return new ECSignature(r, s)\n}\n\n// https://github.com/bitcoincashorg/bitcoincash.org/blob/master/spec/2019-05-15-schnorr.md#signature-verification-algorithm\nfunction verify (h, signature, P) {\n  typeforce(types.tuple(\n    types.BufferN(32),\n    types.ECSignature,\n    types.ECPoint\n  ), arguments)\n\n  var n = secp256k1.n\n  var G = secp256k1.G\n\n  var r = signature.r\n  var s = signature.s\n\n  // 1. Fail if point P is not actually on the curve, or if it is the point at infinity.\n  if(!secp256k1.isOnCurve(P)) return false\n  if(secp256k1.isInfinity(P)) return false\n\n  // 2. Fail if r >= p, where p is the field size used in secp256k1.\n  if(r.compareTo(secp256k1.p) >= 0) return false\n\n  // 3. Fail if s >= n, where n is the order of the secp256k1 curve.\n  if(s.compareTo(n) >= 0) return false\n\n  // 4. Let BP be the 33-byte encoding of P as a compressed point.\n  var BP = toCompressedPoint(P)\n\n  // 5. Let Br be the 32-byte encoding of r as an unsigned big-endian 256-bit integer.\n  var Br = r.toBuffer(32)\n\n  // 6. Compute integer e = H(Br | BP | h) mod n.\n  var h = crypto.sha256(Buffer.concat([Br, BP, h]))\n  var e = BigInteger.fromBuffer(h).mod(n)\n\n  // 7. Compute elliptic curve point R' = sG + (-e)P, where G is the secp256k1 generator point.\n  var R = G.multiply(s).add(P.multiply(n.subtract(e)))\n\n  // 8. Fail if R' is the point at infinity.\n  if(secp256k1.isInfinity(R)) return false\n\n  // 9. Fail if the X coordinate of R' is not equal to r.\n  if(R.affineX.compareTo(r) != 0) return false\n\n  // 10. Fail if the Jacobi symbol of the Y coordinate of R' is not 1.\n  if(jacobi(R.affineY, secp256k1.p) != 1) return false\n\n  // 11. Otherwise, the signature is valid\n  return true\n}\n\nfunction jacobi(a, p){\n  return a.modPow(p.subtract(BigInteger.ONE).divide(BigInteger.valueOf(2)), p).intValue();\n}\n\nfunction toCompressedPoint(P){\n  typeforce(types.tuple(\n    types.ECPoint\n  ), arguments)\n\n  return Buffer.concat([Buffer.from([P.affineY.isEven() ? 0x02 : 0x03]), P.affineX.toBuffer(32)]);\n}\n\nfunction fromCompressedPoint(buffer){\n  typeforce(types.tuple(\n    types.BufferN(33)\n  ), arguments)\n\n  if(buffer.length !== 33) throw new Error('Invalid length of buffer')\n  if(buffer[0] !== 0x2 && buffer[0] !== 0x3) throw new Error('Invalid signum byte')\n\n  var isOdd = buffer[0] === 0x3\n  var x = BigInteger.fromBuffer(buffer.slice(1, 33))\n\n  return secp256k1.pointFromX(isOdd, x)\n}\n\nmodule.exports = {\n  deterministicGenerateK: deterministicGenerateK,\n  sign: sign,\n  verify: verify,\n\n  jacobi: jacobi,\n  toCompressedPoint: toCompressedPoint,\n  fromCompressedPoint: fromCompressedPoint,\n\n  // TODO: remove\n  __curve: secp256k1,\n\n  // If disabled, Wuille's nonce generation instead of RFC6979 will be used\n  // https://github.com/sipa/bips/blob/bip-schnorr/bip-schnorr/reference.py#L63\n  __useRFC6979: function(use){\n    if(typeof use !== 'boolean'){\n      throw new Error(\"'use' must be a boolean\");\n    }\n\n    USE_RFC6979 = use\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}