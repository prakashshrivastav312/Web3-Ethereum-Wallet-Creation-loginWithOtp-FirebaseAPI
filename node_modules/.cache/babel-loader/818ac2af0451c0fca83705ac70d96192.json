{"ast":null,"code":"\"use strict\";\n\nfunction __export(m) {\n  for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n}\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar ClassTransformer_1 = require(\"./ClassTransformer\");\n\nvar ClassTransformer_2 = require(\"./ClassTransformer\");\n\nexports.ClassTransformer = ClassTransformer_2.ClassTransformer;\n\n__export(require(\"./decorators\"));\n\nvar classTransformer = new ClassTransformer_1.ClassTransformer();\n\nfunction classToPlain(object, options) {\n  return classTransformer.classToPlain(object, options);\n}\n\nexports.classToPlain = classToPlain;\n\nfunction classToPlainFromExist(object, plainObject, options) {\n  return classTransformer.classToPlainFromExist(object, plainObject, options);\n}\n\nexports.classToPlainFromExist = classToPlainFromExist;\n\nfunction plainToClass(cls, plain, options) {\n  return classTransformer.plainToClass(cls, plain, options);\n}\n\nexports.plainToClass = plainToClass;\n\nfunction plainToClassFromExist(clsObject, plain, options) {\n  return classTransformer.plainToClassFromExist(clsObject, plain, options);\n}\n\nexports.plainToClassFromExist = plainToClassFromExist;\n\nfunction classToClass(object, options) {\n  return classTransformer.classToClass(object, options);\n}\n\nexports.classToClass = classToClass;\n\nfunction classToClassFromExist(object, fromObject, options) {\n  return classTransformer.classToClassFromExist(object, fromObject, options);\n}\n\nexports.classToClassFromExist = classToClassFromExist;\n\nfunction serialize(object, options) {\n  return classTransformer.serialize(object, options);\n}\n\nexports.serialize = serialize;\n/**\n * Deserializes given JSON string to a object of the given class.\n */\n\nfunction deserialize(cls, json, options) {\n  return classTransformer.deserialize(cls, json, options);\n}\n\nexports.deserialize = deserialize;\n/**\n * Deserializes given JSON string to an array of objects of the given class.\n */\n\nfunction deserializeArray(cls, json, options) {\n  return classTransformer.deserializeArray(cls, json, options);\n}\n\nexports.deserializeArray = deserializeArray;\n/**\n * Enum representing the different transformation types.\n */\n\nvar TransformationType;\n\n(function (TransformationType) {\n  TransformationType[TransformationType[\"PLAIN_TO_CLASS\"] = 0] = \"PLAIN_TO_CLASS\";\n  TransformationType[TransformationType[\"CLASS_TO_PLAIN\"] = 1] = \"CLASS_TO_PLAIN\";\n  TransformationType[TransformationType[\"CLASS_TO_CLASS\"] = 2] = \"CLASS_TO_CLASS\";\n})(TransformationType = exports.TransformationType || (exports.TransformationType = {}));","map":{"version":3,"mappings":";;;;;;;;;;AAAA;;AAGA;;AAAQA;;AAGRC;;AAEA,IAAMC,gBAAgB,GAAG,IAAIC,mCAAJ,EAAzB;;AAOA,sBAAgCC,MAAhC,EAA+CC,OAA/C,EAA8E;EAC1E,OAAOH,gBAAgB,CAACI,YAAjB,CAA8BF,MAA9B,EAAsCC,OAAtC,CAAP;AACH;;AAFDL;;AAWA,+BAAyCI,MAAzC,EAAoDG,WAApD,EAAkFF,OAAlF,EAAiH;EAC7G,OAAOH,gBAAgB,CAACM,qBAAjB,CAAuCJ,MAAvC,EAA+CG,WAA/C,EAA4DF,OAA5D,CAAP;AACH;;AAFDL;;AASA,sBAAmCS,GAAnC,EAAsDC,KAAtD,EAAoEL,OAApE,EAAmG;EAC/F,OAAOH,gBAAgB,CAACS,YAAjB,CAA8BF,GAA9B,EAAmCC,KAAnC,EAAiDL,OAAjD,CAAP;AACH;;AAFDL;;AAWA,+BAA4CY,SAA5C,EAA0DF,KAA1D,EAAwEL,OAAxE,EAAuG;EACnG,OAAOH,gBAAgB,CAACW,qBAAjB,CAAuCD,SAAvC,EAAkDF,KAAlD,EAAyDL,OAAzD,CAAP;AACH;;AAFDL;;AASA,sBAAgCI,MAAhC,EAA+CC,OAA/C,EAA8E;EAC1E,OAAOH,gBAAgB,CAACY,YAAjB,CAA8BV,MAA9B,EAAsCC,OAAtC,CAAP;AACH;;AAFDL;;AAWA,+BAAyCI,MAAzC,EAAoDW,UAApD,EAAuEV,OAAvE,EAAsG;EAClG,OAAOH,gBAAgB,CAACc,qBAAjB,CAAuCZ,MAAvC,EAA+CW,UAA/C,EAA2DV,OAA3D,CAAP;AACH;;AAFDL;;AASA,mBAA6BI,MAA7B,EAA4CC,OAA5C,EAA2E;EACvE,OAAOH,gBAAgB,CAACe,SAAjB,CAA2Bb,MAA3B,EAAmCC,OAAnC,CAAP;AACH;;AAFDL;AAIA;;;;AAGA,qBAA+BS,GAA/B,EAAkDS,IAAlD,EAAgEb,OAAhE,EAA+F;EAC3F,OAAOH,gBAAgB,CAACiB,WAAjB,CAA6BV,GAA7B,EAAkCS,IAAlC,EAAwCb,OAAxC,CAAP;AACH;;AAFDL;AAIA;;;;AAGA,0BAAoCS,GAApC,EAAuDS,IAAvD,EAAqEb,OAArE,EAAoG;EAChG,OAAOH,gBAAgB,CAACkB,gBAAjB,CAAkCX,GAAlC,EAAuCS,IAAvC,EAA6Cb,OAA7C,CAAP;AACH;;AAFDL;AAIA;;;;AAIA,IAAYqB,kBAAZ;;AAAA,WAAYA,kBAAZ,EAA8B;EAC1BA;EACAA;EACAA;AACH,CAJD,EAAYA,kBAAkB,GAAlBrB,4DAAkB,EAAlB,CAAZ","names":["exports","__export","classTransformer","ClassTransformer_1","object","options","classToPlain","plainObject","classToPlainFromExist","cls","plain","plainToClass","clsObject","plainToClassFromExist","classToClass","fromObject","classToClassFromExist","serialize","json","deserialize","deserializeArray","TransformationType"],"sourceRoot":".","sources":["../../src/index.ts"],"sourcesContent":["import {ClassTransformer, ClassType} from \"./ClassTransformer\";\nimport {ClassTransformOptions} from \"./ClassTransformOptions\";\n\nexport {ClassTransformer} from \"./ClassTransformer\";\nexport {ClassTransformOptions} from \"./ClassTransformOptions\";\nexport * from \"./metadata/ExposeExcludeOptions\";\nexport * from \"./decorators\";\n\nconst classTransformer = new ClassTransformer();\n\n/**\n * Converts class (constructor) object to plain (literal) object. Also works with arrays.\n */\nexport function classToPlain<T>(object: T, options?: ClassTransformOptions): Object;\nexport function classToPlain<T>(object: T[], options?: ClassTransformOptions): Object[];\nexport function classToPlain<T>(object: T|T[], options?: ClassTransformOptions): Object|Object[] {\n    return classTransformer.classToPlain(object, options);\n}\n\n/**\n * Converts class (constructor) object to plain (literal) object.\n * Uses given plain object as source object (it means fills given plain object with data from class object).\n * Also works with arrays.\n */\nexport function classToPlainFromExist<T>(object: T, plainObject: Object, options?: ClassTransformOptions): Object;\nexport function classToPlainFromExist<T>(object: T, plainObjects: Object[], options?: ClassTransformOptions): Object[];\nexport function classToPlainFromExist<T>(object: T, plainObject: Object|Object[], options?: ClassTransformOptions): Object|Object[] {\n    return classTransformer.classToPlainFromExist(object, plainObject, options);\n}\n\n/**\n * Converts plain (literal) object to class (constructor) object. Also works with arrays.\n */\nexport function plainToClass<T, V>(cls: ClassType<T>, plain: V[], options?: ClassTransformOptions): T[];\nexport function plainToClass<T, V>(cls: ClassType<T>, plain: V, options?: ClassTransformOptions): T;\nexport function plainToClass<T, V>(cls: ClassType<T>, plain: V|V[], options?: ClassTransformOptions): T|T[] {\n    return classTransformer.plainToClass(cls, plain as any, options);\n}\n\n/**\n * Converts plain (literal) object to class (constructor) object.\n * Uses given object as source object (it means fills given object with data from plain object).\n *  Also works with arrays.\n */\nexport function plainToClassFromExist<T, V>(clsObject: T[], plain: V[], options?: ClassTransformOptions): T[];\nexport function plainToClassFromExist<T, V>(clsObject: T, plain: V, options?: ClassTransformOptions): T;\nexport function plainToClassFromExist<T, V>(clsObject: T, plain: V|V[], options?: ClassTransformOptions): T|T[] {\n    return classTransformer.plainToClassFromExist(clsObject, plain, options);\n}\n\n/**\n * Converts class (constructor) object to new class (constructor) object. Also works with arrays.\n */\nexport function classToClass<T>(object: T, options?: ClassTransformOptions): T;\nexport function classToClass<T>(object: T[], options?: ClassTransformOptions): T[];\nexport function classToClass<T>(object: T|T[], options?: ClassTransformOptions): T|T[] {\n    return classTransformer.classToClass(object, options);\n}\n\n/**\n * Converts class (constructor) object to plain (literal) object.\n * Uses given plain object as source object (it means fills given plain object with data from class object).\n * Also works with arrays.\n */\nexport function classToClassFromExist<T>(object: T, fromObject: T, options?: ClassTransformOptions): T;\nexport function classToClassFromExist<T>(object: T, fromObjects: T[], options?: ClassTransformOptions): T[];\nexport function classToClassFromExist<T>(object: T, fromObject: T|T[], options?: ClassTransformOptions): T|T[] {\n    return classTransformer.classToClassFromExist(object, fromObject, options);\n}\n\n/**\n * Serializes given object to a JSON string.\n */\nexport function serialize<T>(object: T, options?: ClassTransformOptions): string;\nexport function serialize<T>(object: T[], options?: ClassTransformOptions): string;\nexport function serialize<T>(object: T|T[], options?: ClassTransformOptions): string {\n    return classTransformer.serialize(object, options);\n}\n\n/**\n * Deserializes given JSON string to a object of the given class.\n */\nexport function deserialize<T>(cls: ClassType<T>, json: string, options?: ClassTransformOptions): T {\n    return classTransformer.deserialize(cls, json, options);\n}\n\n/**\n * Deserializes given JSON string to an array of objects of the given class.\n */\nexport function deserializeArray<T>(cls: ClassType<T>, json: string, options?: ClassTransformOptions): T[] {\n    return classTransformer.deserializeArray(cls, json, options);\n}\n\n/**\n * Enum representing the different transformation types.\n */\n\nexport enum TransformationType {\n    PLAIN_TO_CLASS,\n    CLASS_TO_PLAIN,\n    CLASS_TO_CLASS\n}\n"]},"metadata":{},"sourceType":"script"}