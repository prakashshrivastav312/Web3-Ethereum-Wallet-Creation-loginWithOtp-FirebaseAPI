{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar storage_1 = require(\"./storage\");\n\nvar TransformationType;\n\n(function (TransformationType) {\n  TransformationType[TransformationType[\"PLAIN_TO_CLASS\"] = 0] = \"PLAIN_TO_CLASS\";\n  TransformationType[TransformationType[\"CLASS_TO_PLAIN\"] = 1] = \"CLASS_TO_PLAIN\";\n  TransformationType[TransformationType[\"CLASS_TO_CLASS\"] = 2] = \"CLASS_TO_CLASS\";\n})(TransformationType = exports.TransformationType || (exports.TransformationType = {}));\n\nvar TransformOperationExecutor =\n/** @class */\nfunction () {\n  // -------------------------------------------------------------------------\n  // Constructor\n  // -------------------------------------------------------------------------\n  function TransformOperationExecutor(transformationType, options) {\n    this.transformationType = transformationType;\n    this.options = options; // -------------------------------------------------------------------------\n    // Private Properties\n    // -------------------------------------------------------------------------\n\n    this.recursionStack = new Set();\n  } // -------------------------------------------------------------------------\n  // Public Methods\n  // -------------------------------------------------------------------------\n\n\n  TransformOperationExecutor.prototype.transform = function (source, value, targetType, arrayType, isMap, level) {\n    var _this = this;\n\n    if (level === void 0) {\n      level = 0;\n    }\n\n    if (Array.isArray(value) || value instanceof Set) {\n      var newValue_1 = arrayType && this.transformationType === TransformationType.PLAIN_TO_CLASS ? instantiateArrayType(arrayType) : [];\n      value.forEach(function (subValue, index) {\n        var subSource = source ? source[index] : undefined;\n\n        if (!_this.options.enableCircularCheck || !_this.isCircular(subValue)) {\n          var realTargetType = void 0;\n\n          if (typeof targetType !== \"function\" && targetType && targetType.options && targetType.options.discriminator && targetType.options.discriminator.property && targetType.options.discriminator.subTypes) {\n            if (_this.transformationType === TransformationType.PLAIN_TO_CLASS) {\n              realTargetType = targetType.options.discriminator.subTypes.find(function (subType) {\n                return subType.name === subValue[targetType.options.discriminator.property];\n              });\n              var options = {\n                newObject: newValue_1,\n                object: subValue,\n                property: undefined\n              };\n              var newType = targetType.typeFunction(options);\n              realTargetType === undefined ? realTargetType = newType : realTargetType = realTargetType.value;\n              if (!targetType.options.keepDiscriminatorProperty) delete subValue[targetType.options.discriminator.property];\n            }\n\n            if (_this.transformationType === TransformationType.CLASS_TO_CLASS) {\n              realTargetType = subValue.constructor;\n            }\n\n            if (_this.transformationType === TransformationType.CLASS_TO_PLAIN) {\n              subValue[targetType.options.discriminator.property] = targetType.options.discriminator.subTypes.find(function (subType) {\n                return subType.value === subValue.constructor;\n              }).name;\n            }\n          } else {\n            realTargetType = targetType;\n          }\n\n          var value_1 = _this.transform(subSource, subValue, realTargetType, undefined, subValue instanceof Map, level + 1);\n\n          if (newValue_1 instanceof Set) {\n            newValue_1.add(value_1);\n          } else {\n            newValue_1.push(value_1);\n          }\n        } else if (_this.transformationType === TransformationType.CLASS_TO_CLASS) {\n          if (newValue_1 instanceof Set) {\n            newValue_1.add(subValue);\n          } else {\n            newValue_1.push(subValue);\n          }\n        }\n      });\n      return newValue_1;\n    } else if (targetType === String && !isMap) {\n      if (value === null || value === undefined) return value;\n      return String(value);\n    } else if (targetType === Number && !isMap) {\n      if (value === null || value === undefined) return value;\n      return Number(value);\n    } else if (targetType === Boolean && !isMap) {\n      if (value === null || value === undefined) return value;\n      return Boolean(value);\n    } else if ((targetType === Date || value instanceof Date) && !isMap) {\n      if (value instanceof Date) {\n        return new Date(value.valueOf());\n      }\n\n      if (value === null || value === undefined) return value;\n      return new Date(value);\n    } else if (testForBuffer() && (targetType === Buffer || value instanceof Buffer) && !isMap) {\n      if (value === null || value === undefined) return value;\n      return Buffer.from(value);\n    } else if (typeof value === \"object\" && value !== null) {\n      // try to guess the type\n      if (!targetType && value.constructor !== Object\n      /* && TransformationType === TransformationType.CLASS_TO_PLAIN*/\n      ) targetType = value.constructor;\n      if (!targetType && source) targetType = source.constructor;\n\n      if (this.options.enableCircularCheck) {\n        // add transformed type to prevent circular references\n        this.recursionStack.add(value);\n      }\n\n      var keys = this.getKeys(targetType, value);\n      var newValue = source ? source : {};\n\n      if (!source && (this.transformationType === TransformationType.PLAIN_TO_CLASS || this.transformationType === TransformationType.CLASS_TO_CLASS)) {\n        if (isMap) {\n          newValue = new Map();\n        } else if (targetType) {\n          newValue = new targetType();\n        } else {\n          newValue = {};\n        }\n      }\n\n      var _loop_1 = function (key) {\n        var valueKey = key,\n            newValueKey = key,\n            propertyName = key;\n\n        if (!this_1.options.ignoreDecorators && targetType) {\n          if (this_1.transformationType === TransformationType.PLAIN_TO_CLASS) {\n            var exposeMetadata = storage_1.defaultMetadataStorage.findExposeMetadataByCustomName(targetType, key);\n\n            if (exposeMetadata) {\n              propertyName = exposeMetadata.propertyName;\n              newValueKey = exposeMetadata.propertyName;\n            }\n          } else if (this_1.transformationType === TransformationType.CLASS_TO_PLAIN || this_1.transformationType === TransformationType.CLASS_TO_CLASS) {\n            var exposeMetadata = storage_1.defaultMetadataStorage.findExposeMetadata(targetType, key);\n\n            if (exposeMetadata && exposeMetadata.options && exposeMetadata.options.name) {\n              newValueKey = exposeMetadata.options.name;\n            }\n          }\n        } // get a subvalue\n\n\n        var subValue = undefined;\n\n        if (value instanceof Map) {\n          subValue = value.get(valueKey);\n        } else if (value[valueKey] instanceof Function) {\n          subValue = value[valueKey]();\n        } else {\n          subValue = value[valueKey];\n        } // determine a type\n\n\n        var type = undefined,\n            isSubValueMap = subValue instanceof Map;\n\n        if (targetType && isMap) {\n          type = targetType;\n        } else if (targetType) {\n          var metadata_1 = storage_1.defaultMetadataStorage.findTypeMetadata(targetType, propertyName);\n\n          if (metadata_1) {\n            var options = {\n              newObject: newValue,\n              object: value,\n              property: propertyName\n            };\n            var newType = metadata_1.typeFunction ? metadata_1.typeFunction(options) : metadata_1.reflectedType;\n\n            if (metadata_1.options && metadata_1.options.discriminator && metadata_1.options.discriminator.property && metadata_1.options.discriminator.subTypes) {\n              if (!(value[valueKey] instanceof Array)) {\n                if (this_1.transformationType === TransformationType.PLAIN_TO_CLASS) {\n                  type = metadata_1.options.discriminator.subTypes.find(function (subType) {\n                    if (subValue && metadata_1.options.discriminator.property in subValue) {\n                      return subType.name === subValue[metadata_1.options.discriminator.property];\n                    }\n                  });\n                  type === undefined ? type = newType : type = type.value;\n\n                  if (!metadata_1.options.keepDiscriminatorProperty) {\n                    if (subValue && metadata_1.options.discriminator.property in subValue) {\n                      delete subValue[metadata_1.options.discriminator.property];\n                    }\n                  }\n                }\n\n                if (this_1.transformationType === TransformationType.CLASS_TO_CLASS) {\n                  type = subValue.constructor;\n                }\n\n                if (this_1.transformationType === TransformationType.CLASS_TO_PLAIN) {\n                  subValue[metadata_1.options.discriminator.property] = metadata_1.options.discriminator.subTypes.find(function (subType) {\n                    return subType.value === subValue.constructor;\n                  }).name;\n                }\n              } else {\n                type = metadata_1;\n              }\n            } else {\n              type = newType;\n            }\n\n            isSubValueMap = isSubValueMap || metadata_1.reflectedType === Map;\n          } else if (this_1.options.targetMaps) {\n            // try to find a type in target maps\n            this_1.options.targetMaps.filter(function (map) {\n              return map.target === targetType && !!map.properties[propertyName];\n            }).forEach(function (map) {\n              return type = map.properties[propertyName];\n            });\n          } else if (this_1.options.enableImplicitConversion && this_1.transformationType === TransformationType.PLAIN_TO_CLASS) {\n            // if we have no registererd type via the @Type() decorator then we check if we have any\n            // type declarations in reflect-metadata (type declaration is emited only if some decorator is added to the property.)\n            var reflectedType = Reflect.getMetadata(\"design:type\", targetType.prototype, propertyName);\n\n            if (reflectedType) {\n              type = reflectedType;\n            }\n          }\n        } // if value is an array try to get its custom array type\n\n\n        var arrayType_1 = Array.isArray(value[valueKey]) ? this_1.getReflectedType(targetType, propertyName) : undefined; // const subValueKey = TransformationType === TransformationType.PLAIN_TO_CLASS && newKeyName ? newKeyName : key;\n\n        var subSource = source ? source[valueKey] : undefined; // if its deserialization then type if required\n        // if we uncomment this types like string[] will not work\n        // if (this.transformationType === TransformationType.PLAIN_TO_CLASS && !type && subValue instanceof Object && !(subValue instanceof Date))\n        //     throw new Error(`Cannot determine type for ${(targetType as any).name }.${propertyName}, did you forget to specify a @Type?`);\n        // if newValue is a source object that has method that match newKeyName then skip it\n\n        if (newValue.constructor.prototype) {\n          var descriptor = Object.getOwnPropertyDescriptor(newValue.constructor.prototype, newValueKey);\n          if ((this_1.transformationType === TransformationType.PLAIN_TO_CLASS || this_1.transformationType === TransformationType.CLASS_TO_CLASS) && (descriptor && !descriptor.set || newValue[newValueKey] instanceof Function)) //  || TransformationType === TransformationType.CLASS_TO_CLASS\n            return \"continue\";\n        }\n\n        if (!this_1.options.enableCircularCheck || !this_1.isCircular(subValue)) {\n          var transformKey = this_1.transformationType === TransformationType.PLAIN_TO_CLASS ? newValueKey : key;\n          var finalValue = void 0;\n\n          if (this_1.transformationType === TransformationType.CLASS_TO_PLAIN) {\n            // Get original value\n            finalValue = value[transformKey]; // Apply custom transformation\n\n            finalValue = this_1.applyCustomTransformations(finalValue, targetType, transformKey, value, this_1.transformationType); // If nothing change, it means no custom transformation was applied, so use the subValue.\n\n            finalValue = value[transformKey] === finalValue ? subValue : finalValue; // Apply the default transformation\n\n            finalValue = this_1.transform(subSource, finalValue, type, arrayType_1, isSubValueMap, level + 1);\n          } else {\n            finalValue = this_1.transform(subSource, subValue, type, arrayType_1, isSubValueMap, level + 1);\n            finalValue = this_1.applyCustomTransformations(finalValue, targetType, transformKey, value, this_1.transformationType);\n          }\n\n          if (newValue instanceof Map) {\n            newValue.set(newValueKey, finalValue);\n          } else {\n            newValue[newValueKey] = finalValue;\n          }\n        } else if (this_1.transformationType === TransformationType.CLASS_TO_CLASS) {\n          var finalValue = subValue;\n          finalValue = this_1.applyCustomTransformations(finalValue, targetType, key, value, this_1.transformationType);\n\n          if (newValue instanceof Map) {\n            newValue.set(newValueKey, finalValue);\n          } else {\n            newValue[newValueKey] = finalValue;\n          }\n        }\n      };\n\n      var this_1 = this; // traverse over keys\n\n      for (var _i = 0, keys_1 = keys; _i < keys_1.length; _i++) {\n        var key = keys_1[_i];\n\n        _loop_1(key);\n      }\n\n      if (this.options.enableCircularCheck) {\n        this.recursionStack.delete(value);\n      }\n\n      return newValue;\n    } else {\n      return value;\n    }\n  };\n\n  TransformOperationExecutor.prototype.applyCustomTransformations = function (value, target, key, obj, transformationType) {\n    var _this = this;\n\n    var metadatas = storage_1.defaultMetadataStorage.findTransformMetadatas(target, key, this.transformationType); // apply versioning options\n\n    if (this.options.version !== undefined) {\n      metadatas = metadatas.filter(function (metadata) {\n        if (!metadata.options) return true;\n        return _this.checkVersion(metadata.options.since, metadata.options.until);\n      });\n    } // apply grouping options\n\n\n    if (this.options.groups && this.options.groups.length) {\n      metadatas = metadatas.filter(function (metadata) {\n        if (!metadata.options) return true;\n        return _this.checkGroups(metadata.options.groups);\n      });\n    } else {\n      metadatas = metadatas.filter(function (metadata) {\n        return !metadata.options || !metadata.options.groups || !metadata.options.groups.length;\n      });\n    }\n\n    metadatas.forEach(function (metadata) {\n      value = metadata.transformFn(value, obj, transformationType);\n    });\n    return value;\n  }; // preventing circular references\n\n\n  TransformOperationExecutor.prototype.isCircular = function (object) {\n    return this.recursionStack.has(object);\n  };\n\n  TransformOperationExecutor.prototype.getReflectedType = function (target, propertyName) {\n    if (!target) return undefined;\n    var meta = storage_1.defaultMetadataStorage.findTypeMetadata(target, propertyName);\n    return meta ? meta.reflectedType : undefined;\n  };\n\n  TransformOperationExecutor.prototype.getKeys = function (target, object) {\n    var _this = this; // determine exclusion strategy\n\n\n    var strategy = storage_1.defaultMetadataStorage.getStrategy(target);\n    if (strategy === \"none\") strategy = this.options.strategy || \"exposeAll\"; // exposeAll is default strategy\n    // get all keys that need to expose\n\n    var keys = [];\n\n    if (strategy === \"exposeAll\") {\n      if (object instanceof Map) {\n        keys = Array.from(object.keys());\n      } else {\n        keys = Object.keys(object);\n      }\n    }\n\n    if (!this.options.ignoreDecorators && target) {\n      // add all exposed to list of keys\n      var exposedProperties = storage_1.defaultMetadataStorage.getExposedProperties(target, this.transformationType);\n\n      if (this.transformationType === TransformationType.PLAIN_TO_CLASS) {\n        exposedProperties = exposedProperties.map(function (key) {\n          var exposeMetadata = storage_1.defaultMetadataStorage.findExposeMetadata(target, key);\n\n          if (exposeMetadata && exposeMetadata.options && exposeMetadata.options.name) {\n            return exposeMetadata.options.name;\n          }\n\n          return key;\n        });\n      }\n\n      if (this.options.excludeExtraneousValues) {\n        keys = exposedProperties;\n      } else {\n        keys = keys.concat(exposedProperties);\n      } // exclude excluded properties\n\n\n      var excludedProperties_1 = storage_1.defaultMetadataStorage.getExcludedProperties(target, this.transformationType);\n\n      if (excludedProperties_1.length > 0) {\n        keys = keys.filter(function (key) {\n          return excludedProperties_1.indexOf(key) === -1;\n        });\n      } // apply versioning options\n\n\n      if (this.options.version !== undefined) {\n        keys = keys.filter(function (key) {\n          var exposeMetadata = storage_1.defaultMetadataStorage.findExposeMetadata(target, key);\n          if (!exposeMetadata || !exposeMetadata.options) return true;\n          return _this.checkVersion(exposeMetadata.options.since, exposeMetadata.options.until);\n        });\n      } // apply grouping options\n\n\n      if (this.options.groups && this.options.groups.length) {\n        keys = keys.filter(function (key) {\n          var exposeMetadata = storage_1.defaultMetadataStorage.findExposeMetadata(target, key);\n          if (!exposeMetadata || !exposeMetadata.options) return true;\n          return _this.checkGroups(exposeMetadata.options.groups);\n        });\n      } else {\n        keys = keys.filter(function (key) {\n          var exposeMetadata = storage_1.defaultMetadataStorage.findExposeMetadata(target, key);\n          return !exposeMetadata || !exposeMetadata.options || !exposeMetadata.options.groups || !exposeMetadata.options.groups.length;\n        });\n      }\n    } // exclude prefixed properties\n\n\n    if (this.options.excludePrefixes && this.options.excludePrefixes.length) {\n      keys = keys.filter(function (key) {\n        return _this.options.excludePrefixes.every(function (prefix) {\n          return key.substr(0, prefix.length) !== prefix;\n        });\n      });\n    } // make sure we have unique keys\n\n\n    keys = keys.filter(function (key, index, self) {\n      return self.indexOf(key) === index;\n    });\n    return keys;\n  };\n\n  TransformOperationExecutor.prototype.checkVersion = function (since, until) {\n    var decision = true;\n    if (decision && since) decision = this.options.version >= since;\n    if (decision && until) decision = this.options.version < until;\n    return decision;\n  };\n\n  TransformOperationExecutor.prototype.checkGroups = function (groups) {\n    if (!groups) return true;\n    return this.options.groups.some(function (optionGroup) {\n      return groups.indexOf(optionGroup) !== -1;\n    });\n  };\n\n  return TransformOperationExecutor;\n}();\n\nexports.TransformOperationExecutor = TransformOperationExecutor;\n\nfunction instantiateArrayType(arrayType) {\n  var array = new arrayType();\n\n  if (!(array instanceof Set) && !(\"push\" in array)) {\n    return [];\n  }\n\n  return array;\n}\n\nfunction testForBuffer() {\n  try {\n    Buffer;\n    return true;\n  } catch (_a) {}\n\n  return false;\n}\n\nexports.testForBuffer = testForBuffer;","map":{"version":3,"mappings":"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","names":["TransformationType","exports","transformationType","options","Set","TransformOperationExecutor","source","value","targetType","arrayType","isMap","level","Array","isArray","newValue_1","PLAIN_TO_CLASS","instantiateArrayType","forEach","subValue","index","subSource","undefined","_this","enableCircularCheck","isCircular","realTargetType","discriminator","property","subTypes","find","subType","name","newObject","object","newType","typeFunction","keepDiscriminatorProperty","CLASS_TO_CLASS","constructor","CLASS_TO_PLAIN","value_1","transform","Map","add","push","String","Number","Boolean","Date","valueOf","testForBuffer","Buffer","from","Object","recursionStack","keys","getKeys","newValue","key","valueKey","newValueKey","propertyName","this_1","ignoreDecorators","exposeMetadata","storage_1","findExposeMetadataByCustomName","findExposeMetadata","get","Function","type","isSubValueMap","metadata_1","findTypeMetadata","reflectedType","targetMaps","filter","target","map","properties","enableImplicitConversion","Reflect","getMetadata","prototype","arrayType_1","getReflectedType","descriptor","getOwnPropertyDescriptor","set","transformKey","finalValue","applyCustomTransformations","_i","delete","obj","metadatas","findTransformMetadatas","version","metadata","checkVersion","since","until","groups","length","checkGroups","transformFn","has","meta","strategy","getStrategy","exposedProperties","getExposedProperties","excludeExtraneousValues","concat","excludedProperties_1","getExcludedProperties","indexOf","excludePrefixes","every","substr","prefix","self","decision","some","optionGroup","array"],"sourceRoot":".","sources":["../../src/TransformOperationExecutor.ts"],"sourcesContent":["import { ClassTransformOptions } from \"./ClassTransformOptions\";\nimport { defaultMetadataStorage } from \"./storage\";\nimport { TypeHelpOptions, TypeOptions } from \"./metadata/ExposeExcludeOptions\";\nimport { TypeMetadata } from \"./metadata/TypeMetadata\";\n\nexport enum TransformationType {\n    PLAIN_TO_CLASS,\n    CLASS_TO_PLAIN,\n    CLASS_TO_CLASS\n}\n\nexport class TransformOperationExecutor {\n\n    // -------------------------------------------------------------------------\n    // Private Properties\n    // -------------------------------------------------------------------------\n\n    private recursionStack = new Set<Object>();\n\n    // -------------------------------------------------------------------------\n    // Constructor\n    // -------------------------------------------------------------------------\n\n    constructor(private transformationType: TransformationType,\n        private options: ClassTransformOptions) {\n    }\n\n    // -------------------------------------------------------------------------\n    // Public Methods\n    // -------------------------------------------------------------------------\n\n    transform(source: Object | Object[] | any,\n        value: Object | Object[] | any,\n        targetType: Function | TypeMetadata,\n        arrayType: Function,\n        isMap: boolean,\n        level: number = 0) {\n\n        if (Array.isArray(value) || value instanceof Set) {\n            const newValue = arrayType && this.transformationType === TransformationType.PLAIN_TO_CLASS ? instantiateArrayType(arrayType) : [];\n            (value as any[]).forEach((subValue, index) => {\n                const subSource = source ? source[index] : undefined;\n                if (!this.options.enableCircularCheck || !this.isCircular(subValue)) {\n                    let realTargetType;\n                    if (typeof targetType !== \"function\" && targetType && targetType.options && targetType.options.discriminator && targetType.options.discriminator.property && targetType.options.discriminator.subTypes) {\n                        if (this.transformationType === TransformationType.PLAIN_TO_CLASS) {\n                            realTargetType = targetType.options.discriminator.subTypes.find((subType) => subType.name === subValue[(targetType as { options: TypeOptions }).options.discriminator.property]);\n                            const options: TypeHelpOptions = { newObject: newValue, object: subValue, property: undefined };\n                            const newType = targetType.typeFunction(options);\n                            realTargetType === undefined ? realTargetType = newType : realTargetType = realTargetType.value;\n                            if (!targetType.options.keepDiscriminatorProperty) delete subValue[targetType.options.discriminator.property];\n                        }\n                        if (this.transformationType === TransformationType.CLASS_TO_CLASS) {\n                            realTargetType = subValue.constructor;\n                        }\n                        if (this.transformationType === TransformationType.CLASS_TO_PLAIN) {\n                            subValue[targetType.options.discriminator.property] = targetType.options.discriminator.subTypes.find((subType) => subType.value === subValue.constructor).name;\n                        }\n                    } else {\n                        realTargetType = targetType;\n                    }\n                    const value = this.transform(subSource, subValue, realTargetType, undefined, subValue instanceof Map, level + 1);\n\n                    if (newValue instanceof Set) {\n                        newValue.add(value);\n                    } else {\n                        newValue.push(value);\n                    }\n                } else if (this.transformationType === TransformationType.CLASS_TO_CLASS) {\n                    if (newValue instanceof Set) {\n                        newValue.add(subValue);\n                    } else {\n                        newValue.push(subValue);\n                    }\n                }\n            });\n            return newValue;\n        } else if (targetType === String && !isMap) {\n            if (value === null || value === undefined)\n                return value;\n            return String(value);\n\n        } else if (targetType === Number && !isMap) {\n            if (value === null || value === undefined)\n                return value;\n            return Number(value);\n\n        } else if (targetType === Boolean && !isMap) {\n            if (value === null || value === undefined)\n                return value;\n            return Boolean(value);\n\n        } else if ((targetType === Date || value instanceof Date) && !isMap) {\n            if (value instanceof Date) {\n                return new Date(value.valueOf());\n            }\n            if (value === null || value === undefined)\n                return value;\n            return new Date(value);\n\n        } else if (testForBuffer() && (targetType === Buffer || value instanceof Buffer) && !isMap) {\n            if (value === null || value === undefined)\n                return value;\n            return Buffer.from(value);\n\n        } else if (typeof value === \"object\" && value !== null) {\n\n            // try to guess the type\n            if (!targetType && value.constructor !== Object/* && TransformationType === TransformationType.CLASS_TO_PLAIN*/) targetType = value.constructor;\n            if (!targetType && source) targetType = source.constructor;\n\n            if (this.options.enableCircularCheck) {\n                // add transformed type to prevent circular references\n                this.recursionStack.add(value);\n            }\n\n            const keys = this.getKeys((targetType as Function), value);\n            let newValue: any = source ? source : {};\n            if (!source && (this.transformationType === TransformationType.PLAIN_TO_CLASS || this.transformationType === TransformationType.CLASS_TO_CLASS)) {\n                if (isMap) {\n                    newValue = new Map();\n                } else if (targetType) {\n                    newValue = new (targetType as any)();\n                } else {\n                    newValue = {};\n                }\n            }\n\n            // traverse over keys\n            for (let key of keys) {\n\n                let valueKey = key, newValueKey = key, propertyName = key;\n                if (!this.options.ignoreDecorators && targetType) {\n                    if (this.transformationType === TransformationType.PLAIN_TO_CLASS) {\n                        const exposeMetadata = defaultMetadataStorage.findExposeMetadataByCustomName((targetType as Function), key);\n                        if (exposeMetadata) {\n                            propertyName = exposeMetadata.propertyName;\n                            newValueKey = exposeMetadata.propertyName;\n                        }\n\n                    } else if (this.transformationType === TransformationType.CLASS_TO_PLAIN || this.transformationType === TransformationType.CLASS_TO_CLASS) {\n                        const exposeMetadata = defaultMetadataStorage.findExposeMetadata((targetType as Function), key);\n                        if (exposeMetadata && exposeMetadata.options && exposeMetadata.options.name) {\n                            newValueKey = exposeMetadata.options.name;\n                        }\n                    }\n                }\n\n                // get a subvalue\n                let subValue: any = undefined;\n                if (value instanceof Map) {\n                    subValue = value.get(valueKey);\n                } else if (value[valueKey] instanceof Function) {\n                    subValue = value[valueKey]();\n                } else {\n                    subValue = value[valueKey];\n                }\n\n                // determine a type\n                let type: any = undefined, isSubValueMap = subValue instanceof Map;\n                if (targetType && isMap) {\n                    type = targetType;\n\n                } else if (targetType) {\n\n                    const metadata = defaultMetadataStorage.findTypeMetadata((targetType as Function), propertyName);\n                    if (metadata) {\n                        const options: TypeHelpOptions = { newObject: newValue, object: value, property: propertyName };\n                        const newType = metadata.typeFunction ? metadata.typeFunction(options) : metadata.reflectedType;\n                        if (metadata.options && metadata.options.discriminator && metadata.options.discriminator.property && metadata.options.discriminator.subTypes) {\n                            if (!(value[valueKey] instanceof Array)) {\n                                if (this.transformationType === TransformationType.PLAIN_TO_CLASS) {\n                                    type = metadata.options.discriminator.subTypes.find((subType) => {\n                                        if (subValue && metadata.options.discriminator.property in subValue) {\n                                            return subType.name === subValue[metadata.options.discriminator.property]\n                                        }\n                                    });\n                                    type === undefined ? type = newType : type = type.value;\n                                    if (!metadata.options.keepDiscriminatorProperty) {\n                                        if (subValue && metadata.options.discriminator.property in subValue) {\n                                            delete subValue[metadata.options.discriminator.property];\n                                        }\n                                    }\n                                }\n                                if (this.transformationType === TransformationType.CLASS_TO_CLASS) {\n                                    type = subValue.constructor;\n                                }\n                                if (this.transformationType === TransformationType.CLASS_TO_PLAIN) {\n                                    subValue[metadata.options.discriminator.property] = metadata.options.discriminator.subTypes.find((subType) => subType.value === subValue.constructor).name;\n                                }\n                            } else {\n                                type = metadata;\n                            }\n                        } else {\n                            type = newType;\n                        }\n                        isSubValueMap = isSubValueMap || metadata.reflectedType === Map;\n                    } else if (this.options.targetMaps) { // try to find a type in target maps\n                        this.options.targetMaps\n                            .filter(map => map.target === targetType && !!map.properties[propertyName])\n                            .forEach(map => type = map.properties[propertyName]);\n                    } else if(this.options.enableImplicitConversion && this.transformationType === TransformationType.PLAIN_TO_CLASS) {\n                        // if we have no registererd type via the @Type() decorator then we check if we have any\n                        // type declarations in reflect-metadata (type declaration is emited only if some decorator is added to the property.)\n                        const reflectedType = Reflect.getMetadata(\"design:type\", (targetType as Function).prototype, propertyName);\n\n                        if (reflectedType) {\n                            type = reflectedType;\n                        }\n                    }\n                }\n\n                // if value is an array try to get its custom array type\n                const arrayType = Array.isArray(value[valueKey]) ? this.getReflectedType((targetType as Function), propertyName) : undefined;\n\n                // const subValueKey = TransformationType === TransformationType.PLAIN_TO_CLASS && newKeyName ? newKeyName : key;\n                const subSource = source ? source[valueKey] : undefined;\n\n                // if its deserialization then type if required\n                // if we uncomment this types like string[] will not work\n                // if (this.transformationType === TransformationType.PLAIN_TO_CLASS && !type && subValue instanceof Object && !(subValue instanceof Date))\n                //     throw new Error(`Cannot determine type for ${(targetType as any).name }.${propertyName}, did you forget to specify a @Type?`);\n\n                // if newValue is a source object that has method that match newKeyName then skip it\n                if (newValue.constructor.prototype) {\n                    const descriptor = Object.getOwnPropertyDescriptor(newValue.constructor.prototype, newValueKey);\n                    if ((this.transformationType === TransformationType.PLAIN_TO_CLASS || this.transformationType === TransformationType.CLASS_TO_CLASS)\n                        && ((descriptor && !descriptor.set) || newValue[newValueKey] instanceof Function)) //  || TransformationType === TransformationType.CLASS_TO_CLASS\n                        continue;\n                }\n\n                if (!this.options.enableCircularCheck || !this.isCircular(subValue)) {\n                    let transformKey = this.transformationType === TransformationType.PLAIN_TO_CLASS ? newValueKey : key;\n                    let finalValue;\n\n                    if (this.transformationType === TransformationType.CLASS_TO_PLAIN) {\n                        // Get original value\n                        finalValue = value[transformKey];\n                        // Apply custom transformation\n                        finalValue = this.applyCustomTransformations(finalValue, (targetType as Function), transformKey, value, this.transformationType);\n                        // If nothing change, it means no custom transformation was applied, so use the subValue.\n                        finalValue = (value[transformKey] === finalValue) ? subValue : finalValue;\n                        // Apply the default transformation\n                        finalValue = this.transform(subSource, finalValue, type, arrayType, isSubValueMap, level + 1);\n                    } else {\n                        finalValue = this.transform(subSource, subValue, type, arrayType, isSubValueMap, level + 1);\n                        finalValue = this.applyCustomTransformations(finalValue, (targetType as Function), transformKey, value, this.transformationType);\n                    }\n\n                    if (newValue instanceof Map) {\n                        newValue.set(newValueKey, finalValue);\n                    } else {\n                        newValue[newValueKey] = finalValue;\n                    }\n                } else if (this.transformationType === TransformationType.CLASS_TO_CLASS) {\n                    let finalValue = subValue;\n                    finalValue = this.applyCustomTransformations(finalValue, (targetType as Function), key, value, this.transformationType);\n                    if (newValue instanceof Map) {\n                        newValue.set(newValueKey, finalValue);\n                    } else {\n                        newValue[newValueKey] = finalValue;\n                    }\n                }\n\n            }\n\n            if (this.options.enableCircularCheck) {\n                this.recursionStack.delete(value);\n            }\n\n            return newValue;\n\n        } else {\n            return value;\n        }\n    }\n\n    private applyCustomTransformations(value: any, target: Function, key: string, obj: any, transformationType: TransformationType) {\n        let metadatas = defaultMetadataStorage.findTransformMetadatas(target, key, this.transformationType);\n\n        // apply versioning options\n        if (this.options.version !== undefined) {\n            metadatas = metadatas.filter(metadata => {\n                if (!metadata.options)\n                    return true;\n\n                return this.checkVersion(metadata.options.since, metadata.options.until);\n            });\n        }\n\n        // apply grouping options\n        if (this.options.groups && this.options.groups.length) {\n            metadatas = metadatas.filter(metadata => {\n                if (!metadata.options)\n                    return true;\n\n                return this.checkGroups(metadata.options.groups);\n            });\n        } else {\n            metadatas = metadatas.filter(metadata => {\n                return !metadata.options || !metadata.options.groups || !metadata.options.groups.length;\n            });\n        }\n\n        metadatas.forEach(metadata => {\n            value = metadata.transformFn(value, obj, transformationType);\n        });\n\n        return value;\n    }\n\n    // preventing circular references\n    private isCircular(object: Object) {\n        return this.recursionStack.has(object);\n    }\n\n    private getReflectedType(target: Function, propertyName: string) {\n        if (!target) return undefined;\n        const meta = defaultMetadataStorage.findTypeMetadata(target, propertyName);\n        return meta ? meta.reflectedType : undefined;\n    }\n\n    private getKeys(target: Function, object: Object): string[] {\n\n        // determine exclusion strategy\n        let strategy = defaultMetadataStorage.getStrategy(target);\n        if (strategy === \"none\")\n            strategy = this.options.strategy || \"exposeAll\"; // exposeAll is default strategy\n\n        // get all keys that need to expose\n        let keys: any[] = [];\n        if (strategy === \"exposeAll\") {\n            if (object instanceof Map) {\n                keys = Array.from(object.keys());\n            } else {\n                keys = Object.keys(object);\n            }\n        }\n\n        if (!this.options.ignoreDecorators && target) {\n\n            // add all exposed to list of keys\n            let exposedProperties = defaultMetadataStorage.getExposedProperties(target, this.transformationType);\n            if (this.transformationType === TransformationType.PLAIN_TO_CLASS) {\n                exposedProperties = exposedProperties.map(key => {\n                    const exposeMetadata = defaultMetadataStorage.findExposeMetadata(target, key);\n                    if (exposeMetadata && exposeMetadata.options && exposeMetadata.options.name) {\n                        return exposeMetadata.options.name;\n                    }\n\n                    return key;\n                });\n            }\n            if (this.options.excludeExtraneousValues) {\n                keys = exposedProperties;\n            } else {\n                keys = keys.concat(exposedProperties);\n            }\n\n            // exclude excluded properties\n            const excludedProperties = defaultMetadataStorage.getExcludedProperties(target, this.transformationType);\n            if (excludedProperties.length > 0) {\n                keys = keys.filter(key => {\n                    return excludedProperties.indexOf(key) === -1;\n                });\n            }\n\n            // apply versioning options\n            if (this.options.version !== undefined) {\n                keys = keys.filter(key => {\n                    const exposeMetadata = defaultMetadataStorage.findExposeMetadata(target, key);\n                    if (!exposeMetadata || !exposeMetadata.options)\n                        return true;\n\n                    return this.checkVersion(exposeMetadata.options.since, exposeMetadata.options.until);\n                });\n            }\n\n            // apply grouping options\n            if (this.options.groups && this.options.groups.length) {\n                keys = keys.filter(key => {\n                    const exposeMetadata = defaultMetadataStorage.findExposeMetadata(target, key);\n                    if (!exposeMetadata || !exposeMetadata.options)\n                        return true;\n\n                    return this.checkGroups(exposeMetadata.options.groups);\n                });\n            } else {\n                keys = keys.filter(key => {\n                    const exposeMetadata = defaultMetadataStorage.findExposeMetadata(target, key);\n                    return !exposeMetadata || !exposeMetadata.options || !exposeMetadata.options.groups || !exposeMetadata.options.groups.length;\n                });\n            }\n        }\n\n        // exclude prefixed properties\n        if (this.options.excludePrefixes && this.options.excludePrefixes.length) {\n            keys = keys.filter(key => this.options.excludePrefixes.every(prefix => {\n                return key.substr(0, prefix.length) !== prefix;\n            }));\n        }\n\n        // make sure we have unique keys\n        keys = keys.filter((key, index, self) => {\n            return self.indexOf(key) === index;\n        });\n\n        return keys;\n    }\n\n    private checkVersion(since: number, until: number) {\n        let decision = true;\n        if (decision && since)\n            decision = this.options.version >= since;\n        if (decision && until)\n            decision = this.options.version < until;\n\n        return decision;\n    }\n\n    private checkGroups(groups: string[]) {\n        if (!groups)\n            return true;\n\n        return this.options.groups.some(optionGroup => groups.indexOf(optionGroup) !== -1);\n    }\n\n}\n\nfunction instantiateArrayType(arrayType: Function): Array<any> | Set<any> {\n    const array = new (arrayType as any)();\n    if (!(array instanceof Set) && !(\"push\" in array)) {\n        return [];\n    }\n    return array;\n}\n\nexport function testForBuffer(): boolean {\n    try {\n        Buffer\n        return true;\n    } catch { }\n    return false;\n}\n"]},"metadata":{},"sourceType":"script"}