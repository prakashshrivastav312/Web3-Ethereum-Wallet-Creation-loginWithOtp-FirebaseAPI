{"ast":null,"code":"var Buffer = require('safe-buffer').Buffer;\n\nvar bcrypto = require('./crypto');\n\nvar fastMerkleRoot = require('merkle-lib/fastRoot');\n\nvar typeforce = require('typeforce');\n\nvar types = require('./types');\n\nvar varuint = require('varuint-bitcoin');\n\nvar Transaction = require('./transaction');\n\nfunction Block() {\n  this.version = 1;\n  this.prevHash = null;\n  this.merkleRoot = null;\n  this.timestamp = 0;\n  this.bits = 0;\n  this.nonce = 0;\n}\n\nBlock.fromBuffer = function (buffer) {\n  if (buffer.length < 80) throw new Error('Buffer too small (< 80 bytes)');\n  var offset = 0;\n\n  function readSlice(n) {\n    offset += n;\n    return buffer.slice(offset - n, offset);\n  }\n\n  function readUInt32() {\n    var i = buffer.readUInt32LE(offset);\n    offset += 4;\n    return i;\n  }\n\n  function readInt32() {\n    var i = buffer.readInt32LE(offset);\n    offset += 4;\n    return i;\n  }\n\n  var block = new Block();\n  block.version = readInt32();\n  block.prevHash = readSlice(32);\n  block.merkleRoot = readSlice(32);\n  block.timestamp = readUInt32();\n  block.bits = readUInt32();\n  block.nonce = readUInt32();\n  if (buffer.length === 80) return block;\n\n  function readVarInt() {\n    var vi = varuint.decode(buffer, offset);\n    offset += varuint.decode.bytes;\n    return vi;\n  }\n\n  function readTransaction() {\n    var tx = Transaction.fromBuffer(buffer.slice(offset), true);\n    offset += tx.byteLength();\n    return tx;\n  }\n\n  var nTransactions = readVarInt();\n  block.transactions = [];\n\n  for (var i = 0; i < nTransactions; ++i) {\n    var tx = readTransaction();\n    block.transactions.push(tx);\n  }\n\n  return block;\n};\n\nBlock.prototype.byteLength = function (headersOnly) {\n  if (headersOnly || !this.transactions) return 80;\n  return 80 + varuint.encodingLength(this.transactions.length) + this.transactions.reduce(function (a, x) {\n    return a + x.byteLength();\n  }, 0);\n};\n\nBlock.fromHex = function (hex) {\n  return Block.fromBuffer(Buffer.from(hex, 'hex'));\n};\n\nBlock.prototype.getHash = function () {\n  return bcrypto.hash256(this.toBuffer(true));\n};\n\nBlock.prototype.getId = function () {\n  return this.getHash().reverse().toString('hex');\n};\n\nBlock.prototype.getUTCDate = function () {\n  var date = new Date(0); // epoch\n\n  date.setUTCSeconds(this.timestamp);\n  return date;\n}; // TODO: buffer, offset compatibility\n\n\nBlock.prototype.toBuffer = function (headersOnly) {\n  var buffer = Buffer.allocUnsafe(this.byteLength(headersOnly));\n  var offset = 0;\n\n  function writeSlice(slice) {\n    slice.copy(buffer, offset);\n    offset += slice.length;\n  }\n\n  function writeInt32(i) {\n    buffer.writeInt32LE(i, offset);\n    offset += 4;\n  }\n\n  function writeUInt32(i) {\n    buffer.writeUInt32LE(i, offset);\n    offset += 4;\n  }\n\n  writeInt32(this.version);\n  writeSlice(this.prevHash);\n  writeSlice(this.merkleRoot);\n  writeUInt32(this.timestamp);\n  writeUInt32(this.bits);\n  writeUInt32(this.nonce);\n  if (headersOnly || !this.transactions) return buffer;\n  varuint.encode(this.transactions.length, buffer, offset);\n  offset += varuint.encode.bytes;\n  this.transactions.forEach(function (tx) {\n    var txSize = tx.byteLength(); // TODO: extract from toBuffer?\n\n    tx.toBuffer(buffer, offset);\n    offset += txSize;\n  });\n  return buffer;\n};\n\nBlock.prototype.toHex = function (headersOnly) {\n  return this.toBuffer(headersOnly).toString('hex');\n};\n\nBlock.calculateTarget = function (bits) {\n  var exponent = ((bits & 0xff000000) >> 24) - 3;\n  var mantissa = bits & 0x007fffff;\n  var target = Buffer.alloc(32, 0);\n  target.writeUInt32BE(mantissa, 28 - exponent);\n  return target;\n};\n\nBlock.calculateMerkleRoot = function (transactions) {\n  typeforce([{\n    getHash: types.Function\n  }], transactions);\n  if (transactions.length === 0) throw TypeError('Cannot compute merkle root for zero transactions');\n  var hashes = transactions.map(function (transaction) {\n    return transaction.getHash();\n  });\n  return fastMerkleRoot(hashes, bcrypto.hash256);\n};\n\nBlock.prototype.checkMerkleRoot = function () {\n  if (!this.transactions) return false;\n  var actualMerkleRoot = Block.calculateMerkleRoot(this.transactions);\n  return this.merkleRoot.compare(actualMerkleRoot) === 0;\n};\n\nBlock.prototype.checkProofOfWork = function () {\n  var hash = this.getHash().reverse();\n  var target = Block.calculateTarget(this.bits);\n  return hash.compare(target) <= 0;\n};\n\nmodule.exports = Block;","map":{"version":3,"names":["Buffer","require","bcrypto","fastMerkleRoot","typeforce","types","varuint","Transaction","Block","version","prevHash","merkleRoot","timestamp","bits","nonce","fromBuffer","buffer","length","Error","offset","readSlice","n","slice","readUInt32","i","readUInt32LE","readInt32","readInt32LE","block","readVarInt","vi","decode","bytes","readTransaction","tx","byteLength","nTransactions","transactions","push","prototype","headersOnly","encodingLength","reduce","a","x","fromHex","hex","from","getHash","hash256","toBuffer","getId","reverse","toString","getUTCDate","date","Date","setUTCSeconds","allocUnsafe","writeSlice","copy","writeInt32","writeInt32LE","writeUInt32","writeUInt32LE","encode","forEach","txSize","toHex","calculateTarget","exponent","mantissa","target","alloc","writeUInt32BE","calculateMerkleRoot","Function","TypeError","hashes","map","transaction","checkMerkleRoot","actualMerkleRoot","compare","checkProofOfWork","hash","module","exports"],"sources":["C:/Users/acer/node_modules/@tatumio/bitcoincashjs2-lib/src/block.js"],"sourcesContent":["var Buffer = require('safe-buffer').Buffer\nvar bcrypto = require('./crypto')\nvar fastMerkleRoot = require('merkle-lib/fastRoot')\nvar typeforce = require('typeforce')\nvar types = require('./types')\nvar varuint = require('varuint-bitcoin')\n\nvar Transaction = require('./transaction')\n\nfunction Block () {\n  this.version = 1\n  this.prevHash = null\n  this.merkleRoot = null\n  this.timestamp = 0\n  this.bits = 0\n  this.nonce = 0\n}\n\nBlock.fromBuffer = function (buffer) {\n  if (buffer.length < 80) throw new Error('Buffer too small (< 80 bytes)')\n\n  var offset = 0\n  function readSlice (n) {\n    offset += n\n    return buffer.slice(offset - n, offset)\n  }\n\n  function readUInt32 () {\n    var i = buffer.readUInt32LE(offset)\n    offset += 4\n    return i\n  }\n\n  function readInt32 () {\n    var i = buffer.readInt32LE(offset)\n    offset += 4\n    return i\n  }\n\n  var block = new Block()\n  block.version = readInt32()\n  block.prevHash = readSlice(32)\n  block.merkleRoot = readSlice(32)\n  block.timestamp = readUInt32()\n  block.bits = readUInt32()\n  block.nonce = readUInt32()\n\n  if (buffer.length === 80) return block\n\n  function readVarInt () {\n    var vi = varuint.decode(buffer, offset)\n    offset += varuint.decode.bytes\n    return vi\n  }\n\n  function readTransaction () {\n    var tx = Transaction.fromBuffer(buffer.slice(offset), true)\n    offset += tx.byteLength()\n    return tx\n  }\n\n  var nTransactions = readVarInt()\n  block.transactions = []\n\n  for (var i = 0; i < nTransactions; ++i) {\n    var tx = readTransaction()\n    block.transactions.push(tx)\n  }\n\n  return block\n}\n\nBlock.prototype.byteLength = function (headersOnly) {\n  if (headersOnly || !this.transactions) return 80\n\n  return 80 + varuint.encodingLength(this.transactions.length) + this.transactions.reduce(function (a, x) {\n    return a + x.byteLength()\n  }, 0)\n}\n\nBlock.fromHex = function (hex) {\n  return Block.fromBuffer(Buffer.from(hex, 'hex'))\n}\n\nBlock.prototype.getHash = function () {\n  return bcrypto.hash256(this.toBuffer(true))\n}\n\nBlock.prototype.getId = function () {\n  return this.getHash().reverse().toString('hex')\n}\n\nBlock.prototype.getUTCDate = function () {\n  var date = new Date(0) // epoch\n  date.setUTCSeconds(this.timestamp)\n\n  return date\n}\n\n// TODO: buffer, offset compatibility\nBlock.prototype.toBuffer = function (headersOnly) {\n  var buffer = Buffer.allocUnsafe(this.byteLength(headersOnly))\n\n  var offset = 0\n  function writeSlice (slice) {\n    slice.copy(buffer, offset)\n    offset += slice.length\n  }\n\n  function writeInt32 (i) {\n    buffer.writeInt32LE(i, offset)\n    offset += 4\n  }\n  function writeUInt32 (i) {\n    buffer.writeUInt32LE(i, offset)\n    offset += 4\n  }\n\n  writeInt32(this.version)\n  writeSlice(this.prevHash)\n  writeSlice(this.merkleRoot)\n  writeUInt32(this.timestamp)\n  writeUInt32(this.bits)\n  writeUInt32(this.nonce)\n\n  if (headersOnly || !this.transactions) return buffer\n\n  varuint.encode(this.transactions.length, buffer, offset)\n  offset += varuint.encode.bytes\n\n  this.transactions.forEach(function (tx) {\n    var txSize = tx.byteLength() // TODO: extract from toBuffer?\n    tx.toBuffer(buffer, offset)\n    offset += txSize\n  })\n\n  return buffer\n}\n\nBlock.prototype.toHex = function (headersOnly) {\n  return this.toBuffer(headersOnly).toString('hex')\n}\n\nBlock.calculateTarget = function (bits) {\n  var exponent = ((bits & 0xff000000) >> 24) - 3\n  var mantissa = bits & 0x007fffff\n  var target = Buffer.alloc(32, 0)\n  target.writeUInt32BE(mantissa, 28 - exponent)\n  return target\n}\n\nBlock.calculateMerkleRoot = function (transactions) {\n  typeforce([{ getHash: types.Function }], transactions)\n  if (transactions.length === 0) throw TypeError('Cannot compute merkle root for zero transactions')\n\n  var hashes = transactions.map(function (transaction) {\n    return transaction.getHash()\n  })\n\n  return fastMerkleRoot(hashes, bcrypto.hash256)\n}\n\nBlock.prototype.checkMerkleRoot = function () {\n  if (!this.transactions) return false\n\n  var actualMerkleRoot = Block.calculateMerkleRoot(this.transactions)\n  return this.merkleRoot.compare(actualMerkleRoot) === 0\n}\n\nBlock.prototype.checkProofOfWork = function () {\n  var hash = this.getHash().reverse()\n  var target = Block.calculateTarget(this.bits)\n\n  return hash.compare(target) <= 0\n}\n\nmodule.exports = Block\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}