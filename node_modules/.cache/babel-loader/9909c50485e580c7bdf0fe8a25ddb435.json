{"ast":null,"code":"/*\n    Modifications copyright 2018 The caver-js Authors\n    This file is part of web3.js.\n\n    web3.js is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Lesser General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    web3.js is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public License\n    along with web3.js.  If not, see <http://www.gnu.org/licenses/>.\n\n    This file is derived from web3.js/packages/web3-core-subscriptions/src/subscription.js (2019/06/12).\n    Modified and improved for the caver-js development.\n*/\n\n/**\n * @file subscription.js\n * @author Fabian Vogelsteller <fabian@ethereum.org>\n * @date 2017\n */\nconst _ = require('lodash');\n\nconst EventEmitter = require('eventemitter3');\n\nconst errors = require('../../caver-core-helpers').errors;\n/**\n * @classdesc A subscription class implemented to subscribe the specific events in the blockchain.\n * @class\n * @hideconstructor\n */\n\n\nfunction Subscription(options) {\n  EventEmitter.call(this);\n  this.id = null;\n  this.callback = null;\n  this.arguments = null;\n  this._reconnectIntervalId = null;\n  this.options = {\n    subscription: options.subscription,\n    type: options.type,\n    requestManager: options.requestManager\n  };\n}\n\nSubscription.prototype = Object.create(EventEmitter.prototype, {\n  constructor: {\n    value: Subscription\n  }\n});\n/**\n * Should be used to extract callback from array of arguments. Modifies input param\n *\n * @ignore\n * @method _extractCallback\n * @param {Array} arguments\n * @return {Function|Null} callback, if exists\n */\n\nSubscription.prototype._extractCallback = function (args) {\n  if (_.isFunction(args[args.length - 1])) {\n    return args.pop(); // modify the args array!\n  }\n};\n/**\n * Should be called to check if the number of arguments is correct\n *\n * @ignore\n * @method _validateArgs\n * @param {Array} arguments\n * @throws {Error} if it is not\n */\n\n\nSubscription.prototype._validateArgs = function (args) {\n  let subscription = this.options.subscription;\n\n  if (!subscription) {\n    subscription = {};\n  }\n\n  if (!subscription.params) {\n    subscription.params = 0;\n  }\n\n  if (args.length !== subscription.params) {\n    throw errors.InvalidNumberOfParams(args.length, subscription.params + 1, args[0]);\n  }\n};\n/**\n * Should be called to format input args of method\n *\n * @ignore\n * @method _formatInput\n * @param {Array}\n * @return {Array}\n */\n\n\nSubscription.prototype._formatInput = function (args) {\n  const subscription = this.options.subscription;\n\n  if (!subscription) {\n    return args;\n  }\n\n  if (!subscription.inputFormatter) {\n    return args;\n  }\n\n  const formattedArgs = subscription.inputFormatter.map(function (formatter, index) {\n    return formatter ? formatter(args[index]) : args[index];\n  });\n  return formattedArgs;\n};\n/**\n * Should be called to format output(result) of method\n *\n * @ignore\n * @method _formatOutput\n * @param {Object}\n * @return {Object}\n */\n\n\nSubscription.prototype._formatOutput = function (result) {\n  const subscription = this.options.subscription;\n  return subscription && subscription.outputFormatter && result ? subscription.outputFormatter(result) : result;\n};\n/**\n * Should create payload from given input args\n *\n * @ignore\n * @method _toPayload\n * @param {Array} args\n * @return {Object}\n */\n\n\nSubscription.prototype._toPayload = function (args) {\n  let params = [];\n  this.callback = this._extractCallback(args);\n\n  if (!this.subscriptionMethod) {\n    this.subscriptionMethod = args.shift();\n\n    if (this.options.subscription.subscriptionName) {\n      this.subscriptionMethod = this.options.subscription.subscriptionName;\n    }\n  }\n\n  if (!this.arguments) {\n    this.arguments = this._formatInput(args);\n\n    this._validateArgs(this.arguments);\n\n    args = []; // make empty after validation\n  } // re-add subscriptionName\n\n\n  params.push(this.subscriptionMethod);\n  params = params.concat(this.arguments);\n\n  if (args.length) {\n    throw new Error('Only a callback is allowed as parameter on an already instantiated subscription.');\n  }\n\n  return {\n    method: `${this.options.type}_subscribe`,\n    params: params\n  };\n};\n/**\n * Unsubscribes and clears callbacks.\n *\n * @return {Object}\n */\n\n\nSubscription.prototype.unsubscribe = function (callback) {\n  this.options.requestManager.removeSubscription(this.id, callback);\n  this.id = null;\n  this.removeAllListeners();\n  clearInterval(this._reconnectIntervalId);\n};\n/**\n * Subscribes and watches for changes\n *\n * @param {String} subscription the subscription\n * @param {Object} options the options object with address topics and fromBlock\n * @return {Object}\n */\n\n\nSubscription.prototype.subscribe = function () {\n  const _this = this;\n\n  const args = Array.prototype.slice.call(arguments);\n\n  const payload = this._toPayload(args);\n\n  if (!payload) {\n    return this;\n  }\n\n  if (!this.options.requestManager.provider) {\n    const err1 = new Error('No provider set.');\n    this.callback(err1, null, this);\n    /**\n     * Subscription 'error' event.\n     *\n     * @event Subscription#error\n     * @type {Error}\n     */\n\n    this.emit('error', err1);\n    return this;\n  }\n\n  if (!this.options.requestManager.provider.on) {\n    const err2 = new Error(`The current provider doesn't support subscriptions: ${this.options.requestManager.provider.constructor.name}`);\n    this.callback(err2, null, this);\n    this.emit('error', err2);\n    return this;\n  }\n\n  if (this.id) {\n    this.unsubscribe();\n  }\n\n  this.options.params = payload.params[1]; // get past logs, if fromBlock is available\n\n  if (payload.params[0] === 'logs' && _.isObject(payload.params[1]) && Object.prototype.hasOwnProperty.call(payload.params[1], 'fromBlock') && isFinite(payload.params[1].fromBlock)) {\n    // send the subscription request\n    // copy the params to avoid race-condition with deletion below this block\n    const blockParams = { ...payload.params[1]\n    };\n    this.options.requestManager.send({\n      method: 'klay_getLogs',\n      params: [blockParams]\n    }, function (err, logs) {\n      if (!err) {\n        logs.forEach(function (log) {\n          const output = _this._formatOutput(log);\n\n          _this.callback(null, output, _this);\n          /**\n           * Subscription 'data' event.\n           *\n           * @event Subscription#data\n           * @type {object}\n           */\n\n\n          _this.emit('data', output);\n        }); // TODO subscribe here? after the past logs?\n      } else {\n        _this.callback(err, null, _this);\n\n        _this.emit('error', err);\n      }\n    });\n  } // create subscription\n  // TODO move to separate function? so that past logs can go first?\n\n\n  if (typeof payload.params[1] === 'object') {\n    delete payload.params[1].fromBlock;\n  }\n\n  this.options.requestManager.send(payload, function (err, result) {\n    if (!err && result) {\n      _this.id = result;\n      /**\n       * Subscription 'connected' event.\n       *\n       * @event Subscription#connected\n       * @type {string}\n       */\n\n      _this.emit('connected', result); // call callback on notifications\n\n\n      _this.options.requestManager.addSubscription(_this.id, payload.params[0], _this.options.type, function (error, ret) {\n        if (!error) {\n          if (!_.isArray(ret)) {\n            ret = [ret];\n          }\n\n          ret.forEach(function (resultItem) {\n            const output = _this._formatOutput(resultItem);\n\n            if (_.isFunction(_this.options.subscription.subscriptionHandler)) {\n              return _this.options.subscription.subscriptionHandler.call(_this, output);\n            }\n\n            _this.emit('data', output); // call the callback, last so that unsubscribe there won't affect the emit above\n\n\n            if (_.isFunction(_this.callback)) {\n              _this.callback(null, output, _this);\n            }\n          });\n        } else {\n          // unsubscribe, but keep listeners\n          _this.options.requestManager.removeSubscription(_this.id); // re-subscribe, if connection fails\n\n\n          if (_this.options.requestManager.provider.once) {\n            _this._reconnectIntervalId = setInterval(function () {\n              // TODO check if that makes sense!\n              if (_this.options.requestManager.provider.reconnect) {\n                _this.options.requestManager.provider.reconnect();\n              }\n            }, 500);\n\n            _this.options.requestManager.provider.once('connect', function () {\n              clearInterval(_this._reconnectIntervalId);\n\n              _this.subscribe(_this.callback);\n            });\n          }\n\n          _this.emit('error', error); // call the callback, last so that unsubscribe there won't affect the emit above\n\n\n          if (_.isFunction(_this.callback)) {\n            _this.callback(error, null, _this);\n          }\n        }\n      });\n    } else if (_.isFunction(_this.callback)) {\n      _this.callback(err, null, _this);\n\n      _this.emit('error', err);\n    } else {\n      // emit the event even if no callback was provided\n      _this.emit('error', err);\n    }\n  }); // return an object to cancel the subscription\n\n  return this;\n};\n\nmodule.exports = Subscription;","map":{"version":3,"names":["_","require","EventEmitter","errors","Subscription","options","call","id","callback","arguments","_reconnectIntervalId","subscription","type","requestManager","prototype","Object","create","constructor","value","_extractCallback","args","isFunction","length","pop","_validateArgs","params","InvalidNumberOfParams","_formatInput","inputFormatter","formattedArgs","map","formatter","index","_formatOutput","result","outputFormatter","_toPayload","subscriptionMethod","shift","subscriptionName","push","concat","Error","method","unsubscribe","removeSubscription","removeAllListeners","clearInterval","subscribe","_this","Array","slice","payload","provider","err1","emit","on","err2","name","isObject","hasOwnProperty","isFinite","fromBlock","blockParams","send","err","logs","forEach","log","output","addSubscription","error","ret","isArray","resultItem","subscriptionHandler","once","setInterval","reconnect","module","exports"],"sources":["C:/Users/acer/node_modules/caver-js/packages/caver-core-subscriptions/src/subscription.js"],"sourcesContent":["/*\n    Modifications copyright 2018 The caver-js Authors\n    This file is part of web3.js.\n\n    web3.js is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Lesser General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    web3.js is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public License\n    along with web3.js.  If not, see <http://www.gnu.org/licenses/>.\n\n    This file is derived from web3.js/packages/web3-core-subscriptions/src/subscription.js (2019/06/12).\n    Modified and improved for the caver-js development.\n*/\n/**\n * @file subscription.js\n * @author Fabian Vogelsteller <fabian@ethereum.org>\n * @date 2017\n */\n\nconst _ = require('lodash')\nconst EventEmitter = require('eventemitter3')\nconst errors = require('../../caver-core-helpers').errors\n\n/**\n * @classdesc A subscription class implemented to subscribe the specific events in the blockchain.\n * @class\n * @hideconstructor\n */\nfunction Subscription(options) {\n    EventEmitter.call(this)\n\n    this.id = null\n    this.callback = null\n    this.arguments = null\n    this._reconnectIntervalId = null\n\n    this.options = {\n        subscription: options.subscription,\n        type: options.type,\n        requestManager: options.requestManager,\n    }\n}\n\nSubscription.prototype = Object.create(EventEmitter.prototype, {\n    constructor: { value: Subscription },\n})\n\n/**\n * Should be used to extract callback from array of arguments. Modifies input param\n *\n * @ignore\n * @method _extractCallback\n * @param {Array} arguments\n * @return {Function|Null} callback, if exists\n */\nSubscription.prototype._extractCallback = function(args) {\n    if (_.isFunction(args[args.length - 1])) {\n        return args.pop() // modify the args array!\n    }\n}\n\n/**\n * Should be called to check if the number of arguments is correct\n *\n * @ignore\n * @method _validateArgs\n * @param {Array} arguments\n * @throws {Error} if it is not\n */\nSubscription.prototype._validateArgs = function(args) {\n    let subscription = this.options.subscription\n\n    if (!subscription) {\n        subscription = {}\n    }\n\n    if (!subscription.params) {\n        subscription.params = 0\n    }\n\n    if (args.length !== subscription.params) {\n        throw errors.InvalidNumberOfParams(args.length, subscription.params + 1, args[0])\n    }\n}\n\n/**\n * Should be called to format input args of method\n *\n * @ignore\n * @method _formatInput\n * @param {Array}\n * @return {Array}\n */\nSubscription.prototype._formatInput = function(args) {\n    const subscription = this.options.subscription\n\n    if (!subscription) {\n        return args\n    }\n\n    if (!subscription.inputFormatter) {\n        return args\n    }\n\n    const formattedArgs = subscription.inputFormatter.map(function(formatter, index) {\n        return formatter ? formatter(args[index]) : args[index]\n    })\n\n    return formattedArgs\n}\n\n/**\n * Should be called to format output(result) of method\n *\n * @ignore\n * @method _formatOutput\n * @param {Object}\n * @return {Object}\n */\nSubscription.prototype._formatOutput = function(result) {\n    const subscription = this.options.subscription\n\n    return subscription && subscription.outputFormatter && result ? subscription.outputFormatter(result) : result\n}\n\n/**\n * Should create payload from given input args\n *\n * @ignore\n * @method _toPayload\n * @param {Array} args\n * @return {Object}\n */\nSubscription.prototype._toPayload = function(args) {\n    let params = []\n    this.callback = this._extractCallback(args)\n\n    if (!this.subscriptionMethod) {\n        this.subscriptionMethod = args.shift()\n\n        if (this.options.subscription.subscriptionName) {\n            this.subscriptionMethod = this.options.subscription.subscriptionName\n        }\n    }\n\n    if (!this.arguments) {\n        this.arguments = this._formatInput(args)\n        this._validateArgs(this.arguments)\n        args = [] // make empty after validation\n    }\n\n    // re-add subscriptionName\n    params.push(this.subscriptionMethod)\n    params = params.concat(this.arguments)\n\n    if (args.length) {\n        throw new Error('Only a callback is allowed as parameter on an already instantiated subscription.')\n    }\n\n    return {\n        method: `${this.options.type}_subscribe`,\n        params: params,\n    }\n}\n\n/**\n * Unsubscribes and clears callbacks.\n *\n * @return {Object}\n */\nSubscription.prototype.unsubscribe = function(callback) {\n    this.options.requestManager.removeSubscription(this.id, callback)\n    this.id = null\n    this.removeAllListeners()\n    clearInterval(this._reconnectIntervalId)\n}\n\n/**\n * Subscribes and watches for changes\n *\n * @param {String} subscription the subscription\n * @param {Object} options the options object with address topics and fromBlock\n * @return {Object}\n */\nSubscription.prototype.subscribe = function() {\n    const _this = this\n    const args = Array.prototype.slice.call(arguments)\n    const payload = this._toPayload(args)\n\n    if (!payload) {\n        return this\n    }\n\n    if (!this.options.requestManager.provider) {\n        const err1 = new Error('No provider set.')\n        this.callback(err1, null, this)\n\n        /**\n         * Subscription 'error' event.\n         *\n         * @event Subscription#error\n         * @type {Error}\n         */\n        this.emit('error', err1)\n        return this\n    }\n\n    if (!this.options.requestManager.provider.on) {\n        const err2 = new Error(\n            `The current provider doesn't support subscriptions: ${this.options.requestManager.provider.constructor.name}`\n        )\n        this.callback(err2, null, this)\n        this.emit('error', err2)\n        return this\n    }\n\n    if (this.id) {\n        this.unsubscribe()\n    }\n\n    this.options.params = payload.params[1]\n\n    // get past logs, if fromBlock is available\n    if (\n        payload.params[0] === 'logs' &&\n        _.isObject(payload.params[1]) &&\n        Object.prototype.hasOwnProperty.call(payload.params[1], 'fromBlock') &&\n        isFinite(payload.params[1].fromBlock)\n    ) {\n        // send the subscription request\n\n        // copy the params to avoid race-condition with deletion below this block\n        const blockParams = { ...payload.params[1] }\n\n        this.options.requestManager.send(\n            {\n                method: 'klay_getLogs',\n                params: [blockParams],\n            },\n            function(err, logs) {\n                if (!err) {\n                    logs.forEach(function(log) {\n                        const output = _this._formatOutput(log)\n                        _this.callback(null, output, _this)\n                        /**\n                         * Subscription 'data' event.\n                         *\n                         * @event Subscription#data\n                         * @type {object}\n                         */\n                        _this.emit('data', output)\n                    })\n\n                    // TODO subscribe here? after the past logs?\n                } else {\n                    _this.callback(err, null, _this)\n                    _this.emit('error', err)\n                }\n            }\n        )\n    }\n\n    // create subscription\n    // TODO move to separate function? so that past logs can go first?\n\n    if (typeof payload.params[1] === 'object') {\n        delete payload.params[1].fromBlock\n    }\n\n    this.options.requestManager.send(payload, function(err, result) {\n        if (!err && result) {\n            _this.id = result\n            /**\n             * Subscription 'connected' event.\n             *\n             * @event Subscription#connected\n             * @type {string}\n             */\n            _this.emit('connected', result)\n\n            // call callback on notifications\n            _this.options.requestManager.addSubscription(_this.id, payload.params[0], _this.options.type, function(error, ret) {\n                if (!error) {\n                    if (!_.isArray(ret)) {\n                        ret = [ret]\n                    }\n\n                    ret.forEach(function(resultItem) {\n                        const output = _this._formatOutput(resultItem)\n\n                        if (_.isFunction(_this.options.subscription.subscriptionHandler)) {\n                            return _this.options.subscription.subscriptionHandler.call(_this, output)\n                        }\n                        _this.emit('data', output)\n\n                        // call the callback, last so that unsubscribe there won't affect the emit above\n                        if (_.isFunction(_this.callback)) {\n                            _this.callback(null, output, _this)\n                        }\n                    })\n                } else {\n                    // unsubscribe, but keep listeners\n                    _this.options.requestManager.removeSubscription(_this.id)\n\n                    // re-subscribe, if connection fails\n                    if (_this.options.requestManager.provider.once) {\n                        _this._reconnectIntervalId = setInterval(function() {\n                            // TODO check if that makes sense!\n                            if (_this.options.requestManager.provider.reconnect) {\n                                _this.options.requestManager.provider.reconnect()\n                            }\n                        }, 500)\n\n                        _this.options.requestManager.provider.once('connect', function() {\n                            clearInterval(_this._reconnectIntervalId)\n                            _this.subscribe(_this.callback)\n                        })\n                    }\n                    _this.emit('error', error)\n\n                    // call the callback, last so that unsubscribe there won't affect the emit above\n                    if (_.isFunction(_this.callback)) {\n                        _this.callback(error, null, _this)\n                    }\n                }\n            })\n        } else if (_.isFunction(_this.callback)) {\n            _this.callback(err, null, _this)\n            _this.emit('error', err)\n        } else {\n            // emit the event even if no callback was provided\n            _this.emit('error', err)\n        }\n    })\n    // return an object to cancel the subscription\n    return this\n}\n\nmodule.exports = Subscription\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}