{"ast":null,"code":"\"use strict\";\n\nvar assert = require(\"assert\");\n\nvar coretypes_1 = require(\"./coretypes\");\n\nvar ledger_hashes_1 = require(\"./ledger-hashes\");\n\nvar enums_1 = require(\"./enums\");\n\nvar signingData = coretypes_1.binary.signingData,\n    signingClaimData = coretypes_1.binary.signingClaimData,\n    multiSigningData = coretypes_1.binary.multiSigningData,\n    binaryToJSON = coretypes_1.binary.binaryToJSON,\n    serializeObject = coretypes_1.binary.serializeObject;\n/**\n * Decode a transaction\n *\n * @param binary hex-string of the encoded transaction\n * @returns the JSON representation of the transaction\n */\n\nfunction decode(binary) {\n  assert.ok(typeof binary === 'string', 'binary must be a hex string');\n  return binaryToJSON(binary);\n}\n/**\n * Encode a transaction\n *\n * @param json The JSON representation of a transaction\n * @returns A hex-string of the encoded transaction\n */\n\n\nfunction encode(json) {\n  assert.ok(typeof json === 'object');\n  return serializeObject(json).toString('hex').toUpperCase();\n}\n/**\n * Encode a transaction and prepare for signing\n *\n * @param json JSON object representing the transaction\n * @param signer string representing the account to sign the transaction with\n * @returns a hex string of the encoded transaction\n */\n\n\nfunction encodeForSigning(json) {\n  assert.ok(typeof json === 'object');\n  return signingData(json).toString('hex').toUpperCase();\n}\n/**\n * Encode a transaction and prepare for signing with a claim\n *\n * @param json JSON object representing the transaction\n * @param signer string representing the account to sign the transaction with\n * @returns a hex string of the encoded transaction\n */\n\n\nfunction encodeForSigningClaim(json) {\n  assert.ok(typeof json === 'object');\n  return signingClaimData(json).toString('hex').toUpperCase();\n}\n/**\n * Encode a transaction and prepare for multi-signing\n *\n * @param json JSON object representing the transaction\n * @param signer string representing the account to sign the transaction with\n * @returns a hex string of the encoded transaction\n */\n\n\nfunction encodeForMultisigning(json, signer) {\n  assert.ok(typeof json === 'object');\n  assert.equal(json['SigningPubKey'], '');\n  return multiSigningData(json, signer).toString('hex').toUpperCase();\n}\n/**\n * Encode a quality value\n *\n * @param value string representation of a number\n * @returns a hex-string representing the quality\n */\n\n\nfunction encodeQuality(value) {\n  assert.ok(typeof value === 'string');\n  return coretypes_1.quality.encode(value).toString('hex').toUpperCase();\n}\n/**\n * Decode a quality value\n *\n * @param value hex-string of a quality\n * @returns a string representing the quality\n */\n\n\nfunction decodeQuality(value) {\n  assert.ok(typeof value === 'string');\n  return coretypes_1.quality.decode(value).toString();\n}\n\nmodule.exports = {\n  decode: decode,\n  encode: encode,\n  encodeForSigning: encodeForSigning,\n  encodeForSigningClaim: encodeForSigningClaim,\n  encodeForMultisigning: encodeForMultisigning,\n  encodeQuality: encodeQuality,\n  decodeQuality: decodeQuality,\n  decodeLedgerData: ledger_hashes_1.decodeLedgerData,\n  TRANSACTION_TYPES: enums_1.TRANSACTION_TYPES\n};","map":{"version":3,"mappings":";;AAAA;;AACA;;AACA;;AAGA;;AAGE,eAAW,GAKTA,mBAAMC,WALR;AAAA,IACAC,gBAAgB,GAIdF,mBAAME,gBALR;AAAA,IAEAC,gBAAgB,GAGdH,mBAAMG,gBALR;AAAA,IAGAC,YAAY,GAEVJ,mBAAMI,YALR;AAAA,IAIAC,eAAe,GACbL,mBAAMK,eALR;AAOF;;;;;;;AAMA,SAASC,MAAT,CAAgBC,MAAhB,EAA8B;EAC5BC,MAAM,CAACC,EAAP,CAAU,OAAOF,MAAP,KAAkB,QAA5B,EAAsC,6BAAtC;EACA,OAAOH,YAAY,CAACG,MAAD,CAAnB;AACD;AAED;;;;;;;;AAMA,SAASG,MAAT,CAAgBC,IAAhB,EAA4B;EAC1BH,MAAM,CAACC,EAAP,CAAU,OAAOE,IAAP,KAAgB,QAA1B;EACA,OAAON,eAAe,CAACM,IAAD,CAAf,CACJC,QADI,CACK,KADL,EAEJC,WAFI,EAAP;AAGD;AAED;;;;;;;;;AAOA,SAASC,gBAAT,CAA0BH,IAA1B,EAAsC;EACpCH,MAAM,CAACC,EAAP,CAAU,OAAOE,IAAP,KAAgB,QAA1B;EACA,OAAOV,WAAW,CAACU,IAAD,CAAX,CACJC,QADI,CACK,KADL,EAEJC,WAFI,EAAP;AAGD;AAED;;;;;;;;;AAOA,SAASE,qBAAT,CAA+BJ,IAA/B,EAA2C;EACzCH,MAAM,CAACC,EAAP,CAAU,OAAOE,IAAP,KAAgB,QAA1B;EACA,OAAOT,gBAAgB,CAACS,IAAD,CAAhB,CACJC,QADI,CACK,KADL,EAEJC,WAFI,EAAP;AAGD;AAED;;;;;;;;;AAOA,SAASG,qBAAT,CAA+BL,IAA/B,EAA6CM,MAA7C,EAA2D;EACzDT,MAAM,CAACC,EAAP,CAAU,OAAOE,IAAP,KAAgB,QAA1B;EACAH,MAAM,CAACU,KAAP,CAAaP,IAAI,CAAC,eAAD,CAAjB,EAAoC,EAApC;EACA,OAAOR,gBAAgB,CAACQ,IAAD,EAAqBM,MAArB,CAAhB,CACJL,QADI,CACK,KADL,EAEJC,WAFI,EAAP;AAGD;AAED;;;;;;;;AAMA,SAASM,aAAT,CAAuBC,KAAvB,EAAoC;EAClCZ,MAAM,CAACC,EAAP,CAAU,OAAOW,KAAP,KAAiB,QAA3B;EACA,OAAOpB,oBAAQU,MAAR,CAAeU,KAAf,EAAsBR,QAAtB,CAA+B,KAA/B,EAAsCC,WAAtC,EAAP;AACD;AAED;;;;;;;;AAMA,SAASQ,aAAT,CAAuBD,KAAvB,EAAoC;EAClCZ,MAAM,CAACC,EAAP,CAAU,OAAOW,KAAP,KAAiB,QAA3B;EACA,OAAOpB,oBAAQM,MAAR,CAAec,KAAf,EAAsBR,QAAtB,EAAP;AACD;;AAEDU,iBAAS;EACPhB,MAAM,QADC;EAEPI,MAAM,QAFC;EAGPI,gBAAgB,kBAHT;EAIPC,qBAAqB,uBAJd;EAKPC,qBAAqB,uBALd;EAMPG,aAAa,eANN;EAOPE,aAAa,eAPN;EAQPE,gBAAgB,kCART;EASPC,iBAAiB;AATV,CAAT","names":["coretypes_1","signingData","signingClaimData","multiSigningData","binaryToJSON","serializeObject","decode","binary","assert","ok","encode","json","toString","toUpperCase","encodeForSigning","encodeForSigningClaim","encodeForMultisigning","signer","equal","encodeQuality","value","decodeQuality","module","decodeLedgerData","TRANSACTION_TYPES"],"sourceRoot":"","sources":["../src/index.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}