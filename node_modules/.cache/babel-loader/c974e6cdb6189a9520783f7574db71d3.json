{"ast":null,"code":"'use strict';\n\nvar BN = require('./bn');\n\nvar _ = require('lodash');\n\nvar $ = require('../util/preconditions');\n\nvar BufferUtil = require('../util/buffer');\n\nvar JSUtil = require('../util/js');\n\nvar Signature = function Signature(r, s) {\n  if (!(this instanceof Signature)) {\n    return new Signature(r, s);\n  }\n\n  if (r instanceof BN) {\n    this.set({\n      r: r,\n      s: s\n    });\n  } else if (r) {\n    var obj = r;\n    this.set(obj);\n  }\n};\n/* jshint maxcomplexity: 7 */\n\n\nSignature.prototype.set = function (obj) {\n  this.r = obj.r || this.r || undefined;\n  this.s = obj.s || this.s || undefined;\n  this.i = typeof obj.i !== 'undefined' ? obj.i : this.i; //public key recovery parameter in range [0, 3]\n\n  this.compressed = typeof obj.compressed !== 'undefined' ? obj.compressed : this.compressed; //whether the recovered pubkey is compressed\n\n  this.nhashtype = obj.nhashtype || this.nhashtype || undefined;\n  return this;\n};\n\nSignature.fromCompact = function (buf) {\n  $.checkArgument(BufferUtil.isBuffer(buf), 'Argument is expected to be a Buffer');\n  var sig = new Signature();\n  var compressed = true;\n  var i = buf.slice(0, 1)[0] - 27 - 4;\n\n  if (i < 0) {\n    compressed = false;\n    i = i + 4;\n  }\n\n  var b2 = buf.slice(1, 33);\n  var b3 = buf.slice(33, 65);\n  $.checkArgument(i === 0 || i === 1 || i === 2 || i === 3, new Error('i must be 0, 1, 2, or 3'));\n  $.checkArgument(b2.length === 32, new Error('r must be 32 bytes'));\n  $.checkArgument(b3.length === 32, new Error('s must be 32 bytes'));\n  sig.compressed = compressed;\n  sig.i = i;\n  sig.r = BN.fromBuffer(b2);\n  sig.s = BN.fromBuffer(b3);\n  return sig;\n};\n\nSignature.fromDER = Signature.fromBuffer = function (buf, strict) {\n  var obj = Signature.parseDER(buf, strict);\n  var sig = new Signature();\n  sig.r = obj.r;\n  sig.s = obj.s;\n  return sig;\n}; // The format used in a tx\n\n\nSignature.fromTxFormat = function (buf) {\n  var nhashtype = buf.readUInt8(buf.length - 1);\n  var derbuf = buf.slice(0, buf.length - 1);\n  var sig = new Signature.fromDER(derbuf, false);\n  sig.nhashtype = nhashtype;\n  return sig;\n};\n\nSignature.fromString = function (str) {\n  var buf = Buffer.from(str, 'hex');\n  return Signature.fromDER(buf);\n};\n/**\n * In order to mimic the non-strict DER encoding of OpenSSL, set strict = false.\n */\n\n\nSignature.parseDER = function (buf, strict) {\n  $.checkArgument(BufferUtil.isBuffer(buf), new Error('DER formatted signature should be a buffer'));\n\n  if (_.isUndefined(strict)) {\n    strict = true;\n  }\n\n  var header = buf[0];\n  $.checkArgument(header === 0x30, new Error('Header byte should be 0x30'));\n  var length = buf[1];\n  var buflength = buf.slice(2).length;\n  $.checkArgument(!strict || length === buflength, new Error('Length byte should length of what follows'));\n  length = length < buflength ? length : buflength;\n  var rheader = buf[2 + 0];\n  $.checkArgument(rheader === 0x02, new Error('Integer byte for r should be 0x02'));\n  var rlength = buf[2 + 1];\n  var rbuf = buf.slice(2 + 2, 2 + 2 + rlength);\n  var r = BN.fromBuffer(rbuf);\n  var rneg = buf[2 + 1 + 1] === 0x00 ? true : false;\n  $.checkArgument(rlength === rbuf.length, new Error('Length of r incorrect'));\n  var sheader = buf[2 + 2 + rlength + 0];\n  $.checkArgument(sheader === 0x02, new Error('Integer byte for s should be 0x02'));\n  var slength = buf[2 + 2 + rlength + 1];\n  var sbuf = buf.slice(2 + 2 + rlength + 2, 2 + 2 + rlength + 2 + slength);\n  var s = BN.fromBuffer(sbuf);\n  var sneg = buf[2 + 2 + rlength + 2 + 2] === 0x00 ? true : false;\n  $.checkArgument(slength === sbuf.length, new Error('Length of s incorrect'));\n  var sumlength = 2 + 2 + rlength + 2 + slength;\n  $.checkArgument(length === sumlength - 2, new Error('Length of signature incorrect'));\n  var obj = {\n    header: header,\n    length: length,\n    rheader: rheader,\n    rlength: rlength,\n    rneg: rneg,\n    rbuf: rbuf,\n    r: r,\n    sheader: sheader,\n    slength: slength,\n    sneg: sneg,\n    sbuf: sbuf,\n    s: s\n  };\n  return obj;\n};\n\nSignature.prototype.toCompact = function (i, compressed) {\n  i = typeof i === 'number' ? i : this.i;\n  compressed = typeof compressed === 'boolean' ? compressed : this.compressed;\n\n  if (!(i === 0 || i === 1 || i === 2 || i === 3)) {\n    throw new Error('i must be equal to 0, 1, 2, or 3');\n  }\n\n  var val = i + 27 + 4;\n\n  if (compressed === false) {\n    val = val - 4;\n  }\n\n  var b1 = Buffer.from([val]);\n  var b2 = this.r.toBuffer({\n    size: 32\n  });\n  var b3 = this.s.toBuffer({\n    size: 32\n  });\n  return Buffer.concat([b1, b2, b3]);\n};\n\nSignature.prototype.toBuffer = Signature.prototype.toDER = function () {\n  var rnbuf = this.r.toBuffer();\n  var snbuf = this.s.toBuffer();\n  var rneg = rnbuf[0] & 0x80 ? true : false;\n  var sneg = snbuf[0] & 0x80 ? true : false;\n  var rbuf = rneg ? Buffer.concat([Buffer.from([0x00]), rnbuf]) : rnbuf;\n  var sbuf = sneg ? Buffer.concat([Buffer.from([0x00]), snbuf]) : snbuf;\n  var rlength = rbuf.length;\n  var slength = sbuf.length;\n  var length = 2 + rlength + 2 + slength;\n  var rheader = 0x02;\n  var sheader = 0x02;\n  var header = 0x30;\n  var der = Buffer.concat([Buffer.from([header, length, rheader, rlength]), rbuf, Buffer.from([sheader, slength]), sbuf]);\n  return der;\n};\n\nSignature.prototype.toString = function () {\n  var buf = this.toDER();\n  return buf.toString('hex');\n};\n/**\n * This function is translated from bitcoind's IsDERSignature and is used in\n * the script interpreter.  This \"DER\" format actually includes an extra byte,\n * the nhashtype, at the end. It is really the tx format, not DER format.\n *\n * A canonical signature exists of: [30] [total len] [02] [len R] [R] [02] [len S] [S] [hashtype]\n * Where R and S are not negative (their first byte has its highest bit not set), and not\n * excessively padded (do not start with a 0 byte, unless an otherwise negative number follows,\n * in which case a single 0 byte is necessary and even required).\n *\n * See https://bitcointalk.org/index.php?topic=8392.msg127623#msg127623\n */\n\n\nSignature.isTxDER = function (buf) {\n  if (buf.length < 9) {\n    //  Non-canonical signature: too short\n    return false;\n  }\n\n  if (buf.length > 73) {\n    // Non-canonical signature: too long\n    return false;\n  }\n\n  if (buf[0] !== 0x30) {\n    //  Non-canonical signature: wrong type\n    return false;\n  }\n\n  if (buf[1] !== buf.length - 3) {\n    //  Non-canonical signature: wrong length marker\n    return false;\n  }\n\n  var nLenR = buf[3];\n\n  if (5 + nLenR >= buf.length) {\n    //  Non-canonical signature: S length misplaced\n    return false;\n  }\n\n  var nLenS = buf[5 + nLenR];\n\n  if (nLenR + nLenS + 7 !== buf.length) {\n    //  Non-canonical signature: R+S length mismatch\n    return false;\n  }\n\n  var R = buf.slice(4);\n\n  if (buf[4 - 2] !== 0x02) {\n    //  Non-canonical signature: R value type mismatch\n    return false;\n  }\n\n  if (nLenR === 0) {\n    //  Non-canonical signature: R length is zero\n    return false;\n  }\n\n  if (R[0] & 0x80) {\n    //  Non-canonical signature: R value negative\n    return false;\n  }\n\n  if (nLenR > 1 && R[0] === 0x00 && !(R[1] & 0x80)) {\n    //  Non-canonical signature: R value excessively padded\n    return false;\n  }\n\n  var S = buf.slice(6 + nLenR);\n\n  if (buf[6 + nLenR - 2] !== 0x02) {\n    //  Non-canonical signature: S value type mismatch\n    return false;\n  }\n\n  if (nLenS === 0) {\n    //  Non-canonical signature: S length is zero\n    return false;\n  }\n\n  if (S[0] & 0x80) {\n    //  Non-canonical signature: S value negative\n    return false;\n  }\n\n  if (nLenS > 1 && S[0] === 0x00 && !(S[1] & 0x80)) {\n    //  Non-canonical signature: S value excessively padded\n    return false;\n  }\n\n  return true;\n};\n/**\n * Compares to bitcoind's IsLowDERSignature\n * See also ECDSA signature algorithm which enforces this.\n * See also BIP 62, \"low S values in signatures\"\n */\n\n\nSignature.prototype.hasLowS = function () {\n  if (this.s.lt(new BN(1)) || this.s.gt(new BN('7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0', 'hex'))) {\n    return false;\n  }\n\n  return true;\n};\n/**\n * @returns true if the nhashtype is exactly equal to one of the standard options or combinations thereof.\n * Translated from bitcoind's IsDefinedHashtypeSignature\n */\n\n\nSignature.prototype.hasDefinedHashtype = function () {\n  if (!JSUtil.isNaturalNumber(this.nhashtype)) {\n    return false;\n  } // accept with or without Signature.SIGHASH_ANYONECANPAY by ignoring the bit\n\n\n  var temp = this.nhashtype & ~Signature.SIGHASH_ANYONECANPAY;\n\n  if (temp < Signature.SIGHASH_ALL || temp > Signature.SIGHASH_SINGLE) {\n    return false;\n  }\n\n  return true;\n};\n\nSignature.prototype.toTxFormat = function () {\n  var derbuf = this.toDER();\n  var buf = Buffer.alloc(1);\n  buf.writeUInt8(this.nhashtype, 0);\n  return Buffer.concat([derbuf, buf]);\n};\n\nSignature.SIGHASH_ALL = 0x01;\nSignature.SIGHASH_NONE = 0x02;\nSignature.SIGHASH_SINGLE = 0x03;\nSignature.SIGHASH_ANYONECANPAY = 0x80;\nmodule.exports = Signature;","map":{"version":3,"names":["BN","require","_","$","BufferUtil","JSUtil","Signature","r","s","set","obj","prototype","undefined","i","compressed","nhashtype","fromCompact","buf","checkArgument","isBuffer","sig","slice","b2","b3","Error","length","fromBuffer","fromDER","strict","parseDER","fromTxFormat","readUInt8","derbuf","fromString","str","Buffer","from","isUndefined","header","buflength","rheader","rlength","rbuf","rneg","sheader","slength","sbuf","sneg","sumlength","toCompact","val","b1","toBuffer","size","concat","toDER","rnbuf","snbuf","der","toString","isTxDER","nLenR","nLenS","R","S","hasLowS","lt","gt","hasDefinedHashtype","isNaturalNumber","temp","SIGHASH_ANYONECANPAY","SIGHASH_ALL","SIGHASH_SINGLE","toTxFormat","alloc","writeUInt8","SIGHASH_NONE","module","exports"],"sources":["C:/Users/acer/node_modules/bitcore-lib/lib/crypto/signature.js"],"sourcesContent":["'use strict';\n\nvar BN = require('./bn');\nvar _ = require('lodash');\nvar $ = require('../util/preconditions');\nvar BufferUtil = require('../util/buffer');\nvar JSUtil = require('../util/js');\n\nvar Signature = function Signature(r, s) {\n  if (!(this instanceof Signature)) {\n    return new Signature(r, s);\n  }\n  if (r instanceof BN) {\n    this.set({\n      r: r,\n      s: s\n    });\n  } else if (r) {\n    var obj = r;\n    this.set(obj);\n  }\n};\n\n/* jshint maxcomplexity: 7 */\nSignature.prototype.set = function(obj) {\n  this.r = obj.r || this.r || undefined;\n  this.s = obj.s || this.s || undefined;\n\n  this.i = typeof obj.i !== 'undefined' ? obj.i : this.i; //public key recovery parameter in range [0, 3]\n  this.compressed = typeof obj.compressed !== 'undefined' ?\n    obj.compressed : this.compressed; //whether the recovered pubkey is compressed\n  this.nhashtype = obj.nhashtype || this.nhashtype || undefined;\n  return this;\n};\n\nSignature.fromCompact = function(buf) {\n  $.checkArgument(BufferUtil.isBuffer(buf), 'Argument is expected to be a Buffer');\n\n  var sig = new Signature();\n\n  var compressed = true;\n  var i = buf.slice(0, 1)[0] - 27 - 4;\n  if (i < 0) {\n    compressed = false;\n    i = i + 4;\n  }\n\n  var b2 = buf.slice(1, 33);\n  var b3 = buf.slice(33, 65);\n\n  $.checkArgument(i === 0 || i === 1 || i === 2 || i === 3, new Error('i must be 0, 1, 2, or 3'));\n  $.checkArgument(b2.length === 32, new Error('r must be 32 bytes'));\n  $.checkArgument(b3.length === 32, new Error('s must be 32 bytes'));\n\n  sig.compressed = compressed;\n  sig.i = i;\n  sig.r = BN.fromBuffer(b2);\n  sig.s = BN.fromBuffer(b3);\n\n  return sig;\n};\n\nSignature.fromDER = Signature.fromBuffer = function(buf, strict) {\n  var obj = Signature.parseDER(buf, strict);\n  var sig = new Signature();\n\n  sig.r = obj.r;\n  sig.s = obj.s;\n\n  return sig;\n};\n\n// The format used in a tx\nSignature.fromTxFormat = function(buf) {\n  var nhashtype = buf.readUInt8(buf.length - 1);\n  var derbuf = buf.slice(0, buf.length - 1);\n  var sig = new Signature.fromDER(derbuf, false);\n  sig.nhashtype = nhashtype;\n  return sig;\n};\n\nSignature.fromString = function(str) {\n  var buf = Buffer.from(str, 'hex');\n  return Signature.fromDER(buf);\n};\n\n\n/**\n * In order to mimic the non-strict DER encoding of OpenSSL, set strict = false.\n */\nSignature.parseDER = function(buf, strict) {\n  $.checkArgument(BufferUtil.isBuffer(buf), new Error('DER formatted signature should be a buffer'));\n  if (_.isUndefined(strict)) {\n    strict = true;\n  }\n\n  var header = buf[0];\n  $.checkArgument(header === 0x30, new Error('Header byte should be 0x30'));\n\n  var length = buf[1];\n  var buflength = buf.slice(2).length;\n  $.checkArgument(!strict || length === buflength, new Error('Length byte should length of what follows'));\n\n  length = length < buflength ? length : buflength;\n\n  var rheader = buf[2 + 0];\n  $.checkArgument(rheader === 0x02, new Error('Integer byte for r should be 0x02'));\n\n  var rlength = buf[2 + 1];\n  var rbuf = buf.slice(2 + 2, 2 + 2 + rlength);\n  var r = BN.fromBuffer(rbuf);\n  var rneg = buf[2 + 1 + 1] === 0x00 ? true : false;\n  $.checkArgument(rlength === rbuf.length, new Error('Length of r incorrect'));\n\n  var sheader = buf[2 + 2 + rlength + 0];\n  $.checkArgument(sheader === 0x02, new Error('Integer byte for s should be 0x02'));\n\n  var slength = buf[2 + 2 + rlength + 1];\n  var sbuf = buf.slice(2 + 2 + rlength + 2, 2 + 2 + rlength + 2 + slength);\n  var s = BN.fromBuffer(sbuf);\n  var sneg = buf[2 + 2 + rlength + 2 + 2] === 0x00 ? true : false;\n  $.checkArgument(slength === sbuf.length, new Error('Length of s incorrect'));\n\n  var sumlength = 2 + 2 + rlength + 2 + slength;\n  $.checkArgument(length === sumlength - 2, new Error('Length of signature incorrect'));\n\n  var obj = {\n    header: header,\n    length: length,\n    rheader: rheader,\n    rlength: rlength,\n    rneg: rneg,\n    rbuf: rbuf,\n    r: r,\n    sheader: sheader,\n    slength: slength,\n    sneg: sneg,\n    sbuf: sbuf,\n    s: s\n  };\n\n  return obj;\n};\n\n\nSignature.prototype.toCompact = function(i, compressed) {\n  i = typeof i === 'number' ? i : this.i;\n  compressed = typeof compressed === 'boolean' ? compressed : this.compressed;\n\n  if (!(i === 0 || i === 1 || i === 2 || i === 3)) {\n    throw new Error('i must be equal to 0, 1, 2, or 3');\n  }\n\n  var val = i + 27 + 4;\n  if (compressed === false) {\n    val = val - 4;\n  }\n  var b1 = Buffer.from([val]);\n  var b2 = this.r.toBuffer({\n    size: 32\n  });\n  var b3 = this.s.toBuffer({\n    size: 32\n  });\n  return Buffer.concat([b1, b2, b3]);\n};\n\nSignature.prototype.toBuffer = Signature.prototype.toDER = function() {\n  var rnbuf = this.r.toBuffer();\n  var snbuf = this.s.toBuffer();\n\n  var rneg = rnbuf[0] & 0x80 ? true : false;\n  var sneg = snbuf[0] & 0x80 ? true : false;\n\n  var rbuf = rneg ? Buffer.concat([Buffer.from([0x00]), rnbuf]) : rnbuf;\n  var sbuf = sneg ? Buffer.concat([Buffer.from([0x00]), snbuf]) : snbuf;\n\n  var rlength = rbuf.length;\n  var slength = sbuf.length;\n  var length = 2 + rlength + 2 + slength;\n  var rheader = 0x02;\n  var sheader = 0x02;\n  var header = 0x30;\n\n  var der = Buffer.concat([Buffer.from([header, length, rheader, rlength]), rbuf, Buffer.from([sheader, slength]), sbuf]);\n  return der;\n};\n\nSignature.prototype.toString = function() {\n  var buf = this.toDER();\n  return buf.toString('hex');\n};\n\n/**\n * This function is translated from bitcoind's IsDERSignature and is used in\n * the script interpreter.  This \"DER\" format actually includes an extra byte,\n * the nhashtype, at the end. It is really the tx format, not DER format.\n *\n * A canonical signature exists of: [30] [total len] [02] [len R] [R] [02] [len S] [S] [hashtype]\n * Where R and S are not negative (their first byte has its highest bit not set), and not\n * excessively padded (do not start with a 0 byte, unless an otherwise negative number follows,\n * in which case a single 0 byte is necessary and even required).\n *\n * See https://bitcointalk.org/index.php?topic=8392.msg127623#msg127623\n */\nSignature.isTxDER = function(buf) {\n  if (buf.length < 9) {\n    //  Non-canonical signature: too short\n    return false;\n  }\n  if (buf.length > 73) {\n    // Non-canonical signature: too long\n    return false;\n  }\n  if (buf[0] !== 0x30) {\n    //  Non-canonical signature: wrong type\n    return false;\n  }\n  if (buf[1] !== buf.length - 3) {\n    //  Non-canonical signature: wrong length marker\n    return false;\n  }\n  var nLenR = buf[3];\n  if (5 + nLenR >= buf.length) {\n    //  Non-canonical signature: S length misplaced\n    return false;\n  }\n  var nLenS = buf[5 + nLenR];\n  if ((nLenR + nLenS + 7) !== buf.length) {\n    //  Non-canonical signature: R+S length mismatch\n    return false;\n  }\n\n  var R = buf.slice(4);\n  if (buf[4 - 2] !== 0x02) {\n    //  Non-canonical signature: R value type mismatch\n    return false;\n  }\n  if (nLenR === 0) {\n    //  Non-canonical signature: R length is zero\n    return false;\n  }\n  if (R[0] & 0x80) {\n    //  Non-canonical signature: R value negative\n    return false;\n  }\n  if (nLenR > 1 && (R[0] === 0x00) && !(R[1] & 0x80)) {\n    //  Non-canonical signature: R value excessively padded\n    return false;\n  }\n\n  var S = buf.slice(6 + nLenR);\n  if (buf[6 + nLenR - 2] !== 0x02) {\n    //  Non-canonical signature: S value type mismatch\n    return false;\n  }\n  if (nLenS === 0) {\n    //  Non-canonical signature: S length is zero\n    return false;\n  }\n  if (S[0] & 0x80) {\n    //  Non-canonical signature: S value negative\n    return false;\n  }\n  if (nLenS > 1 && (S[0] === 0x00) && !(S[1] & 0x80)) {\n    //  Non-canonical signature: S value excessively padded\n    return false;\n  }\n  return true;\n};\n\n/**\n * Compares to bitcoind's IsLowDERSignature\n * See also ECDSA signature algorithm which enforces this.\n * See also BIP 62, \"low S values in signatures\"\n */\nSignature.prototype.hasLowS = function() {\n  if (this.s.lt(new BN(1)) ||\n    this.s.gt(new BN('7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0', 'hex'))) {\n    return false;\n  }\n  return true;\n};\n\n/**\n * @returns true if the nhashtype is exactly equal to one of the standard options or combinations thereof.\n * Translated from bitcoind's IsDefinedHashtypeSignature\n */\nSignature.prototype.hasDefinedHashtype = function() {\n  if (!JSUtil.isNaturalNumber(this.nhashtype)) {\n    return false;\n  }\n  // accept with or without Signature.SIGHASH_ANYONECANPAY by ignoring the bit\n  var temp = this.nhashtype & ~Signature.SIGHASH_ANYONECANPAY;\n  if (temp < Signature.SIGHASH_ALL || temp > Signature.SIGHASH_SINGLE) {\n    return false;\n  }\n  return true;\n};\n\nSignature.prototype.toTxFormat = function() {\n  var derbuf = this.toDER();\n  var buf = Buffer.alloc(1);\n  buf.writeUInt8(this.nhashtype, 0);\n  return Buffer.concat([derbuf, buf]);\n};\n\nSignature.SIGHASH_ALL = 0x01;\nSignature.SIGHASH_NONE = 0x02;\nSignature.SIGHASH_SINGLE = 0x03;\nSignature.SIGHASH_ANYONECANPAY = 0x80;\n\nmodule.exports = Signature;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}