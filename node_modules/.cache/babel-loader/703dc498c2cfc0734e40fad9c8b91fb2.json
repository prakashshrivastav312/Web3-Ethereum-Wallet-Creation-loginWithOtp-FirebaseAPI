{"ast":null,"code":"'use strict';\n\nvar BN = require('./crypto/bn');\n\nvar Point = require('./crypto/point');\n\nvar Hash = require('./crypto/hash');\n\nvar JSUtil = require('./util/js');\n\nvar Network = require('./networks');\n\nvar _ = require('lodash');\n\nvar $ = require('./util/preconditions');\n/**\n * Instantiate a PublicKey from a {@link PrivateKey}, {@link Point}, `string`, or `Buffer`.\n *\n * There are two internal properties, `network` and `compressed`, that deal with importing\n * a PublicKey from a PrivateKey in WIF format. More details described on {@link PrivateKey}\n *\n * @example\n * ```javascript\n * // instantiate from a private key\n * var key = PublicKey(privateKey, true);\n *\n * // export to as a DER hex encoded string\n * var exported = key.toString();\n *\n * // import the public key\n * var imported = PublicKey.fromString(exported);\n * ```\n *\n * @param {string} data - The encoded data in various formats\n * @param {Object} extra - additional options\n * @param {Network=} extra.network - Which network should the address for this public key be for\n * @param {String=} extra.compressed - If the public key is compressed\n * @returns {PublicKey} A new valid instance of an PublicKey\n * @constructor\n */\n\n\nfunction PublicKey(data, extra) {\n  if (!(this instanceof PublicKey)) {\n    return new PublicKey(data, extra);\n  }\n\n  $.checkArgument(data, 'First argument is required, please include public key data.');\n\n  if (data instanceof PublicKey) {\n    // Return copy, but as it's an immutable object, return same argument\n    return data;\n  }\n\n  extra = extra || {};\n\n  var info = this._classifyArgs(data, extra); // validation\n\n\n  info.point.validate();\n  JSUtil.defineImmutable(this, {\n    point: info.point,\n    compressed: info.compressed,\n    network: info.network || Network.defaultNetwork\n  });\n  return this;\n}\n\n;\n/**\n * Internal function to differentiate between arguments passed to the constructor\n * @param {*} data\n * @param {Object} extra\n */\n\nPublicKey.prototype._classifyArgs = function (data, extra) {\n  /* jshint maxcomplexity: 10 */\n  var info = {\n    compressed: _.isUndefined(extra.compressed) || extra.compressed\n  }; // detect type of data\n\n  if (data instanceof Point) {\n    info.point = data;\n  } else if (data.x && data.y) {\n    info = PublicKey._transformObject(data);\n  } else if (typeof data === 'string') {\n    info = PublicKey._transformDER(Buffer.from(data, 'hex'));\n  } else if (PublicKey._isBuffer(data)) {\n    info = PublicKey._transformDER(data);\n  } else if (PublicKey._isPrivateKey(data)) {\n    info = PublicKey._transformPrivateKey(data);\n  } else {\n    throw new TypeError('First argument is an unrecognized data format.');\n  }\n\n  if (!info.network) {\n    info.network = _.isUndefined(extra.network) ? undefined : Network.get(extra.network);\n  }\n\n  return info;\n};\n/**\n * Internal function to detect if an object is a {@link PrivateKey}\n *\n * @param {*} param - object to test\n * @returns {boolean}\n * @private\n */\n\n\nPublicKey._isPrivateKey = function (param) {\n  var PrivateKey = require('./privatekey');\n\n  return param instanceof PrivateKey;\n};\n/**\n * Internal function to detect if an object is a Buffer\n *\n * @param {*} param - object to test\n * @returns {boolean}\n * @private\n */\n\n\nPublicKey._isBuffer = function (param) {\n  return param instanceof Buffer || param instanceof Uint8Array;\n};\n/**\n * Internal function to transform a private key into a public key point\n *\n * @param {PrivateKey} privkey - An instance of PrivateKey\n * @returns {Object} An object with keys: point and compressed\n * @private\n */\n\n\nPublicKey._transformPrivateKey = function (privkey) {\n  $.checkArgument(PublicKey._isPrivateKey(privkey), 'Must be an instance of PrivateKey');\n  var info = {};\n  info.point = Point.getG().mul(privkey.bn);\n  info.compressed = privkey.compressed;\n  info.network = privkey.network;\n  return info;\n};\n/**\n * Internal function to transform DER into a public key point\n *\n * @param {Buffer} buf - An hex encoded buffer\n * @param {bool=} strict - if set to false, will loosen some conditions\n * @returns {Object} An object with keys: point and compressed\n * @private\n */\n\n\nPublicKey._transformDER = function (buf, strict) {\n  /* jshint maxstatements: 30 */\n\n  /* jshint maxcomplexity: 12 */\n  $.checkArgument(PublicKey._isBuffer(buf), 'Must be a hex buffer of DER encoded public key');\n  var info = {};\n  strict = _.isUndefined(strict) ? true : strict;\n  var x;\n  var y;\n  var xbuf;\n  var ybuf;\n\n  if (buf[0] === 0x04 || !strict && (buf[0] === 0x06 || buf[0] === 0x07)) {\n    xbuf = buf.slice(1, 33);\n    ybuf = buf.slice(33, 65);\n\n    if (xbuf.length !== 32 || ybuf.length !== 32 || buf.length !== 65) {\n      throw new TypeError('Length of x and y must be 32 bytes');\n    }\n\n    x = new BN(xbuf);\n    y = new BN(ybuf);\n    info.point = new Point(x, y);\n    info.compressed = false;\n  } else if (buf[0] === 0x03) {\n    xbuf = buf.slice(1);\n    x = new BN(xbuf);\n    info = PublicKey._transformX(true, x);\n    info.compressed = true;\n  } else if (buf[0] === 0x02) {\n    xbuf = buf.slice(1);\n    x = new BN(xbuf);\n    info = PublicKey._transformX(false, x);\n    info.compressed = true;\n  } else {\n    throw new TypeError('Invalid DER format public key');\n  }\n\n  return info;\n};\n/**\n * Internal function to transform X into a public key point\n *\n * @param {Boolean} odd - If the point is above or below the x axis\n * @param {Point} x - The x point\n * @returns {Object} An object with keys: point and compressed\n * @private\n */\n\n\nPublicKey._transformX = function (odd, x) {\n  $.checkArgument(typeof odd === 'boolean', 'Must specify whether y is odd or not (true or false)');\n  var info = {};\n  info.point = Point.fromX(odd, x);\n  return info;\n};\n/**\n * Internal function to transform a JSON into a public key point\n *\n * @param {String|Object} json - a JSON string or plain object\n * @returns {Object} An object with keys: point and compressed\n * @private\n */\n\n\nPublicKey._transformObject = function (json) {\n  var x = new BN(json.x, 'hex');\n  var y = new BN(json.y, 'hex');\n  var point = new Point(x, y);\n  return new PublicKey(point, {\n    compressed: json.compressed\n  });\n};\n/**\n * Instantiate a PublicKey from a PrivateKey\n *\n * @param {PrivateKey} privkey - An instance of PrivateKey\n * @returns {PublicKey} A new valid instance of PublicKey\n */\n\n\nPublicKey.fromPrivateKey = function (privkey) {\n  $.checkArgument(PublicKey._isPrivateKey(privkey), 'Must be an instance of PrivateKey');\n\n  var info = PublicKey._transformPrivateKey(privkey);\n\n  return new PublicKey(info.point, {\n    compressed: info.compressed,\n    network: info.network\n  });\n};\n/**\n * Instantiate a PublicKey from a Buffer\n * @param {Buffer} buf - A DER hex buffer\n * @param {bool=} strict - if set to false, will loosen some conditions\n * @returns {PublicKey} A new valid instance of PublicKey\n */\n\n\nPublicKey.fromDER = PublicKey.fromBuffer = function (buf, strict) {\n  $.checkArgument(PublicKey._isBuffer(buf), 'Must be a hex buffer of DER encoded public key');\n\n  var info = PublicKey._transformDER(buf, strict);\n\n  return new PublicKey(info.point, {\n    compressed: info.compressed\n  });\n};\n/**\n * Instantiate a PublicKey from a Point\n *\n * @param {Point} point - A Point instance\n * @param {boolean=} compressed - whether to store this public key as compressed format\n * @returns {PublicKey} A new valid instance of PublicKey\n */\n\n\nPublicKey.fromPoint = function (point, compressed) {\n  $.checkArgument(point instanceof Point, 'First argument must be an instance of Point.');\n  return new PublicKey(point, {\n    compressed: compressed\n  });\n};\n/**\n * Instantiate a PublicKey from a DER hex encoded string\n *\n * @param {string} str - A DER hex string\n * @param {String=} encoding - The type of string encoding\n * @returns {PublicKey} A new valid instance of PublicKey\n */\n\n\nPublicKey.fromString = function (str, encoding) {\n  var buf = Buffer.from(str, encoding || 'hex');\n\n  var info = PublicKey._transformDER(buf);\n\n  return new PublicKey(info.point, {\n    compressed: info.compressed\n  });\n};\n/**\n * Instantiate a PublicKey from an X Point\n *\n * @param {Boolean} odd - If the point is above or below the x axis\n * @param {Point} x - The x point\n * @returns {PublicKey} A new valid instance of PublicKey\n */\n\n\nPublicKey.fromX = function (odd, x) {\n  var info = PublicKey._transformX(odd, x);\n\n  return new PublicKey(info.point, {\n    compressed: info.compressed\n  });\n};\n/**\n * Check if there would be any errors when initializing a PublicKey\n *\n * @param {string} data - The encoded data in various formats\n * @returns {null|Error} An error if exists\n */\n\n\nPublicKey.getValidationError = function (data) {\n  var error;\n\n  try {\n    /* jshint nonew: false */\n    new PublicKey(data);\n  } catch (e) {\n    error = e;\n  }\n\n  return error;\n};\n/**\n * Check if the parameters are valid\n *\n * @param {string} data - The encoded data in various formats\n * @returns {Boolean} If the public key would be valid\n */\n\n\nPublicKey.isValid = function (data) {\n  return !PublicKey.getValidationError(data);\n};\n/**\n * @returns {Object} A plain object of the PublicKey\n */\n\n\nPublicKey.prototype.toObject = PublicKey.prototype.toJSON = function toObject() {\n  return {\n    x: this.point.getX().toString('hex', 2),\n    y: this.point.getY().toString('hex', 2),\n    compressed: this.compressed\n  };\n};\n/**\n * Will output the PublicKey to a DER Buffer\n *\n * @returns {Buffer} A DER hex encoded buffer\n */\n\n\nPublicKey.prototype.toBuffer = PublicKey.prototype.toDER = function () {\n  var x = this.point.getX();\n  var y = this.point.getY();\n  var xbuf = x.toBuffer({\n    size: 32\n  });\n  var ybuf = y.toBuffer({\n    size: 32\n  });\n  var prefix;\n\n  if (!this.compressed) {\n    prefix = Buffer.from([0x04]);\n    return Buffer.concat([prefix, xbuf, ybuf]);\n  } else {\n    var odd = ybuf[ybuf.length - 1] % 2;\n\n    if (odd) {\n      prefix = Buffer.from([0x03]);\n    } else {\n      prefix = Buffer.from([0x02]);\n    }\n\n    return Buffer.concat([prefix, xbuf]);\n  }\n};\n/**\n * Will return a sha256 + ripemd160 hash of the serialized public key\n * @see https://github.com/bitcoin/bitcoin/blob/master/src/pubkey.h#L141\n * @returns {Buffer}\n */\n\n\nPublicKey.prototype._getID = function _getID() {\n  return Hash.sha256ripemd160(this.toBuffer());\n};\n/**\n * Will return an address for the public key\n *\n * @param {String|Network=} network - Which network should the address be for\n * @returns {Address} An address generated from the public key\n */\n\n\nPublicKey.prototype.toAddress = function (network) {\n  var Address = require('./address');\n\n  return Address.fromPublicKey(this, network || this.network);\n};\n/**\n * Will output the PublicKey to a DER encoded hex string\n *\n * @returns {string} A DER hex encoded string\n */\n\n\nPublicKey.prototype.toString = function () {\n  return this.toDER().toString('hex');\n};\n/**\n * Will return a string formatted for the console\n *\n * @returns {string} Public key\n */\n\n\nPublicKey.prototype.inspect = function () {\n  return '<PublicKey: ' + this.toString() + (this.compressed ? '' : ', uncompressed') + '>';\n};\n\nmodule.exports = PublicKey;","map":{"version":3,"names":["BN","require","Point","Hash","JSUtil","Network","_","$","PublicKey","data","extra","checkArgument","info","_classifyArgs","point","validate","defineImmutable","compressed","network","defaultNetwork","prototype","isUndefined","x","y","_transformObject","_transformDER","Buffer","from","_isBuffer","_isPrivateKey","_transformPrivateKey","TypeError","undefined","get","param","PrivateKey","Uint8Array","privkey","getG","mul","bn","buf","strict","xbuf","ybuf","slice","length","_transformX","odd","fromX","json","fromPrivateKey","fromDER","fromBuffer","fromPoint","fromString","str","encoding","getValidationError","error","e","isValid","toObject","toJSON","getX","toString","getY","toBuffer","toDER","size","prefix","concat","_getID","sha256ripemd160","toAddress","Address","fromPublicKey","inspect","module","exports"],"sources":["C:/Users/acer/node_modules/bitcore-lib-doge/lib/publickey.js"],"sourcesContent":["'use strict';\n\nvar BN = require('./crypto/bn');\nvar Point = require('./crypto/point');\nvar Hash = require('./crypto/hash');\nvar JSUtil = require('./util/js');\nvar Network = require('./networks');\nvar _ = require('lodash');\nvar $ = require('./util/preconditions');\n\n/**\n * Instantiate a PublicKey from a {@link PrivateKey}, {@link Point}, `string`, or `Buffer`.\n *\n * There are two internal properties, `network` and `compressed`, that deal with importing\n * a PublicKey from a PrivateKey in WIF format. More details described on {@link PrivateKey}\n *\n * @example\n * ```javascript\n * // instantiate from a private key\n * var key = PublicKey(privateKey, true);\n *\n * // export to as a DER hex encoded string\n * var exported = key.toString();\n *\n * // import the public key\n * var imported = PublicKey.fromString(exported);\n * ```\n *\n * @param {string} data - The encoded data in various formats\n * @param {Object} extra - additional options\n * @param {Network=} extra.network - Which network should the address for this public key be for\n * @param {String=} extra.compressed - If the public key is compressed\n * @returns {PublicKey} A new valid instance of an PublicKey\n * @constructor\n */\nfunction PublicKey(data, extra) {\n\n  if (!(this instanceof PublicKey)) {\n    return new PublicKey(data, extra);\n  }\n\n  $.checkArgument(data, 'First argument is required, please include public key data.');\n\n  if (data instanceof PublicKey) {\n    // Return copy, but as it's an immutable object, return same argument\n    return data;\n  }\n  extra = extra || {};\n\n  var info = this._classifyArgs(data, extra);\n\n  // validation\n  info.point.validate();\n\n  JSUtil.defineImmutable(this, {\n    point: info.point,\n    compressed: info.compressed,\n    network: info.network || Network.defaultNetwork\n  });\n\n  return this;\n};\n\n/**\n * Internal function to differentiate between arguments passed to the constructor\n * @param {*} data\n * @param {Object} extra\n */\nPublicKey.prototype._classifyArgs = function(data, extra) {\n  /* jshint maxcomplexity: 10 */\n  var info = {\n    compressed: _.isUndefined(extra.compressed) || extra.compressed\n  };\n\n  // detect type of data\n  if (data instanceof Point) {\n    info.point = data;\n  } else if (data.x && data.y) {\n    info = PublicKey._transformObject(data);\n  } else if (typeof(data) === 'string') {\n    info = PublicKey._transformDER(Buffer.from(data, 'hex'));\n  } else if (PublicKey._isBuffer(data)) {\n    info = PublicKey._transformDER(data);\n  } else if (PublicKey._isPrivateKey(data)) {\n    info = PublicKey._transformPrivateKey(data);\n  } else {\n    throw new TypeError('First argument is an unrecognized data format.');\n  }\n  if (!info.network) {\n    info.network = _.isUndefined(extra.network) ? undefined : Network.get(extra.network);\n  }\n  return info;\n};\n\n/**\n * Internal function to detect if an object is a {@link PrivateKey}\n *\n * @param {*} param - object to test\n * @returns {boolean}\n * @private\n */\nPublicKey._isPrivateKey = function(param) {\n  var PrivateKey = require('./privatekey');\n  return param instanceof PrivateKey;\n};\n\n/**\n * Internal function to detect if an object is a Buffer\n *\n * @param {*} param - object to test\n * @returns {boolean}\n * @private\n */\nPublicKey._isBuffer = function(param) {\n  return (param instanceof Buffer) || (param instanceof Uint8Array);\n};\n\n/**\n * Internal function to transform a private key into a public key point\n *\n * @param {PrivateKey} privkey - An instance of PrivateKey\n * @returns {Object} An object with keys: point and compressed\n * @private\n */\nPublicKey._transformPrivateKey = function(privkey) {\n  $.checkArgument(PublicKey._isPrivateKey(privkey), 'Must be an instance of PrivateKey');\n  var info = {};\n  info.point = Point.getG().mul(privkey.bn);\n  info.compressed = privkey.compressed;\n  info.network = privkey.network;\n  return info;\n};\n\n/**\n * Internal function to transform DER into a public key point\n *\n * @param {Buffer} buf - An hex encoded buffer\n * @param {bool=} strict - if set to false, will loosen some conditions\n * @returns {Object} An object with keys: point and compressed\n * @private\n */\nPublicKey._transformDER = function(buf, strict) {\n  /* jshint maxstatements: 30 */\n  /* jshint maxcomplexity: 12 */\n  $.checkArgument(PublicKey._isBuffer(buf), 'Must be a hex buffer of DER encoded public key');\n  var info = {};\n\n  strict = _.isUndefined(strict) ? true : strict;\n\n  var x;\n  var y;\n  var xbuf;\n  var ybuf;\n\n  if (buf[0] === 0x04 || (!strict && (buf[0] === 0x06 || buf[0] === 0x07))) {\n    xbuf = buf.slice(1, 33);\n    ybuf = buf.slice(33, 65);\n    if (xbuf.length !== 32 || ybuf.length !== 32 || buf.length !== 65) {\n      throw new TypeError('Length of x and y must be 32 bytes');\n    }\n    x = new BN(xbuf);\n    y = new BN(ybuf);\n    info.point = new Point(x, y);\n    info.compressed = false;\n  } else if (buf[0] === 0x03) {\n    xbuf = buf.slice(1);\n    x = new BN(xbuf);\n    info = PublicKey._transformX(true, x);\n    info.compressed = true;\n  } else if (buf[0] === 0x02) {\n    xbuf = buf.slice(1);\n    x = new BN(xbuf);\n    info = PublicKey._transformX(false, x);\n    info.compressed = true;\n  } else {\n    throw new TypeError('Invalid DER format public key');\n  }\n  return info;\n};\n\n/**\n * Internal function to transform X into a public key point\n *\n * @param {Boolean} odd - If the point is above or below the x axis\n * @param {Point} x - The x point\n * @returns {Object} An object with keys: point and compressed\n * @private\n */\nPublicKey._transformX = function(odd, x) {\n  $.checkArgument(typeof odd === 'boolean', 'Must specify whether y is odd or not (true or false)');\n  var info = {};\n  info.point = Point.fromX(odd, x);\n  return info;\n};\n\n/**\n * Internal function to transform a JSON into a public key point\n *\n * @param {String|Object} json - a JSON string or plain object\n * @returns {Object} An object with keys: point and compressed\n * @private\n */\nPublicKey._transformObject = function(json) {\n  var x = new BN(json.x, 'hex');\n  var y = new BN(json.y, 'hex');\n  var point = new Point(x, y);\n  return new PublicKey(point, {\n    compressed: json.compressed\n  });\n};\n\n/**\n * Instantiate a PublicKey from a PrivateKey\n *\n * @param {PrivateKey} privkey - An instance of PrivateKey\n * @returns {PublicKey} A new valid instance of PublicKey\n */\nPublicKey.fromPrivateKey = function(privkey) {\n  $.checkArgument(PublicKey._isPrivateKey(privkey), 'Must be an instance of PrivateKey');\n  var info = PublicKey._transformPrivateKey(privkey);\n  return new PublicKey(info.point, {\n    compressed: info.compressed,\n    network: info.network\n  });\n};\n\n/**\n * Instantiate a PublicKey from a Buffer\n * @param {Buffer} buf - A DER hex buffer\n * @param {bool=} strict - if set to false, will loosen some conditions\n * @returns {PublicKey} A new valid instance of PublicKey\n */\nPublicKey.fromDER = PublicKey.fromBuffer = function(buf, strict) {\n  $.checkArgument(PublicKey._isBuffer(buf), 'Must be a hex buffer of DER encoded public key');\n  var info = PublicKey._transformDER(buf, strict);\n  return new PublicKey(info.point, {\n    compressed: info.compressed\n  });\n};\n\n/**\n * Instantiate a PublicKey from a Point\n *\n * @param {Point} point - A Point instance\n * @param {boolean=} compressed - whether to store this public key as compressed format\n * @returns {PublicKey} A new valid instance of PublicKey\n */\nPublicKey.fromPoint = function(point, compressed) {\n  $.checkArgument(point instanceof Point, 'First argument must be an instance of Point.');\n  return new PublicKey(point, {\n    compressed: compressed\n  });\n};\n\n/**\n * Instantiate a PublicKey from a DER hex encoded string\n *\n * @param {string} str - A DER hex string\n * @param {String=} encoding - The type of string encoding\n * @returns {PublicKey} A new valid instance of PublicKey\n */\nPublicKey.fromString = function(str, encoding) {\n  var buf = Buffer.from(str, encoding || 'hex');\n  var info = PublicKey._transformDER(buf);\n  return new PublicKey(info.point, {\n    compressed: info.compressed\n  });\n};\n\n/**\n * Instantiate a PublicKey from an X Point\n *\n * @param {Boolean} odd - If the point is above or below the x axis\n * @param {Point} x - The x point\n * @returns {PublicKey} A new valid instance of PublicKey\n */\nPublicKey.fromX = function(odd, x) {\n  var info = PublicKey._transformX(odd, x);\n  return new PublicKey(info.point, {\n    compressed: info.compressed\n  });\n};\n\n/**\n * Check if there would be any errors when initializing a PublicKey\n *\n * @param {string} data - The encoded data in various formats\n * @returns {null|Error} An error if exists\n */\nPublicKey.getValidationError = function(data) {\n  var error;\n  try {\n    /* jshint nonew: false */\n    new PublicKey(data);\n  } catch (e) {\n    error = e;\n  }\n  return error;\n};\n\n/**\n * Check if the parameters are valid\n *\n * @param {string} data - The encoded data in various formats\n * @returns {Boolean} If the public key would be valid\n */\nPublicKey.isValid = function(data) {\n  return !PublicKey.getValidationError(data);\n};\n\n/**\n * @returns {Object} A plain object of the PublicKey\n */\nPublicKey.prototype.toObject = PublicKey.prototype.toJSON = function toObject() {\n  return {\n    x: this.point.getX().toString('hex', 2),\n    y: this.point.getY().toString('hex', 2),\n    compressed: this.compressed\n  };\n};\n\n/**\n * Will output the PublicKey to a DER Buffer\n *\n * @returns {Buffer} A DER hex encoded buffer\n */\nPublicKey.prototype.toBuffer = PublicKey.prototype.toDER = function() {\n  var x = this.point.getX();\n  var y = this.point.getY();\n\n  var xbuf = x.toBuffer({\n    size: 32\n  });\n  var ybuf = y.toBuffer({\n    size: 32\n  });\n\n  var prefix;\n  if (!this.compressed) {\n    prefix = Buffer.from([0x04]);\n    return Buffer.concat([prefix, xbuf, ybuf]);\n  } else {\n    var odd = ybuf[ybuf.length - 1] % 2;\n    if (odd) {\n      prefix = Buffer.from([0x03]);\n    } else {\n      prefix = Buffer.from([0x02]);\n    }\n    return Buffer.concat([prefix, xbuf]);\n  }\n};\n\n/**\n * Will return a sha256 + ripemd160 hash of the serialized public key\n * @see https://github.com/bitcoin/bitcoin/blob/master/src/pubkey.h#L141\n * @returns {Buffer}\n */\nPublicKey.prototype._getID = function _getID() {\n  return Hash.sha256ripemd160(this.toBuffer());\n};\n\n/**\n * Will return an address for the public key\n *\n * @param {String|Network=} network - Which network should the address be for\n * @returns {Address} An address generated from the public key\n */\nPublicKey.prototype.toAddress = function(network) {\n  var Address = require('./address');\n  return Address.fromPublicKey(this, network || this.network);\n};\n\n/**\n * Will output the PublicKey to a DER encoded hex string\n *\n * @returns {string} A DER hex encoded string\n */\nPublicKey.prototype.toString = function() {\n  return this.toDER().toString('hex');\n};\n\n/**\n * Will return a string formatted for the console\n *\n * @returns {string} Public key\n */\nPublicKey.prototype.inspect = function() {\n  return '<PublicKey: ' + this.toString() +\n    (this.compressed ? '' : ', uncompressed') + '>';\n};\n\n\nmodule.exports = PublicKey;"],"mappings":"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"},"metadata":{},"sourceType":"script"}