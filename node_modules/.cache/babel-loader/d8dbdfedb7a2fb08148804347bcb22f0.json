{"ast":null,"code":"\"use strict\";\n\nvar __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    if (typeof b !== \"function\" && b !== null) throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ShaMapLeaf = exports.ShaMapNode = exports.ShaMap = void 0;\n\nvar assert_1 = require(\"assert\");\n\nvar types_1 = require(\"./types\");\n\nvar hash_prefixes_1 = require(\"./hash-prefixes\");\n\nvar hashes_1 = require(\"./hashes\");\n\nvar buffer_1 = require(\"buffer/\");\n/**\n * Abstract class describing a SHAMapNode\n */\n\n\nvar ShaMapNode =\n/** @class */\nfunction () {\n  function ShaMapNode() {}\n\n  return ShaMapNode;\n}();\n\nexports.ShaMapNode = ShaMapNode;\n/**\n * Class describing a Leaf of SHAMap\n */\n\nvar ShaMapLeaf =\n/** @class */\nfunction (_super) {\n  __extends(ShaMapLeaf, _super);\n\n  function ShaMapLeaf(index, item) {\n    var _this = _super.call(this) || this;\n\n    _this.index = index;\n    _this.item = item;\n    return _this;\n  }\n  /**\n   * @returns true as ShaMapLeaf is a leaf node\n   */\n\n\n  ShaMapLeaf.prototype.isLeaf = function () {\n    return true;\n  };\n  /**\n   * @returns false as ShaMapLeaf is not an inner node\n   */\n\n\n  ShaMapLeaf.prototype.isInner = function () {\n    return false;\n  };\n  /**\n   * Get the prefix of the this.item\n   *\n   * @returns The hash prefix, unless this.item is undefined, then it returns an empty Buffer\n   */\n\n\n  ShaMapLeaf.prototype.hashPrefix = function () {\n    return this.item === undefined ? buffer_1.Buffer.alloc(0) : this.item.hashPrefix();\n  };\n  /**\n   * Hash the bytes representation of this\n   *\n   * @returns hash of this.item concatenated with this.index\n   */\n\n\n  ShaMapLeaf.prototype.hash = function () {\n    var hash = hashes_1.Sha512Half.put(this.hashPrefix());\n    this.toBytesSink(hash);\n    return hash.finish();\n  };\n  /**\n   * Write the bytes representation of this to a BytesList\n   * @param list BytesList to write bytes to\n   */\n\n\n  ShaMapLeaf.prototype.toBytesSink = function (list) {\n    if (this.item !== undefined) {\n      this.item.toBytesSink(list);\n    }\n\n    this.index.toBytesSink(list);\n  };\n\n  return ShaMapLeaf;\n}(ShaMapNode);\n\nexports.ShaMapLeaf = ShaMapLeaf;\n/**\n * Class defining an Inner Node of a SHAMap\n */\n\nvar ShaMapInner =\n/** @class */\nfunction (_super) {\n  __extends(ShaMapInner, _super);\n\n  function ShaMapInner(depth) {\n    if (depth === void 0) {\n      depth = 0;\n    }\n\n    var _this = _super.call(this) || this;\n\n    _this.depth = depth;\n    _this.slotBits = 0;\n    _this.branches = Array(16);\n    return _this;\n  }\n  /**\n   * @returns true as ShaMapInner is an inner node\n   */\n\n\n  ShaMapInner.prototype.isInner = function () {\n    return true;\n  };\n  /**\n   * @returns false as ShaMapInner is not a leaf node\n   */\n\n\n  ShaMapInner.prototype.isLeaf = function () {\n    return false;\n  };\n  /**\n   * Get the hash prefix for this node\n   *\n   * @returns hash prefix describing an inner node\n   */\n\n\n  ShaMapInner.prototype.hashPrefix = function () {\n    return hash_prefixes_1.HashPrefix.innerNode;\n  };\n  /**\n   * Set a branch of this node to be another node\n   *\n   * @param slot Slot to add branch to this.branches\n   * @param branch Branch to add\n   */\n\n\n  ShaMapInner.prototype.setBranch = function (slot, branch) {\n    this.slotBits = this.slotBits | 1 << slot;\n    this.branches[slot] = branch;\n  };\n  /**\n   * @returns true if node is empty\n   */\n\n\n  ShaMapInner.prototype.empty = function () {\n    return this.slotBits === 0;\n  };\n  /**\n   * Compute the hash of this node\n   *\n   * @returns The hash of this node\n   */\n\n\n  ShaMapInner.prototype.hash = function () {\n    if (this.empty()) {\n      return types_1.coreTypes.Hash256.ZERO_256;\n    }\n\n    var hash = hashes_1.Sha512Half.put(this.hashPrefix());\n    this.toBytesSink(hash);\n    return hash.finish();\n  };\n  /**\n   * Writes the bytes representation of this node to a BytesList\n   *\n   * @param list BytesList to write bytes to\n   */\n\n\n  ShaMapInner.prototype.toBytesSink = function (list) {\n    for (var i = 0; i < this.branches.length; i++) {\n      var branch = this.branches[i];\n      var hash = branch ? branch.hash() : types_1.coreTypes.Hash256.ZERO_256;\n      hash.toBytesSink(list);\n    }\n  };\n  /**\n   * Add item to the SHAMap\n   *\n   * @param index Hash of the index of the item being inserted\n   * @param item Item to insert in the map\n   * @param leaf Leaf node to insert when branch doesn't exist\n   */\n\n\n  ShaMapInner.prototype.addItem = function (index, item, leaf) {\n    assert_1.strict.ok(index !== undefined);\n    var nibble = index.nibblet(this.depth);\n    var existing = this.branches[nibble];\n\n    if (existing === undefined) {\n      this.setBranch(nibble, leaf || new ShaMapLeaf(index, item));\n    } else if (existing instanceof ShaMapLeaf) {\n      var newInner = new ShaMapInner(this.depth + 1);\n      newInner.addItem(existing.index, undefined, existing);\n      newInner.addItem(index, item, leaf);\n      this.setBranch(nibble, newInner);\n    } else if (existing instanceof ShaMapInner) {\n      existing.addItem(index, item, leaf);\n    } else {\n      throw new Error('invalid ShaMap.addItem call');\n    }\n  };\n\n  return ShaMapInner;\n}(ShaMapNode);\n\nvar ShaMap =\n/** @class */\nfunction (_super) {\n  __extends(ShaMap, _super);\n\n  function ShaMap() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  return ShaMap;\n}(ShaMapInner);\n\nexports.ShaMap = ShaMap;","map":{"version":3,"mappings":"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","names":["exports","__extends","index","item","_super","_this","ShaMapLeaf","undefined","buffer_1","alloc","hashPrefix","hash","hashes_1","put","toBytesSink","finish","list","ShaMapNode","depth","Array","ShaMapInner","hash_prefixes_1","innerNode","slot","branch","slotBits","branches","empty","types_1","Hash256","ZERO_256","i","length","leaf","assert_1","ok","nibble","nibblet","existing","setBranch","newInner","addItem","Error"],"sourceRoot":"","sources":["../src/shamap.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}