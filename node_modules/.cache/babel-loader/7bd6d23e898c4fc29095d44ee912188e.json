{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.isValidXAddress = exports.decodeXAddress = exports.xAddressToClassicAddress = exports.encodeXAddress = exports.classicAddressToXAddress = exports.isValidClassicAddress = exports.decodeAccountPublic = exports.encodeAccountPublic = exports.decodeNodePublic = exports.encodeNodePublic = exports.decodeAccountID = exports.encodeAccountID = exports.decodeSeed = exports.encodeSeed = exports.codec = void 0;\n\nconst assert = require(\"assert\");\n\nconst xrp_codec_1 = require(\"./xrp-codec\");\n\nObject.defineProperty(exports, \"codec\", {\n  enumerable: true,\n  get: function () {\n    return xrp_codec_1.codec;\n  }\n});\nObject.defineProperty(exports, \"encodeSeed\", {\n  enumerable: true,\n  get: function () {\n    return xrp_codec_1.encodeSeed;\n  }\n});\nObject.defineProperty(exports, \"decodeSeed\", {\n  enumerable: true,\n  get: function () {\n    return xrp_codec_1.decodeSeed;\n  }\n});\nObject.defineProperty(exports, \"encodeAccountID\", {\n  enumerable: true,\n  get: function () {\n    return xrp_codec_1.encodeAccountID;\n  }\n});\nObject.defineProperty(exports, \"decodeAccountID\", {\n  enumerable: true,\n  get: function () {\n    return xrp_codec_1.decodeAccountID;\n  }\n});\nObject.defineProperty(exports, \"encodeNodePublic\", {\n  enumerable: true,\n  get: function () {\n    return xrp_codec_1.encodeNodePublic;\n  }\n});\nObject.defineProperty(exports, \"decodeNodePublic\", {\n  enumerable: true,\n  get: function () {\n    return xrp_codec_1.decodeNodePublic;\n  }\n});\nObject.defineProperty(exports, \"encodeAccountPublic\", {\n  enumerable: true,\n  get: function () {\n    return xrp_codec_1.encodeAccountPublic;\n  }\n});\nObject.defineProperty(exports, \"decodeAccountPublic\", {\n  enumerable: true,\n  get: function () {\n    return xrp_codec_1.decodeAccountPublic;\n  }\n});\nObject.defineProperty(exports, \"isValidClassicAddress\", {\n  enumerable: true,\n  get: function () {\n    return xrp_codec_1.isValidClassicAddress;\n  }\n});\nconst PREFIX_BYTES = {\n  // 5, 68\n  main: Buffer.from([0x05, 0x44]),\n  // 4, 147\n  test: Buffer.from([0x04, 0x93])\n};\nconst MAX_32_BIT_UNSIGNED_INT = 4294967295;\n\nfunction classicAddressToXAddress(classicAddress, tag, test) {\n  const accountId = (0, xrp_codec_1.decodeAccountID)(classicAddress);\n  return encodeXAddress(accountId, tag, test);\n}\n\nexports.classicAddressToXAddress = classicAddressToXAddress;\n\nfunction encodeXAddress(accountId, tag, test) {\n  if (accountId.length !== 20) {\n    // RIPEMD160 is 160 bits = 20 bytes\n    throw new Error('Account ID must be 20 bytes');\n  }\n\n  if (tag > MAX_32_BIT_UNSIGNED_INT) {\n    throw new Error('Invalid tag');\n  }\n\n  const theTag = tag || 0; // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition -- Passing null is a common js mistake\n\n  const flag = tag === false || tag == null ? 0 : 1;\n  /* eslint-disable no-bitwise ---\n   * need to use bitwise operations here */\n\n  const bytes = Buffer.concat([test ? PREFIX_BYTES.test : PREFIX_BYTES.main, accountId, Buffer.from([// 0x00 if no tag, 0x01 if 32-bit tag\n  flag, // first byte\n  theTag & 0xff, // second byte\n  theTag >> 8 & 0xff, // third byte\n  theTag >> 16 & 0xff, // fourth byte\n  theTag >> 24 & 0xff, 0, 0, 0, // four zero bytes (reserved for 64-bit tags)\n  0])]);\n  /* eslint-enable no-bitwise */\n\n  return xrp_codec_1.codec.encodeChecked(bytes);\n}\n\nexports.encodeXAddress = encodeXAddress;\n\nfunction xAddressToClassicAddress(xAddress) {\n  /* eslint-disable @typescript-eslint/naming-convention --\n   * TODO 'test' should be something like 'isTest', do this later\n   */\n  const {\n    accountId,\n    tag,\n    test\n  } = decodeXAddress(xAddress);\n  /* eslint-enable @typescript-eslint/naming-convention */\n\n  const classicAddress = (0, xrp_codec_1.encodeAccountID)(accountId);\n  return {\n    classicAddress,\n    tag,\n    test\n  };\n}\n\nexports.xAddressToClassicAddress = xAddressToClassicAddress;\n\nfunction decodeXAddress(xAddress) {\n  const decoded = xrp_codec_1.codec.decodeChecked(xAddress);\n  /* eslint-disable @typescript-eslint/naming-convention --\n   * TODO 'test' should be something like 'isTest', do this later\n   */\n\n  const test = isBufferForTestAddress(decoded);\n  /* eslint-enable @typescript-eslint/naming-convention */\n\n  const accountId = decoded.slice(2, 22);\n  const tag = tagFromBuffer(decoded);\n  return {\n    accountId,\n    tag,\n    test\n  };\n}\n\nexports.decodeXAddress = decodeXAddress;\n\nfunction isBufferForTestAddress(buf) {\n  const decodedPrefix = buf.slice(0, 2);\n\n  if (PREFIX_BYTES.main.equals(decodedPrefix)) {\n    return false;\n  }\n\n  if (PREFIX_BYTES.test.equals(decodedPrefix)) {\n    return true;\n  }\n\n  throw new Error('Invalid X-address: bad prefix');\n}\n\nfunction tagFromBuffer(buf) {\n  const flag = buf[22];\n\n  if (flag >= 2) {\n    // No support for 64-bit tags at this time\n    throw new Error('Unsupported X-address');\n  }\n\n  if (flag === 1) {\n    // Little-endian to big-endian\n    return buf[23] + buf[24] * 0x100 + buf[25] * 0x10000 + buf[26] * 0x1000000;\n  }\n\n  assert.strictEqual(flag, 0, 'flag must be zero to indicate no tag');\n  assert.ok(Buffer.from('0000000000000000', 'hex').equals(buf.slice(23, 23 + 8)), 'remaining bytes must be zero');\n  return false;\n}\n\nfunction isValidXAddress(xAddress) {\n  try {\n    decodeXAddress(xAddress);\n  } catch (_error) {\n    return false;\n  }\n\n  return true;\n}\n\nexports.isValidXAddress = isValidXAddress;","map":{"version":3,"mappings":"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","names":["Object","enumerable","get","xrp_codec_1","PREFIX_BYTES","main","Buffer","from","test","MAX_32_BIT_UNSIGNED_INT","classicAddressToXAddress","classicAddress","tag","accountId","encodeXAddress","exports","length","Error","theTag","flag","bytes","concat","encodeChecked","xAddressToClassicAddress","xAddress","decodeXAddress","decoded","decodeChecked","isBufferForTestAddress","slice","tagFromBuffer","buf","decodedPrefix","equals","assert","strictEqual","ok","isValidXAddress","_error"],"sourceRoot":"","sources":["../src/index.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}