{"ast":null,"code":"var Buffer = require(\"safe-buffer\").Buffer;\n\nvar bip66 = require(\"bip66\");\n\nvar pushdata = require(\"@tatumio/pushdata-bitcoin\");\n\nvar typeforce = require(\"typeforce\");\n\nvar types = require(\"./types\");\n\nvar scriptNumber = require(\"./script_number\");\n\nvar OPS = require(\"@tatumio/bitcoincash-ops\");\n\nvar REVERSE_OPS = require(\"@tatumio/bitcoincash-ops/map\");\n\nvar OP_INT_BASE = OPS.OP_RESERVED; // OP_1 - 1\n\nfunction isOPInt(value) {\n  return types.Number(value) && (value === OPS.OP_0 || value >= OPS.OP_1 && value <= OPS.OP_16 || value === OPS.OP_1NEGATE);\n}\n\nfunction isPushOnlyChunk(value) {\n  return types.Buffer(value) || isOPInt(value);\n}\n\nfunction isPushOnly(value) {\n  return types.Array(value) && value.every(isPushOnlyChunk);\n}\n\nfunction asMinimalOP(buffer) {\n  if (buffer.length === 0) return OPS.OP_0;\n  if (buffer.length !== 1) return;\n  if (buffer[0] >= 1 && buffer[0] <= 16) return OP_INT_BASE + buffer[0];\n  if (buffer[0] === 0x81) return OPS.OP_1NEGATE;\n}\n\nfunction compile(chunks) {\n  // TODO: remove me\n  if (Buffer.isBuffer(chunks)) return chunks;\n  typeforce(types.Array, chunks);\n  var bufferSize = chunks.reduce(function (accum, chunk) {\n    // data chunk\n    if (Buffer.isBuffer(chunk)) {\n      // adhere to BIP62.3, minimal push policy\n      if (chunk.length === 1 && asMinimalOP(chunk) !== undefined) {\n        return accum + 1;\n      }\n\n      return accum + pushdata.encodingLength(chunk.length) + chunk.length;\n    } // opcode\n\n\n    return accum + 1;\n  }, 0.0);\n  var buffer = Buffer.allocUnsafe(bufferSize);\n  var offset = 0;\n  chunks.forEach(function (chunk) {\n    // data chunk\n    if (Buffer.isBuffer(chunk)) {\n      // adhere to BIP62.3, minimal push policy\n      var opcode = asMinimalOP(chunk);\n\n      if (opcode !== undefined) {\n        buffer.writeUInt8(opcode, offset);\n        offset += 1;\n        return;\n      }\n\n      offset += pushdata.encode(buffer, chunk.length, offset);\n      chunk.copy(buffer, offset);\n      offset += chunk.length; // opcode\n    } else {\n      buffer.writeUInt8(chunk, offset);\n      offset += 1;\n    }\n  });\n  if (offset !== buffer.length) throw new Error(\"Could not decode chunks\");\n  return buffer;\n} // Alternative implementation of compile2 that will not mangle SLP OP_RETURN\n// Expects an array of Buffers, to be compiled into a binary blob returned\n// as a Buffer. This final blob is ready to used as an output of a Bitcoin\n// Cash transaction.\n\n\nfunction compile2(chunks) {\n  // If the chunks object is a Buffer, return it.\n  if (Buffer.isBuffer(chunks)) return chunks; // Calculate the final size the buffer should be. Allows error checking in\n  // case compilation goes wonky.\n\n  var bufferSize = chunks.reduce(function (accum, chunk) {\n    // If the chunk is of type Buffer.\n    if (Buffer.isBuffer(chunk)) {\n      // Return the final complied length this Buffer will take up.\n      return accum + pushdata.encodingLength(chunk.length) + chunk.length;\n    } // Otherwise the chunk object is an OP code. It will take up 1 byte.\n\n\n    return accum + 1;\n  }, 0.0); // buffer will hold final compiled Buffer.\n\n  var buffer = Buffer.allocUnsafe(bufferSize);\n  var offset = 0; // Loop through each element in the chunks Array.\n\n  chunks.forEach(function (chunk, index) {\n    // If the chunk is a Buffer and not an OP code.\n    if (Buffer.isBuffer(chunk)) {\n      // console.log(\" \")\n      // console.log(`index: ${index}`)\n      // console.log(`chunk: ${chunk.toString(\"hex\")}`)\n      // console.log(`original buffer: ${buffer.toString(\"hex\")}`)\n      // Calculate the offset for adding this new chunk.\n      offset += pushdata.encode(buffer, chunk.length, offset); // Copy the current chunk into the buffer.\n\n      chunk.copy(buffer, offset); // Calculate the new offset.\n\n      offset += chunk.length; // The chunk is an OP code and not a Buffer.\n    } else {\n      // Add the 1-byte OP code to the final Buffer output.\n      buffer.writeUInt8(chunk, offset);\n      offset += 1;\n    }\n  }); // If the calculated offset and buffer length don't match, then something\n  // went wrong. Throw an error.\n\n  if (offset !== buffer.length) throw new Error(\"Could not decode chunks\"); // Return the final, compiled binary blog as a buffer.\n\n  return buffer;\n}\n\nfunction decompile(buffer) {\n  // TODO: remove me\n  if (types.Array(buffer)) return buffer;\n  typeforce(types.Buffer, buffer);\n  var chunks = [];\n  var i = 0;\n\n  while (i < buffer.length) {\n    var opcode = buffer[i]; // data chunk\n\n    if (opcode > OPS.OP_0 && opcode <= OPS.OP_PUSHDATA4) {\n      var d = pushdata.decode(buffer, i); // did reading a pushDataInt fail? empty script\n\n      if (d === null) return [];\n      i += d.size; // attempt to read too much data? empty script\n      // if (i + d.number > buffer.length) return []\n\n      var data = buffer.slice(i, i + d.number);\n      i += d.number; // decompile minimally\n\n      var op = asMinimalOP(data);\n\n      if (op !== undefined) {\n        chunks.push(op);\n      } else {\n        chunks.push(data);\n      } // opcode\n\n    } else {\n      chunks.push(opcode);\n      i += 1;\n    }\n  }\n\n  return chunks;\n}\n\nfunction toASM(chunks) {\n  if (Buffer.isBuffer(chunks)) {\n    chunks = decompile(chunks);\n  }\n\n  return chunks.map(function (chunk) {\n    // data?\n    if (Buffer.isBuffer(chunk)) {\n      var op = asMinimalOP(chunk);\n      if (op === undefined) return chunk.toString(\"hex\");\n      chunk = op;\n    } // opcode!\n\n\n    return REVERSE_OPS[chunk];\n  }).join(\" \");\n}\n\nfunction fromASM(asm) {\n  typeforce(types.String, asm);\n  return compile(asm.split(\" \").map(function (chunkStr) {\n    // opcode?\n    if (OPS[chunkStr] !== undefined) return OPS[chunkStr]; // typeforce(types.Hex, chunkStr)\n    // data!\n\n    return Buffer.from(chunkStr, \"hex\");\n  }));\n}\n\nfunction toStack(chunks) {\n  chunks = decompile(chunks);\n  typeforce(isPushOnly, chunks);\n  return chunks.map(function (op) {\n    if (Buffer.isBuffer(op)) return op;\n    if (op === OPS.OP_0) return Buffer.allocUnsafe(0);\n    return scriptNumber.encode(op - OP_INT_BASE);\n  });\n}\n\nfunction isCanonicalPubKey(buffer) {\n  if (!Buffer.isBuffer(buffer)) return false;\n  if (buffer.length < 33) return false;\n\n  switch (buffer[0]) {\n    case 0x02:\n    case 0x03:\n      return buffer.length === 33;\n\n    case 0x04:\n      return buffer.length === 65;\n  }\n\n  return false;\n}\n\nfunction isDefinedHashType(hashType) {\n  var hashTypeMod = hashType & ~0xc0; // return hashTypeMod > SIGHASH_ALL && hashTypeMod < SIGHASH_SINGLE\n\n  return hashTypeMod > 0x00 && hashTypeMod < 0x04;\n}\n\nfunction isCanonicalSignature(buffer) {\n  if (!Buffer.isBuffer(buffer)) return false;\n  if (!isDefinedHashType(buffer[buffer.length - 1])) return false;\n  if (buffer.length === 65) return true;\n  return bip66.check(buffer.slice(0, -1));\n}\n\nmodule.exports = {\n  compile: compile,\n  compile2: compile2,\n  decompile: decompile,\n  fromASM: fromASM,\n  toASM: toASM,\n  toStack: toStack,\n  number: require(\"./script_number\"),\n  isCanonicalPubKey: isCanonicalPubKey,\n  isCanonicalSignature: isCanonicalSignature,\n  isPushOnly: isPushOnly,\n  isDefinedHashType: isDefinedHashType\n};","map":{"version":3,"names":["Buffer","require","bip66","pushdata","typeforce","types","scriptNumber","OPS","REVERSE_OPS","OP_INT_BASE","OP_RESERVED","isOPInt","value","Number","OP_0","OP_1","OP_16","OP_1NEGATE","isPushOnlyChunk","isPushOnly","Array","every","asMinimalOP","buffer","length","compile","chunks","isBuffer","bufferSize","reduce","accum","chunk","undefined","encodingLength","allocUnsafe","offset","forEach","opcode","writeUInt8","encode","copy","Error","compile2","index","decompile","i","OP_PUSHDATA4","d","decode","size","data","slice","number","op","push","toASM","map","toString","join","fromASM","asm","String","split","chunkStr","from","toStack","isCanonicalPubKey","isDefinedHashType","hashType","hashTypeMod","isCanonicalSignature","check","module","exports"],"sources":["C:/Users/acer/node_modules/@tatumio/bitcoincashjs2-lib/src/script.js"],"sourcesContent":["var Buffer = require(\"safe-buffer\").Buffer;\nvar bip66 = require(\"bip66\");\nvar pushdata = require(\"@tatumio/pushdata-bitcoin\");\nvar typeforce = require(\"typeforce\");\nvar types = require(\"./types\");\nvar scriptNumber = require(\"./script_number\");\n\nvar OPS = require(\"@tatumio/bitcoincash-ops\");\nvar REVERSE_OPS = require(\"@tatumio/bitcoincash-ops/map\");\nvar OP_INT_BASE = OPS.OP_RESERVED; // OP_1 - 1\n\nfunction isOPInt(value) {\n  return (\n    types.Number(value) &&\n    (value === OPS.OP_0 ||\n      (value >= OPS.OP_1 && value <= OPS.OP_16) ||\n      value === OPS.OP_1NEGATE)\n  );\n}\n\nfunction isPushOnlyChunk(value) {\n  return types.Buffer(value) || isOPInt(value);\n}\n\nfunction isPushOnly(value) {\n  return types.Array(value) && value.every(isPushOnlyChunk);\n}\n\nfunction asMinimalOP(buffer) {\n  if (buffer.length === 0) return OPS.OP_0;\n  if (buffer.length !== 1) return;\n  if (buffer[0] >= 1 && buffer[0] <= 16) return OP_INT_BASE + buffer[0];\n  if (buffer[0] === 0x81) return OPS.OP_1NEGATE;\n}\n\nfunction compile(chunks) {\n  // TODO: remove me\n  if (Buffer.isBuffer(chunks)) return chunks;\n\n  typeforce(types.Array, chunks);\n\n  var bufferSize = chunks.reduce(function(accum, chunk) {\n    // data chunk\n    if (Buffer.isBuffer(chunk)) {\n      // adhere to BIP62.3, minimal push policy\n      if (chunk.length === 1 && asMinimalOP(chunk) !== undefined) {\n        return accum + 1;\n      }\n\n      return accum + pushdata.encodingLength(chunk.length) + chunk.length;\n    }\n\n    // opcode\n    return accum + 1;\n  }, 0.0);\n\n  var buffer = Buffer.allocUnsafe(bufferSize);\n  var offset = 0;\n\n  chunks.forEach(function(chunk) {\n    // data chunk\n    if (Buffer.isBuffer(chunk)) {\n      // adhere to BIP62.3, minimal push policy\n      var opcode = asMinimalOP(chunk);\n      if (opcode !== undefined) {\n        buffer.writeUInt8(opcode, offset);\n        offset += 1;\n        return;\n      }\n\n      offset += pushdata.encode(buffer, chunk.length, offset);\n      chunk.copy(buffer, offset);\n      offset += chunk.length;\n\n      // opcode\n    } else {\n      buffer.writeUInt8(chunk, offset);\n      offset += 1;\n    }\n  });\n\n  if (offset !== buffer.length) throw new Error(\"Could not decode chunks\");\n  return buffer;\n}\n\n// Alternative implementation of compile2 that will not mangle SLP OP_RETURN\n// Expects an array of Buffers, to be compiled into a binary blob returned\n// as a Buffer. This final blob is ready to used as an output of a Bitcoin\n// Cash transaction.\nfunction compile2(chunks) {\n  // If the chunks object is a Buffer, return it.\n  if (Buffer.isBuffer(chunks)) return chunks\n\n  // Calculate the final size the buffer should be. Allows error checking in\n  // case compilation goes wonky.\n  var bufferSize = chunks.reduce(function(accum, chunk) {\n    // If the chunk is of type Buffer.\n    if (Buffer.isBuffer(chunk)) {\n      // Return the final complied length this Buffer will take up.\n      return accum + pushdata.encodingLength(chunk.length) + chunk.length\n    }\n\n    // Otherwise the chunk object is an OP code. It will take up 1 byte.\n    return accum + 1\n  }, 0.0)\n\n  // buffer will hold final compiled Buffer.\n  var buffer = Buffer.allocUnsafe(bufferSize)\n  var offset = 0\n\n  // Loop through each element in the chunks Array.\n  chunks.forEach(function(chunk, index) {\n    // If the chunk is a Buffer and not an OP code.\n    if (Buffer.isBuffer(chunk)) {\n      // console.log(\" \")\n      // console.log(`index: ${index}`)\n      // console.log(`chunk: ${chunk.toString(\"hex\")}`)\n      // console.log(`original buffer: ${buffer.toString(\"hex\")}`)\n\n      // Calculate the offset for adding this new chunk.\n      offset += pushdata.encode(buffer, chunk.length, offset)\n\n      // Copy the current chunk into the buffer.\n      chunk.copy(buffer, offset)\n\n      // Calculate the new offset.\n      offset += chunk.length\n\n      // The chunk is an OP code and not a Buffer.\n    } else {\n      // Add the 1-byte OP code to the final Buffer output.\n      buffer.writeUInt8(chunk, offset)\n      offset += 1\n    }\n  })\n\n  // If the calculated offset and buffer length don't match, then something\n  // went wrong. Throw an error.\n  if (offset !== buffer.length) throw new Error(\"Could not decode chunks\")\n\n  // Return the final, compiled binary blog as a buffer.\n  return buffer\n}\n\nfunction decompile(buffer) {\n  // TODO: remove me\n  if (types.Array(buffer)) return buffer;\n\n  typeforce(types.Buffer, buffer);\n\n  var chunks = [];\n  var i = 0;\n\n  while (i < buffer.length) {\n    var opcode = buffer[i];\n\n    // data chunk\n    if (opcode > OPS.OP_0 && opcode <= OPS.OP_PUSHDATA4) {\n      var d = pushdata.decode(buffer, i);\n\n      // did reading a pushDataInt fail? empty script\n      if (d === null) return [];\n      i += d.size;\n\n      // attempt to read too much data? empty script\n      // if (i + d.number > buffer.length) return []\n\n      var data = buffer.slice(i, i + d.number);\n      i += d.number;\n\n      // decompile minimally\n      var op = asMinimalOP(data);\n      if (op !== undefined) {\n        chunks.push(op);\n      } else {\n        chunks.push(data);\n      }\n\n      // opcode\n    } else {\n      chunks.push(opcode);\n\n      i += 1;\n    }\n  }\n\n  return chunks;\n}\n\nfunction toASM(chunks) {\n  if (Buffer.isBuffer(chunks)) {\n    chunks = decompile(chunks);\n  }\n\n  return chunks\n    .map(function(chunk) {\n      // data?\n      if (Buffer.isBuffer(chunk)) {\n        var op = asMinimalOP(chunk);\n        if (op === undefined) return chunk.toString(\"hex\");\n        chunk = op;\n      }\n\n      // opcode!\n      return REVERSE_OPS[chunk];\n    })\n    .join(\" \");\n}\n\nfunction fromASM(asm) {\n  typeforce(types.String, asm);\n\n  return compile(\n    asm.split(\" \").map(function(chunkStr) {\n      // opcode?\n      if (OPS[chunkStr] !== undefined) return OPS[chunkStr];\n      // typeforce(types.Hex, chunkStr)\n\n      // data!\n      return Buffer.from(chunkStr, \"hex\");\n    })\n  );\n}\n\nfunction toStack(chunks) {\n  chunks = decompile(chunks);\n  typeforce(isPushOnly, chunks);\n\n  return chunks.map(function(op) {\n    if (Buffer.isBuffer(op)) return op;\n    if (op === OPS.OP_0) return Buffer.allocUnsafe(0);\n\n    return scriptNumber.encode(op - OP_INT_BASE);\n  });\n}\n\nfunction isCanonicalPubKey(buffer) {\n  if (!Buffer.isBuffer(buffer)) return false;\n  if (buffer.length < 33) return false;\n\n  switch (buffer[0]) {\n    case 0x02:\n    case 0x03:\n      return buffer.length === 33;\n    case 0x04:\n      return buffer.length === 65;\n  }\n\n  return false;\n}\n\nfunction isDefinedHashType(hashType) {\n  var hashTypeMod = hashType & ~0xc0;\n\n  // return hashTypeMod > SIGHASH_ALL && hashTypeMod < SIGHASH_SINGLE\n  return hashTypeMod > 0x00 && hashTypeMod < 0x04;\n}\n\nfunction isCanonicalSignature(buffer) {\n  if (!Buffer.isBuffer(buffer)) return false;\n  if (!isDefinedHashType(buffer[buffer.length - 1])) return false;\n\n  if(buffer.length === 65) return true;\n\n  return bip66.check(buffer.slice(0, -1));\n}\n\nmodule.exports = {\n  compile: compile,\n  compile2: compile2,\n  decompile: decompile,\n  fromASM: fromASM,\n  toASM: toASM,\n  toStack: toStack,\n\n  number: require(\"./script_number\"),\n\n  isCanonicalPubKey: isCanonicalPubKey,\n  isCanonicalSignature: isCanonicalSignature,\n  isPushOnly: isPushOnly,\n  isDefinedHashType: isDefinedHashType\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}