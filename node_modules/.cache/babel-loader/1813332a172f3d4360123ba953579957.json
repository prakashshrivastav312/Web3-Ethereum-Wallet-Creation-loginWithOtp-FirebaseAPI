{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.decodeAddressToMuxedAccount = decodeAddressToMuxedAccount;\nexports.encodeMuxedAccountToAddress = encodeMuxedAccountToAddress;\nexports.encodeMuxedAccount = encodeMuxedAccount;\n\nvar _isString = require('lodash/isString');\n\nvar _isString2 = _interopRequireDefault(_isString);\n\nvar _stellarXdr_generated = require('../generated/stellar-xdr_generated');\n\nvar _stellarXdr_generated2 = _interopRequireDefault(_stellarXdr_generated);\n\nvar _strkey = require('../strkey');\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n/**\n * Converts a Stellar address (in G... or M... form) to an XDR MuxedAccount\n * structure, forcing the ed25519 representation by default.\n *\n * This optionally (that is, opt-in only) supports proper muxed accounts, where\n * an M... address will resolve to both its underlying G... address and an ID.\n * Note that this behaviour will eventually be the default.\n *\n * @function\n *\n * @param   {string}  address         G... or M... address to encode into XDR\n * @param   {bool}   [supportMuxing]  allows decoding of the muxed\n *     representation of the address, extracting the underlying ID from the M...\n *     address\n *\n * @returns {xdr.MuxedAccount}  a muxed account object for this address string\n *\n * @note     If you pass a G... address, `supportMuxing` will be ignored.\n * @warning  If you pass an M... address and do NOT specify supportMuxing=true,\n *           then this function will throw an error.\n */\n\n\nfunction decodeAddressToMuxedAccount(address, supportMuxing) {\n  if (supportMuxing && _strkey.StrKey.isValidMed25519PublicKey(address)) {\n    return _decodeAddressFullyToMuxedAccount(address);\n  }\n\n  return _stellarXdr_generated2.default.MuxedAccount.keyTypeEd25519(_strkey.StrKey.decodeEd25519PublicKey(address));\n}\n/**\n * Converts an xdr.MuxedAccount to its string representation.\n *\n * By default, this returns its \"G...\" string representation (i.e. forcing the\n * ed25519 representation), but can return the \"M...\" representation via opt-in.\n *\n * @function\n *\n * @param   {xdr.MuxedAccount} muxedAccount   account to stringify\n * @param   {bool}            [supportMuxing] converts the object into its full,\n *     proper M... address, encoding both the underlying G... address and the\n *     muxing ID, but *ONLY* when the ID is present.\n *\n * @returns {string}  stringified G... (corresponding to the underlying pubkey)\n *     or M... address (corresponding to both the key and the muxed ID)\n */\n\n\nfunction encodeMuxedAccountToAddress(muxedAccount, supportMuxing) {\n  if (muxedAccount.switch().value === _stellarXdr_generated2.default.CryptoKeyType.keyTypeMuxedEd25519().value) {\n    if (supportMuxing) {\n      return _encodeMuxedAccountFullyToAddress(muxedAccount);\n    }\n\n    muxedAccount = muxedAccount.med25519();\n  }\n\n  return _strkey.StrKey.encodeEd25519PublicKey(muxedAccount.ed25519());\n}\n/**\n * Transform a Stellar address (G...) and an ID into its XDR representation.\n *\n * @param  {string} address   - a Stellar G... address\n * @param  {string} id        - a Uint64 ID represented as a string\n * @return {xdr.MuxedAccount} - XDR representation of the above muxed account\n */\n\n\nfunction encodeMuxedAccount(address, id) {\n  if (!_strkey.StrKey.isValidEd25519PublicKey(address)) {\n    throw new Error('address should be a Stellar account ID (G...)');\n  }\n\n  if (!(0, _isString2.default)(id)) {\n    throw new Error('id should be a string representing a number (uint64)');\n  }\n\n  return _stellarXdr_generated2.default.MuxedAccount.keyTypeMuxedEd25519(new _stellarXdr_generated2.default.MuxedAccountMed25519({\n    id: _stellarXdr_generated2.default.Uint64.fromString(id),\n    ed25519: _strkey.StrKey.decodeEd25519PublicKey(address)\n  }));\n} // Decodes an \"M...\" account ID into its MuxedAccount object representation.\n\n\nfunction _decodeAddressFullyToMuxedAccount(address) {\n  var rawBytes = _strkey.StrKey.decodeMed25519PublicKey(address); // Decoding M... addresses cannot be done through a simple\n  // MuxedAccountMed25519.fromXDR() call, because the definition is:\n  //\n  //    constructor(attributes: { id: Uint64; ed25519: Buffer });\n  //\n  // Note the ID is the first attribute. However, the ID comes *last* in the\n  // stringified (base32-encoded) address itself (it's the last 8-byte suffix).\n  // The `fromXDR()` method interprets bytes in order, so we need to parse out\n  // the raw binary into its requisite parts, i.e. use the MuxedAccountMed25519\n  // constructor directly.\n  //\n  // Refer to https://github.com/stellar/go/blob/master/xdr/muxed_account.go#L26\n  // for the Golang implementation of the M... parsing.\n\n\n  return _stellarXdr_generated2.default.MuxedAccount.keyTypeMuxedEd25519(new _stellarXdr_generated2.default.MuxedAccountMed25519({\n    id: _stellarXdr_generated2.default.Uint64.fromXDR(rawBytes.slice(-8)),\n    ed25519: rawBytes.slice(0, -8)\n  }));\n} // Converts an xdr.MuxedAccount into its *true* \"M...\" string representation.\n\n\nfunction _encodeMuxedAccountFullyToAddress(muxedAccount) {\n  if (muxedAccount.switch() === _stellarXdr_generated2.default.CryptoKeyType.keyTypeEd25519()) {\n    return encodeMuxedAccountToAddress(muxedAccount);\n  }\n\n  var muxed = muxedAccount.med25519();\n  return _strkey.StrKey.encodeMed25519PublicKey(Buffer.concat([muxed.ed25519(), muxed.id().toXDR('raw')]));\n}","map":{"version":3,"names":["Object","defineProperty","exports","value","decodeAddressToMuxedAccount","encodeMuxedAccountToAddress","encodeMuxedAccount","_isString","require","_isString2","_interopRequireDefault","_stellarXdr_generated","_stellarXdr_generated2","_strkey","obj","__esModule","default","address","supportMuxing","StrKey","isValidMed25519PublicKey","_decodeAddressFullyToMuxedAccount","MuxedAccount","keyTypeEd25519","decodeEd25519PublicKey","muxedAccount","switch","CryptoKeyType","keyTypeMuxedEd25519","_encodeMuxedAccountFullyToAddress","med25519","encodeEd25519PublicKey","ed25519","id","isValidEd25519PublicKey","Error","MuxedAccountMed25519","Uint64","fromString","rawBytes","decodeMed25519PublicKey","fromXDR","slice","muxed","encodeMed25519PublicKey","Buffer","concat","toXDR"],"sources":["C:/Users/acer/node_modules/stellar-base/lib/util/decode_encode_muxed_account.js"],"sourcesContent":["'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.decodeAddressToMuxedAccount = decodeAddressToMuxedAccount;\nexports.encodeMuxedAccountToAddress = encodeMuxedAccountToAddress;\nexports.encodeMuxedAccount = encodeMuxedAccount;\n\nvar _isString = require('lodash/isString');\n\nvar _isString2 = _interopRequireDefault(_isString);\n\nvar _stellarXdr_generated = require('../generated/stellar-xdr_generated');\n\nvar _stellarXdr_generated2 = _interopRequireDefault(_stellarXdr_generated);\n\nvar _strkey = require('../strkey');\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * Converts a Stellar address (in G... or M... form) to an XDR MuxedAccount\n * structure, forcing the ed25519 representation by default.\n *\n * This optionally (that is, opt-in only) supports proper muxed accounts, where\n * an M... address will resolve to both its underlying G... address and an ID.\n * Note that this behaviour will eventually be the default.\n *\n * @function\n *\n * @param   {string}  address         G... or M... address to encode into XDR\n * @param   {bool}   [supportMuxing]  allows decoding of the muxed\n *     representation of the address, extracting the underlying ID from the M...\n *     address\n *\n * @returns {xdr.MuxedAccount}  a muxed account object for this address string\n *\n * @note     If you pass a G... address, `supportMuxing` will be ignored.\n * @warning  If you pass an M... address and do NOT specify supportMuxing=true,\n *           then this function will throw an error.\n */\nfunction decodeAddressToMuxedAccount(address, supportMuxing) {\n  if (supportMuxing && _strkey.StrKey.isValidMed25519PublicKey(address)) {\n    return _decodeAddressFullyToMuxedAccount(address);\n  }\n\n  return _stellarXdr_generated2.default.MuxedAccount.keyTypeEd25519(_strkey.StrKey.decodeEd25519PublicKey(address));\n}\n\n/**\n * Converts an xdr.MuxedAccount to its string representation.\n *\n * By default, this returns its \"G...\" string representation (i.e. forcing the\n * ed25519 representation), but can return the \"M...\" representation via opt-in.\n *\n * @function\n *\n * @param   {xdr.MuxedAccount} muxedAccount   account to stringify\n * @param   {bool}            [supportMuxing] converts the object into its full,\n *     proper M... address, encoding both the underlying G... address and the\n *     muxing ID, but *ONLY* when the ID is present.\n *\n * @returns {string}  stringified G... (corresponding to the underlying pubkey)\n *     or M... address (corresponding to both the key and the muxed ID)\n */\nfunction encodeMuxedAccountToAddress(muxedAccount, supportMuxing) {\n  if (muxedAccount.switch().value === _stellarXdr_generated2.default.CryptoKeyType.keyTypeMuxedEd25519().value) {\n    if (supportMuxing) {\n      return _encodeMuxedAccountFullyToAddress(muxedAccount);\n    }\n    muxedAccount = muxedAccount.med25519();\n  }\n  return _strkey.StrKey.encodeEd25519PublicKey(muxedAccount.ed25519());\n}\n\n/**\n * Transform a Stellar address (G...) and an ID into its XDR representation.\n *\n * @param  {string} address   - a Stellar G... address\n * @param  {string} id        - a Uint64 ID represented as a string\n * @return {xdr.MuxedAccount} - XDR representation of the above muxed account\n */\nfunction encodeMuxedAccount(address, id) {\n  if (!_strkey.StrKey.isValidEd25519PublicKey(address)) {\n    throw new Error('address should be a Stellar account ID (G...)');\n  }\n  if (!(0, _isString2.default)(id)) {\n    throw new Error('id should be a string representing a number (uint64)');\n  }\n\n  return _stellarXdr_generated2.default.MuxedAccount.keyTypeMuxedEd25519(new _stellarXdr_generated2.default.MuxedAccountMed25519({\n    id: _stellarXdr_generated2.default.Uint64.fromString(id),\n    ed25519: _strkey.StrKey.decodeEd25519PublicKey(address)\n  }));\n}\n\n// Decodes an \"M...\" account ID into its MuxedAccount object representation.\nfunction _decodeAddressFullyToMuxedAccount(address) {\n  var rawBytes = _strkey.StrKey.decodeMed25519PublicKey(address);\n\n  // Decoding M... addresses cannot be done through a simple\n  // MuxedAccountMed25519.fromXDR() call, because the definition is:\n  //\n  //    constructor(attributes: { id: Uint64; ed25519: Buffer });\n  //\n  // Note the ID is the first attribute. However, the ID comes *last* in the\n  // stringified (base32-encoded) address itself (it's the last 8-byte suffix).\n  // The `fromXDR()` method interprets bytes in order, so we need to parse out\n  // the raw binary into its requisite parts, i.e. use the MuxedAccountMed25519\n  // constructor directly.\n  //\n  // Refer to https://github.com/stellar/go/blob/master/xdr/muxed_account.go#L26\n  // for the Golang implementation of the M... parsing.\n  return _stellarXdr_generated2.default.MuxedAccount.keyTypeMuxedEd25519(new _stellarXdr_generated2.default.MuxedAccountMed25519({\n    id: _stellarXdr_generated2.default.Uint64.fromXDR(rawBytes.slice(-8)),\n    ed25519: rawBytes.slice(0, -8)\n  }));\n}\n\n// Converts an xdr.MuxedAccount into its *true* \"M...\" string representation.\nfunction _encodeMuxedAccountFullyToAddress(muxedAccount) {\n  if (muxedAccount.switch() === _stellarXdr_generated2.default.CryptoKeyType.keyTypeEd25519()) {\n    return encodeMuxedAccountToAddress(muxedAccount);\n  }\n\n  var muxed = muxedAccount.med25519();\n  return _strkey.StrKey.encodeMed25519PublicKey(Buffer.concat([muxed.ed25519(), muxed.id().toXDR('raw')]));\n}"],"mappings":"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"},"metadata":{},"sourceType":"script"}